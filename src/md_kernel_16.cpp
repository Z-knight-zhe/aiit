#include "md_kernel_16.h"
#include "iime.h"
#include "md_dummy.h"
#include "md_cmod.h"
#include "com_def.h"

#pragma warning(disable:4102)
#pragma warning(disable:4334)
#pragma warning(disable:4018)
#pragma warning(disable:26453)
#pragma warning(disable:6297)
#define UPDATE_SIZE_MAX16 16*16
#define GET_I_COST(rate, lamba)  (rate*lamba)
extern int op_patch_mode_on;
static const s8 com_tbl_log2[257] = {
	/* 0, 1 */
	-1, -1,
	/* 2, 3 */
	1, -1,
	/* 4 ~ 7 */
	2, -1, -1, -1,
	/* 8 ~ 15 */
	3, -1, -1, -1, -1, -1, -1, -1,
	/* 16 ~ 31 */
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 31 ~ 63 */
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 64 ~ 127 */
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 128 ~ 255 */
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 256 */
	8
};

static int encode_umve_idx_est(u8 umve_idx)
{
	U3 enc_est;
	enc_est = 0;
	if (umve_idx < 20)
		enc_est++;
	else
	{
		enc_est += 2;


	}
	if (umve_idx < 4 || (umve_idx >= 20 && umve_idx < 24))
		enc_est++;
	else
	{
		enc_est += 2;


	}

	enc_est += 2;
	return enc_est;
}

static int encode_affine_flag_est(U1 flag, u8 affine_enable_flag, U3 cu_width_log2, U3 cu_height_log2)
{
	//COM_MODE *mod_info_curr = &core->mod_info_curr;
	U1 enc_est = 0;
	if (cu_width_log2 >= 4 && cu_height_log2 >= 4 && 1) {
		enc_est++;
	}
	return enc_est;
}

static int sbac_write_truncate_unary_sym_est(U8 sym, U8 max_num)
{

#pragma HLS INLINE
	U8 enc_est;
	enc_est = (max_num - (1) > sym + (1) ? sym + (1) : max_num - (1));
	return enc_est;
}


static int enc_eco_abs_mvd_est(U16 sym)
{
	U5 enc_est = 0;
	U4 exp_golomb_order = 0;
	// 0, 1, 2
	if (sym < (3)) {
		if (sym == (0)) {
			enc_est++;
		}
		else if (sym == (1)) {
			enc_est += 2;
		}
		else if (sym == (2)) {
			enc_est += 3;
		}
	}
	else {
		U1 offset;
		sym -= (3);
		offset = ((sym & (1)));
		enc_est += 3;
		enc_est++;
		sym = (sym - (offset)) >> 1;
		// exp_golomb part
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 1;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 3;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 5;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 7;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 9;
		}
		else //if (sym >= (1023) && sym < (2047)) 
		{
			exp_golomb_order = 10;
		}
		//else if (sym >= (2047) && sym < (4095)) {
		//	exp_golomb_order = 11;
		//}
		enc_est = enc_est + 2 * exp_golomb_order;
		//enc_est+=sbac_write_unary_sym_ep_est(exp_golomb_order);
		//enc_est+=sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}


static int encode_mvd_est(S16 mvd[2])
{
	U16 mv;
	U5 enc_est = 0;

	mv = (mvd[0]);
	if ((mvd[0]) < 0) {

		mv = ((-(mvd[0])));
	}
	enc_est += enc_eco_abs_mvd_est(mv);
	if (mv) {
		enc_est++;
	}

	mv = (mvd[1]);
	if ((mvd[1]) < 0) {

		mv = ((-(mvd[1])));
	}
	enc_est += enc_eco_abs_mvd_est(mv);
	if (mv) {
		enc_est++;
	}
	return enc_est;
}

//static int enc_eco_cbf_est_skip(RDOQ_MODEL model_cnt, int tb_avaliable, int pb_part_size, int tb_part_size, int num_nz[4][3], u8 pred_mode,
//	S8 ipm[4][2], u8 tree_status, U3 cu_width_log2, U3 cu_height_log2)
//{
//	U3 enc_est = 0;
//	if ((pred_mode) != 0) {
//		if (!((pred_mode) == 3)) {
//			if (tree_status == TREE_LC) {
//				if (cu_width_log2 > 6 || cu_height_log2 > 6) {
//					enc_est++;
//				}
//				else {
//					enc_est++;
//				}
//
//				return 0;
//
//			}
//		}
//		if (tb_avaliable) {
//			enc_est++;
//		}
//
//		if (tree_status == TREE_LC) {
//			enc_est += 2;
//			model_cnt.cbf[1]++;
//		}
//		else {
//			//int part_num = get_part_num((PART_SIZE)tb_part_size);
//
//			enc_est += 1;
//			model_cnt.cbf[0]++;
//		}
//	}
//	else {
//		if (!((ipm[0][0]) == 33)) {
//			//int part_num = get_part_num((PART_SIZE)tb_part_size);
//			enc_est += 1;
//			model_cnt.cbf[0]++;
//
//		}
//		if (tree_status == TREE_LC) {
//			if (!((ipm[0][0]) == 33 && (ipm[0][1]) == 0)) {
//				enc_est += 2;
//				model_cnt.cbf[1]++;
//			}
//		}
//	}
//	return enc_est;
//}
//static int enc_eco_cbf_est(int tb_avaliable, int pb_part_size, int tb_part_size, int num_nz[4][3], u8 pred_mode,
//	s8 ipm[4][2], u8 tree_status, int cu_width_log2, int cu_height_log2)
//{
//	U3 enc_est = 0;
//	//COM_MODE *mod_info_curr = &core->mod_info_curr;
//	U1 ctp_zero_flag = !is_cu_nz(num_nz);
//	/* code allcbf */
//	if ((pred_mode) != 0) {
//		if (!((pred_mode) == 3)) {
//			if (tree_status == TREE_LC) {
//				if (cu_width_log2 > 6 || cu_height_log2 > 6) {
//					enc_est++;
//				}
//				else {
//					enc_est++;
//				}
//				if (ctp_zero_flag) {
//					return 0;
//				}
//			}
//		}
//		if (tb_avaliable) {
//			enc_est++;
//		}
//
//		if (tree_status == TREE_LC) {
//			enc_est += 2;
//
//		}
//		if (num_nz[0][1] + num_nz[0][2] == 0 && tb_part_size == (SIZE_2Nx2N) && tree_status == TREE_LC) {
//		}
//		else {
//			//int part_num = get_part_num((PART_SIZE)tb_part_size);
//
//			enc_est += 1;
//
//		}
//	}
//	else {
//		if (!((ipm[0][0]) == 33)) {
//			//int part_num = get_part_num((PART_SIZE)tb_part_size);
//
//			enc_est += 1;
//
//
//		}
//		if (tree_status == TREE_LC) {
//			if (!((ipm[0][0]) == 33 && (ipm[0][1]) == 0)) {
//				enc_est += 2;
//
//			}
//		}
//	}
//	return enc_est;
//}


static int enc_eco_level_est_2(u16 sym)
{

#pragma HLS INLINE
	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0)
		enc_est = 0;
	else if (sym < (9)) {
		enc_est = sym;
		enc_est += 2;
	}
	else {
		sym -= (9);
		//enc_est += sbac_write_truncate_unary_sym_est(8, 9);
		enc_est = 10;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 16;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 18;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 20;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 22;
		}
		enc_est += exp_golomb_order;
		//sbac_write_unary_sym_ep_est(exp_golomb_order);
		//sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}
static int enc_eco_run_est_2(U10 sym, u16 level)
{

#pragma HLS INLINE
	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0) {
		if (level == 0) {
			enc_est = 0;
		}
		else {
			enc_est = 1;
		}
	}
	else if (sym < (16)) {
		enc_est += sym + 1;
	}
	else {
		sym -= (16);
		enc_est += 16;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 16;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 18;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 20;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 22;
		}
		enc_est += exp_golomb_order;
	}
	return enc_est;
}
static int enc_eco_level_est_3(U10 sym)
{

#pragma HLS INLINE
	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0)
		enc_est = 0;
	else if (sym < (9)) {
		enc_est = sym;
		//enc_est += 2;
	}
	else {
		sym -= (9);
		enc_est = 8;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else /*if (sym >= ( 255) && sym < ( 511)) */ {
			exp_golomb_order = 16;
		}/*
		 else if (sym >= ( 512) && sym < ( 1023)) {
		 exp_golomb_order = 9;
		 }
		 else if (sym >= ( 1023) && sym < ( 2047)) {
		 exp_golomb_order = 10;
		 }
		 else if (sym >= ( 2047) && sym < ( 4095)) {
		 exp_golomb_order = 11;
		 }*/
		enc_est += exp_golomb_order;
	}
	return enc_est;
}

static int enc_eco_run_est_3(U10 run)
{

#pragma HLS INLINE
	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (run < (16)) {
		enc_est += run + 1;
	}
	else {
		run -= (16);
		enc_est += 16;
		if (run == (0)) {
			exp_golomb_order = 0;
		}
		else if (run >= (1) && run < (3)) {
			exp_golomb_order = 2;
		}
		else if (run >= (3) && run < (7)) {
			exp_golomb_order = 4;
		}
		else if (run >= (7) && run < (15)) {
			exp_golomb_order = 6;
		}
		else if (run >= (15) && run < (31)) {
			exp_golomb_order = 8;
		}
		else if (run >= (31) && run < (63)) {
			exp_golomb_order = 10;
		}
		else if (run >= (63) && run < (127)) {
			exp_golomb_order = 12;
		}
		else if (run >= (127) && run < (255)) {
			exp_golomb_order = 14;
		}
		else /*if (run >= (255) && run < (511))*/ {
			exp_golomb_order = 16;
		}/*
		 else if (run >= (512) && run < (1023)) {
		 exp_golomb_order = 9;
		 }
		 else if (run >= (1023) && run < (2047)) {
		 exp_golomb_order = 10;
		 }
		 else if (run >= (2047) && run < (4095)) {
		 exp_golomb_order = 11;
		 }*/
		enc_est += exp_golomb_order;
	}
	return enc_est;
}

static int rate_coef_est_16(s16 coef[16], U10 run[16])
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=run complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef complete dim=1
	U12 enc_est = 0;
	U6 i;
	for (i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		u16  level;
		level = abs(coef[i]);
		//level = ((((coef[i]) ^ (coef[i]) >> 15) - ((coef[i]) >> 15)));
		//level = (coef[i]) ^ ((coef[i]) >> 15) - ((coef[i]) >> 15);
		enc_est += enc_eco_run_est_2(run[i], level);
		enc_est += enc_eco_level_est_2(level);
	}
	return enc_est;
}

static int encode_skip_idx_cu_est(u8  skip_idx, u8 num_hmvp_cands, u8 slice_type)
{

	U8 enc_est = 0;
	U8 val;
	U8 max_skip_num;
	// for P slice, change 3, 4, ..., 13 to 1, 2, ..., 11
	if ((slice_type) == 2 && skip_idx > 0) {
		skip_idx -= 2;
	}
	val = skip_idx;
	max_skip_num = (((slice_type) == 2 ? 2 : (PRED_DIR_NUM)+1)) + num_hmvp_cands;
	enc_est += val;
	if (skip_idx != max_skip_num - 1) {
		enc_est++;
	}
	return enc_est;
}
static int encode_intra_dir_est(u8 ipm, u8 mpm[2])
{
	U3 enc_est = 0;
	S8 ipm_code = (ipm) == (mpm[0]) ? -2 : (((mpm[1]) == (ipm) ? -1 : (((ipm) < (mpm[0]) ? (ipm) : (((ipm) < (mpm[1]) ? (ipm)-1 : (ipm)-2))))));
	if (ipm_code < 0) {
		enc_est += 2;
	}
	else {
		enc_est += 6;
	}
	return enc_est;
}

static int enc_eco_cbf_est_16(int num_nz[4][3], U2 pred_mode,
	S8 ipm[4][2], U2 tree_status, U3 cu_width_log2, U3 cu_height_log2)
{
	U4 enc_est = 0;
	//COM_MODE *mod_info_curr = &core->mod_info_curr;
	U1 ctp_zero_flag = !is_cu_nz(num_nz);
	/* code allcbf */
	if ((pred_mode) != 0) {
		if (!((pred_mode) == 3)) {
			if (tree_status == TREE_LC) {
				enc_est++;
				if (ctp_zero_flag) {
					return 0;
				}
			}
		}

		if (tree_status == TREE_LC) {
			enc_est += 2;

		}
		if (num_nz[0][1] + num_nz[0][2] == 0 && tree_status == TREE_LC) {
		}
		else {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);

			enc_est += 1;
			//model_cnt->cbf[0]++;
		}
	}
	else {
		if (!((ipm[0][0]) == 33)) {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);

			enc_est += 1;
			//model_cnt->cbf[0]++;

		}
		if (tree_status == TREE_LC) {
			if (!((ipm[0][0]) == 33 && (ipm[0][1]) == 0)) {
				enc_est += 2;
				//model_cnt->cbf[1]++;
			}
		}
	}
	return enc_est;
}

static int  enc_eco_coef_16_1(U8 cu_width, U8 cu_height, s16 coef[256], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	U6 scan_pos;
	u16 level;

	U10 run;

	s16 coef_cur;
	//u16 scan[16*16];
	u8 max_scan = 64;
	//FUNC_NAME(ready_coef, W, H)(coef, coef_out);
	u8 scan_tab_index = 0;
	//u16 scan_16x4[16 * 4] = { 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 49, 34, 19, 4, 5, 20, 35, 50, 51, 36, 21, 6, 7, 22, 37, 52, 53, 38, 23, 8, 9, 24, 39, 54, 55, 40, 25, 10, 11, 26, 41, 56, 57, 42, 27, 12, 13, 28, 43, 58, 59, 44, 29, 14, 15, 30, 45, 60, 61, 46, 31, 47, 62, 63 };
	//u16 scan_4x16[4 * 16] = { 0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 11, 14, 17, 20, 24, 21, 18, 15, 19, 22, 25, 28, 32, 29, 26, 23, 27, 30, 33, 36, 40, 37, 34, 31, 35, 38, 41, 44, 48, 45, 42, 39, 43, 46, 49, 52, 56, 53, 50, 47, 51, 54, 57, 60, 61, 58, 55, 59, 62, 63 };
	//u16 scan_16x8[16 * 8] = { 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73, 88, 103, 118, 119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120, 121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 123, 108, 93, 78, 63, 79, 94, 109, 124, 125, 110, 95, 111, 126, 127 };
	//u16 scan_8x16[8 * 16] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 64, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 65, 72, 80, 73, 66, 59, 52, 45, 38, 31, 39, 46, 53, 60, 67, 74, 81, 88, 96, 89, 82, 75, 68, 61, 54, 47, 55, 62, 69, 76, 83, 90, 97, 104, 112, 105, 98, 91, 84, 77, 70, 63, 71, 78, 85, 92, 99, 106, 113, 120, 121, 114, 107, 100, 93, 86, 79, 87, 94, 101, 108, 115, 122, 123, 116, 109, 102, 95, 103, 110, 117, 124, 125, 118, 111, 119, 126, 127 };
	//u16 scan_16x16[16 * 16] = { 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 128, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 129, 144, 160, 145, 130, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 131, 146, 161, 176, 192, 177, 162, 147, 132, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73, 88, 103, 118, 133, 148, 163, 178, 193, 208, 224, 209, 194, 179, 164, 149, 134, 119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 241, 226, 211, 196, 181, 166, 151, 136, 121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 137, 152, 167, 182, 197, 212, 227, 242, 243, 228, 213, 198, 183, 168, 153, 138, 123, 108, 93, 78, 63, 79, 94, 109, 124, 139, 154, 169, 184, 199, 214, 229, 244, 245, 230, 215, 200, 185, 170, 155, 140, 125, 110, 95, 111, 126, 141, 156, 171, 186, 201, 216, 231, 246, 247, 232, 217, 202, 187, 172, 157, 142, 127, 143, 158, 173, 188, 203, 218, 233, 248, 249, 234, 219, 204, 189, 174, 159, 175, 190, 205, 220, 235, 250, 251, 236, 221, 206, 191, 207, 222, 237, 252, 253, 238, 223, 239, 254, 255 };

	static const u16 scan[5][64] = {
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 49, 34, 19, 4, 5, 20, 35, 50, 51, 36, 21, 6, 7, 22, 37, 52, 53, 38, 23, 8, 9, 24, 39, 54, 55, 40, 25, 10, 11, 26, 41, 56, 57, 42, 27, 12, 13, 28, 43, 58, 59, 44, 29, 14, 15, 30, 45, 60, 61, 46, 31, 47, 62, 63 },
		{ 0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 11, 14, 17, 20, 24, 21, 18, 15, 19, 22, 25, 28, 32, 29, 26, 23, 27, 30, 33, 36, 40, 37, 34, 31, 35, 38, 41, 44, 48, 45, 42, 39, 43, 46, 49, 52, 56, 53, 50, 47, 51, 54, 57, 60, 61, 58, 55, 59, 62, 63 },
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, },
		{ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 64, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 65, 72, 80, 73, 66, 59, 52, 45, 38, 31, 39, 46, 53, 60, },
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 128, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 129, 144, 160, 145, 130, 115, 100, 85, 70, 55, 40,}
	};

	if (cu_width == 16 && cu_height == 8)
	{
		scan_tab_index = 2;
	}
	else if (cu_width == 8 && cu_height == 16)
	{
		scan_tab_index = 3;
	}
	else if (cu_width == 16 && cu_height == 4)
	{
		scan_tab_index = 0;
		max_scan = 32;
	}
	else if (cu_width == 4 && cu_height == 16)
	{
		scan_tab_index = 1;
		max_scan = 32;
	}
	else // (cu_width == 16 && cu_height == 16)
	{
		scan_tab_index = 4;
	}

	run = 0;
	for (scan_pos = 0; scan_pos < 64; scan_pos++) {
#pragma HLS loop_tripcount max=64
		if (scan_pos >= max_scan)
			break;

		coef_cur = coef[scan[scan_tab_index][scan_pos]];
		if (coef_cur) {
			level = abs(coef_cur);
			//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
			enc_est += enc_eco_run_est_3(run);
			enc_est += enc_eco_level_est_3(level);
			enc_est++;
			if (scan_pos == cu_width * cu_height - 1) {
				break;
			}
			run = 0;
			enc_est++;
		}
		else {
			run++;
		}


	}

	return enc_est;
}
static int  enc_eco_coef_16(U8 cu_width, U8 cu_height, s16 coef[256], U3 log2_w, U3 log2_h)
{
#pragma HLS ARRAY_PARTITION variable=coef complete dim=0
	U15 enc_est = 0;
	U6 scan_pos;
	u16 level;
	int i;
	U10 run;
	U15 enc_est1 = 0;
	U15 enc_est2 = 0;
	U15 enc_est3 = 0;
	U15 enc_est4 = 0;
	U15 enc_est5 = 0;
	U15 enc_est6 = 0;
	U15 enc_est7 = 0;
	U15 enc_est8 = 0;
	U10 run1 = 0;
	U10 run2 = 0;
	U10 run3 = 0;
	U10 run4 = 0;
	U10 run5 = 0;
	U10 run6 = 0;
	U10 run7 = 0;
	U10 run8 = 0;
	U8 runflag1 = 0;
	U8 runflag2 = 0;
	U8 runflag3 = 0;
	U8 runflag4 = 0;
	U8 runflag5 = 0;
	U8 runflag6 = 0;
	U8 runflag7 = 0;
	s16 coef_cur;
	u8 max_scan = 64;
	u8 scan_tab_index = 0;

	static const u16 scan[5][64] = {
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 49, 34, 19, 4, 5, 20, 35, 50, 51, 36, 21, 6, 7, 22, 37, 52, 53, 38, 23, 8, 9, 24, 39, 54, 55, 40, 25, 10, 11, 26, 41, 56, 57, 42, 27, 12, 13, 28, 43, 58, 59, 44, 29, 14, 15, 30, 45, 60, 61, 46, 31, 47, 62, 63 },
		{ 0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 11, 14, 17, 20, 24, 21, 18, 15, 19, 22, 25, 28, 32, 29, 26, 23, 27, 30, 33, 36, 40, 37, 34, 31, 35, 38, 41, 44, 48, 45, 42, 39, 43, 46, 49, 52, 56, 53, 50, 47, 51, 54, 57, 60, 61, 58, 55, 59, 62, 63 },
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, },
		{ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 64, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 65, 72, 80, 73, 66, 59, 52, 45, 38, 31, 39, 46, 53, 60, },
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 128, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 129, 144, 160, 145, 130, 115, 100, 85, 70, 55, 40,}
	};

	if (cu_width == 16 && cu_height == 8)
	{
		scan_tab_index = 2;
	}
	else if (cu_width == 8 && cu_height == 16)
	{
		scan_tab_index = 3;
	}
	else if (cu_width == 16 && cu_height == 4)
	{
		scan_tab_index = 0;
		max_scan = 32;
	}
	else if (cu_width == 4 && cu_height == 16)
	{
		scan_tab_index = 1;
		max_scan = 32;
	}
	else // (cu_width == 16 && cu_height == 16)
	{
		scan_tab_index = 4;
	}

	run = 0;
	if (cu_width == 16 && cu_height == 16) {
		for (i = 0; i < 8; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est1 += enc_eco_run_est_3(run1);
				enc_est1 += enc_eco_level_est_3(level);
				enc_est1++;
				run1 = 0;
				enc_est1++;
			}
			else {
				run1++;
			}
			if (i == 7) {
				runflag1 = run1;
			}
		}
		for (i = 8; i < 16; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (coef_cur) {
				run2 = 0;
			}
			else {
				run2++;
			}
			if (i == 15) {
				runflag2 = run2;
			}
		}
		for (i = 16; i < 24; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (coef_cur) {
				run3 = 0;
			}
			else {
				run3++;
			}
			if (i == 23) {
				runflag3 = run3;
			}
		}
		for (i = 24; i < 32; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (coef_cur) {
				run4 = 0;
			}
			else {
				run4++;
			}
			if (i == 31) {
				runflag4 = run4;
			}
		}
		for (i = 32; i < 40; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (coef_cur) {
				run5 = 0;
			}
			else {
				run5++;
			}
			if (i == 39) {
				runflag5 = run5;
			}
		}
		for (i = 40; i < 48; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (coef_cur) {
				run6 = 0;
			}
			else {
				run6++;
			}
			if (i == 47) {
				runflag6 = run6;
			}
		}
		for (i = 48; i < 56; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (coef_cur) {
				run7 = 0;
			}
			else {
				run7++;
			}
			if (i == 55) {
				runflag7 = run7;
			}

		}
		///////////////////////////////////////////////////////////////
		for (i = 8; i < 16; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (i == 8) {
				run = runflag1;
			}
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est2 += enc_eco_run_est_3(run);
				enc_est2 += enc_eco_level_est_3(level);
				enc_est2++;
				run = 0;
				enc_est2++;
			}
			else {
				run++;
			}
		}
		for (i = 16; i < 24; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (i == 16) {
				if (runflag2 == 8) {
					run = runflag1 + runflag2;
				}
				else {
					run = runflag2;
				}
			}
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est3 += enc_eco_run_est_3(run);
				enc_est3 += enc_eco_level_est_3(level);
				enc_est3++;
				run = 0;
				enc_est3++;
			}
			else {
				run++;
			}
		}
		for (i = 24; i < 32; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (i == 24) {
				if (runflag3 == 8) {
					if (runflag2 == 8) {
						run = runflag1 + runflag2 + runflag3;
					}
					else {
						run = runflag2 + runflag3;
					}
				}
				else {
					run = runflag3;
				}
			}
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est4 += enc_eco_run_est_3(run);
				enc_est4 += enc_eco_level_est_3(level);
				enc_est4++;
				run = 0;
				enc_est4++;
			}
			else {
				run++;
			}
		}
		for (i = 32; i < 40; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (i == 40) {
				if (runflag4 == 8) {
					if (runflag3 == 8) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2 + runflag3 + runflag4;
						}
						else {
							run = runflag2 + runflag3 + runflag4;
						}
					}
					else {
						run = runflag3 + runflag4;
					}
				}
				else {
					run = runflag4;
				}
			}
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est5 += enc_eco_run_est_3(run);
				enc_est5 += enc_eco_level_est_3(level);
				enc_est5++;
				run = 0;
				enc_est5++;
			}
			else {
				run++;
			}
		}
		for (i = 40; i < 48; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (i == 40) {
				if (runflag5 == 8) {
					if (runflag4 == 8) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
							}
							else {
								run = runflag2 + runflag3 + runflag4 + runflag5;
							}
						}
						else {
							run = runflag3 + runflag4 + runflag5;
						}

					}
					else {
						run = runflag4 + runflag5;
					}
				}
				else {
					run = runflag5;
				}
			}
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est6 += enc_eco_run_est_3(run);
				enc_est6 += enc_eco_level_est_3(level);
				enc_est6++;
				run = 0;
				enc_est6++;
			}
			else {
				run++;
			}
		}
		for (i = 48; i < 56; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (i == 48) {
				if (runflag6 == 8) {
					if (runflag5 == 8) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
								}
								else {
									run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag3 + runflag4 + runflag5 + runflag6;
							}
						}
						else {
							run = runflag4 + runflag5 + runflag6;
						}
					}
					else {
						run = runflag5 + runflag6;
					}
				}
				else {
					run = runflag6;
				}

			}
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est7 += enc_eco_run_est_3(run);
				enc_est7 += enc_eco_level_est_3(level);
				enc_est7++;
				run = 0;
				enc_est7++;
			}
			else {
				run++;
			}
		}
		for (i = 56; i < 64; i++) {
#pragma HLS UNROLL
			s16 coef_cur;
			u16 level;
			coef_cur = coef[scan[scan_tab_index][i]];
			if (i == 56) {
				if (runflag7 == 8) {
					if (runflag6 == 8) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag4 + runflag5 + runflag6 + runflag7;
							}
						}
						else {
							run = runflag5 + runflag6 + runflag7;
						}
					}
					else {
						run = runflag6 + runflag7;
					}
				}
				else {
					run = runflag7;
				}

			}
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est8 += enc_eco_run_est_3(run);
				enc_est8 += enc_eco_level_est_3(level);
				enc_est8++;
				/*if (i == 64 - 1) {
					break;
				}*/
				run = 0;
				enc_est8++;
			}
			else {
				run++;
			}
		}
		enc_est = enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;


	}
	else {
		for (scan_pos = 0; scan_pos < 64; scan_pos++) {
#pragma HLS loop_tripcount max=64
			if (scan_pos >= max_scan)
				break;

			coef_cur = coef[scan[scan_tab_index][scan_pos]];
			if (coef_cur) {
				level = abs(coef_cur);
				//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
				enc_est += enc_eco_run_est_3(run);
				enc_est += enc_eco_level_est_3(level);
				enc_est++;
				if (scan_pos == cu_width * cu_height - 1) {
					break;
				}
				run = 0;
				enc_est++;
			}
			else {
				run++;
			}


		}
	}
	return enc_est;

}

static int enc_eco_level_est_2_only(u16 sym)
{

#pragma HLS INLINE
	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0)
		enc_est = 0;
	else if (sym < (9)) {
		enc_est = sym;
		enc_est += 2;
	}
	else {
		sym -= (9);
		//enc_est += sbac_write_truncate_unary_sym_est(8, 9);
		enc_est = 10;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else {
			exp_golomb_order = 16;
		}

		enc_est += exp_golomb_order;
		//sbac_write_unary_sym_ep_est(exp_golomb_order);
		//sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}

static int enc_eco_run_est_2_only(U10 sym)
{

#pragma HLS INLINE
	U5 exp_golomb_order = 0;
	U6 enc_est = 0;
	if (sym == 65) {
		enc_est = 1;
	}
	else if (sym == 0) {
		enc_est = 0;
	}
	else if (sym < (16)) {
		enc_est += sym + 1;
	}
	else {
		sym -= (16);
		enc_est += 16;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else /*if (run >= (255) && run < (511))*/ {
			exp_golomb_order = 16;
		}
		enc_est += exp_golomb_order;
	}
	return enc_est;
}


static int rate_coef_level_est_16(s16 coef[16], u8 w)
{
	U12 enc_est = 0;
	U6 i;

	for (i = 0; i < 16; i++)
	{
		if (i < w)
		{
			u16  level;
			level = abs(coef[i]);
			enc_est += enc_eco_level_est_2_only(level);
		}
	}
	return enc_est;
}


static int enc_eco_coef_16_16_run(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h) {
#pragma HLS ARRAY_PARTITION variable=coef block factor = 16 dim=1
	int final_rate = 0;
	int last_x[16];  // the last non-zero position of scan-line.
	int last_y[16];

	int first_x[16]; // the first non-zero position of scan-line.
	int first_y[16];

	//int sumRate[16] = { 0, };
	int sumRate[16];
	int final_last_x = -1, final_last_y = -1;
	int final_zig_zag = 0;
#pragma HLS ARRAY_PARTITION variable=last_x		dim=1	complete
#pragma HLS ARRAY_PARTITION variable=last_y		dim=1	complete
#pragma HLS ARRAY_PARTITION variable=first_x	dim=1	complete
#pragma HLS ARRAY_PARTITION variable=first_y	dim=1	complete
#pragma HLS ARRAY_PARTITION variable=sumRate	dim=1	complete
	/*	memset(last_x, -1, sizeof(int) * 16);
		memset(last_y, -1, sizeof(int) * 16);

		memset(first_x, -1, sizeof(int) * 16);
		memset(first_y, -1, sizeof(int) * 16);*/
	for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL
		last_x[i] = -1;
		last_y[i] = -1;
		first_x[i] = -1;
		first_y[i] = -1;
		sumRate[i] = 0;
		//coef_out[i] =  0;
	}
	for (int j = 0; j < 11; j++) // vertical
	{
#pragma HLS PIPELINE
		int zzz = 0;
		for (int i = 0; i < 11; i++) // horizontal
		{
			if (j == 0) // first input row data.
			{
				if (coef[i][j])
				{
					last_x[i] = i;
					last_y[i] = j;

					first_x[i] = i;
					first_y[i] = j;
				}
			}

			else
			{
				if ((i == 0 && j == 10) || (i == 1 && j == 9)) {
					int zzz = 0;
					break;
				}
				else {

					if ((i + j) % 2 == 0) // above-right-scan
					{
						if (first_x[i] == -1 && coef[i][j])
						{
							first_x[i] = i;
							first_y[i] = j;
						}

						if (coef[i][j])
						{
							if (last_x[i] != -1)
							{
								int offset = last_x[i] - i;
								if (offset == 1) // previou is non-zero coeff. 
								{
									sumRate[i] += 1;
								}
								else
								{
									sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
								}
							}
							last_x[i] = i;
							last_y[i] = j;
						}
					}
					else // above - top scan for (i+j)%2 is even case
					{
						if (coef[i][j] && last_x[i] == -1) // first non-zero position
						{
							last_x[i] = i;
							last_y[i] = j;
						}

						if (coef[i][j] && first_x[i] != -1)
						{
							int offset = first_x[i] - i;
							if (offset == 1) // previou is non-zero coeff. 
							{
								sumRate[i] += 1;
							}
							else
							{
								// should change here.
								sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
							}
						}

						if (coef[i][j])
						{
							first_x[i] = i;
							first_y[i] = j;
						}
					}
				}
			}
		}

		// calculate the rate of the last coeff.
		int cur_zig_zag_num;
		if (last_x[0] == -1) // all zeros for current scan-line.
		{
			cur_zig_zag_num = j + 1;
			final_zig_zag += cur_zig_zag_num;
		}
		else
		{
			if (j % 2 == 1) // bottom -left scan
			{
				cur_zig_zag_num = first_x[0];
			}
			else
			{
				cur_zig_zag_num = j - first_x[0];
			}

			final_zig_zag += cur_zig_zag_num;

			// rate _cal:
			// get(final_zig_zag); 
			if (final_zig_zag == 0) // only one non-zero coeff.
			{
				final_rate += 1;
			}
			else
			{
				final_rate += enc_eco_run_est_2_only(final_zig_zag);
			}

			if (j % 2 == 1) // bottom -left scan
			{
				final_zig_zag = j - last_x[0]; // update
			}
			else
			{
				final_zig_zag = j - last_y[0]; // update
			}
			final_rate += sumRate[0];
		}


		// shift register.
		for (int i = 1; i < 16; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];

			first_x[i - 1] = first_x[i];
			first_y[i - 1] = first_y[i];

			sumRate[i - 1] = sumRate[i];
		}
	}
	return final_rate;
}

static int enc_eco_coef_16_8_run(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h) {
#pragma HLS ARRAY_PARTITION variable=coef block factor = 16 dim=1
	int final_rate = 0;
	int last_x[16];  // the last non-zero position of scan-line.
	int last_y[16];

	int first_x[16]; // the first non-zero position of scan-line.
	int first_y[16];

	//int sumRate[16] = { 0, };
	int sumRate[16];
	int final_last_x = -1, final_last_y = -1;
	int final_zig_zag = 0;

#pragma HLS ARRAY_PARTITION variable=last_x		dim=1	complete
#pragma HLS ARRAY_PARTITION variable=last_y		dim=1	complete
#pragma HLS ARRAY_PARTITION variable=first_x	dim=1	complete
#pragma HLS ARRAY_PARTITION variable=first_y	dim=1	complete

	/*memset(last_x, -1, sizeof(int) * 16);
	memset(last_y, -1, sizeof(int) * 16);

	memset(first_x, -1, sizeof(int) * 16);
	memset(first_y, -1, sizeof(int) * 16);*/
	for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL
		last_x[i] = -1;
		last_y[i] = -1;
		first_x[i] = -1;
		first_y[i] = -1;
		sumRate[i] = 0;
		//coef_out[i] =  0;
	}
	for (int j = 0; j < 12; j++) // vertical
	{
#pragma HLS PIPELINE
		int zzz = 0;
		for (int i = 0; i < 8; i++) // horizontal
		{
			if (j == 0) // first input row data.
			{
				if (coef[i][j])
				{
					last_x[i] = i;
					last_y[i] = j;

					first_x[i] = i;
					first_y[i] = j;
				}
			}
			else if (i == 7) {
				last_x[i] = -1;
				last_y[i] = -1;

				first_x[i] = -1;
				first_y[i] = -1;

				if (coef[i][j])
				{
					last_x[i] = i;
					last_y[i] = j;

					first_x[i] = i;
					first_y[i] = j;
				}
			}
			else
			{
				if ((i == 7 && j == 4) || (i == 6 && j == 5) || (i == 5 && j == 6) || (i == 4 && j == 7)) {
					int zzz = 0;
					break;
				}
				else {

					if ((i + j) % 2 == 0) // above-right-scan
					{
						if (first_x[i] == -1 && coef[i][j])
						{
							first_x[i] = i;
							first_y[i] = j;
						}

						if (coef[i][j])
						{
							if (last_x[i] != -1)
							{
								int offset = last_x[i] - i;
								if (offset == 1) // previou is non-zero coeff. 
								{
									sumRate[i] += 1;
								}
								else
								{
									sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
								}
							}
							last_x[i] = i;
							last_y[i] = j;
						}
					}
					else // above - top scan for (i+j)%2 is even case
					{
						if (coef[i][j] && last_x[i] == -1) // first non-zero position
						{
							last_x[i] = i;
							last_y[i] = j;
						}

						if (coef[i][j] && first_x[i] != -1)
						{
							int offset = first_x[i] - i;
							if (offset == 1) // previou is non-zero coeff. 
							{
								sumRate[i] += 1;
							}
							else
							{
								// should change here.
								sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
							}
						}

						if (coef[i][j])
						{
							first_x[i] = i;
							first_y[i] = j;
						}
					}
				}
			}
		}

		// calculate the rate of the last coeff.
		int cur_zig_zag_num;
		if (last_x[0] == -1) // all zeros for current scan-line.
		{
			if (j < 8) {
				cur_zig_zag_num = j + 1;
			}
			else if (j < 11) {
				cur_zig_zag_num = 8;
			}
			else {
				cur_zig_zag_num = 4;
			}
			final_zig_zag += cur_zig_zag_num;
		}
		else
		{
			if (j % 2 == 1) // bottom -left scan
			{
				cur_zig_zag_num = first_x[0];
			}
			else
			{
				if (j < 8) {
					cur_zig_zag_num = j - first_x[0];
				}
				else if (j < 11) {
					cur_zig_zag_num = 8 - 1 - first_x[0];
				}
				else {
					cur_zig_zag_num = 4 - 1 - first_x[0];
				}
			}

			final_zig_zag += cur_zig_zag_num;

			// rate _cal:
			// get(final_zig_zag); 
			if (final_zig_zag == 0) // only one non-zero coeff.
			{
				final_rate += 1;
			}
			else
			{
				final_rate += enc_eco_run_est_2_only(final_zig_zag);
			}

			if (j % 2 == 1) // bottom -left scan
			{
				if (j < 8) {
					final_zig_zag = j - last_x[0]; // update
				}
				else if (j < 11) {
					final_zig_zag = 8 - 1 - last_x[0];
				}
				else {
					final_zig_zag = 4 - 1 - last_x[0];
				}
			}
			else
			{
				final_zig_zag = j - last_y[0]; // update
			}
			final_rate += sumRate[0];
		}


		// shift register.
		for (int i = 1; i < 8; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];

			first_x[i - 1] = first_x[i];
			first_y[i - 1] = first_y[i];

			sumRate[i - 1] = sumRate[i];
		}
	}
	return final_rate;
}

static int enc_eco_coef_8_16_run(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h) {
#pragma HLS ARRAY_PARTITION variable=coef block factor = 16 dim=1
	int final_rate = 0;
	int last_x[16];  // the last non-zero position of scan-line.
	int last_y[16];

	int first_x[16]; // the first non-zero position of scan-line.
	int first_y[16];

	//int sumRate[16] = { 0, };
	int sumRate[16] ;
	int final_last_x = -1, final_last_y = -1;
	int final_zig_zag = 0;

	//memset(last_x, -1, sizeof(int) * 16);
	//memset(last_y, -1, sizeof(int) * 16);

	//memset(first_x, -1, sizeof(int) * 16);
	//memset(first_y, -1, sizeof(int) * 16);
#pragma HLS ARRAY_PARTITION variable=last_x		dim=1	complete
#pragma HLS ARRAY_PARTITION variable=last_y		dim=1	complete
#pragma HLS ARRAY_PARTITION variable=first_x	dim=1	complete
#pragma HLS ARRAY_PARTITION variable=first_y	dim=1	complete
#pragma HLS ARRAY_PARTITION variable=sumRate	dim=1	complete
	for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL
		last_x[i] = -1;
		last_y[i] = -1;
		first_x[i] = -1;
		first_y[i] = -1;
		sumRate[i] = 0;
	}
	int max_num = 0;
	for (int j = 0; j < 12; j++) // vertical
	{
#pragma HLS PIPELINE
		int zzz = 0;
		if (j < 4) {
			max_num = 11 - j;
		}
		else if (j < 8) {
			max_num = 12 - j;
		}
		else {
			max_num = 0;
		}
		//for (int i = 0; i < max_num; i++) // horizontal
		for (int i = 0; i < 11; i++)
		{
			if (i < max_num)
			{
				if (j == 0) // first input row data.
				{
					if (coef[i][j])
					{
						last_x[i] = i;
						last_y[i] = j;

						first_x[i] = i;
						first_y[i] = j;
					}
				}
				else
				{

					if ((i + j) % 2 == 0) // above-right-scan
					{
						if (first_x[i] == -1 && coef[i][j])
						{
							first_x[i] = i;
							first_y[i] = j;
						}

						if (coef[i][j])
						{
							if (last_x[i] != -1)
							{
								int offset = last_x[i] - i;
								if (offset == 1) // previou is non-zero coeff. 
								{
									sumRate[i] += 1;
								}
								else
								{
									sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
								}
							}
							last_x[i] = i;
							last_y[i] = j;
						}
					}
					else // above - top scan for (i+j)%2 is even case
					{
						if (coef[i][j] && last_x[i] == -1) // first non-zero position
						{
							last_x[i] = i;
							last_y[i] = j;
						}

						if (coef[i][j] && first_x[i] != -1)
						{
							int offset = first_x[i] - i;
							if (offset == 1) // previou is non-zero coeff. 
							{
								sumRate[i] += 1;
							}
							else
							{
								// should change here.
								sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
							}
						}

						if (coef[i][j])
						{
							first_x[i] = i;
							first_y[i] = j;
						}
					}
				}
			}
		}

		// calculate the rate of the last coeff.
		int cur_zig_zag_num;
		if (last_x[0] == -1) // all zeros for current scan-line.
		{
			if (j < 8) {
				cur_zig_zag_num = j + 1;
			}
			else if (j < 11) {
				cur_zig_zag_num = 8;
			}
			else {
				cur_zig_zag_num = 4;
			}
			final_zig_zag += cur_zig_zag_num;
		}
		else
		{
			if (j % 2 == 1) // bottom -left scan
			{
				if (j < 8) {
					cur_zig_zag_num = first_x[0];
				}
				else {
					cur_zig_zag_num = first_x[0] - j + 7;
				}
			}
			else
			{
				cur_zig_zag_num = j - first_x[0];
			}

			final_zig_zag += cur_zig_zag_num;

			// rate _cal:
			// get(final_zig_zag); 
			if (final_zig_zag == 0) // only one non-zero coeff.
			{
				final_rate += 1;
			}
			else
			{
				final_rate += enc_eco_run_est_2_only(final_zig_zag);
			}

			if (j % 2 == 1) // bottom -left scan
			{
				final_zig_zag = j - last_x[0]; // update
			}
			else
			{
				if (j < 8) {
					final_zig_zag = j - last_y[0]; // update
				}
				else {
					final_zig_zag = 7 - last_y[0];
				}
			}
			final_rate += sumRate[0];
		}


		// shift register.
		for (int i = 1; i < 16; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];

			first_x[i - 1] = first_x[i];
			first_y[i - 1] = first_y[i];

			sumRate[i - 1] = sumRate[i];
		}
	}
	return final_rate;
}

static int  enc_eco_coef_16_16_level(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	static s16 coef_out[16];
	int max_num = 0;
#pragma HLS ARRAY_PARTITION variable=coef_out complete dim=1


	for (U7 z = 0; z < 16; z++) {
#pragma HLS UNROLL
		coef_out[z] = 0;
	}
	for (int j = 0; j < 11; j++)
	{
#pragma HLS PIPELINE

		if (j < 9) {
			max_num = 11 - j;
		}
		else {
			max_num = 10 - j;
		}
		for (int i = 0; i < 11; i++)
		{
			if (i < max_num) {
				coef_out[i] = coef[i][j];
			}
		}
		enc_est += rate_coef_level_est_16(coef_out, max_num);
	}

	return enc_est;


}

static int  enc_eco_coef_16_8_level(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	static s16 coef_out[16];
	int max_num = 0;
#pragma HLS ARRAY_PARTITION variable=coef_out complete dim=1


	for (U7 z = 0; z < 16; z++) {
#pragma HLS UNROLL
		coef_out[z] = 0;
	}
	for (int j = 0; j < 12; j++)
	{
#pragma HLS PIPELINE
		if (j < 4) {
			max_num = 8;
		}
		else if (j < 8) {
			max_num = 11 - j;
		}
		else {
			max_num = 12 - j;
		}
		for (int i = 0; i < 8; i++)
		{
			if (i < max_num) {
				coef_out[i] = coef[i][j];
			}
		}
		enc_est += rate_coef_level_est_16(coef_out, max_num);
	}

	return enc_est;


}

static int  enc_eco_coef_8_16_level(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	static s16 coef_out[16];
	int max_num = 0;
#pragma HLS ARRAY_PARTITION variable=coef_out complete dim=1

	for (U7 z = 0; z < 16; z++) {
#pragma HLS UNROLL
		coef_out[z] = 0;
	}
	for (int j = 0; j < 8; j++)
	{
#pragma HLS PIPELINE
		if (j < 4) {
			max_num = 11 - j;
		}
		else {
			max_num = 12 - j;
		}
		for (int i = 0; i < 12; i++)
		{
			if (i < max_num) {
				coef_out[i] = coef[i][j];
			}
		}
		enc_est += rate_coef_level_est_16(coef_out, max_num);
	}

	return enc_est;


}


static int  enc_eco_coef_16_16(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h)
{
//#pragma HLS ARRAY_PARTITION variable=coef complete dim=0
	U15 enc_est = 0;
	enc_est += enc_eco_coef_16_16_run(cu_width, cu_height, coef, log2_w, log2_h);
	enc_est += enc_eco_coef_16_16_level(cu_width, cu_height, coef, log2_w, log2_h);
	return enc_est;

}

static int  enc_eco_coef_16_8(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h)
{
#pragma HLS ARRAY_PARTITION variable=coef complete dim=0
	U15 enc_est = 0;
	enc_est += enc_eco_coef_16_8_run(cu_width, cu_height, coef, log2_w, log2_h);
	enc_est += enc_eco_coef_16_8_level(cu_width, cu_height, coef, log2_w, log2_h);
	return enc_est;

}

static int  enc_eco_coef_8_16(U8 cu_width, U8 cu_height, s16 coef[16][16], U3 log2_w, U3 log2_h)
{
#pragma HLS ARRAY_PARTITION variable=coef complete dim=0
	U15 enc_est = 0;
	enc_est += enc_eco_coef_8_16_run(cu_width, cu_height, coef, log2_w, log2_h);
	enc_est += enc_eco_coef_8_16_level(cu_width, cu_height, coef, log2_w, log2_h);
	return enc_est;

}
static int enc_bit_est_flag_16(U2 slice_type, U21 f_scu, u8 curr_mvr, U2 tree_status, U2 cons_pred_mode, U2 cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, u8 num_refp, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], int cur_ptr, int refp_ptr0, int refp_ptr1, u8 num_of_hmvp_cand, u8 mpm[4][2], U1 intra)
{
#pragma HLS array_partition variable=mpm complete dim=0
	//#pragma HLS array_partition variable=model_cnt->cbf complete dim=0
#pragma HLS array_partition variable=num_nz complete dim=0
#pragma HLS array_partition variable=ipm complete dim=0
#pragma HLS array_partition variable=refi complete dim=0
#pragma HLS array_partition variable=mvd complete dim=0

	U8 enc_est = 0;
	if (intra) {
		if (slice_type != 1) {
			if ((cons_pred_mode) != (ONLY_INTRA)) {
				enc_est += 2;
			}
			if (cons_pred_mode == NO_MODE_CONS) {
				enc_est++;
			}
		}
		enc_est += encode_intra_dir_est(ipm[0][0], mpm[0]);
		enc_est++;
	}
	else {
		U2 skip_flag = (cu_mode == 2);
		U2 dir_flag = (cu_mode == 3);
		U1 umve_enable_flag = 1;
		U4 num_of_hmvp_cand = 8;
		U1 amvr_enable_flag = 1;
		U1 emvr_enable_flag = 1;
		U1 smvd_enable_flag = 1;
		enc_est++;
		if (!skip_flag) {
			enc_est++;
		}
		if (skip_flag || dir_flag) {
			if (umve_enable_flag) {
				enc_est++;
			}
			if (umve_flag) {
				enc_est += encode_umve_idx_est((umve_idx));
			}
			else {
				if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
								}
								else */ {
					enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
				}
			}
		}
		else {
			if (((cons_pred_mode)) == (NO_MODE_CONS)) {
				enc_est++;
			}
			enc_est += encode_affine_flag_est(((affine_flag)) != 0, 1, cu_width_log2, cu_height_log2);
			if (amvr_enable_flag) {
				// also imply ctx->info.sqh.num_of_hmvp_cand is not zero
				if (emvr_enable_flag && !affine_flag) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 3);
								}
								else */ {
					enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 5);
				}
			}
			{
				S8 refi0 = refi[0];
				S8 refi1 = refi[1];
				if ((smvd_enable_flag) && refi0 >= 0 && refi1 >= 0 && cur_ptr - (refp_ptr0) == (refp_ptr1)-cur_ptr && (affine_flag) == 0 && !(mvp_from_hmvp_flag)) {
					enc_est++;
				}
				if (IS_INTER_SLICE(slice_type) && refi0 >= 0) {
					if ((smvd_flag) == 0)
						if ((num_refp) > 1) {
							enc_est += sbac_write_truncate_unary_sym_est(refi0, num_refp);
						}
					/*					if (affine_flag) {
											S16 affine_mvd_real[2];
											U3 amvr_shift = ((curr_mvr) == 0 ? 2 : (((curr_mvr) == 1 ? 4 : 0)));
											affine_mvd_real[0] = (((affine_mvd[0][0][0]) >> (amvr_shift)));
											affine_mvd_real[1] = (((affine_mvd[0][0][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real);
											S16 affine_mvd_real_1[2];
											affine_mvd_real_1[0] = (((affine_mvd[0][1][0]) >> (amvr_shift)));
											affine_mvd_real_1[1] = (((affine_mvd[0][1][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real_1);
										}
										else */ {
						S16 a_mvd[2];
						a_mvd[0] = (((mvd[0][0]) >> (curr_mvr)));
						a_mvd[1] = (((mvd[0][1]) >> (curr_mvr)));
						enc_est += encode_mvd_est(a_mvd);
					}
				}
			}
		}


		if (tree_status != TREE_C) {
			enc_est += enc_eco_cbf_est_16(num_nz, cu_mode, ipm, tree_status, cu_width_log2, cu_height_log2);
		}
		else if (!((cu_mode) == 0 && (ipm[0][0]) == 33
			&& (ipm[0][1]) == 0)) {
			enc_est += 2;
			//model_cnt->cbf[1]++;
		}
	}

	return enc_est;
}

static int enc_bit_est_flag_8_16(U2 slice_type, U21 f_scu, u8 curr_mvr, U2 tree_status, U2 cons_pred_mode, U2 cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, u8 num_refp, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], int cur_ptr, int refp_ptr0, int refp_ptr1, u8 num_of_hmvp_cand, u8 mpm[4][2], U1 intra)
{
#pragma HLS array_partition variable=mpm complete dim=0
	//#pragma HLS array_partition variable=model_cnt->cbf complete dim=0
#pragma HLS array_partition variable=num_nz complete dim=0
#pragma HLS array_partition variable=ipm complete dim=0
#pragma HLS array_partition variable=refi complete dim=0
#pragma HLS array_partition variable=mvd complete dim=0

	U8 enc_est = 0;
	if (intra) {
		if (slice_type != 1) {
			if ((cons_pred_mode) != (ONLY_INTRA)) {
				enc_est += 2;
			}
			if (cons_pred_mode == NO_MODE_CONS) {
				enc_est++;
			}
		}
		enc_est += encode_intra_dir_est(ipm[0][0], mpm[0]);
		enc_est++;
	}
	else {
		U2 skip_flag = (cu_mode == 2);
		U2 dir_flag = (cu_mode == 3);
		U1 umve_enable_flag = 1;
		U4 num_of_hmvp_cand = 8;
		U1 amvr_enable_flag = 1;
		U1 emvr_enable_flag = 1;
		U1 smvd_enable_flag = 1;
		enc_est++;
		if (!skip_flag) {
			enc_est++;
		}
		if (skip_flag || dir_flag) {
			if (umve_enable_flag) {
				enc_est++;
			}
			if (umve_flag) {
				enc_est += encode_umve_idx_est((umve_idx));
			}
			else {
				if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
								}
								else */ {
					enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
				}
			}
		}
		else {
			if (((cons_pred_mode)) == (NO_MODE_CONS)) {
				enc_est++;
			}
			enc_est += encode_affine_flag_est(((affine_flag)) != 0, 1, cu_width_log2, cu_height_log2);
			if (amvr_enable_flag) {
				// also imply ctx->info.sqh.num_of_hmvp_cand is not zero
				if (emvr_enable_flag && !affine_flag) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 3);
								}
								else */ {
					enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 5);
				}
			}
			{
				S8 refi0 = refi[0];
				S8 refi1 = refi[1];
				if ((smvd_enable_flag) && refi0 >= 0 && refi1 >= 0 && cur_ptr - (refp_ptr0) == (refp_ptr1)-cur_ptr && (affine_flag) == 0 && !(mvp_from_hmvp_flag)) {
					enc_est++;
				}
				if (IS_INTER_SLICE(slice_type) && refi0 >= 0) {
					if ((smvd_flag) == 0)
						if ((num_refp) > 1) {
							enc_est += sbac_write_truncate_unary_sym_est(refi0, num_refp);
						}
					/*					if (affine_flag) {
											S16 affine_mvd_real[2];
											U3 amvr_shift = ((curr_mvr) == 0 ? 2 : (((curr_mvr) == 1 ? 4 : 0)));
											affine_mvd_real[0] = (((affine_mvd[0][0][0]) >> (amvr_shift)));
											affine_mvd_real[1] = (((affine_mvd[0][0][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real);
											S16 affine_mvd_real_1[2];
											affine_mvd_real_1[0] = (((affine_mvd[0][1][0]) >> (amvr_shift)));
											affine_mvd_real_1[1] = (((affine_mvd[0][1][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real_1);
										}
										else */ {
						S16 a_mvd[2];
						a_mvd[0] = (((mvd[0][0]) >> (curr_mvr)));
						a_mvd[1] = (((mvd[0][1]) >> (curr_mvr)));
						enc_est += encode_mvd_est(a_mvd);
					}
				}
			}
		}


		if (tree_status != TREE_C) {
			enc_est += enc_eco_cbf_est_16(num_nz, cu_mode, ipm, tree_status, cu_width_log2, cu_height_log2);
		}
		else if (!((cu_mode) == 0 && (ipm[0][0]) == 33
			&& (ipm[0][1]) == 0)) {
			enc_est += 2;
			//model_cnt->cbf[1]++;
		}
	}

	return enc_est;
}

static int enc_bit_est_flag_16_8(U2 slice_type, U21 f_scu, u8 curr_mvr, U2 tree_status, U2 cons_pred_mode, U2 cu_mode,
 u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], 
 u8 mvp_from_hmvp_flag, u8 smvd_flag, u8 num_refp, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], 
 U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], int cur_ptr, 
 int refp_ptr0, int refp_ptr1, u8 num_of_hmvp_cand, u8 mpm[4][2], U1 intra)
{
#pragma HLS array_partition variable=mpm complete dim=0
	//#pragma HLS array_partition variable=model_cnt->cbf complete dim=0
#pragma HLS array_partition variable=num_nz complete dim=0
#pragma HLS array_partition variable=ipm complete dim=0
#pragma HLS array_partition variable=refi complete dim=0
#pragma HLS array_partition variable=mvd complete dim=0

	U8 enc_est = 0;
	if (intra) {
		if (slice_type != 1) {
			if ((cons_pred_mode) != (ONLY_INTRA)) {
				enc_est += 2;
			}
			if (cons_pred_mode == NO_MODE_CONS) {
				enc_est++;
			}
		}
		enc_est += encode_intra_dir_est(ipm[0][0], mpm[0]);
		enc_est++;
	}
	else {
		U2 skip_flag = (cu_mode == 2);
		U2 dir_flag = (cu_mode == 3);
		U1 umve_enable_flag = 1;
		U4 num_of_hmvp_cand = 8;
		U1 amvr_enable_flag = 1;
		U1 emvr_enable_flag = 1;
		U1 smvd_enable_flag = 1;
		enc_est++;
		if (!skip_flag) {
			enc_est++;
		}
		if (skip_flag || dir_flag) {
			if (umve_enable_flag) {
				enc_est++;
			}
			if (umve_flag) {
				enc_est += encode_umve_idx_est((umve_idx));
			}
			else {
				if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
								}
								else */ {
					enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
				}
			}
		}
		else {
			if (((cons_pred_mode)) == (NO_MODE_CONS)) {
				enc_est++;
			}
			enc_est += encode_affine_flag_est(((affine_flag)) != 0, 1, cu_width_log2, cu_height_log2);
			if (amvr_enable_flag) {
				// also imply ctx->info.sqh.num_of_hmvp_cand is not zero
				if (emvr_enable_flag && !affine_flag) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 3);
								}
								else */ {
					enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 5);
				}
			}
			{
				S8 refi0 = refi[0];
				S8 refi1 = refi[1];
				if ((smvd_enable_flag) && refi0 >= 0 && refi1 >= 0 && cur_ptr - (refp_ptr0) == (refp_ptr1)-cur_ptr && (affine_flag) == 0 && !(mvp_from_hmvp_flag)) {
					enc_est++;
				}
				if (IS_INTER_SLICE(slice_type) && refi0 >= 0) {
					if ((smvd_flag) == 0)
						if ((num_refp) > 1) {
							enc_est += sbac_write_truncate_unary_sym_est(refi0, num_refp);
						}
					/*					if (affine_flag) {
											S16 affine_mvd_real[2];
											U3 amvr_shift = ((curr_mvr) == 0 ? 2 : (((curr_mvr) == 1 ? 4 : 0)));
											affine_mvd_real[0] = (((affine_mvd[0][0][0]) >> (amvr_shift)));
											affine_mvd_real[1] = (((affine_mvd[0][0][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real);
											S16 affine_mvd_real_1[2];
											affine_mvd_real_1[0] = (((affine_mvd[0][1][0]) >> (amvr_shift)));
											affine_mvd_real_1[1] = (((affine_mvd[0][1][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real_1);
										}
										else */ {
						S16 a_mvd[2];
						a_mvd[0] = (((mvd[0][0]) >> (curr_mvr)));
						a_mvd[1] = (((mvd[0][1]) >> (curr_mvr)));
						enc_est += encode_mvd_est(a_mvd);
					}
				}
			}
		}


		if (tree_status != TREE_C) {
			enc_est += enc_eco_cbf_est_16(num_nz, cu_mode, ipm, tree_status, cu_width_log2, cu_height_log2);
		}
		else if (!((cu_mode) == 0 && (ipm[0][0]) == 33
			&& (ipm[0][1]) == 0)) {
			enc_est += 2;
			//model_cnt->cbf[1]++;
		}
	}

	return enc_est;
}

static int enc_bit_est_flag_16_16(U2 slice_type, U21 f_scu, u8 curr_mvr, U2 tree_status, U2 cons_pred_mode, U2 cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, u8 num_refp, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], int cur_ptr, int refp_ptr0, int refp_ptr1, u8 num_of_hmvp_cand, u8 mpm[4][2], U1 intra)
{
#pragma HLS array_partition variable=mpm complete dim=0
	//#pragma HLS array_partition variable=model_cnt->cbf complete dim=0
#pragma HLS array_partition variable=num_nz complete dim=0
#pragma HLS array_partition variable=ipm complete dim=0
#pragma HLS array_partition variable=refi complete dim=0
#pragma HLS array_partition variable=mvd complete dim=0

	U8 enc_est = 0;
	if (intra) {
		if (slice_type != 1) {
			if ((cons_pred_mode) != (ONLY_INTRA)) {
				enc_est += 2;
			}
			if (cons_pred_mode == NO_MODE_CONS) {
				enc_est++;
			}
		}
		enc_est += encode_intra_dir_est(ipm[0][0], mpm[0]);
		enc_est++;
	}
	else {
		U2 skip_flag = (cu_mode == 2);
		U2 dir_flag = (cu_mode == 3);
		U1 umve_enable_flag = 1;
		U4 num_of_hmvp_cand = 8;
		U1 amvr_enable_flag = 1;
		U1 emvr_enable_flag = 1;
		U1 smvd_enable_flag = 1;
		enc_est++;
		if (!skip_flag) {
			enc_est++;
		}
		if (skip_flag || dir_flag) {
			if (umve_enable_flag) {
				enc_est++;
			}
			if (umve_flag) {
				enc_est += encode_umve_idx_est((umve_idx));
			}
			else {
				if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
								}
								else */ {
					enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
				}
			}
		}
		else {
			if (((cons_pred_mode)) == (NO_MODE_CONS)) {
				enc_est++;
			}
			enc_est += encode_affine_flag_est(((affine_flag)) != 0, 1, cu_width_log2, cu_height_log2);
			if (amvr_enable_flag) {
				// also imply ctx->info.sqh.num_of_hmvp_cand is not zero
				if (emvr_enable_flag && !affine_flag) {
					enc_est++;
				}
				/*				if (affine_flag) {
									enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 3);
								}
								else */ {
					enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 5);
				}
			}
			{
				S8 refi0 = refi[0];
				S8 refi1 = refi[1];
				if ((smvd_enable_flag) && refi0 >= 0 && refi1 >= 0 && cur_ptr - (refp_ptr0) == (refp_ptr1)-cur_ptr && (affine_flag) == 0 && !(mvp_from_hmvp_flag)) {
					enc_est++;
				}
				if (IS_INTER_SLICE(slice_type) && refi0 >= 0) {
					if ((smvd_flag) == 0)
						if ((num_refp) > 1) {
							enc_est += sbac_write_truncate_unary_sym_est(refi0, num_refp);
						}
					/*					if (affine_flag) {
											S16 affine_mvd_real[2];
											U3 amvr_shift = ((curr_mvr) == 0 ? 2 : (((curr_mvr) == 1 ? 4 : 0)));
											affine_mvd_real[0] = (((affine_mvd[0][0][0]) >> (amvr_shift)));
											affine_mvd_real[1] = (((affine_mvd[0][0][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real);
											S16 affine_mvd_real_1[2];
											affine_mvd_real_1[0] = (((affine_mvd[0][1][0]) >> (amvr_shift)));
											affine_mvd_real_1[1] = (((affine_mvd[0][1][1]) >> (amvr_shift)));
											enc_est += encode_mvd_est(affine_mvd_real_1);
										}
										else */ {
						S16 a_mvd[2];
						a_mvd[0] = (((mvd[0][0]) >> (curr_mvr)));
						a_mvd[1] = (((mvd[0][1]) >> (curr_mvr)));
						enc_est += encode_mvd_est(a_mvd);
					}
				}
			}
		}


		if (tree_status != TREE_C) {
			enc_est += enc_eco_cbf_est_16(num_nz, cu_mode, ipm, tree_status, cu_width_log2, cu_height_log2);
		}
		else if (!((cu_mode) == 0 && (ipm[0][0]) == 33
			&& (ipm[0][1]) == 0)) {
			enc_est += 2;
			//model_cnt->cbf[1]++;
		}
	}

	return enc_est;
}

static int get_bitcnt_est_8_16_coef_0(U21 f_scu, u8 curr_mvr, U2 tree_status,
	U2 ch_type, U2 slice_type, U2 cons_pred_mode, U2 cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, u8 num_refp, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], U3 cu_width_log2, U3 cu_height_log2, int tb_part, int pb_part, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], U2 slice_type_md, U9 cur_ptr, int refp_ptr0, int refp_ptr1, u8 mpm[4][2], U1 is_intra)
{

	U16 enc_est;
	enc_est = enc_bit_est_flag_8_16(slice_type, f_scu, curr_mvr, tree_status, cons_pred_mode, cu_mode, umve_flag, umve_idx, affine_flag, 1, skip_idx, refi, mvp_from_hmvp_flag, smvd_flag, num_refp, affine_mvd, mvd, cu_width_log2, cu_height_log2, num_nz, ipm, cur_ptr, refp_ptr0, refp_ptr1, 8, mpm, is_intra);
	return enc_est;
}
static int get_bitcnt_est_16_8_coef_0(U21 f_scu, u8 curr_mvr, U2 tree_status,
	U2 ch_type, U2 slice_type, U2 cons_pred_mode, U2 cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, u8 num_refp, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], U3 cu_width_log2, U3 cu_height_log2, int tb_part, int pb_part, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], U2 slice_type_md, U9 cur_ptr, int refp_ptr0, int refp_ptr1, u8 mpm[4][2], U1 is_intra)
{

	U16 enc_est;
	enc_est = enc_bit_est_flag_16_8(slice_type, f_scu, curr_mvr, tree_status, cons_pred_mode, cu_mode, umve_flag, umve_idx, affine_flag, 1, skip_idx, refi, mvp_from_hmvp_flag, smvd_flag, num_refp, affine_mvd, mvd, cu_width_log2, cu_height_log2, num_nz, ipm, cur_ptr, refp_ptr0, refp_ptr1, 8, mpm, is_intra);
	return enc_est;
}
static int get_bitcnt_est_16_16_coef_0(U21 f_scu, u8 curr_mvr, U2 tree_status,
	U2 ch_type, U2 slice_type, U2 cons_pred_mode, U2 cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, u8 num_refp, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], U3 cu_width_log2, U3 cu_height_log2, int tb_part, int pb_part, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], U2 slice_type_md, U9 cur_ptr, int refp_ptr0, int refp_ptr1, u8 mpm[4][2], U1 is_intra)
{

	U16 enc_est;
	enc_est = enc_bit_est_flag_16_16(slice_type, f_scu, curr_mvr, tree_status, cons_pred_mode, cu_mode, umve_flag, umve_idx, affine_flag, 1, skip_idx, refi, mvp_from_hmvp_flag, smvd_flag, num_refp, affine_mvd, mvd, cu_width_log2, cu_height_log2, num_nz, ipm, cur_ptr, refp_ptr0, refp_ptr1, 8, mpm, is_intra);
	return enc_est;
}

static int enc_eco_cbf_est_skip_16(U1 tb_avaliable, int num_nz[4][3], U2 pred_mode, S8 ipm[4][2], U2 tree_status, U3 cu_width_log2, U3 cu_height_log2)
{
	U4 enc_est = 0;
	if ((pred_mode) != 0) {
		if (!((pred_mode) == 3)) {
			if (tree_status == TREE_LC) {
				if (cu_width_log2 > 6 || cu_height_log2 > 6) {
					enc_est++;
				}
				else {
					enc_est++;
				}

				return 0;

			}
		}
		if (tb_avaliable) {
			enc_est++;
		}

		if (tree_status == TREE_LC) {
			enc_est += 2;
			//model_cnt->cbf[1]++;
		}
		else {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);

			enc_est += 1;
			//model_cnt->cbf[0]++;
		}
	}
	else {
		if (!((ipm[0][0]) == 33)) {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);
			enc_est += 1;
			//model_cnt->cbf[0]++;

		}
		if (tree_status == TREE_LC) {
			if (!((ipm[0][0]) == 33 && (ipm[0][1]) == 0)) {
				enc_est += 2;
				//model_cnt->cbf[1]++;
			}
		}
	}
	return enc_est;
}

static int enc_bit_est_flag_skip_16(U2 slice_type, U2 tree_status, u8 umve_flag, u8 umve_idx, u8 affine_flag, u8 skip_idx, U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], u8 num_of_hmvp_cand)
{
	int enc_est = 0;
	int umve_enable_flag = 1;
	enc_est++;
	if (umve_enable_flag) {
		enc_est++;
	}
	if (umve_flag) {
		enc_est += encode_umve_idx_est((umve_idx));
	}
	else {
		if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
			enc_est++;
		}
		//if (affine_flag) {
		//	enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
		//}
		//else
		{
			enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
		}
	}

	if (tree_status != TREE_C) {
		enc_est += enc_eco_cbf_est_skip_16(0, num_nz, 2, ipm, tree_status, cu_width_log2, cu_height_log2);
	}
	else if (!((2) == 0 && (ipm[0][0]) == 33
		&& (ipm[0][1]) == 0)) {
		enc_est += 2;
		//model_cnt->cbf[1]++;

	}
	return enc_est;
}
static int enc_bit_est_flag_skip_8_16(U2 slice_type, U2 tree_status, u8 umve_flag, u8 umve_idx, u8 affine_flag, u8 skip_idx, U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], u8 num_of_hmvp_cand)
{
	int enc_est = 0;
	int umve_enable_flag = 1;
	enc_est++;
	if (umve_enable_flag) {
		enc_est++;
	}
	if (umve_flag) {
		enc_est += encode_umve_idx_est((umve_idx));
	}
	else {
		if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
			enc_est++;
		}
		//if (affine_flag) {
		//	enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
		//}
		//else
		{
			enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
		}
	}

	if (tree_status != TREE_C) {
		enc_est += enc_eco_cbf_est_skip_16(0, num_nz, 2, ipm, tree_status, cu_width_log2, cu_height_log2);
	}
	else if (!((2) == 0 && (ipm[0][0]) == 33
		&& (ipm[0][1]) == 0)) {
		enc_est += 2;
		//model_cnt->cbf[1]++;

	}
	return enc_est;
}

static int enc_bit_est_flag_skip_16_8(U2 slice_type, U2 tree_status, u8 umve_flag, u8 umve_idx, u8 affine_flag, u8 skip_idx, U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], u8 num_of_hmvp_cand)
{
	int enc_est = 0;
	int umve_enable_flag = 1;
	enc_est++;
	if (umve_enable_flag) {
		enc_est++;
	}
	if (umve_flag) {
		enc_est += encode_umve_idx_est((umve_idx));
	}
	else {
		if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
			enc_est++;
		}
		//if (affine_flag) {
		//	enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
		//}
		//else
		{
			enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
		}
	}

	if (tree_status != TREE_C) {
		enc_est += enc_eco_cbf_est_skip_16(0, num_nz, 2, ipm, tree_status, cu_width_log2, cu_height_log2);
	}
	else if (!((2) == 0 && (ipm[0][0]) == 33
		&& (ipm[0][1]) == 0)) {
		enc_est += 2;
		//model_cnt->cbf[1]++;

	}
	return enc_est;
}

static int enc_bit_est_flag_skip_16_16(U2 slice_type, U2 tree_status, u8 umve_flag, u8 umve_idx, u8 affine_flag, u8 skip_idx, U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], u8 num_of_hmvp_cand)
{
	int enc_est = 0;
	int umve_enable_flag = 1;
	enc_est++;
	if (umve_enable_flag) {
		enc_est++;
	}
	if (umve_flag) {
		enc_est += encode_umve_idx_est((umve_idx));
	}
	else {
		if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
			enc_est++;
		}
		//if (affine_flag) {
		//	enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
		//}
		//else
		{
			enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
		}
	}

	if (tree_status != TREE_C) {
		enc_est += enc_eco_cbf_est_skip_16(0, num_nz, 2, ipm, tree_status, cu_width_log2, cu_height_log2);
	}
	else if (!((2) == 0 && (ipm[0][0]) == 33
		&& (ipm[0][1]) == 0)) {
		enc_est += 2;
		//model_cnt->cbf[1]++;

	}
	return enc_est;
}


static int enc_eco_run_length_cc_est_2(s16* coef, int log2_w, int log2_h, int num_sig);

void rate_est_8_16(U8 cu_width, U8 cu_height, MD_FW* md_fw_ptr, 
	S3 mod_info_refi_for_rate[2], s16 mod_info_mvd_for_rate[2][2], u8 num_refp_for_rate, S8 mod_info_ipm_for_rate[4][2], u8 mod_info_mpm_for_rate[4][2],
	MD_KERNEL_MODE* md_info_nz, u8 mode_type_rate, u8* mode_type_update,
	u8 curr_mvr_rate, u8* curr_mvr_update, u8 tree_status, u8 cons_pred_mode, s16 coef_y_pb_part[16][16], s64 lambda,
	U1 is_intra_rate, U1* is_intra_update, s64 flag_cost[2], int num_nz_rate[MAX_NUM_TB][N_C], MD_KERNEL_INPUT* md_kernel_input, int refp_ptr0, int refp_ptr1)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_rate
#pragma HLS INTERFACE axis port=mode_type_update
#pragma HLS INTERFACE axis port=curr_mvr_rate
#pragma HLS INTERFACE axis port=curr_mvr_update
#pragma HLS INTERFACE axis port=is_intra_rate
#pragma HLS INTERFACE axis port=is_intra_update
#pragma HLS RESOURCE variable=coef_y_pb_part core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=flag_cost core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=flag_cost complete dim=0

	// STREAM BUFFER
	u8 mode_type_read = mode_type_rate;
	u8 curr_mvr_read = curr_mvr_rate;
	U1 is_intra_read = is_intra_rate;

	flag_cost[0] = 0;
//#if ENABLE_BFRAME
//	U16 flag_est = enc_bit_est_flag_8_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, md_info_nz->refi, 0, md_info_nz->smvd_flag, md_fw_ptr->num_refp[0], md_info_nz->affine_mvd, md_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, 8, md_info_nz->mpm, is_intra_read);
//#else
//	U16 flag_est = enc_bit_est_flag_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, md_info_nz->refi, 0, md_info_nz->smvd_flag, md_fw_ptr->num_refp, md_info_nz->affine_mvd, md_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, 8, md_info_nz->mpm, is_intra_read);
//#endif
	U16 flag_est = enc_bit_est_flag_8_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode,
		md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx,
		mod_info_refi_for_rate, 0, md_info_nz->smvd_flag, num_refp_for_rate, md_info_nz->affine_mvd, mod_info_mvd_for_rate,
		md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, mod_info_ipm_for_rate, md_fw_ptr->cur_ptr,
		refp_ptr0, refp_ptr1, 8, mod_info_mpm_for_rate, is_intra_read);
#if RATE_EST_SWITCH
	U16 coef_est = 0;
		coef_est = enc_eco_coef_8_16(cu_width, cu_height, coef_y_pb_part, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2);
#else
	static s16 coef_tmp[128];
	for (int i = 0; i < cu_height; i++)
	{
		for (int j = 0; j < cu_width; j++)
		{
			coef_tmp[i * cu_width + j] = coef_y_pb_part[i][j];
		}
	}
	U16 coef_est = enc_eco_run_length_cc_est_2(coef_tmp, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate[0][0]);
#endif
	U16 bit_cnt = flag_est + coef_est;
	flag_cost[0] += (bit_cnt * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;

	if (is_intra_read == 0) {
		if (mode_type_read == 0) {
			flag_cost[1] = 0;
			flag_est = enc_bit_est_flag_skip_8_16(md_fw_ptr->slice_type, tree_status, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, md_info_nz->skip_idx, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, 8);
			flag_cost[1] += (flag_est * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		}
	}

	// WRITE STREAMS
	*curr_mvr_update = curr_mvr_read;
	*mode_type_update = mode_type_read;
	*is_intra_update = is_intra_read;
}

void rate_est_16_8(U8 cu_width, U8 cu_height, MD_FW* md_fw_ptr,
	S3 mod_info_refi_for_rate[2], s16 mod_info_mvd_for_rate[2][2], u8 num_refp_for_rate, S8 mod_info_ipm_for_rate[4][2], u8 mod_info_mpm_for_rate[4][2],
	MD_KERNEL_MODE* md_info_nz, u8 mode_type_rate, u8* mode_type_update,
	u8 curr_mvr_rate, u8* curr_mvr_update, u8 tree_status, u8 cons_pred_mode, s16 coef_y_pb_part[16][16], s64 lambda,
	U1 is_intra_rate, U1* is_intra_update, s64 flag_cost[2], int num_nz_rate[MAX_NUM_TB][N_C], MD_KERNEL_INPUT* md_kernel_input, int refp_ptr0, int refp_ptr1)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_rate
#pragma HLS INTERFACE axis port=mode_type_update
#pragma HLS INTERFACE axis port=curr_mvr_rate
#pragma HLS INTERFACE axis port=curr_mvr_update
#pragma HLS INTERFACE axis port=is_intra_rate
#pragma HLS INTERFACE axis port=is_intra_update
#pragma HLS RESOURCE variable=coef_y_pb_part core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=flag_cost core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=flag_cost complete dim=0

	// STREAM BUFFER
	u8 mode_type_read = mode_type_rate;
	u8 curr_mvr_read = curr_mvr_rate;
	U1 is_intra_read = is_intra_rate;

	flag_cost[0] = 0;
#if ENABLE_BFRAME
	U16 flag_est = enc_bit_est_flag_16_8(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status,
		cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, 
		mod_info_refi_for_rate, 0, md_info_nz->smvd_flag, num_refp_for_rate, md_info_nz->affine_mvd, mod_info_mvd_for_rate,
		md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, mod_info_ipm_for_rate, md_fw_ptr->cur_ptr,
		refp_ptr0, refp_ptr1, 8, mod_info_mpm_for_rate, is_intra_read);
#else
U16 flag_est = enc_bit_est_flag_16_8(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status,
		cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, 
		mod_info_refi_for_rate, 0, md_info_nz->smvd_flag, num_refp_for_rate, md_info_nz->affine_mvd, mod_info_mvd_for_rate,
		md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, mod_info_ipm_for_rate, md_fw_ptr->cur_ptr,
		refp_ptr0, refp_ptr1, 8, mod_info_mpm_for_rate, is_intra_read);
#endif

#if RATE_EST_SWITCH
	U16 coef_est = 0;
		coef_est = enc_eco_coef_16_8(cu_width, cu_height, coef_y_pb_part, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2);
	
#else
static s16 coef_tmp[128];
for (int i = 0; i < cu_height; i++)
{
	for (int j = 0; j < cu_width; j++)
	{
		coef_tmp[i * cu_width + j] = coef_y_pb_part[i][j];
	}
}
U16 coef_est = enc_eco_run_length_cc_est_2(coef_tmp, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate[0][0]);
#endif
	U16 bit_cnt = flag_est + coef_est;
	flag_cost[0] += (bit_cnt * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;

	if (is_intra_read == 0) {
		if (mode_type_read == 0) {
			flag_cost[1] = 0;
			flag_est = enc_bit_est_flag_skip_16_8(md_fw_ptr->slice_type, tree_status, md_info_nz->umve_flag,
				md_info_nz->umve_idx, md_info_nz->affine_flag, md_info_nz->skip_idx, md_kernel_input->cu_width_log2,
				md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, 8);
			flag_cost[1] += (flag_est * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		}
	}

	// WRITE STREAMS
	*curr_mvr_update = curr_mvr_read;
	*mode_type_update = mode_type_read;
	*is_intra_update = is_intra_read;
}

void rate_est_16_16(U8 cu_width, U8 cu_height, MD_FW* md_fw_ptr,
	S3 mod_info_refi_for_rate[2], s16 mod_info_mvd_for_rate[2][2], u8 num_refp_for_rate, S8 mod_info_ipm_for_rate[4][2], u8 mod_info_mpm_for_rate[4][2],
	MD_KERNEL_MODE* md_info_nz, u8 mode_type_rate, u8* mode_type_update,
	u8 curr_mvr_rate, u8* curr_mvr_update, u8 tree_status, u8 cons_pred_mode, s16 coef_y_pb_part_ori[16][16], s64 lambda,
	U1 is_intra_rate, U1* is_intra_update, s64 flag_cost[2], int num_nz_rate[MAX_NUM_TB][N_C], MD_KERNEL_INPUT* md_kernel_input, int refp_ptr0, int refp_ptr1)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_rate
#pragma HLS INTERFACE axis port=mode_type_update
#pragma HLS INTERFACE axis port=curr_mvr_rate
#pragma HLS INTERFACE axis port=curr_mvr_update
#pragma HLS INTERFACE axis port=is_intra_rate
#pragma HLS INTERFACE axis port=is_intra_update
#pragma HLS RESOURCE variable=coef_y_pb_part core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=flag_cost core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=flag_cost complete dim=0

	// STREAM BUFFER
	u8 mode_type_read = mode_type_rate;
	u8 curr_mvr_read = curr_mvr_rate;
	U1 is_intra_read = is_intra_rate;
	s16 coef_y_pb_part[16][16];
#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part_ori complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part complete dim=2
	flag_cost[0] = 0;
		for (int i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < cu_width; j++)
		{
			coef_y_pb_part[i][j] = coef_y_pb_part_ori[i][j];
		}

	}
//#if ENABLE_BFRAME
//	U16 flag_est = enc_bit_est_flag_16_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag,
//		md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, md_info_nz->refi, 0, md_info_nz->smvd_flag, md_fw_ptr->num_refp[0], md_info_nz->affine_mvd,
//		md_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, 8, md_info_nz->mpm,
//		is_intra_read);
//#else
//	U16 flag_est = enc_bit_est_flag_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, md_info_nz->refi, 0, md_info_nz->smvd_flag, md_fw_ptr->num_refp, md_info_nz->affine_mvd, md_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, 8, md_info_nz->mpm, is_intra_read);
//#endif
	U16 flag_est = enc_bit_est_flag_16_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode,
		md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx,
		mod_info_refi_for_rate, 0, md_info_nz->smvd_flag, num_refp_for_rate, md_info_nz->affine_mvd, mod_info_mvd_for_rate,
		md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, mod_info_ipm_for_rate, md_fw_ptr->cur_ptr,
		refp_ptr0, refp_ptr1, 8, mod_info_mpm_for_rate, is_intra_read);
#if RATE_EST_SWITCH
	U16 coef_est = 0;
		coef_est = enc_eco_coef_16_16(cu_width, cu_height, coef_y_pb_part, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2);
	
	
#else
	static s16 coef_tmp[256];
	for (int i = 0; i < cu_height; i++)
	{
		for (int j = 0; j < cu_width; j++)
		{
			coef_tmp[i * cu_width + j] = coef_y_pb_part[i][j];
		}
	}
	U16 coef_est = enc_eco_run_length_cc_est_2(coef_tmp, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate[0][0]);
#endif
	U16 bit_cnt = flag_est + coef_est;
	flag_cost[0] += (bit_cnt * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;

	if (is_intra_read == 0) {
		if (mode_type_read == 0) {
			flag_cost[1] = 0;
			/*flag_est = enc_bit_est_flag_skip_16_16(md_fw_ptr->slice_type, tree_status, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 
				md_info_nz->skip_idx, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, 8);*/
			flag_est = enc_bit_est_flag_skip_16_16(md_fw_ptr->slice_type, tree_status, md_info_nz->umve_flag,
				md_info_nz->umve_idx, md_info_nz->affine_flag, md_info_nz->skip_idx, md_kernel_input->cu_width_log2,
				md_kernel_input->cu_height_log2, num_nz_rate, mod_info_ipm_for_rate, 8);
			flag_cost[1] += (flag_est * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		}
	}

	// WRITE STREAMS
	*curr_mvr_update = curr_mvr_read;
	*mode_type_update = mode_type_read;
	*is_intra_update = is_intra_read;
}

// copy of rate_est_16 with coeff not coding.
void rate_est_azb_16(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, MD_FW* md_fw_ptr, MD_KERNEL_MODE* md_info_nz, u8 mode_type_rate, u8* mode_type_update,
	u8 curr_mvr_rate, u8* curr_mvr_update, u8 tree_status, u8 cons_pred_mode, s16 coef_y_pb_part[256], s64 lambda,
	U1 is_intra_rate, U1* is_intra_update, s64 flag_cost[2], int num_nz_rate[MAX_NUM_TB][N_C], MD_KERNEL_INPUT* md_kernel_input, int refp_ptr0, int refp_ptr1)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_rate
#pragma HLS INTERFACE axis port=mode_type_update
#pragma HLS INTERFACE axis port=curr_mvr_rate
#pragma HLS INTERFACE axis port=curr_mvr_update
#pragma HLS INTERFACE axis port=is_intra_rate
#pragma HLS INTERFACE axis port=is_intra_update
#pragma HLS RESOURCE variable=coef_y_pb_part core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=flag_cost core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=flag_cost complete dim=0

	// STREAM BUFFER
	u8 mode_type_read = mode_type_rate;
	u8 curr_mvr_read = curr_mvr_rate;
	U1 is_intra_read = is_intra_rate;

	flag_cost[0] = 0;
#if ENABLE_BFRAME
	U16 flag_est = enc_bit_est_flag_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, md_info_nz->refi, 0, md_info_nz->smvd_flag, md_fw_ptr->num_refp[0], md_info_nz->affine_mvd, md_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, 8, md_info_nz->mpm, is_intra_read);
#else
	U16 flag_est = enc_bit_est_flag_16(md_fw_ptr->slice_type, md_fw_ptr->f_scu, curr_mvr_read, tree_status, cons_pred_mode, md_info_nz->cu_mode, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, 1, md_info_nz->skip_idx, md_info_nz->refi, 0, md_info_nz->smvd_flag, md_fw_ptr->num_refp, md_info_nz->affine_mvd, md_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, 8, md_info_nz->mpm, is_intra_read);
#endif

#if RATE_EST_SWITCH
	// U16 coef_est = enc_eco_coef_16(cu_width, cu_height, coef_y_pb_part, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2);
	U16 coef_est = 0;
#else
	U16 coef_est = enc_eco_run_length_cc_est_2(coef_y_pb_part, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate[0][0]);
#endif
	U16 bit_cnt = flag_est + coef_est;
	flag_cost[0] += (bit_cnt * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;

	if (is_intra_read == 0) {
		if (mode_type_read == 0) {
			flag_cost[1] = 0;
			flag_est = enc_bit_est_flag_skip_16(md_fw_ptr->slice_type, tree_status, md_info_nz->umve_flag, md_info_nz->umve_idx, md_info_nz->affine_flag, md_info_nz->skip_idx, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, num_nz_rate, md_info_nz->ipm, 8);
			flag_cost[1] += (flag_est * lambda + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		}
	}

	// WRITE STREAMS
	*curr_mvr_update = curr_mvr_read;
	*mode_type_update = mode_type_read;
	*is_intra_update = is_intra_read;
}

void memcpy_1d_2_1d_16(s16 des[64 * 64], s16 src[16 * 16], int n)
{
#pragma HLS INLINE off

#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=des cyclic factor=64 dim=1
#pragma HLS ARRAY_PARTITION variable=src cyclic factor=64 dim=1
#else
#pragma HLS ARRAY_PARTITION variable=des cyclic factor=128 dim=1
#pragma HLS ARRAY_PARTITION variable=src complete dim=0
#endif // CMOD_LUMA_16_LITE
	int z;
	if (n == 64)
		for (z = 0; z < 64; z++)
#pragma HLS UNROLL
			des[z] = src[z];
	else if (n == 128)
		for (z = 0; z < 128; z++)
#pragma HLS UNROLL
			des[z] = src[z];
	else if (n == 256)
		for (z = 0; z < 256; z++)
#pragma HLS UNROLL
			des[z] = src[z];
}
void memcpy_2d_2_1d_16(s16 des[64 * 64], s16 src[16][16], int w, int h)
{
#pragma HLS INLINE off
#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=des cyclic factor=64 dim=1
#pragma HLS ARRAY_PARTITION variable=src complete dim=1
#pragma HLS ARRAY_PARTITION variable=src cyclic factor=4 dim=2
#else
#pragma HLS ARRAY_PARTITION variable=des cyclic factor=128 dim=1
#pragma HLS ARRAY_PARTITION variable=src complete dim=0
#endif // CMOD_LUMA_16_LITE

	if (w == 4 && h == 16) {
		for (int i = 0; i < 16; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 4; j++)
#pragma HLS UNROLL
				des[i * 4 + j] = src[i][j];
		}
	}
	else if (w == 16 && h == 4) {
		for (int i = 0; i < 4; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 16; j++)
#pragma HLS UNROLL
				des[i * 16 + j] = src[i][j];
		}
	}
	else if (w == 8 && h == 16) {
		for (int i = 0; i < 16; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 8; j++)
#pragma HLS UNROLL
				des[i * 8 + j] = src[i][j];
		}
	}
	else if (w == 16 && h == 8) {
		for (int i = 0; i < 8; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 16; j++)
#pragma HLS UNROLL
				des[i * 16 + j] = src[i][j];
		}
	}
	else if (w == 16 && h == 16) {
		for (int i = 0; i < 16; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 16; j++)
#pragma HLS UNROLL
				des[i * 16 + j] = src[i][j];
		}
	}
}
void memcpy_2d_2_1d_16(u8 des[64 * 64], s16 src[16][16], int w, int h)
{
#pragma HLS INLINE off
#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=des cyclic factor=64 dim=1
#pragma HLS ARRAY_PARTITION variable=src complete dim=1
#pragma HLS ARRAY_PARTITION variable=src cyclic factor=4 dim=2
#else
#pragma HLS ARRAY_PARTITION variable=des cyclic factor=128 dim=1
#pragma HLS ARRAY_PARTITION variable=src complete dim=0
#endif // CMOD_LUMA_16_LITE
	if (w == 4 && h == 16) {
		for (int i = 0; i < 16; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 4; j++)
#pragma HLS UNROLL
				des[i * 4 + j] = src[i][j];
		}
	}
	else if (w == 16 && h == 4) {
		for (int i = 0; i < 4; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 16; j++)
#pragma HLS UNROLL
				des[i * 16 + j] = src[i][j];
		}
	}
	else if (w == 8 && h == 16) {
		for (int i = 0; i < 16; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 8; j++)
#pragma HLS UNROLL
				des[i * 8 + j] = src[i][j];
		}
	}
	else if (w == 16 && h == 8) {
		for (int i = 0; i < 8; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 16; j++)
#pragma HLS UNROLL
				des[i * 16 + j] = src[i][j];
		}
	}
	else if (w == 16 && h == 16) {
		for (int i = 0; i < 16; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 16; j++)
#pragma HLS UNROLL
				des[i * 16 + j] = src[i][j];
		}
	}
}

void update_rdo_luma_8_16(U1 valid_flag, U8 cu_width, U8 cu_height, s16 mod_info_mvd_for_up[2][2],
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16, S8 mod_info_ipm_for_up[4][2], u8 mod_info_mpm_for_up[4][2],
	MD_KERNEL_MODE* md_info_nz, MD_COM_MODE_BEST_16* best_info_ptr_16,
	s64 dist_pred, s32 dist_value,
	s64 cost_best_temp, s64* cost_best, s64 flag_cost[2],
	u8 mode_type_update, U1 is_intra_update, u8 curr_mvr_update,
	pel rec[16][16], pel pred_cache_update[16][16], s16 coef_update[16][16], int num_nz_update[MAX_NUM_TB][N_C], MD_KERNEL_INPUT* md_kernel_input, s64 cost_skip, u8 iUpdate
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
	, U1 valid_mode_config[3]
#endif
)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=cu_data_temp_ptr->coef_y core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=cu_data_temp_ptr->reco_y core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=dist_pred
#pragma HLS INTERFACE axis port=dist_value
#pragma HLS INTERFACE axis port=cost_best_temp
#pragma HLS INTERFACE axis port=cost_best
#pragma HLS INTERFACE axis port=mode_type_update
#pragma HLS INTERFACE axis port=is_intra_update
#pragma HLS INTERFACE axis port=curr_mvr_update
#pragma HLS INTERFACE axis port=cost_skip
#pragma HLS INTERFACE axis port=iUpdate
#pragma HLS RESOURCE variable=flag_cost core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rec core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_update core=RAM_1P_BRAM
#endif

#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part cyclic factor=64 dim=1
#else
// #pragma HLS ARRAY_PARTITION variable=coef_y_pb_part complete dim=0
#endif // CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=num_nz_update complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->num_nz complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->coef_y complete dim=2
#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->reco_y complete dim=2

	// STREAM BUFFER
	U1 valid_flag_read = valid_flag;
	s64 dist_pred_read = dist_pred;
	s32 dist_read = dist_value;
	s64 cost_nz_read = cost_best_temp;
	u8 mode_type_read = mode_type_update;
	U1 is_intra_read = is_intra_update;
	u8 curr_mvr_read = curr_mvr_update;
	U2 cu_mode_read = md_info_nz->cu_mode;
	int tb_part_read = md_info_nz->tb_part;

	static s64 cost_buffer;
	if (iUpdate == 0)
	{
		cost_buffer = cost_skip;
	}

	//if (valid_flag_read)
	{
		s64 cost[2] = { 0 };
		U7 pb_w = cu_width;
		U7 pb_h = cu_height;
		s64 cost_pb_temp = 0;
		int bin_cnt_luma[1] = { 0 };
		U13 i;
		U13 j;
		s16 wxh = s16(cu_width) * s16(cu_height);
		U3 cu_width_log2 = md_kernel_input->cu_width_log2;

		if (is_intra_read || num_nz_update[0][0])
		{
			cost[0] = dist_read;
			cost[0] += flag_cost[0];
		}
		if (!is_intra_read && !mode_type_read)
		{
			cost[1] = dist_pred_read;
			cost[1] += flag_cost[1];
		}
#if USE_ROI_MODE_CONFIG

		if (valid_mode_config[2] == 0 && cu_mode_read == 0)
			cost[0] = MAX_S64;

		if (valid_mode_config[1] == 0 && cu_mode_read == 1)
			cost[0] = MAX_S64;

		if (valid_mode_config[0] == 0 && (cu_mode_read == 2 || cu_mode_read == 3))
			cost[0] = MAX_S64;
#endif

		if (is_intra_read == 0)
		{
			if (num_nz_update[0][0])
			{
				//if (cost[0] < cost_nz_read)
				{
					cost_nz_read = cost[0];
				}
			}
			/*if (mode_type_read == 0)
			{
				if (cost[1] < cost_nz_read)
				{
					cost_nz_read = cost[1];
					cu_mode_read = 2;
					tb_part_read = (SIZE_2Nx2N);
					for (i = 0; i < 4; i++)
					{
#pragma HLS UNROLL
						for (j = 0; j < 3; j++)
						{
#pragma HLS UNROLL
							num_nz_update[i][j] = 0;
						}
					}
				}
			}*/

#if SUB_TMVP
			BOOL isSubTMVP = cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE && md_info_nz->cu_mode >= MODE_SKIP && md_info_nz->skip_idx == 0 && md_info_nz->umve_flag == 0;
			BOOL rdoRun = TRUE;
			if (isSubTMVP)
				rdoRun = core_sbtmvp->isValid;
#endif

			U2 lidx;
			if (cost_nz_read < cost_buffer
#if SUB_TMVP
				&& rdoRun
#endif	
				)
			{


				best_info_ptr_16->cu_mode = cu_mode_read;
				best_info_ptr_16->pb_part = md_info_nz->pb_part;
				best_info_ptr_16->tb_part = tb_part_read;
				best_info_ptr_16->umve_flag = md_info_nz->umve_flag;
				cost_buffer = cost_nz_read;
				if (best_info_ptr_16->cu_mode != 0)
				{
					if (best_info_ptr_16->cu_mode == 2 || best_info_ptr_16->cu_mode == 3)
					{
						best_info_ptr_16->mvr_idx = 0;
					}
					else
					{
						best_info_ptr_16->mvp_from_hmvp_flag = 0;
						best_info_ptr_16->mvr_idx = curr_mvr_read;
					}
					best_info_ptr_16->refi[0] = md_info_nz->refi[0];
					best_info_ptr_16->refi[1] = md_info_nz->refi[1];
					for (lidx = 0; lidx < 2; lidx++)
					{
#pragma HLS UNROLL
						best_info_ptr_16->mv[lidx][0] = md_info_nz->mv[lidx][0];
						best_info_ptr_16->mv[lidx][1] = md_info_nz->mv[lidx][1];
						best_info_ptr_16->mv[lidx][0] = md_info_nz->mv[lidx][0];
						best_info_ptr_16->mv[lidx][1] = md_info_nz->mv[lidx][1];
						/*best_info_ptr_16->mvd[lidx][0] = md_info_nz->mvd[lidx][0];
						best_info_ptr_16->mvd[lidx][1] = md_info_nz->mvd[lidx][1];*/
						best_info_ptr_16->mvd[lidx][0] = mod_info_mvd_for_up[lidx][0];
						best_info_ptr_16->mvd[lidx][1] = mod_info_mvd_for_up[lidx][1];
					}
					best_info_ptr_16->smvd_flag = md_info_nz->smvd_flag;
					best_info_ptr_16->affine_flag = md_info_nz->affine_flag;

					//memcpy_2d_2_1d_16(best_info_ptr_16->pred_y, pred_cache_update, cu_width, cu_height);

					if (best_info_ptr_16->cu_mode == 2)
					{
						if (best_info_ptr_16->umve_flag != 0)
						{
							best_info_ptr_16->umve_idx = md_info_nz->umve_idx;
						}
						else
						{
							best_info_ptr_16->skip_idx = md_info_nz->skip_idx;
						}
					}
					else
					{
						if (best_info_ptr_16->cu_mode == 3)
						{
							if (best_info_ptr_16->umve_flag)
							{
								best_info_ptr_16->umve_idx = md_info_nz->umve_idx;
							}
							else
							{
								best_info_ptr_16->skip_idx = md_info_nz->skip_idx;
							}
						}
					}

					for (U3 i_numnz = 0; i_numnz < 4; i_numnz++)
					{
#pragma HLS UNROLL
						best_info_ptr_16->num_nz_y[i_numnz] = best_info_ptr_16->cu_mode == 2 ? 0 : num_nz_update[i_numnz][0];
					}
					for (i = 0; i < cu_height; i++)
					{
#pragma HLS PIPELINE
						for (j = 0; j < cu_width; j++)
#pragma HLS UNROLL
							cu_data_temp_ptr_16->coef_y[i][j] = best_info_ptr_16->cu_mode == 2 ? 0 : coef_update[i][j];
					}
				}

				U1 b_num_nz = num_nz_update[0][0] == 0;
				if (b_num_nz)
				{
					for (int i = 0; i < cu_height; i++)
#pragma HLS PIPELINE
						for (int j = 0; j < cu_width; j++)
							cu_data_temp_ptr_16->reco_y[i][j] = pred_cache_update[i][j];
				}
				else
				{
					for (int i = 0; i < cu_height; i++)
#pragma HLS PIPELINE
						for (int j = 0; j < cu_width; j++)
							cu_data_temp_ptr_16->reco_y[i][j] = rec[i][j];
				}
			}
		}

		if (is_intra_read)
		{
			cost_pb_temp += cost[0];
			if (cost_pb_temp < cost_buffer)
			{


				best_info_ptr_16->cu_mode = MODE_INTRA;
				best_info_ptr_16->affine_flag = 0;
				cost_buffer = cost_pb_temp;
				for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
					for (j = 0; j < cu_width; j++)
					{
						cu_data_temp_ptr_16->coef_y[i][j] = coef_update[i][j];
						cu_data_temp_ptr_16->reco_y[i][j] = rec[i][j];
					}
				}
				for (i = 0; i < 4; ++i)
				{
#pragma HLS UNROLL
					for (j = 0; j < 2; ++j)
					{
#pragma HLS UNROLL
						best_info_ptr_16->mpm[i][j] = mod_info_mpm_for_up[i][j];
						best_info_ptr_16->ipm[i][j] = mod_info_ipm_for_up[i][j];
						/*best_info_ptr_16->mpm[i][j] = md_info_nz->mpm[i][j];
						best_info_ptr_16->ipm[i][j] = md_info_nz->ipm[i][j];*/
					}
				}
				for (i = 0; i < 4; ++i)
				{
#pragma HLS UNROLL
					best_info_ptr_16->num_nz_y[i] = num_nz_update[i][0];
				}

			}
		}
	}

	// WRITE_STREAMS
	*cost_best = cost_buffer;
}

void update_rdo_luma_16_8(U1 valid_flag, U8 cu_width, U8 cu_height, s16 mod_info_mvd_for_up[2][2],
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16, S8 mod_info_ipm_for_up[4][2], u8 mod_info_mpm_for_up[4][2],
	MD_KERNEL_MODE* md_info_nz, MD_COM_MODE_BEST_16* best_info_ptr_16,
	s64 dist_pred, s32 dist_value,
	s64 cost_best_temp, s64* cost_best, s64 flag_cost[2],
	u8 mode_type_update, U1 is_intra_update, u8 curr_mvr_update,
	pel rec[16][16], pel pred_cache_update[16][16], s16 coef_update[16][16], int num_nz_update[MAX_NUM_TB][N_C], MD_KERNEL_INPUT* md_kernel_input, s64 cost_skip, u8 iUpdate
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
	, U1 valid_mode_config[3]
#endif
)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=cu_data_temp_ptr->coef_y core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=cu_data_temp_ptr->reco_y core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=dist_pred
#pragma HLS INTERFACE axis port=dist_value
#pragma HLS INTERFACE axis port=cost_best_temp
#pragma HLS INTERFACE axis port=cost_best
#pragma HLS INTERFACE axis port=mode_type_update
#pragma HLS INTERFACE axis port=is_intra_update
#pragma HLS INTERFACE axis port=curr_mvr_update
#pragma HLS INTERFACE axis port=cost_skip
#pragma HLS INTERFACE axis port=iUpdate
#pragma HLS RESOURCE variable=flag_cost core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rec core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_update core=RAM_1P_BRAM
#endif

#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part cyclic factor=64 dim=1
#else
// #pragma HLS ARRAY_PARTITION variable=coef_y_pb_part complete dim=0
#endif // CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=num_nz_update complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->num_nz complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->coef_y complete dim=2
#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->reco_y complete dim=2

	// STREAM BUFFER
	U1 valid_flag_read = valid_flag;
	s64 dist_pred_read = dist_pred;
	s32 dist_read = dist_value;
	s64 cost_nz_read = cost_best_temp;
	u8 mode_type_read = mode_type_update;
	U1 is_intra_read = is_intra_update;
	u8 curr_mvr_read = curr_mvr_update;
	U2 cu_mode_read = md_info_nz->cu_mode;
	int tb_part_read = md_info_nz->tb_part;

	static s64 cost_buffer;
	if (iUpdate == 0)
	{
		cost_buffer = cost_skip;
	}

	//if (valid_flag_read)
	{
		s64 cost[2] = { 0 };
		U7 pb_w = cu_width;
		U7 pb_h = cu_height;
		s64 cost_pb_temp = 0;
		int bin_cnt_luma[1] = { 0 };
		U13 i;
		U13 j;
		s16 wxh = s16(cu_width) * s16(cu_height);
		U3 cu_width_log2 = md_kernel_input->cu_width_log2;

		if (is_intra_read || num_nz_update[0][0])
		{
			cost[0] = dist_read;
			cost[0] += flag_cost[0];
		}
		if (!is_intra_read && !mode_type_read)
		{
			cost[1] = dist_pred_read;
			cost[1] += flag_cost[1];
		}
#if USE_ROI_MODE_CONFIG

		if (valid_mode_config[2] == 0 && cu_mode_read == 0)
			cost[0] = MAX_S64;

		if (valid_mode_config[1] == 0 && cu_mode_read == 1)
			cost[0] = MAX_S64;

		if (valid_mode_config[0] == 0 && (cu_mode_read == 2 || cu_mode_read == 3))
			cost[0] = MAX_S64;
#endif

		if (is_intra_read == 0)
		{
			if (num_nz_update[0][0])
			{
				//if (cost[0] < cost_nz_read)
				{
					cost_nz_read = cost[0];
				}
			}
			/*if (mode_type_read == 0)
			{
				if (cost[1] < cost_nz_read)
				{
					cost_nz_read = cost[1];
					cu_mode_read = 2;
					tb_part_read = (SIZE_2Nx2N);
					for (i = 0; i < 4; i++)
					{
#pragma HLS UNROLL
						for (j = 0; j < 3; j++)
						{
#pragma HLS UNROLL
							num_nz_update[i][j] = 0;
						}
					}
				}
			}*/

#if SUB_TMVP
			BOOL isSubTMVP = cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE && md_info_nz->cu_mode >= MODE_SKIP && md_info_nz->skip_idx == 0 && md_info_nz->umve_flag == 0;
			BOOL rdoRun = TRUE;
			if (isSubTMVP)
				rdoRun = core_sbtmvp->isValid;
#endif

			U2 lidx;
			if (cost_nz_read < cost_buffer
#if SUB_TMVP
				&& rdoRun
#endif	
				)
			{


				best_info_ptr_16->cu_mode = cu_mode_read;
				best_info_ptr_16->pb_part = md_info_nz->pb_part;
				best_info_ptr_16->tb_part = tb_part_read;
				best_info_ptr_16->umve_flag = md_info_nz->umve_flag;
				cost_buffer = cost_nz_read;
				if (best_info_ptr_16->cu_mode != 0)
				{
					if (best_info_ptr_16->cu_mode == 2 || best_info_ptr_16->cu_mode == 3)
					{
						best_info_ptr_16->mvr_idx = 0;
					}
					else
					{
						best_info_ptr_16->mvp_from_hmvp_flag = 0;
						best_info_ptr_16->mvr_idx = curr_mvr_read;
					}
					best_info_ptr_16->refi[0] = md_info_nz->refi[0];
					best_info_ptr_16->refi[1] = md_info_nz->refi[1];
					for (lidx = 0; lidx < 2; lidx++)
					{
#pragma HLS UNROLL
						best_info_ptr_16->mv[lidx][0] = md_info_nz->mv[lidx][0];
						best_info_ptr_16->mv[lidx][1] = md_info_nz->mv[lidx][1];
						/*best_info_ptr_16->mvd[lidx][0] = md_info_nz->mvd[lidx][0];
						best_info_ptr_16->mvd[lidx][1] = md_info_nz->mvd[lidx][1];*/
						best_info_ptr_16->mvd[lidx][0] = mod_info_mvd_for_up[lidx][0];
						best_info_ptr_16->mvd[lidx][1] = mod_info_mvd_for_up[lidx][1];
					}
					best_info_ptr_16->smvd_flag = md_info_nz->smvd_flag;
					best_info_ptr_16->affine_flag = md_info_nz->affine_flag;

					//memcpy_2d_2_1d_16(best_info_ptr_16->pred_y, pred_cache_update, cu_width, cu_height);

					if (best_info_ptr_16->cu_mode == 2)
					{
						if (best_info_ptr_16->umve_flag != 0)
						{
							best_info_ptr_16->umve_idx = md_info_nz->umve_idx;
						}
						else
						{
							best_info_ptr_16->skip_idx = md_info_nz->skip_idx;
						}
					}
					else
					{
						if (best_info_ptr_16->cu_mode == 3)
						{
							if (best_info_ptr_16->umve_flag)
							{
								best_info_ptr_16->umve_idx = md_info_nz->umve_idx;
							}
							else
							{
								best_info_ptr_16->skip_idx = md_info_nz->skip_idx;
							}
						}
					}

					for (U3 i_numnz = 0; i_numnz < 4; i_numnz++)
					{
#pragma HLS UNROLL
						best_info_ptr_16->num_nz_y[i_numnz] = best_info_ptr_16->cu_mode == 2 ? 0 : num_nz_update[i_numnz][0];
					}
					for (i = 0; i < cu_height; i++)
					{
						for (j = 0; j < cu_width; j++)
#pragma HLS UNROLL
							cu_data_temp_ptr_16->coef_y[i][j] = best_info_ptr_16->cu_mode == 2 ? 0 : coef_update[i][j];
					}
				}

				U1 b_num_nz = num_nz_update[0][0] == 0;
				if (b_num_nz)
				{
					for (int i = 0; i < cu_height; i++)
#pragma HLS PIPELINE
						for (int j = 0; j < cu_width; j++)
							cu_data_temp_ptr_16->reco_y[i][j] = pred_cache_update[i][j];
				}
				else
				{
					for (int i = 0; i < cu_height; i++)
#pragma HLS PIPELINE
						for (int j = 0; j < cu_width; j++)
							cu_data_temp_ptr_16->reco_y[i][j] = rec[i][j];
				}
			}
		}

		if (is_intra_read)
		{
			cost_pb_temp += cost[0];
			if (cost_pb_temp < cost_buffer)
			{


				best_info_ptr_16->cu_mode = MODE_INTRA;
				best_info_ptr_16->affine_flag = 0;
				cost_buffer = cost_pb_temp;
				for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
					for (j = 0; j < cu_width; j++)
					{
						cu_data_temp_ptr_16->coef_y[i][j] = coef_update[i][j];
						cu_data_temp_ptr_16->reco_y[i][j] = rec[i][j];
					}
				}
				for (i = 0; i < 4; ++i)
				{
#pragma HLS UNROLL
					for (j = 0; j < 2; ++j)
					{
#pragma HLS UNROLL
						best_info_ptr_16->mpm[i][j] = mod_info_mpm_for_up[i][j];
						best_info_ptr_16->ipm[i][j] = mod_info_ipm_for_up[i][j];
						/*best_info_ptr_16->mpm[i][j] = md_info_nz->mpm[i][j];
						best_info_ptr_16->ipm[i][j] = md_info_nz->ipm[i][j];*/
					}
				}
				for (i = 0; i < 4; ++i)
				{
#pragma HLS UNROLL
					best_info_ptr_16->num_nz_y[i] = num_nz_update[i][0];
				}
			}
		}
	}

	// WRITE_STREAMS
	*cost_best = cost_buffer;
}

void update_rdo_luma_16_16(U1 valid_flag, U8 cu_width, U8 cu_height, s16 mod_info_mvd_for_up[2][2],
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16, S8 mod_info_ipm_for_up[4][2], u8 mod_info_mpm_for_up[4][2],
	MD_KERNEL_MODE* md_info_nz, MD_COM_MODE_BEST_16* best_info_ptr_16,
	s64 dist_pred, s32 dist_value,
	s64 cost_best_temp, s64* cost_best, s64 flag_cost[2],
	u8 mode_type_update, U1 is_intra_update, u8 curr_mvr_update,
	pel rec[16][16], pel pred_cache_update[16][16], s16 coef_update[16][16], int num_nz_update[MAX_NUM_TB][N_C], MD_KERNEL_INPUT* md_kernel_input, s64 cost_skip, u8 iUpdate
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
	, U1 valid_mode_config[3]
#endif
)
{
#if 0//MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=cu_data_temp_ptr->coef_y core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=cu_data_temp_ptr->reco_y core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=dist_pred
#pragma HLS INTERFACE axis port=dist_value
#pragma HLS INTERFACE axis port=cost_best_temp
#pragma HLS INTERFACE axis port=cost_best
#pragma HLS INTERFACE axis port=mode_type_update
#pragma HLS INTERFACE axis port=is_intra_update
#pragma HLS INTERFACE axis port=curr_mvr_update
#pragma HLS INTERFACE axis port=cost_skip
#pragma HLS INTERFACE axis port=iUpdate
#pragma HLS RESOURCE variable=flag_cost core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rec core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_update core=RAM_1P_BRAM
#endif

#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part cyclic factor=64 dim=1
#else
// #pragma HLS ARRAY_PARTITION variable=coef_y_pb_part complete dim=0
#endif // CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=num_nz_update complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->num_nz complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
// #pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->coef_y complete dim=2  //solve partition conflict
// #pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->reco_y complete dim=2  //solve partition conflict

	// STREAM BUFFER
	U1 valid_flag_read = valid_flag;
	s64 dist_pred_read = dist_pred;
	s32 dist_read = dist_value;
	s64 cost_nz_read = cost_best_temp;
	u8 mode_type_read = mode_type_update;
	U1 is_intra_read = is_intra_update;
	u8 curr_mvr_read = curr_mvr_update;
	U2 cu_mode_read = md_info_nz->cu_mode;
	int tb_part_read = md_info_nz->tb_part;

	static s64 cost_buffer;
	if (iUpdate == 0)
	{
		cost_buffer = cost_skip;
	}

	//if (valid_flag_read)
	{
		s64 cost[2] = { 0 };
		U7 pb_w = cu_width;
		U7 pb_h = cu_height;
		s64 cost_pb_temp = 0;
		int bin_cnt_luma[1] = { 0 };
		U13 i;
		U13 j;
		s16 wxh = s16(cu_width) * s16(cu_height);
		U3 cu_width_log2 = md_kernel_input->cu_width_log2;

		if (is_intra_read || num_nz_update[0][0])
		{
			cost[0] = dist_read;
			cost[0] += flag_cost[0];
		}
#if !SIMPLE_MD
		if (!is_intra_read && !mode_type_read)
		{
			cost[1] = dist_pred_read;
			cost[1] += flag_cost[1];
		}
#endif
#if USE_ROI_MODE_CONFIG

		if (valid_mode_config[2] == 0 && cu_mode_read == 0)
			cost[0] = MAX_S64;

		if (valid_mode_config[1] == 0 && cu_mode_read == 1)
			cost[0] = MAX_S64;

		if (valid_mode_config[0] == 0 && (cu_mode_read == 2 || cu_mode_read == 3))
			cost[0] = MAX_S64;
#endif

#if !SIMPLE_MD
		if (is_intra_read == 0)
		{
			if (num_nz_update[0][0])
			{
				//if (cost[0] < cost_nz_read)
				{
					cost_nz_read = cost[0];
				}
			}
			/*if (mode_type_read == 0)
			{
				if (cost[1] < cost_nz_read)
				{
					cost_nz_read = cost[1];
					cu_mode_read = 2;
					tb_part_read = (SIZE_2Nx2N);
					for (i = 0; i < 4; i++)
					{
#pragma HLS UNROLL
						for (j = 0; j < 3; j++)
						{
#pragma HLS UNROLL
							num_nz_update[i][j] = 0;
						}
					}
				}
			}*/

#if SUB_TMVP
			BOOL isSubTMVP = cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE && md_info_nz->cu_mode >= MODE_SKIP && md_info_nz->skip_idx == 0 && md_info_nz->umve_flag == 0;
			BOOL rdoRun = TRUE;
			if (isSubTMVP)
				rdoRun = core_sbtmvp->isValid;
#endif

			U2 lidx;
			if (cost_nz_read < cost_buffer
#if SUB_TMVP
				&& rdoRun
#endif	
				)
			{


				best_info_ptr_16->cu_mode = cu_mode_read;
				best_info_ptr_16->pb_part = md_info_nz->pb_part;
				best_info_ptr_16->tb_part = tb_part_read;
				best_info_ptr_16->umve_flag = md_info_nz->umve_flag;
				cost_buffer = cost_nz_read;
				if (best_info_ptr_16->cu_mode != 0)
				{
					if (best_info_ptr_16->cu_mode == 2 || best_info_ptr_16->cu_mode == 3)
					{
						best_info_ptr_16->mvr_idx = 0;
					}
					else
					{
						best_info_ptr_16->mvp_from_hmvp_flag = 0;
						best_info_ptr_16->mvr_idx = curr_mvr_read;
					}
					best_info_ptr_16->refi[0] = md_info_nz->refi[0];
					best_info_ptr_16->refi[1] = md_info_nz->refi[1];
					for (lidx = 0; lidx < 2; lidx++)
					{
#pragma HLS UNROLL
						best_info_ptr_16->mv[lidx][0] = md_info_nz->mv[lidx][0];
						best_info_ptr_16->mv[lidx][1] = md_info_nz->mv[lidx][1];
						/*best_info_ptr_16->mvd[lidx][0] = md_info_nz->mvd[lidx][0];
						best_info_ptr_16->mvd[lidx][1] = md_info_nz->mvd[lidx][1];*/
						best_info_ptr_16->mvd[lidx][0] = mod_info_mvd_for_up[lidx][0];
						best_info_ptr_16->mvd[lidx][1] = mod_info_mvd_for_up[lidx][1];
					}
					best_info_ptr_16->smvd_flag = md_info_nz->smvd_flag;
					best_info_ptr_16->affine_flag = md_info_nz->affine_flag;

					//memcpy_2d_2_1d_16(best_info_ptr_16->pred_y, pred_cache_update, cu_width, cu_height);

					if (best_info_ptr_16->cu_mode == 2)
					{
						if (best_info_ptr_16->umve_flag != 0)
						{
							best_info_ptr_16->umve_idx = md_info_nz->umve_idx;
						}
						else
						{
							best_info_ptr_16->skip_idx = md_info_nz->skip_idx;
						}
					}
					else
					{
						if (best_info_ptr_16->cu_mode == 3)
						{
							if (best_info_ptr_16->umve_flag)
							{
								best_info_ptr_16->umve_idx = md_info_nz->umve_idx;
							}
							else
							{
								best_info_ptr_16->skip_idx = md_info_nz->skip_idx;
							}
						}
					}

					for (U3 i_numnz = 0; i_numnz < 4; i_numnz++)
					{
#pragma HLS UNROLL
						best_info_ptr_16->num_nz_y[i_numnz] = best_info_ptr_16->cu_mode == 2 ? 0 : num_nz_update[i_numnz][0];
					}
					for (i = 0; i < cu_height; i++)
#pragma HLS PIPELINE
					{
						for (j = 0; j < cu_width; j++)
#pragma HLS UNROLL
							cu_data_temp_ptr_16->coef_y[i][j] = best_info_ptr_16->cu_mode == 2 ? 0 : coef_update[i][j];
					}
				}

				U1 b_num_nz = num_nz_update[0][0] == 0;
				if (b_num_nz)
				{
					for (int i = 0; i < cu_height; i++)
#pragma HLS PIPELINE
						for (int j = 0; j < cu_width; j++)
							cu_data_temp_ptr_16->reco_y[i][j] = pred_cache_update[i][j];
				}
				else
				{
					for (int i = 0; i < cu_height; i++)
#pragma HLS PIPELINE
						for (int j = 0; j < cu_width; j++)
							cu_data_temp_ptr_16->reco_y[i][j] = rec[i][j];
				}
			}
		}
#endif
		if (is_intra_read)
		{
			cost_pb_temp += cost[0];
			if (cost_pb_temp < cost_buffer)
			{


				best_info_ptr_16->cu_mode = MODE_INTRA;
				best_info_ptr_16->affine_flag = 0;
				cost_buffer = cost_pb_temp;
				for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
					for (j = 0; j < cu_width; j++)
					{
						cu_data_temp_ptr_16->coef_y[i][j] = coef_update[i][j];
						cu_data_temp_ptr_16->reco_y[i][j] = rec[i][j];
					}
				}
				for (i = 0; i < 4; ++i)
				{
#pragma HLS UNROLL
					for (j = 0; j < 2; ++j)
					{
#pragma HLS UNROLL
						/*best_info_ptr_16->mpm[i][j] = md_info_nz->mpm[i][j];
						best_info_ptr_16->ipm[i][j] = md_info_nz->ipm[i][j];*/
						best_info_ptr_16->mpm[i][j] = mod_info_mpm_for_up[i][j];
						best_info_ptr_16->ipm[i][j] = mod_info_ipm_for_up[i][j];
					}
				}
				for (i = 0; i < 4; ++i)
				{
#pragma HLS UNROLL
					best_info_ptr_16->num_nz_y[i] = num_nz_update[i][0];
				}
			}
		}
	}

	// WRITE_STREAMS
	*cost_best = cost_buffer;
}

static void level_core_16(U16 min_size, u32 level[24], u32 level1[24], U5 t0[UPDATE_SIZE_MAX16], U9 i, u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=level1 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
#pragma HLS ARRAY_PARTITION variable=level complete dim=1
	int tmp = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < UPDATE_SIZE_MAX16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= min_size)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	level[i] += tmp;
	level1[i + 1] += 8 * tmp;
}

static void run_core_16(U16 min_size, u32 run[24], u32 run1[24], U5 t0[UPDATE_SIZE_MAX16], U9 i, U1 mat_run[UPDATE_SIZE_MAX16], u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=1
#pragma HLS ARRAY_PARTITION variable=run1 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
#pragma HLS ARRAY_PARTITION variable=run complete dim=1
	int tmp = 0;
	int tmp2 = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < UPDATE_SIZE_MAX16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= min_size)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
			tmp2 += mat_run[pos];
		}
	}
	run[i] += tmp;
	run1[i + 1] += tmp2;
}

static void last1_core_16(U16 min_size, u32 last1[12], U4 t0[UPDATE_SIZE_MAX16], U9 i, u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=last1 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
	int tmp = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < UPDATE_SIZE_MAX16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= min_size)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last1[i] += tmp;
}

static void last2_core_16(U16 min_size, u32 last2[22], U5 t0[UPDATE_SIZE_MAX16], U9 i, u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=last2 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
	int tmp = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < UPDATE_SIZE_MAX16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= min_size)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last2[i] += tmp;
}

static void model_update_16(U16 min_size, u32 last1[12], u32 last2[22], u32 run[24], u32 level[24], U1 mat_run[UPDATE_SIZE_MAX16], U24 mat_prev_level[UPDATE_SIZE_MAX16], U2 ch_type, u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=last2 complete dim=1
#pragma HLS ARRAY_PARTITION variable=last1 complete dim=1
#pragma HLS PIPELINE II=1
#pragma HLS ARRAY_PARTITION variable=run complete dim=1
#pragma HLS ARRAY_PARTITION variable=level complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=1

	U9 scan_pos = 0;
	U5 t0[UPDATE_SIZE_MAX16] = { 0 };
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	U4 last1_pos[UPDATE_SIZE_MAX16] = { 0 };
#pragma HLS ARRAY_PARTITION variable=last1_pos complete dim=1
	U5 last2_pos[UPDATE_SIZE_MAX16] = { 0 };
#pragma HLS ARRAY_PARTITION variable=last2_pos complete dim=1
	static u32 last1_tmp[12] = { 0 };
#pragma HLS ARRAY_PARTITION variable=last1_tmp complete dim=1
	static u32 last2_tmp[22] = { 0 };
#pragma HLS ARRAY_PARTITION variable=last2_tmp complete dim=1
	static u32 level_tmp[24] = { 0 };
#pragma HLS ARRAY_PARTITION variable=level_tmp complete dim=1
	static u32 level_tmp1[24] = { 0 };
#pragma HLS ARRAY_PARTITION variable=level_tmp1 complete dim=1
	static u32 run_tmp[24] = { 0 };
#pragma HLS ARRAY_PARTITION variable=run_tmp complete dim=1
	static u32 run_tmp1[24] = { 0 };
#pragma HLS ARRAY_PARTITION variable=run_tmp1 complete dim=1
	int ace_log2 = 0;

	for (scan_pos = 0; scan_pos < UPDATE_SIZE_MAX16; scan_pos++)
	{
#pragma HLS UNROLL
		if (scan_pos >= min_size)
			break;

		if (scan_pos < max_num)
		{
			if (scan_pos + 1 < 2) {
				ace_log2 = 0;
			}
			else if (scan_pos + 1 < 4) {
				ace_log2 = 1;
			}
			else if (scan_pos + 1 < 8) {
				ace_log2 = 2;
			}
			else if (scan_pos + 1 < 16) {
				ace_log2 = 3;
			}
			else if (scan_pos + 1 < 32) {
				ace_log2 = 4;
			}
			else if (scan_pos + 1 < 64) {
				ace_log2 = 5;
			}
			else if (scan_pos + 1 < 128) {
				ace_log2 = 6;
			}
			else if (scan_pos + 1 < 256) {
				ace_log2 = 7;
			}
			else if (scan_pos + 1 < 512) {
				ace_log2 = 8;
			}
			else if (scan_pos + 1 < 1024) {
				ace_log2 = 9;
			}
			else if (scan_pos + 1 < 2048) {
				ace_log2 = 10;
			}
			else if (scan_pos + 1 < 4096) {
				ace_log2 = 11;
			}
			else {
				ace_log2 = 11;
			}

			t0[scan_pos] = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5)) * 2) + (ch_type == 0 ? 0 : 12);
			last1_pos[scan_pos] = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5))) + (ch_type == 0 ? 0 : 6);
			last2_pos[scan_pos] = ace_log2 + (ch_type == 0 ? 0 : 12);
		}
	}

	for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
	{
#pragma HLS UNROLL
		level_core_16(min_size, level_tmp, level_tmp1, t0, scan_pos, max_num);
		run_core_16(min_size, run_tmp, run_tmp1, t0, scan_pos, mat_run, max_num);
	}

	for (scan_pos = 0; scan_pos < 12; scan_pos++)
	{
#pragma HLS UNROLL
		last1_core_16(min_size, last1_tmp, last1_pos, scan_pos, max_num);
		last1[scan_pos] += last1_tmp[scan_pos];
	}

	for (scan_pos = 0; scan_pos < 22; scan_pos++)
	{
#pragma HLS UNROLL
		last2_core_16(min_size, last2_tmp, last2_pos, scan_pos, max_num);
		last2[scan_pos] += last2_tmp[scan_pos];
	}

	for (scan_pos = 0; scan_pos < 24; scan_pos++)
	{
#pragma HLS UNROLL
		level[scan_pos] += level_tmp[scan_pos] + level_tmp1[scan_pos];
		run[scan_pos] += run_tmp[scan_pos] + run_tmp1[scan_pos];
	}
}

static U4 get_ace_log2(U32 scan_pos)
{
	U4 ace_log2 = 0;
	if ((scan_pos) < 2)
	{
		ace_log2 = 0;
	}
	else if ((scan_pos) < 4)
	{
		ace_log2 = 1;
	}
	else if ((scan_pos) < 8)
	{
		ace_log2 = 2;
	}
	else if ((scan_pos) < 16)
	{
		ace_log2 = 3;
	}
	else if ((scan_pos) < 32)
	{
		ace_log2 = 4;
	}
	else if ((scan_pos) < 64)
	{
		ace_log2 = 5;
	}
	else if ((scan_pos) < 128)
	{
		ace_log2 = 6;
	}
	else if ((scan_pos) < 256)
	{
		ace_log2 = 7;
	}
	else if ((scan_pos) < 512)
	{
		ace_log2 = 8;
	}
	else if ((scan_pos) < 1024)
	{
		ace_log2 = 9;
	}
	else if ((scan_pos) < 2048)
	{
		ace_log2 = 10;
	}
	else if ((scan_pos) < 4096)
	{
		ace_log2 = 11;
	}
	else
	{
		ace_log2 = 11;
	}
	return ace_log2;
}
void level_core_16_16(U8 cu_width, U8 cu_height, u32 level[24], u32 level1[24], U5 t0[16], U7 i, int max_num)
{
#pragma HLS ARRAY_PARTITION variable=level1 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
#pragma HLS ARRAY_PARTITION variable=level complete dim=1
	int tmp = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < 16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= 16)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	level[i] += tmp;
	level1[i + 1] += 8 * tmp;
}
static void run_core_16_16(U8 cu_width, U8 cu_height, u32 run[24], u32 run1[24], U5 t0[16], U9 i, U1 mat_run[16], u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=1
#pragma HLS ARRAY_PARTITION variable=run1 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
#pragma HLS ARRAY_PARTITION variable=run complete dim=1
	int tmp = 0;
	int tmp2 = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < 16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= 16)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
			tmp2 += mat_run[pos];
		}
	}
	run[i] += tmp;
	run1[i + 1] += tmp2;
}
static void last1_core_16_16(U8 cu_width, U8 cu_height, u32 last1[12], U4 t0[16], U9 i, u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=last1 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
	int tmp = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < 16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= 16)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last1[i] += tmp;
}
static void last2_core_16_16(U8 cu_width, U8 cu_height, u32 last2[22], U5 t0[16], U9 i, u8 max_num)
{
#pragma HLS ARRAY_PARTITION variable=last2 complete dim=1
#pragma HLS FUNCTION_INSTANTIATE variable=i
	int tmp = 0;
	int pos = 0;
#pragma HLS ARRAY_PARTITION variable=t0 complete dim=1
	for (pos = 0; pos < 16; pos++)
	{
#pragma HLS UNROLL
		if (pos >= 16)
			break;
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last2[i] += tmp;
}
void rdoq_16_16_hardware_64(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[256], u32 last1[12], u32 last2[22],
	u32 run[24], u32 level[24], int* best_last_idx_p1,
	int rdoq_est_cbf[3][2], u8 scan[256], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth)
{
	U3 cu_width_log2 = 4;
	U3 cu_height_log2 = 4;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16] = { 0 };
	static S64 d64_cost_last_zero[16] = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[256] = { 0 };
	static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16] = { 0 };
	static U1 mat_run[16] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16] = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	int last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[16] = { 0 };
	U4 last1_pos[16] = { 0 };
	U5 last2_pos[16] = { 0 };
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < 11; j++)  //horizontal
	{
		u32 last1_tmp_y[11][12] = { 0 };
		u32 last2_tmp_y[11][22] = { 0 };
		u32 level_tmp_y[11][24] = { 0 };
		u32 level_tmp1_y[11][24] = { 0 };
		u32 run_tmp_y[11][24] = { 0 };
		u32 run_tmp1_y[11][24] = { 0 };
		U10 pos[16] = { 0 };
		for (int i = 0; i < 11; i++) {
			if (i < 11 - j) {
				U36 level_double = src_coef[i][j];
				S25 max_abs_level;
				U1 lower_int;
				U36 temp_level;
				temp_level = (U36)abs(src_coef[i][j]) * q_value;
				level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
				tmp_level_double[i] = level_double;
				max_abs_level = (S32)(level_double >> q_bits);
				lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
				if (!lower_int)
				{
					max_abs_level++;
				}
				tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
			}
		}
		for (U8 i = 0; i < 11; i++)
		{
			if (i < 11 - j) {
				if (tmp_coef[i])
				{
					mat_prev_level[i] = abs(tmp_coef[i]);
					mat_run[i] = 0;
				}
				else
				{
					mat_prev_level[i] = 1;
					mat_run[i] = 1;
				}
			}
		}
		for (U8 i = 0; i < 11; i++) {
			if (i < 11 - j) {
				U24 level;
				U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
				int iflast = (i * 16 + j == 255);
				level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
					mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
				S17 level_cbf = level;
				tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				tmp_dst_coef_out[i * 16 + j] = tmp_dst_coef[i];
				mat_uncoded_cost[i] = d64_uncoded_cost;
				mat_coded_cost[i] = d64_coded_cost;
				lev_opt[i] = level;
			}
		}
		for (int i = 0; i < 11; i++)
		{
#pragma HLS UNROLL
			if ((i + j) < 11) {
				if ((i + j) % 2 == 1) {
					pos[i] = (i + j + 1) * (i + j) / 2 + i;
				}
				else {
					pos[i] = (i + j + 1) * (i + j) / 2 + j;
				}
				ace_log2 = get_ace_log2(pos[i] + 1);
				t0[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == 0 ? 0 : 12);
				last1_pos[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5)))) + (ch_type == 0 ? 0 : 6);
				last2_pos[i] = ace_log2 + (ch_type == 0 ? 0 : 12);
			}
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
		{
#pragma HLS UNROLL
			if (j < 9) {
				level_core_16_16(16, 16, level_tmp_y[j], level_tmp1_y[j], t0, scan_pos, 11 - j);
				run_core_16_16(16, 16, run_tmp_y[j], run_tmp1_y[j], t0, scan_pos, mat_run, 11 - j);
			}
			else if (j < 11) {
				level_core_16_16(16, 16, level_tmp_y[j], level_tmp1_y[j], t0, scan_pos, 10 - j);
				run_core_16_16(16, 16, run_tmp_y[j], run_tmp1_y[j], t0, scan_pos, mat_run, 10 - j);
			}
		}
		for (scan_pos = 0; scan_pos < 12; scan_pos++)
		{
#pragma HLS UNROLL
			if (j < 9) {
				last1_core_16_16(16, 16, last1_tmp_y[j], last1_pos, scan_pos, 11 - j);
				last1[scan_pos] += last1_tmp_y[j][scan_pos];
			}
			else if (j < 11) {
				last1_core_16_16(16, 16, last1_tmp_y[j], last1_pos, scan_pos, 10 - j);
				last1[scan_pos] += last1_tmp_y[j][scan_pos];
			}
		}
		for (scan_pos = 0; scan_pos < 22; scan_pos++)
		{
#pragma HLS UNROLL
			if (j < 9) {
				last2_core_16_16(16, 16, last2_tmp_y[j], last2_pos, scan_pos, 11 - j);
				last2[scan_pos] += last2_tmp_y[j][scan_pos];
			}
			else if (j > 8 && j < 11) {
				last2_core_16_16(16, 16, last2_tmp_y[j], last2_pos, scan_pos, 10 - j);
				last2[scan_pos] += last2_tmp_y[j][scan_pos];
			}
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos++)
		{
#pragma HLS UNROLL
			level[scan_pos] += level_tmp_y[j][scan_pos] + level_tmp1_y[j][scan_pos];
			run[scan_pos] += run_tmp_y[j][scan_pos] + run_tmp1_y[j][scan_pos];
		}
		for (int i = 0; i < 11; i++) {
			if ((i + j) < 11) {
				ace_log2 = get_ace_log2(pos[i]);
				U4 flag = 0;
				if (mat_prev_level[i] - 1 < 5)
				{
					flag = mat_prev_level[i] - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
			}
		}
		for (int i = 0; i < 11; i++)
		{
			if ((i + j) < 11) {
				if (lev_opt[i])
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				}
				else
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
				}
			}
		}
		for (int i = 0; i < 11; i++)
		{
			if ((i + j) < 11) {
				ace_log2 = get_ace_log2(pos[i] + 1);
				U24 prev_level = mat_prev_level[i];
				U4 flag = 0;
				if (prev_level - 1 < 5)
				{
					flag = prev_level - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
			}
		}
		for (int i = 0; i < 11; i++) // vertical
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i == 0 && j == 10) || (i == 1 && j == 9))
				{
					break;
				}
				else
				{
					if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
					{
						if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
						{
							if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += base_cost_buffer_tmp[i];
					}
					else // above - top scan for (i+j)%2 is even case
					{
						S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
						if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
						{
							if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += curCost; // from the start point to current pos cost.
						if (i == 0)  // substract here is to get the actual endPosCost
						{
							endPosCost[i] = tempCost[i] - endPosCost[i];
						}
					}
				}
			}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 16 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}
	for (scan_pos = 0; scan_pos < 256; scan_pos++)
	{
		U8 blk_pos = scan[scan_pos];
		if (blk_pos == final_rdoq_last_x * 16 + final_rdoq_last_y)
		{
			best_last_idx_p1_tmp = scan_pos + 1;
		}
	}
#endif 
	* best_last_idx_p1 = best_last_idx_p1_tmp;
}

void rdoq_16_16_hardware_64_luma(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[256],
	int rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
	U3 cu_width_log2 = 4;
	U3 cu_height_log2 = 4;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16] = { 0 };
	static S64 d64_cost_last_zero[16] = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[256] = { 0 };
	static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16] = { 0 };
	static U1 mat_run[16] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	//S64 d64_cost_last_one_tmp[16] = { 0 };
	S64 d64_cost_last_one_tmp[16];
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	int rdoq_last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[16] = { 0 };
	U4 last1_pos[16] = { 0 };
	U5 last2_pos[16] = { 0 };
#pragma HLS ARRAY_PARTITION variable=last1_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=last2_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=0
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
	}
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < 11; j++)  //horizontal
	{
#pragma HLS PIPELINE
		U10 pos[16] = { 0 };
		for (int i = 0; i < 11; i++) {
			if (i < 11 - j) {
				U36 level_double = src_coef[i][j];
				S25 max_abs_level;
				U1 lower_int;
				U36 temp_level;
				temp_level = (U36)abs(src_coef[i][j]) * q_value;
				level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
				tmp_level_double[i] = level_double;
				max_abs_level = (S32)(level_double >> q_bits);
				lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
				if (!lower_int)
				{
					max_abs_level++;
				}
				tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
			}
		}
		for (U8 i = 0; i < 11; i++)
		{
			if (i < 11 - j) {
				if (tmp_coef[i])
				{
					mat_prev_level[i] = abs(tmp_coef[i]);
					mat_run[i] = 0;
				}
				else
				{
					mat_prev_level[i] = 1;
					mat_run[i] = 1;
				}
			}
		}
		for (U8 i = 0; i < 11; i++) {
			if (i < 11 - j) {
				U24 level;
				U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
				int iflast = (i * 16 + j == 255);
				level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
					mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
				S17 level_cbf = level;
				tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				tmp_dst_coef_out[i * 16 + j] = tmp_dst_coef[i];
				mat_uncoded_cost[i] = d64_uncoded_cost;
				mat_coded_cost[i] = d64_coded_cost;
				lev_opt[i] = level;
			}
		}




		for (int i = 0; i < 11; i++) {
			if ((i + j) < 11) {
				if (i + j < 3) {
					ace_log2 = i + j;
				}
				else if (i + j < 4) {
					ace_log2 = 3;
				}
				else if (i + j < 6) {
					ace_log2 = 4;
				}
				else {
					ace_log2 = 5;
				}
				U4 flag = 0;
				if (mat_prev_level[i] - 1 < 5)
				{
					flag = mat_prev_level[i] - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
			}
		}
		for (int i = 0; i < 11; i++)
		{
			if ((i + j) < 11) {
				if (lev_opt[i])
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				}
				else
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
				}
			}
		}
		for (int i = 0; i < 11; i++)
		{
			if ((i + j) < 11) {
				if (i + j < 3) {
					ace_log2 = i + j;
				}
				else if (i + j < 4) {
					ace_log2 = 3;
				}
				else if (i + j < 6) {
					ace_log2 = 4;
				}
				else {
					ace_log2 = 5;
				}
				U24 prev_level = mat_prev_level[i];
				U4 flag = 0;
				if (prev_level - 1 < 5)
				{
					flag = prev_level - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
			}
		}
		for (int i = 0; i < 11; i++) // vertical
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i == 0 && j == 10) || (i == 1 && j == 9))
				{
					break;
				}
				else
				{
					if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
					{
						if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
						{
							if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += base_cost_buffer_tmp[i];
					}
					else // above - top scan for (i+j)%2 is even case
					{
						S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
						if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
						{
							if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += curCost; // from the start point to current pos cost.
						if (i == 0)  // substract here is to get the actual endPosCost
						{
							endPosCost[i] = tempCost[i] - endPosCost[i];
						}
					}
				}
			}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 16 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}



	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
#endif 
}

void rdoq_16_16_hardware_64_chroma(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[16][16],
	int rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef_out complete dim=1
#pragma HLS ARRAY_PARTITION variable=rdoq_est_cbf complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_run_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_level_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local complete dim=0
	U3 cu_width_log2 = 4;
	U3 cu_height_log2 = 4;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16];// = { 0 };
	static S64 d64_cost_last_zero[16];// = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	//d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	//static S64 d64_base_cost[256] = { 0 };
	//static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16];// = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16];// = { 0 };
	static U1 mat_run[16];// = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16];// = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	int rdoq_last_x[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	//int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoqD64LastOne complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_x complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_y complete dim=0
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
		rdoqD64LastOne[i] = -1;
		rdoq_last_x[i] = -1;
		rdoq_last_y[i] = -1;
	}
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < 11; j++)  //horizontal
	{
#pragma HLS PIPELINE II=1
		U10 pos[16] = { 0 };
		for (int i = 0; i < 11; i++) {
			if (i < 11 - j) {
				U36 level_double = src_coef[i][j];
				S25 max_abs_level;
				U1 lower_int;
				U36 temp_level;
				temp_level = (U36)abs(src_coef[i][j]) * q_value;
				level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
				tmp_level_double[i] = level_double;
				max_abs_level = (S32)(level_double >> q_bits);
				lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
				if (!lower_int)
				{
					max_abs_level++;
				}
				tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
			}
		}
		for (U8 i = 0; i < 11; i++)
		{
			if (i < 11 - j) {
				if (tmp_coef[i])
				{
					mat_prev_level[i] = abs(tmp_coef[i]);
					mat_run[i] = 0;
				}
				else
				{
					mat_prev_level[i] = 1;
					mat_run[i] = 1;
				}
			}
		}
		for (U8 i = 0; i < 11; i++) {
			if (i < 11 - j) {
				U24 level;
				U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
				int iflast = (i * 16 + j == 255);
				level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
					mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
				S17 level_cbf = level;
				tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				tmp_dst_coef_out[i][j] = tmp_dst_coef[i];
				mat_uncoded_cost[i] = d64_uncoded_cost;
				mat_coded_cost[i] = d64_coded_cost;
				lev_opt[i] = level;
			}
		}

		for (int i = 0; i < 11; i++) {
			if ((i + j) < 11) {
				ace_log2 = get_ace_log2(pos[i]);
				U4 flag = 0;
				if (mat_prev_level[i] - 1 < 5)
				{
					flag = mat_prev_level[i] - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
			}
		}
		for (int i = 0; i < 11; i++)
		{
			if ((i + j) < 11) {
				if (lev_opt[i])
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				}
				else
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
				}
			}
		}
		for (int i = 0; i < 11; i++)
		{
			if ((i + j) < 11) {
				ace_log2 = get_ace_log2(pos[i] + 1);
				U24 prev_level = mat_prev_level[i];
				U4 flag = 0;
				if (prev_level - 1 < 5)
				{
					flag = prev_level - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
			}
		}
		for (int i = 0; i < 11; i++) // vertical
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i == 0 && j == 10) || (i == 1 && j == 9))
				{
					break;
				}
				else
				{
					if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
					{
						if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
						{
							if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += base_cost_buffer_tmp[i];
					}
					else // above - top scan for (i+j)%2 is even case
					{
						S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
						if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
						{
							if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += curCost; // from the start point to current pos cost.
						if (i == 0)  // substract here is to get the actual endPosCost
						{
							endPosCost[i] = tempCost[i] - endPosCost[i];
						}
					}
				}
			}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 16 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}

	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
#endif 
}

void rdoq_16_all_hardware_chroma(U3 cu_width_log2, U3 cu_height_log2, s16 src_coef[16][16], U6 qp,  s16 tmp_dst_coef_out[16][16],
	int rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 d_lambda, U4 bit_depth, int* final_x, int* final_y)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef_out complete dim=1
#pragma HLS ARRAY_PARTITION variable=rdoq_est_cbf complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_run_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_level_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local complete dim=0
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int q_bits = QUANT_SHIFT + tr_shift;
	const s64 lambda = (d_lambda * (1 << 15) + 500) / 1024;
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16];// = { 0 };
	static S64 d64_cost_last_zero[16];// = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	//d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	//static S64 d64_base_cost[256] = { 0 };
	//static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16];// = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16];// = { 0 };
	static U1 mat_run[16];// = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16];// = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	int rdoq_last_x[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	//int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U6 cu_width = 1 << cu_width_log2;
	U6 cu_height = 1 << cu_height_log2;
#pragma HLS ARRAY_PARTITION variable=tmp_level_double complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_zero complete dim=1
#pragma HLS ARRAY_PARTITION variable=lev_opt complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost complete dim=1
#pragma HLS ARRAY_PARTITION variable=base_cost_buffer_tmp complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=1
#pragma HLS ARRAY_PARTITION variable=tempCost complete dim=1
#pragma HLS ARRAY_PARTITION variable=endPosCost complete dim=1
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoqD64LastOne complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_x complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_y complete dim=0
	int shift_t;
	if (cu_width_log2 == 3 || cu_height_log2 == 3) {
		shift_t = 8;
	}
	else {
		shift_t = 16;
	}
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
		rdoqD64LastOne[i] = -1;
		rdoq_last_x[i] = -1;
		rdoq_last_y[i] = -1;
	}
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < 16; j++)  //horizontal
	{
#pragma HLS PIPELINE II=1
		//U10 pos[16] = { 0 };
		if (j < cu_width) {
			for (int i = 0; i < 16; i++) {
				if ((i < 16 - j) && (i < cu_height)) {
					U36 level_double = src_coef[i][j];
					S25 max_abs_level;
					U1 lower_int;
					U36 temp_level;
					temp_level = (U36)abs(src_coef[i][j]) * q_value;
					level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
					tmp_level_double[i] = level_double;
					max_abs_level = (S32)(level_double >> q_bits);
					lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
					if (!lower_int)
					{
						max_abs_level++;
					}
					tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
				}
			}
			for (int i = 0; i < 16; i++) {
				if ((i < 16 - j) && (i < cu_height)) {
					if (tmp_coef[i])
					{
						mat_prev_level[i] = abs(tmp_coef[i]);
						mat_run[i] = 0;
					}
					else
					{
						mat_prev_level[i] = 1;
						mat_run[i] = 1;
					}
				}
			}
			for (int i = 0; i < 16; i++) {
				if ((i < 16 - j) && (i < cu_height)) {
					U24 level;
					U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
					int iflast = (i * 16 + j == 255);
					level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
						mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
					S17 level_cbf = level;
					tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
					tmp_dst_coef_out[i][j] = tmp_dst_coef[i];
					mat_uncoded_cost[i] = d64_uncoded_cost;
					mat_coded_cost[i] = d64_coded_cost;
					lev_opt[i] = level;
				}
			}
			for (int i = 0; i < 16; i++) {
				if ((i < 16 - j) && (i < cu_height)) {
					if (i + j < 3) {
						ace_log2 = i + j;
					}
					else if (i + j < 4) {
						ace_log2 = 3;
					}
					else if (i + j < 6) {
						ace_log2 = 4;
					}
					else if (i + j < 10) {
						ace_log2 = 5;
					}
					else if (i + j < 14) {
						ace_log2 = 6;
					}
					else {
						ace_log2 = 7;
					}
					U4 flag = 0;
					if (mat_prev_level[i] - 1 < 5)
					{
						flag = mat_prev_level[i] - 1;
					}
					else
					{
						flag = 5;
					}
					d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
				}
			}
			for (int i = 0; i < 16; i++) {
				if ((i < 16 - j) && (i < cu_height)) {
					if (lev_opt[i])
					{
						base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
					}
					else
					{
						base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
					}
				}
			}
			for (int i = 0; i < 16; i++) {
				if ((i < 16 - j) && (i < cu_height)) {
					if (i + j < 3) {
						ace_log2 = i + j;
					}
					else if (i + j < 4) {
						ace_log2 = 3;
					}
					else if (i + j < 6) {
						ace_log2 = 4;
					}
					else if (i + j < 10) {
						ace_log2 = 5;
					}
					else if (i + j < 14) {
						ace_log2 = 6;
					}
					else {
						ace_log2 = 7;
					}
					U24 prev_level = mat_prev_level[i];
					U4 flag = 0;
					if (prev_level - 1 < 5)
					{
						flag = prev_level - 1;
					}
					else
					{
						flag = 5;
					}
					d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
				}
			}
			for (int i = 0; i < 16; i++) {
				if (i < cu_height) {
					if (j == 0)
					{
						if (lev_opt[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] = base_cost_buffer_tmp[i];
						if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
						{
							if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
							else endPosCost[i] = 0;
						}
						else // above - top scan for (i+j)%2 is even case
						{
							if (lev_opt[i]) endPosCost[i] = 0;
							else endPosCost[i] = base_cost_buffer_tmp[i];
							if (i == 0) {   // substract here is to get the actual endPosCost
								endPosCost[i] = tempCost[i] - endPosCost[i];
							}
						}
					}
					else if (i == shift_t - 1)
					{
						rdoq_last_x[i] = -1;
						rdoq_last_y[i] = -1;
						rdoqD64LastOne[i] = -1;
						if (lev_opt[i])
						{
							//last_x[i] = i;
							//last_y[i] = j;
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] = base_cost_buffer_tmp[i];
						if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
						{
							if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
							else endPosCost[i] = 0;
						}
						else // above - top scan for (i+j)%2 is even case
						{
							if (lev_opt[i]) endPosCost[i] = 0;
							else endPosCost[i] = base_cost_buffer_tmp[i];
						}
					}
					else
					{

						if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
						{
							if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
							{
								if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
								{
									rdoq_last_x[i] = i;
									rdoq_last_y[i] = j;
									endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
									rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
								}
							}
							if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
							tempCost[i] += base_cost_buffer_tmp[i];
						}
						else // above - top scan for (i+j)%2 is even case
						{
							S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
							if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
							{
								if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
								{
									rdoq_last_x[i] = i;
									rdoq_last_y[i] = j;
									endPosCost[i] = tempCost[i];
									rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
								}
							}
							if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
							{
								rdoq_last_x[i] = i;
								rdoq_last_y[i] = j;
								endPosCost[i] = tempCost[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
							tempCost[i] += curCost; // from the start point to current pos cost.
							if (i == 0)  // substract here is to get the actual endPosCost
							{
								endPosCost[i] = tempCost[i] - endPosCost[i];
							}
						}

					}
				}
			}
			S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
			//int index = rdoq_last_x[0] * 16 + rdoq_last_y[0];
			if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
			{
				d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
				final_rdoq_last_x = rdoq_last_x[0];
				final_rdoq_last_y = rdoq_last_y[0];
			}
			finalRdoqCost += tempCost[0];
			for (int i = 1; i < 16; i++)
			{
				if (i < shift_t) {
					rdoq_last_x[i - 1] = rdoq_last_x[i];
					rdoq_last_y[i - 1] = rdoq_last_y[i];
					tempCost[i - 1] = tempCost[i];
					endPosCost[i - 1] = endPosCost[i];
					rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
				}
			}
		}
	}
	if (cu_width == 8 && cu_height == 16) {
		for (int i = 0; i < 8; i++)
		{
#pragma HLS UNROLL
			if ((rdoq_last_x[i] + rdoq_last_y[i]) % 2 == 1) // above right scan.
			{
				endPosCost[i] = tempCost[i] - endPosCost[i];
			}
			S64 temp_RdoqCost = finalRdoqCost + endPosCost[i];
			//int index = rdoq_last_x[i] * cu_width + rdoq_last_y[i];
			if (rdoq_last_x[i] != -1 && temp_RdoqCost + rdoqD64LastOne[i] < d64_best_cost_tmp)
			{
				d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[i];
				final_rdoq_last_x = rdoq_last_x[i];
				final_rdoq_last_y = rdoq_last_y[i];

			}
			finalRdoqCost += tempCost[i];
		}
	}
	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
#endif 
}


static U4 get_ace_log2_1_16_8(U8 blk_pos)
{
	U8 ace_log2_table[96] = { 0,0,2,2,3,3,4,4,5,5,5,5,
							  1,2,2,3,4,4,4,5,5,5,5,0,
							  1,3,3,4,4,4,5,5,5,5,0,0,
							  3,3,4,4,4,5,5,5,5,0,0,0,
							  3,4,4,5,5,5,5,0,0,0,0,0,
							  4,4,5,5,5,5,0,0,0,0,0,0,
							  4,5,5,5,5,0,0,0,0,0,0,0,
							  5,5,5,5,0,0,0,0,0,0,0,0 };
	U4 ace_log2 = ace_log2_table[blk_pos];
	return ace_log2;
}
static U4 get_ace_log2_2_16_8(U8 blk_pos)
{
	U8 ace_log2_table[96] = { 0,1,2,2,3,4,4,4,5,5,5,5,
							1,2,3,3,4,4,4,5,5,5,5,0,
							2,3,3,4,4,4,5,5,5,5,0,0,
							3,3,4,4,5,5,5,5,6,0,0,0,
							3,4,4,5,5,5,5,0,0,0,0,0,
							4,4,5,5,5,5,0,0,0,0,0,0,
							4,5,5,5,5,0,0,0,0,0,0,0,
							5,5,5,5,0,0,0,0,0,0,0,0 };
	U4 ace_log2 = ace_log2_table[blk_pos];
	return ace_log2;
}
static U4 get_ace_log2_1_8_16(U8 blk_pos)
{
	U8 ace_log2_table[96] = { 0,0,2,2,3,3,4,4,
							1,2,2,3,4,4,4,5,
							1,3,3,4,4,4,5,5,
							3,3,4,4,4,5,5,5,
							3,4,4,5,5,5,5,5,
							4,4,5,5,5,5,5,6,
							4,5,5,5,5,5,6,6,
							5,5,5,5,5,6,6,6,
							5,5,5,6,6,6,6,6,
							5,5,6,6,6,6,6,6,
							5,6,6,6,6,6,6,6 };
	U4 ace_log2 = ace_log2_table[blk_pos];
	return ace_log2;
}
static U4 get_ace_log2_2_8_16(U8 blk_pos)
{
	U8 ace_log2_table[96] = { 0,1,2,2,3,4,4,4,
							1,2,3,3,4,4,4,5,
							2,3,3,4,4,4,5,5,
							3,3,4,4,5,5,5,5,
							3,4,4,5,5,5,5,5,
							4,4,5,5,5,5,5,6,
							4,5,5,5,5,5,6,6,
							5,5,5,5,6,6,6,6,
							5,5,5,6,6,6,6,6,
							5,5,6,6,6,6,6,6,
							5,6,6,6,6,6,6,6 };
	U4 ace_log2 = ace_log2_table[blk_pos];
	return ace_log2;
}
void CleanNz_16_all_lxy(int cu_width, int cu_height, int* num_nz_coef, s16 dst_tmp[16][16], s16 tmp_dst_coef[256], s16 coef_pb_part[16][16], s16 coef_update[16][16], s16 dst_for_itv[16][16], int final_x, int final_y)
{
	for (int i = 0; i < cu_height; i++)
	{
#pragma HLS PIPELINE
		for (int j = 0; j < cu_width; j++)
		{
			if (i + j < final_x + final_y) {
				dst_tmp[i][j] = tmp_dst_coef[i * cu_width + j];
			}
			else if (i + j == final_x + final_y) {
				if ((final_x + final_y) % 2 == 1) {
					if (i > final_x && j < final_y) {
						dst_tmp[i][j] = 0;
					}
					else {
						dst_tmp[i][j] = tmp_dst_coef[i * cu_width + j];
					}
				}
				else {
					if (i < final_x && j > final_y) {
						dst_tmp[i][j] = 0;
					}
					else {
						dst_tmp[i][j] = tmp_dst_coef[i * cu_width + j];
					}
				}
			}
			else {
				dst_tmp[i][j] = 0;
			}
			coef_pb_part[i][j] = dst_tmp[i][j];
			coef_update[i][j] = dst_tmp[i][j];
			dst_for_itv[i][j] = dst_tmp[i][j];
			*num_nz_coef += !!(dst_tmp[i][j]);
		}
	}
}
void CleanNz_16_all(int cu_width, int cu_height, int* num_nz_coef, s16 dst_tmp[16][16], s16 tmp_dst_coef[256],  int final_x, int final_y)
{
	for (int i = 0; i < cu_height; i++)
	{
		for (int j = 0; j < cu_width; j++)
		{
			if (i + j < final_x + final_y) {
				dst_tmp[i][j] = tmp_dst_coef[i * cu_width + j];
			}
			else if (i + j == final_x + final_y) {
				if ((final_x + final_y) % 2 == 1) {
					if (i > final_x && j < final_y) {
						dst_tmp[i][j] = 0;
					}
					else {
						dst_tmp[i][j] = tmp_dst_coef[i * cu_width + j];
					}
				}
				else {
					if (i < final_x && j > final_y) {
						dst_tmp[i][j] = 0;
					}
					else {
						dst_tmp[i][j] = tmp_dst_coef[i * cu_width + j];
					}
				}
			}
			else {
				dst_tmp[i][j] = 0;
			}
			*num_nz_coef += !!(dst_tmp[i][j]);
		}
	}
}
void coef_pb_part_write(int j, S16 buffer_tmp[16], s16 coef_pb_part[16][16])
{
#pragma HLS INLINE
	if (j == 0) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 1) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 2) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 3) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 4) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 5) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 6) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 7) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 8) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 9) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 10) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 11) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 12) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 13) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 14) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	else if (j == 15) { for (int i = 0; i < 16; i++) { coef_pb_part[(i + j) & 15][j] = buffer_tmp[i]; } }
	
}
void CleanNz_16_all_chroma(int cu_width, int cu_height,  s16 dst_tmp[16][16], s16 tmp_dst_coef[16][16], int final_x, int final_y, 
	 int* num_nz_itv, s16 coef_pb_part[16][16], U8 rdo_idx, U8 all_rdo_num)
{
#pragma HLS ARRAY_PARTITION variable=dst_tmp complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete dim=1
	if (rdo_idx < all_rdo_num) {
	int num_nz_coef = 0;
	S16 buffer_tmp[16];
#pragma HLS ARRAY_PARTITION variable=buffer_tmp complete dim=0
	for (int j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		for (int i = 0; i < 16; i++)
		{
			if ((i < cu_height)&&(j < cu_width)) {
			if (i + j < final_x + final_y) {
					buffer_tmp[i] = tmp_dst_coef[i][j];
			}
			else if (i + j == final_x + final_y) {
				if ((final_x + final_y) % 2 == 1) {
					if (i > final_x && j < final_y) {
							buffer_tmp[i] = 0;
					}
					else {
							buffer_tmp[i] = tmp_dst_coef[i][j];
					}
				}
				else {
					if (i < final_x && j > final_y) {
							buffer_tmp[i] = 0;
					}
					else {
							buffer_tmp[i] = tmp_dst_coef[i][j];
						}
					}
				}
				else {
					buffer_tmp[i] = 0;
				}
			}
			else {
				buffer_tmp[i] = 0;
			}
		}
		for (int i = 0; i < 16; i++)
		{
			dst_tmp[i][j] = buffer_tmp[i];
			num_nz_coef += !!(buffer_tmp[i]);
		}
		coef_pb_part_write( j,  buffer_tmp,  coef_pb_part);
	}
	*num_nz_itv = num_nz_coef;
	//*num_nz_rate = num_nz_coef;
	}
}
void rdoq_16_8_hardware_64(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[256], u32 last1[12], u32 last2[22],
	u32 run[24], u32 level[24], int* best_last_idx_p1,
	int rdoq_est_cbf[3][2], u8 scan[256], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth)
{
	U3 cu_width_log2 = 4;
	U3 cu_height_log2 = 3;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16] = { 0 };
	static S64 d64_cost_last_zero[16] = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[256] = { 0 };
	static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16] = { 0 };
	static U1 mat_run[16] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16] = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	int last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[16] = { 0 };
	U4 last1_pos[16] = { 0 };
	U5 last2_pos[16] = { 0 };
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < 12; j++)  //horizontal
	{
		u32 last1_tmp[12] = { 0 };
		u32 last2_tmp[22] = { 0 };
		u32 level_tmp[24] = { 0 };
		u32 level_tmp1[24] = { 0 };
		u32 run_tmp[24] = { 0 };
		u32 run_tmp1[24] = { 0 };
		U10 pos[16];
		int num_ver = 0;
		if (j < 4) {
			num_ver = 8;
		}
		else if (j < 8) {
			num_ver = 11 - j;
		}
		else {
			num_ver = 12 - j;
		}
		for (int i = 0; i < num_ver; i++) {
			U36 level_double = src_coef[i][j];
			S25 max_abs_level;
			U1 lower_int;
			U36 temp_level;
			temp_level = (U36)abs(src_coef[i][j]) * q_value;
			level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
			tmp_level_double[i] = level_double;
			max_abs_level = (S32)(level_double >> q_bits);
			lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
			if (!lower_int)
			{
				max_abs_level++;
			}
			tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
		}
		for (U8 i = 0; i < num_ver; i++)
		{
			if (tmp_coef[i])
			{
				mat_prev_level[i] = abs(tmp_coef[i]);
				mat_run[i] = 0;
			}
			else
			{
				mat_prev_level[i] = 1;
				mat_run[i] = 1;
			}
		}
		for (U8 i = 0; i < num_ver; i++) {
			U24 level;
			U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
			int iflast = (i * 16 + j == 255);
			level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
				mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
			S17 level_cbf = level;
			tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
			tmp_dst_coef_out[i * 16 + j] = tmp_dst_coef[i];
			mat_uncoded_cost[i] = d64_uncoded_cost;
			mat_coded_cost[i] = d64_coded_cost;
			lev_opt[i] = level;
		}
		for (int i = 0; i < num_ver; i++)
		{
#pragma HLS UNROLL
			ace_log2 = get_ace_log2_2_16_8(i * 12 + j);
			t0[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == 0 ? 0 : 12);
			last1_pos[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5)))) + (ch_type == 0 ? 0 : 6);
			last2_pos[i] = ace_log2 + (ch_type == 0 ? 0 : 12);
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
		{
#pragma HLS UNROLL
			level_core_16_16(16, 16, level_tmp, level_tmp1, t0, scan_pos, num_ver);
			run_core_16_16(16, 16, run_tmp, run_tmp1, t0, scan_pos, mat_run, num_ver);
		}
		for (scan_pos = 0; scan_pos < 12; scan_pos++)
		{
#pragma HLS UNROLL
			last1_core_16_16(16, 16, last1_tmp, last1_pos, scan_pos, num_ver);
			last1[scan_pos] += last1_tmp[scan_pos];
		}
		for (scan_pos = 0; scan_pos < 22; scan_pos++)
		{
#pragma HLS UNROLL
			last2_core_16_16(16, 16, last2_tmp, last2_pos, scan_pos, num_ver);
			last2[scan_pos] += last2_tmp[scan_pos];
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos++)
		{
#pragma HLS UNROLL
			level[scan_pos] += level_tmp[scan_pos] + level_tmp1[scan_pos];
			run[scan_pos] += run_tmp[scan_pos] + run_tmp1[scan_pos];
		}
		for (int i = 0; i < num_ver; i++) {
			ace_log2 = get_ace_log2_1_16_8(i * 12 + j);
			U4 flag = 0;
			if (mat_prev_level[i] - 1 < 5)
			{
				flag = mat_prev_level[i] - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
		}
		for (int i = 0; i < num_ver; i++)
		{
			if (lev_opt[i])
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
			}
			else
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
			}
		}
		for (int i = 0; i < num_ver; i++)
		{
			ace_log2 = get_ace_log2_2_16_8(i * 12 + j);
			U24 prev_level = mat_prev_level[i];
			U4 flag = 0;
			if (prev_level - 1 < 5)
			{
				flag = prev_level - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
		}
		for (int i = 0; i < num_ver; i++) // vertical
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else if (i == 7)
			{
				last_x[i] = -1;
				last_y[i] = -1;
				rdoq_last_x[i] = -1;
				rdoq_last_y[i] = -1;
				rdoqD64LastOne[i] = -1;
				if (lev_opt[i])
				{
					last_x[i] = i;
					last_y[i] = j;
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 16 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}
	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
		U8 blk_pos = scan[scan_pos];
		if (blk_pos == final_rdoq_last_x * 16 + final_rdoq_last_y)
		{
			best_last_idx_p1_tmp = scan_pos + 1;
		}
	}
#endif 
	* best_last_idx_p1 = best_last_idx_p1_tmp;
	int tmp_sum = 0;
}

void rdoq_16_8_hardware_64_luma(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[256],
	int rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
	U3 cu_width_log2 = 4;
	U3 cu_height_log2 = 3;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16] = { 0 };
	static S64 d64_cost_last_zero[16] = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[256] = { 0 };
	static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16] = { 0 };
	static U1 mat_run[16] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16] ;
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	s8 last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 final_last_x = -1, final_last_y = -1;
	s8 final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[16] = { 0 };
	U4 last1_pos[16] = { 0 };
	U5 last2_pos[16] = { 0 };
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
#pragma HLS ARRAY_PARTITION variable=last1_pos complete dim=0
#pragma HLS ARRAY_PARTITION variable=last2_pos complete dim=0
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=0
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
	}
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < 12; j++)  //horizontal
	{
#pragma HLS PIPELINE
		U32 last1_tmp[12] = { 0 };
		U32 last2_tmp[22] = { 0 };
		U32 level_tmp[24] = { 0 };
		U32 level_tmp1[24] = { 0 };
		U32 run_tmp[24] = { 0 };
		U32 run_tmp1[24] = { 0 };
		U10 pos[16];
		int num_ver = 0;
		if (j < 4) {
			num_ver = 8;
		}
		else if (j < 8) {
			num_ver = 11 - j;
		}
		else {
			num_ver = 12 - j;
		}
		for (int i = 0; i < 8; i++) {
			if (i < num_ver)
			{
			U36 level_double = src_coef[i][j];
			S25 max_abs_level;
			U1 lower_int;
			U36 temp_level;
			temp_level = (U36)abs(src_coef[i][j]) * q_value;
			level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
			tmp_level_double[i] = level_double;
			max_abs_level = (S32)(level_double >> q_bits);
			lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
			if (!lower_int)
			{
				max_abs_level++;
			}
			tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
		}
		}
		for (U8 i = 0; i < 8; i++)
		{
			if (i < num_ver)
		{
			if (tmp_coef[i])
			{
				mat_prev_level[i] = abs(tmp_coef[i]);
				mat_run[i] = 0;
			}
			else
			{
				mat_prev_level[i] = 1;
				mat_run[i] = 1;
			}
		}
		}
		for (U8 i = 0; i < 8; i++) {
			if (i < num_ver)
			{
			U24 level;
			U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
			int iflast = (i * 16 + j == 255);
			level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
				mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
			S17 level_cbf = level;
			tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
			tmp_dst_coef_out[i * 16 + j] = tmp_dst_coef[i];
			mat_uncoded_cost[i] = d64_uncoded_cost;
			mat_coded_cost[i] = d64_coded_cost;
			lev_opt[i] = level;
		}
		}



		for (int i = 0; i < 8; i++) {
			if (i < num_ver)
				{
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U4 flag = 0;
			if (mat_prev_level[i] - 1 < 5)
			{
				flag = mat_prev_level[i] - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
		}
		}
		for (int i = 0; i < 8; i++)
		{
			if (i < num_ver)
		{
			if (lev_opt[i])
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
			}
			else
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
			}
		}
		}
		for (int i = 0; i < 8; i++)
		{
			if (i < num_ver)
		{
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U24 prev_level = mat_prev_level[i];
			U4 flag = 0;
			if (prev_level - 1 < 5)
			{
				flag = prev_level - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
		}
		}
		for (int i = 0; i < 8; i++) // vertical
		{
			if (i < num_ver)
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else if (i == 7)
			{
				last_x[i] = -1;
				last_y[i] = -1;
				rdoq_last_x[i] = -1;
				rdoq_last_y[i] = -1;
				rdoqD64LastOne[i] = -1;
				if (lev_opt[i])
				{
					last_x[i] = i;
					last_y[i] = j;
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 16 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}

	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
#endif 
}

void rdoq_16_8_hardware_64_chroma(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[16][16],
	int rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef_out complete dim=1
#pragma HLS ARRAY_PARTITION variable=rdoq_est_cbf complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_run_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_level_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local complete dim=0
	U3 cu_width_log2 = 4;
	U3 cu_height_log2 = 3;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16];// = { 0 };
	static S64 d64_cost_last_zero[16];// = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	//d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	//static S64 d64_base_cost[256] = { 0 };
	//static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16];// = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16];// = { 0 };
	static U1 mat_run[16];// = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16];// = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	//int last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	//int last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_x[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	//U5 t0[16] = { 0 };
	//U4 last1_pos[16] = { 0 };
	//U5 last2_pos[16] = { 0 };
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoqD64LastOne complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_x complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_y complete dim=0
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
		rdoqD64LastOne[i] = -1;
		rdoq_last_x[i] = -1;
		rdoq_last_y[i] = -1;
	}
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < 12; j++)  //horizontal
	{
#pragma HLS PIPELINE II=1
		int num_ver = 0;
		if (j < 4) {
			num_ver = 8;
		}
		else if (j < 8) {
			num_ver = 11 - j;
		}
		else {
			num_ver = 12 - j;
		}
		for (int i = 0; i < 8; i++) {
			if (i < num_ver) {
			U36 level_double = src_coef[i][j];
			S25 max_abs_level;
			U1 lower_int;
			U36 temp_level;
			temp_level = (U36)abs(src_coef[i][j]) * q_value;
			level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
			tmp_level_double[i] = level_double;
			max_abs_level = (S32)(level_double >> q_bits);
			lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
			if (!lower_int)
			{
				max_abs_level++;
			}
			tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
		}
		}
		for (U8 i = 0; i < 8; i++)
		{
			if (i < num_ver) {
			if (tmp_coef[i])
			{
				mat_prev_level[i] = abs(tmp_coef[i]);
				mat_run[i] = 0;
			}
			else
			{
				mat_prev_level[i] = 1;
				mat_run[i] = 1;
			}
		}
		}
		for (U8 i = 0; i < 8; i++) {
			if (i < num_ver) {
			U24 level;
			U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
			int iflast = (i * 16 + j == 255);
			level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
				mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
			S17 level_cbf = level;
			tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				tmp_dst_coef_out[i][j] = tmp_dst_coef[i];
			mat_uncoded_cost[i] = d64_uncoded_cost;
			mat_coded_cost[i] = d64_coded_cost;
			lev_opt[i] = level;
			}
		}

		for (int i = 0; i < 8; i++) {
			if (i < num_ver) {
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U4 flag = 0;
			if (mat_prev_level[i] - 1 < 5)
			{
				flag = mat_prev_level[i] - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
		}
		}
		for (int i = 0; i < 8; i++)
		{
			if (i < num_ver) {
			if (lev_opt[i])
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
			}
			else
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
			}
		}
		}
		for (int i = 0; i < 8; i++)
		{
			if (i < num_ver) {
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U24 prev_level = mat_prev_level[i];
			U4 flag = 0;
			if (prev_level - 1 < 5)
			{
				flag = prev_level - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
		}
		}
		for (int i = 0; i < 8; i++) // vertical
		{
			if (i < num_ver) {
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else if (i == 7)
			{
					//last_x[i] = -1;
					//last_y[i] = -1;
				rdoq_last_x[i] = -1;
				rdoq_last_y[i] = -1;
				rdoqD64LastOne[i] = -1;
				if (lev_opt[i])
				{
						//last_x[i] = i;
						//last_y[i] = j;
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 16 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			//last_x[i - 1] = last_x[i];
			//last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}
	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
#endif 
}

void rdoq_8_16_hardware_64(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[256], u32 last1[12], u32 last2[22],
	u32 run[24], u32 level[24], int* best_last_idx_p1,
	s32 rdoq_est_cbf[3][2], u8 scan[256], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth)
{
	U3 cu_width_log2 = 3;
	U3 cu_height_log2 = 4;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16] = { 0 };
	static S64 d64_cost_last_zero[16] = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[256] = { 0 };
	static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16] = { 0 };
	static U1 mat_run[16] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16] = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	int last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[16] = { 0 };
	U4 last1_pos[16] = { 0 };
	U5 last2_pos[16] = { 0 };
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	int num_ver = 0;
	for (int j = 0; j < 12; j++)  //horizontal
	{
		u32 last1_tmp[12] = { 0 };
		u32 last2_tmp[22] = { 0 };
		u32 level_tmp[24] = { 0 };
		u32 level_tmp1[24] = { 0 };
		u32 run_tmp[24] = { 0 };
		u32 run_tmp1[24] = { 0 };
		U10 pos[16];
		if (j < 4) {
			num_ver = 11 - j;
		}
		else if (j < 8) {
			num_ver = 12 - j;
		}
		else {
			num_ver = 0;
		}
		for (int i = 0; i < num_ver; i++) {
			U36 level_double = src_coef[i][j];
			S25 max_abs_level;
			U1 lower_int;
			U36 temp_level;
			temp_level = (U36)abs(src_coef[i][j]) * q_value;
			level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
			tmp_level_double[i] = level_double;
			max_abs_level = (S32)(level_double >> q_bits);
			lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
			if (!lower_int)
			{
				max_abs_level++;
			}
			tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
		}
		for (U8 i = 0; i < num_ver; i++)
		{
			if (tmp_coef[i])
			{
				mat_prev_level[i] = abs(tmp_coef[i]);
				mat_run[i] = 0;
			}
			else
			{
				mat_prev_level[i] = 1;
				mat_run[i] = 1;
			}
		}
		for (U8 i = 0; i < num_ver; i++) {
			U24 level;
			U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
			int iflast = (i * 8 + j == 128);
			level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
				mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
			S17 level_cbf = level;
			tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
			tmp_dst_coef_out[i * 8 + j] = tmp_dst_coef[i];
			mat_uncoded_cost[i] = d64_uncoded_cost;
			mat_coded_cost[i] = d64_coded_cost;
			lev_opt[i] = level;
		}
		for (int i = 0; i < num_ver; i++)
		{
#pragma HLS UNROLL
			ace_log2 = get_ace_log2_2_8_16(i * 8 + j);
			t0[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == 0 ? 0 : 12);
			last1_pos[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5)))) + (ch_type == 0 ? 0 : 6);
			last2_pos[i] = ace_log2 + (ch_type == 0 ? 0 : 12);
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
		{
#pragma HLS UNROLL
			level_core_16_16(16, 16, level_tmp, level_tmp1, t0, scan_pos, num_ver);
			run_core_16_16(16, 16, run_tmp, run_tmp1, t0, scan_pos, mat_run, num_ver);
		}
		for (scan_pos = 0; scan_pos < 12; scan_pos++)
		{
#pragma HLS UNROLL
			last1_core_16_16(16, 16, last1_tmp, last1_pos, scan_pos, num_ver);
			last1[scan_pos] += last1_tmp[scan_pos];
		}
		for (scan_pos = 0; scan_pos < 22; scan_pos++)
		{
#pragma HLS UNROLL
			last2_core_16_16(16, 16, last2_tmp, last2_pos, scan_pos, num_ver);
			last2[scan_pos] += last2_tmp[scan_pos];
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos++)
		{
#pragma HLS UNROLL
			level[scan_pos] += level_tmp[scan_pos] + level_tmp1[scan_pos];
			run[scan_pos] += run_tmp[scan_pos] + run_tmp1[scan_pos];
		}
		for (int i = 0; i < num_ver; i++) {
			ace_log2 = get_ace_log2_1_8_16(i * 8 + j);
			U4 flag = 0;
			if (mat_prev_level[i] - 1 < 5)
			{
				flag = mat_prev_level[i] - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
		}
		for (int i = 0; i < num_ver; i++)
		{
			if (lev_opt[i])
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
			}
			else
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
			}
		}
		for (int i = 0; i < num_ver; i++)
		{
			ace_log2 = get_ace_log2_2_8_16(i * 8 + j);
			U24 prev_level = mat_prev_level[i];
			U4 flag = 0;
			if (prev_level - 1 < 5)
			{
				flag = prev_level - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
		}
		for (int i = 0; i < num_ver; i++) // vertical
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
					else if (j == 7) {
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 8 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}
	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
		U8 blk_pos = scan[scan_pos];
		if (blk_pos == final_rdoq_last_x * 8 + final_rdoq_last_y)
		{
			best_last_idx_p1_tmp = scan_pos + 1;
		}
	}
#endif 
	* best_last_idx_p1 = best_last_idx_p1_tmp;
	int tmp_sum = 0;
}

void rdoq_8_16_hardware_64_luma(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[256],
	int rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
	U3 cu_width_log2 = 3;
	U3 cu_height_log2 = 4;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16] = { 0 };
	static S64 d64_cost_last_zero[16] = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[256] = { 0 };
	static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16] = { 0 };
	static U1 mat_run[16] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16] ;
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	s8 last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 final_last_x = -1, final_last_y = -1;
	s8 final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[16] = { 0 };
	U4 last1_pos[16] = { 0 };
	U5 last2_pos[16] = { 0 };
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
#pragma HLS ARRAY_PARTITION variable=last1_pos complete dim=0
#pragma HLS ARRAY_PARTITION variable=last2_pos complete dim=0
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=0
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
	}
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	int num_ver = 0;
	for (int j = 0; j < 12; j++)  //horizontal
	{
#pragma HLS PIPELINE
		U32 last1_tmp[12] = { 0 };
		U32 last2_tmp[22] = { 0 };
		U32 level_tmp[24] = { 0 };
		U32 level_tmp1[24] = { 0 };
		U32 run_tmp[24] = { 0 };
		U32 run_tmp1[24] = { 0 };
		U10 pos[16];
		if (j < 4) {
			num_ver = 11 - j;
		}
		else if (j < 8) {
			num_ver = 12 - j;
		}
		else {
			num_ver = 0;
		}
		for (int i = 0; i < 11; i++) {
			if (i < num_ver)
			{
			U36 level_double = src_coef[i][j];
			S25 max_abs_level;
			U1 lower_int;
			U36 temp_level;
			temp_level = (U36)abs(src_coef[i][j]) * q_value;
			level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
			tmp_level_double[i] = level_double;
			max_abs_level = (S32)(level_double >> q_bits);
			lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
			if (!lower_int)
			{
				max_abs_level++;
			}
			tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
		}
		}
		for (U8 i = 0; i < 11; i++)
		{
			if (i < num_ver)
		{
			if (tmp_coef[i])
			{
				mat_prev_level[i] = abs(tmp_coef[i]);
				mat_run[i] = 0;
			}
			else
			{
				mat_prev_level[i] = 1;
				mat_run[i] = 1;
			}
		}
		}
		for (U8 i = 0; i < 11; i++) {
			if (i < num_ver)
			{
			U24 level;
			U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
			int iflast = (i * 8 + j == 128);
			level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
				mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
			S17 level_cbf = level;
			tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
			tmp_dst_coef_out[i * 8 + j] = tmp_dst_coef[i];
			mat_uncoded_cost[i] = d64_uncoded_cost;
			mat_coded_cost[i] = d64_coded_cost;
			lev_opt[i] = level;
		}
		}



		for (int i = 0; i < 11; i++) {
			if (i < num_ver)
			{
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U4 flag = 0;
			if (mat_prev_level[i] - 1 < 5)
			{
				flag = mat_prev_level[i] - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
		}
		}
		for (int i = 0; i < 11; i++)
		{
			if (i < num_ver) {
			if (lev_opt[i])
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
			}
			else
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
			}
		}
		}
		for (int i = 0; i < 11; i++)
		{
			if (i < num_ver)
		{
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U24 prev_level = mat_prev_level[i];
			U4 flag = 0;
			if (prev_level - 1 < 5)
			{
				flag = prev_level - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
		}
		}
		for (int i = 0; i < 11; i++) // vertical
		{
			if (i < num_ver)
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
					else if (j == 7) {
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 8 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}

	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
#endif 

}

void rdoq_8_16_hardware_64_chroma(s16 src_coef[16][16], U6 qp, S32 q_bits, s16 tmp_dst_coef_out[16][16],
	int rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef_out complete dim=1
#pragma HLS ARRAY_PARTITION variable=rdoq_est_cbf complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_run_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_level_local complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local complete dim=0
	U3 cu_width_log2 = 3;
	U3 cu_height_log2 = 4;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[16];
	static U36 tmp_level_double[16];
	static S16 tmp_coef[16];// = { 0 };
	static S64 d64_cost_last_zero[16];// = { 0 };
	static U24 lev_opt[16];
	static S64 mat_coded_cost[16];
	static S64 mat_uncoded_cost[16];
	//d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	//static S64 d64_base_cost[256] = { 0 };
	//static S64 base_cost_buffer[256] = { 0 };
	static S64 base_cost_buffer_tmp[16];// = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[16];// = { 0 };
	static U1 mat_run[16];// = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[16];// = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[16];   // all scan line cost
	S64 endPosCost[16]; // as the last position cost.
	S64 rdoqD64LastOne[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	//int last_x[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	//int last_y[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_x[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[16];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[16] = { 0 };
	U4 last1_pos[16] = { 0 };
	U5 last2_pos[16] = { 0 };
	U16 min_size = (1 << cu_width_log2) * (1 << cu_height_log2);
	U16 max_num = 64;
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoqD64LastOne complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_x complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_last_y complete dim=0
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
		rdoqD64LastOne[i] = -1;
		rdoq_last_x[i] = -1;
		rdoq_last_y[i] = -1;
	}
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	int num_ver = 0;
	for (int j = 0; j < 12; j++)  //horizontal
	{
#pragma HLS PIPELINE II=1
		//U32 last1_tmp[12] = { 0 };
		//U32 last2_tmp[22] = { 0 };
		//U32 level_tmp[24] = { 0 };
		//U32 level_tmp1[24] = { 0 };
		//U32 run_tmp[24] = { 0 };
		//U32 run_tmp1[24] = { 0 };
		U10 pos[16];
		if (j < 4) {
			num_ver = 11 - j;
		}
		else if (j < 8) {
			num_ver = 12 - j;
		}
		else {
			num_ver = 0;
		}
		for (int i = 0; i < 11; i++) {
			if (i < num_ver) {
			U36 level_double = src_coef[i][j];
			S25 max_abs_level;
			U1 lower_int;
			U36 temp_level;
			temp_level = (U36)abs(src_coef[i][j]) * q_value;
			level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
			tmp_level_double[i] = level_double;
			max_abs_level = (S32)(level_double >> q_bits);
			lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
			if (!lower_int)
			{
				max_abs_level++;
			}
			tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
		}
		}
		for (U8 i = 0; i < 11; i++)
		{
			if (i < num_ver) {
			if (tmp_coef[i])
			{
				mat_prev_level[i] = abs(tmp_coef[i]);
				mat_run[i] = 0;
			}
			else
			{
				mat_prev_level[i] = 1;
				mat_run[i] = 1;
			}
		}
		}
		for (U8 i = 0; i < 11; i++) {
			if (i < num_ver) {
			U24 level;
			U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
			int iflast = (i * 8 + j == 128);
			level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], (U32)COM_ABS(tmp_coef[i]),
				mat_run[i], (U5)ctx_run, (U5)ctx_run, q_bits, (U30)err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
			S17 level_cbf = level;
			tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				tmp_dst_coef_out[i][j] = tmp_dst_coef[i];
			mat_uncoded_cost[i] = d64_uncoded_cost;
			mat_coded_cost[i] = d64_coded_cost;
			lev_opt[i] = level;
			}
		}

		for (int i = 0; i < 11; i++) {
			if (i < num_ver) {
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U4 flag = 0;
			if (mat_prev_level[i] - 1 < 5)
			{
				flag = mat_prev_level[i] - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
		}
		}
		for (int i = 0; i < 11; i++)
		{
			if (i < num_ver) {
			if (lev_opt[i])
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
			}
			else
			{
				base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
			}
		}
		}
		for (int i = 0; i < 11; i++)
		{
			if (i < num_ver) {
			if (i + j < 3) {
				ace_log2 = i + j;
			}
			else if (i + j < 4) {
				ace_log2 = 3;
			}
			else if (i + j < 6) {
				ace_log2 = 4;
			}
			else {
				ace_log2 = 5;
			}
			U24 prev_level = mat_prev_level[i];
			U4 flag = 0;
			if (prev_level - 1 < 5)
			{
				flag = prev_level - 1;
			}
			else
			{
				flag = 5;
			}
			d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
		}
		}
		for (int i = 0; i < 11; i++) // vertical
		{
			if (i < num_ver) {
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {   // substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
					else if (j == 7) {
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		int index = rdoq_last_x[0] * 8 + rdoq_last_y[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < 16; i++)
		{
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}
	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
#endif 

}

static int rdoq_top_16_all(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], s16 dst_tmp[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{
#pragma HLS PIPELINE II=1
#pragma HLS ARRAY_PARTITION variable = src_coef complete dim = 0
#pragma HLS ARRAY_PARTITION variable = dst_tmp complete dim = 0

	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	u8 max_num_coef = 64;
	u16 wxh = cu_width * cu_height;
	u8 scan_tbl_index = 0;
	static u8 scan[256];
	static const u8 scan_t[3][256] = {
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73, 88, 103, 118, 119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120, 121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 123, 108, 93, 78, 63, 79, 94, 109, 124, 125, 110, 95, 111, 126, 127 },
		{ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 64, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 65, 72, 80, 73, 66, 59, 52, 45, 38, 31, 39, 46, 53, 60, 67, 74, 81, 88, 96, 89, 82, 75, 68, 61, 54, 47, 55, 62, 69, 76, 83, 90, 97, 104, 112, 105, 98, 91, 84, 77, 70, 63, 71, 78, 85, 92, 99, 106, 113, 120, 121, 114, 107, 100, 93, 86, 79, 87, 94, 101, 108, 115, 122, 123, 116, 109, 102, 95, 103, 110, 117, 124, 125, 118, 111, 119, 126, 127 },
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 128, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 129, 144, 160, 145, 130, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 131, 146, 161, 176, 192, 177, 162, 147, 132, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73, 88, 103, 118, 133, 148, 163, 178, 193, 208, 224, 209, 194, 179, 164, 149, 134, 119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 241, 226, 211, 196, 181, 166, 151, 136, 121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 137, 152, 167, 182, 197, 212, 227, 242, 243, 228, 213, 198, 183, 168, 153, 138, 123, 108, 93, 78, 63, 79, 94, 109, 124, 139, 154, 169, 184, 199, 214, 229, 244, 245, 230, 215, 200, 185, 170, 155, 140, 125, 110, 95, 111, 126, 141, 156, 171, 186, 201, 216, 231, 246, 247, 232, 217, 202, 187, 172, 157, 142, 127, 143, 158, 173, 188, 203, 218, 233, 248, 249, 234, 219, 204, 189, 174, 159, 175, 190, 205, 220, 235, 250, 251, 236, 221, 206, 191, 207, 222, 237, 252, 253, 238, 223, 239, 254, 255 },
	};
	if (cu_width == 16 && cu_height == 8)
	{
		max_num_coef = 64;
		scan_tbl_index = 0;
	}
	else if (cu_width == 8 && cu_height == 16)
	{
		max_num_coef = 64;
		scan_tbl_index = 1;
	}
	else // (cu_width == 16 && cu_height == 16)
	{
		max_num_coef = 64;
		scan_tbl_index = 2;
	}
	for (U9 i = 0; i < 256; i++)
	{
#pragma HLS UNROLL
		scan[i] = scan_t[scan_tbl_index][i];
	}
	const int q_bits = QUANT_SHIFT + tr_shift;
	int num_nz_coef = 0;
	int best_last_idx_p1 = 0;
	s16 tmp_coef[SIZE_16] = { 0 };
	U36 tmp_level_double[SIZE_16] = { 0 };
	s16 tmp_dst_coef[SIZE_16] = { 0 };
	const s64 lambda = (d_lambda * (1 << 15) + 500) / 1024;
	U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
#pragma HLS ARRAY_PARTITION variable=tmp_coef complete dim=0
#pragma HLS ARRAY_PARTITION variable=tmp_level_double complete dim=0
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=0
	U24 mat_prev_level[SIZE_16] = { 0 };
	U1 mat_run[SIZE_16] = { 0 };
	s64 mat_uncoded_cost[SIZE_16] = { 0 };
	s64 mat_coded_cost[SIZE_16] = { 0 };
	U24 lev_opt[SIZE_16] = { 0 };
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=lev_opt complete dim=0
	if (cu_width == 16 && cu_height == 16) {
		rdoq_16_16_hardware_64(src_coef, qp, q_bits, tmp_dst_coef, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level,
			&best_last_idx_p1, rdoq_array->rdoq_est_cbf, scan, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
			rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth);
	}
	else if (cu_width == 16 && cu_height == 8) {
		rdoq_16_8_hardware_64(src_coef, qp, q_bits, tmp_dst_coef, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level,
			&best_last_idx_p1, rdoq_array->rdoq_est_cbf, scan, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
			rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth);
	}
	else// (cu_width == 16 && cu_height == 16) 
	{
		rdoq_8_16_hardware_64(src_coef, qp, q_bits, tmp_dst_coef, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level,
			&best_last_idx_p1, rdoq_array->rdoq_est_cbf, scan, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
			rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth);
	}
	for (U32 scan_pos = 0; scan_pos < 256; scan_pos++)
	{
#pragma HLS UNROLL
		if (scan_pos < wxh)
		{
			u32 blk_pos = scan[scan_pos];
			u8 x = blk_pos % cu_width;
			u8 y = blk_pos >> cu_width_log2;
			dst_tmp[y][x] = scan_pos < best_last_idx_p1 ? tmp_dst_coef[blk_pos] : 0;
			num_nz_coef += !!(dst_tmp[y][x]);
		}
	}
	return num_nz_coef;
}

//static int rdoq_top_8_16_luma(U8 cu_width, U8 cu_height, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], s16 dst_tmp[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
static int rdoq_top_8_16_luma(U8 cu_width, U8 cu_height, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], s16 dst_tmp[16][16],
	s16 coef_pb_part[16][16], s16 coef_update[16][16], s16 dst_for_itv[16][16],
	U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{
//#pragma HLS PIPELINE II=1
#pragma HLS ARRAY_PARTITION variable = src_coef complete dim = 1
#pragma HLS ARRAY_PARTITION variable = dst_tmp complete dim = 2
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_run_local complete dim = 0
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_level_local complete dim = 0
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_last_local complete dim = 0
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int q_bits = QUANT_SHIFT + tr_shift;
	s16 tmp_coef[SIZE_16] = { 0 };
	U36 tmp_level_double[SIZE_16] = { 0 };
	s16 tmp_dst_coef[SIZE_16];
	const s64 lambda = (d_lambda * (1 << 15) + 500) / 1024;
	U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
//#pragma HLS ARRAY_PARTITION variable=tmp_coef complete dim=0
//#pragma HLS ARRAY_PARTITION variable=tmp_level_double complete dim=0
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=0
	U24 mat_prev_level[SIZE_16] = { 0 };
	U1 mat_run[SIZE_16] = { 0 };
	s64 mat_uncoded_cost[SIZE_16] = { 0 };
	s64 mat_coded_cost[SIZE_16] = { 0 };
	U24 lev_opt[SIZE_16] = { 0 };
	int num_nz_coef = 0;
	int final_x = 0, final_y = 0;
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=lev_opt complete dim=0
#pragma HLS ARRAY_PARTITION variable=last1_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=last2_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst_for_itv complete dim=2
	
		rdoq_8_16_hardware_64_luma(src_coef, qp, q_bits, tmp_dst_coef,
			rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
			rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);

	//CleanNz_16_all(cu_width, cu_height, &num_nz_coef, dst_tmp, tmp_dst_coef, final_x, final_y);
	CleanNz_16_all_lxy(cu_width, cu_height, &num_nz_coef, dst_tmp, tmp_dst_coef, coef_pb_part, coef_update, dst_for_itv, final_x, final_y);
	return num_nz_coef;
}

//static int rdoq_top_16_8_luma(U8 cu_width, U8 cu_height, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], s16 dst_tmp[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
static int rdoq_top_16_8_luma(U8 cu_width, U8 cu_height, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], s16 dst_tmp[16][16],
	s16 coef_pb_part[16][16], s16 coef_update[16][16], s16 dst_for_itv[16][16],
	U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{
//#pragma HLS PIPELINE II=1
#pragma HLS ARRAY_PARTITION variable = src_coef complete dim = 1
#pragma HLS ARRAY_PARTITION variable = dst_tmp complete dim = 2
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_run_local complete dim = 0
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_level_local complete dim = 0
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_last_local complete dim = 0
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int q_bits = QUANT_SHIFT + tr_shift;
	s16 tmp_coef[SIZE_16] = { 0 };
	U36 tmp_level_double[SIZE_16] = { 0 };
	s16 tmp_dst_coef[SIZE_16] ;
	const s64 lambda = (d_lambda * (1 << 15) + 500) / 1024;
	U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
//#pragma HLS ARRAY_PARTITION variable=tmp_coef complete dim=0
//#pragma HLS ARRAY_PARTITION variable=tmp_level_double complete dim=0
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=0
	U24 mat_prev_level[SIZE_16] = { 0 };
	U1 mat_run[SIZE_16] = { 0 };
	s64 mat_uncoded_cost[SIZE_16] = { 0 };
	s64 mat_coded_cost[SIZE_16] = { 0 };
	U24 lev_opt[SIZE_16] = { 0 };
	int num_nz_coef = 0;
	int final_x = 0, final_y = 0;
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=lev_opt complete dim=0
#pragma HLS ARRAY_PARTITION variable=last1_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=last2_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst_for_itv complete dim=2
		rdoq_16_8_hardware_64_luma(src_coef, qp, q_bits, tmp_dst_coef,
			rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
			rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
	CleanNz_16_all_lxy(cu_width, cu_height, &num_nz_coef, dst_tmp, tmp_dst_coef, coef_pb_part, coef_update, dst_for_itv, final_x, final_y);
	
	//CleanNz_16_all(cu_width, cu_height, &num_nz_coef, dst_tmp, tmp_dst_coef, final_x, final_y);
	return num_nz_coef;
}

static int rdoq_top_16_16_luma(U8 cu_width, U8 cu_height, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], s16 dst_tmp[16][16], 
	s16 coef_pb_part[16][16], s16 coef_update[16][16], s16 dst_for_itv[16][16],
	U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{
#pragma HLS ARRAY_PARTITION variable = src_coef complete dim = 1
#pragma HLS ARRAY_PARTITION variable = dst_tmp complete dim = 2
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_run_local complete dim = 0
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_level_local complete dim = 0
#pragma HLS ARRAY_PARTITION variable = rdoq_array->rdoq_est_last_local complete dim = 0
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int q_bits = QUANT_SHIFT + tr_shift;
	s16 tmp_coef[SIZE_16] = { 0 };
	U36 tmp_level_double[SIZE_16] = { 0 };
	//s16 tmp_dst_coef[SIZE_16] = { 0 };
	s16 tmp_dst_coef[SIZE_16];
	const s64 lambda = (d_lambda * (1 << 15) + 500) / 1024;
	U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=0
	U24 mat_prev_level[SIZE_16] = { 0 };
	U1 mat_run[SIZE_16] = { 0 };
	s64 mat_uncoded_cost[SIZE_16] = { 0 };
	s64 mat_coded_cost[SIZE_16] = { 0 };
	U24 lev_opt[SIZE_16] = { 0 };
	int num_nz_coef = 0;
	int final_x = 0, final_y = 0;

#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=lev_opt complete dim=0
#pragma HLS ARRAY_PARTITION variable=last1_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=last2_tmp complete dim=0
		rdoq_16_16_hardware_64_luma(src_coef, qp, q_bits, tmp_dst_coef,
			rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
			rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);

	CleanNz_16_all_lxy(cu_width, cu_height, &num_nz_coef, dst_tmp, tmp_dst_coef, coef_pb_part, coef_update, dst_for_itv, final_x, final_y);
	return num_nz_coef;
}

void rdoq_top_16_all_chroma(U8 cu_width, U8 cu_height, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], 
	U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array, 
	 s16 tmp_dst_coef[16][16], int *final_x, int *final_y, U8 rdo_idx, U8 all_rdo_num
	)
{
#pragma HLS INLINE OFF
	rdoq_16_all_hardware_chroma(cu_width_log2, cu_height_log2, src_coef, qp,  tmp_dst_coef,
		rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
		rdoq_array->rdoq_est_last, ch_type, is_intra, d_lambda, bit_depth, final_x, final_y);

}

static int rdoq_top_16(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[16][16], s16 dst_tmp[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{
#pragma HLS PIPELINE II=1
#pragma HLS ARRAY_PARTITION variable = src_coef complete dim = 0
#pragma HLS ARRAY_PARTITION variable = dst_tmp complete dim = 0

	static const U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	const U14 scale = quant_scale[qp];
	const int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const int q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	u8 max_num_coef = 64;
	u8 scan_tbl_index = 0;
	u16 wxh = cu_width * cu_height;

	static u8 scan[256];
	static const u8 scan_t[5][256] = {
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 49, 34, 19, 4, 5, 20, 35, 50, 51, 36, 21, 6, 7, 22, 37, 52, 53, 38, 23, 8, 9, 24, 39, 54, 55, 40, 25, 10, 11, 26, 41, 56, 57, 42, 27, 12, 13, 28, 43, 58, 59, 44, 29, 14, 15, 30, 45, 60, 61, 46, 31, 47, 62, 63 },
		{ 0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 11, 14, 17, 20, 24, 21, 18, 15, 19, 22, 25, 28, 32, 29, 26, 23, 27, 30, 33, 36, 40, 37, 34, 31, 35, 38, 41, 44, 48, 45, 42, 39, 43, 46, 49, 52, 56, 53, 50, 47, 51, 54, 57, 60, 61, 58, 55, 59, 62, 63 },
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73, 88, 103, 118, 119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120, 121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 123, 108, 93, 78, 63, 79, 94, 109, 124, 125, 110, 95, 111, 126, 127 },
		{ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 64, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 65, 72, 80, 73, 66, 59, 52, 45, 38, 31, 39, 46, 53, 60, 67, 74, 81, 88, 96, 89, 82, 75, 68, 61, 54, 47, 55, 62, 69, 76, 83, 90, 97, 104, 112, 105, 98, 91, 84, 77, 70, 63, 71, 78, 85, 92, 99, 106, 113, 120, 121, 114, 107, 100, 93, 86, 79, 87, 94, 101, 108, 115, 122, 123, 116, 109, 102, 95, 103, 110, 117, 124, 125, 118, 111, 119, 126, 127 },
		{ 0, 1, 16, 32, 17, 2, 3, 18, 33, 48, 64, 49, 34, 19, 4, 5, 20, 35, 50, 65, 80, 96, 81, 66, 51, 36, 21, 6, 7, 22, 37, 52, 67, 82, 97, 112, 128, 113, 98, 83, 68, 53, 38, 23, 8, 9, 24, 39, 54, 69, 84, 99, 114, 129, 144, 160, 145, 130, 115, 100, 85, 70, 55, 40, 25, 10, 11, 26, 41, 56, 71, 86, 101, 116, 131, 146, 161, 176, 192, 177, 162, 147, 132, 117, 102, 87, 72, 57, 42, 27, 12, 13, 28, 43, 58, 73, 88, 103, 118, 133, 148, 163, 178, 193, 208, 224, 209, 194, 179, 164, 149, 134, 119, 104, 89, 74, 59, 44, 29, 14, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 241, 226, 211, 196, 181, 166, 151, 136, 121, 106, 91, 76, 61, 46, 31, 47, 62, 77, 92, 107, 122, 137, 152, 167, 182, 197, 212, 227, 242, 243, 228, 213, 198, 183, 168, 153, 138, 123, 108, 93, 78, 63, 79, 94, 109, 124, 139, 154, 169, 184, 199, 214, 229, 244, 245, 230, 215, 200, 185, 170, 155, 140, 125, 110, 95, 111, 126, 141, 156, 171, 186, 201, 216, 231, 246, 247, 232, 217, 202, 187, 172, 157, 142, 127, 143, 158, 173, 188, 203, 218, 233, 248, 249, 234, 219, 204, 189, 174, 159, 175, 190, 205, 220, 235, 250, 251, 236, 221, 206, 191, 207, 222, 237, 252, 253, 238, 223, 239, 254, 255 },
	};
	if (/*cu_width == 16 && */cu_height == 8)
	{
		max_num_coef = 64;
		scan_tbl_index = 2;
	}
	else if (cu_width == 8/* && cu_height == 16*/)
	{
		max_num_coef = 64;
		scan_tbl_index = 3;
	}
	else if (/*cu_width == 16 && */cu_height == 4)
	{
		max_num_coef = 32;
		scan_tbl_index = 0;
	}
	else if (cu_width == 4/* && cu_height == 16*/)
	{
		max_num_coef = 32;
		scan_tbl_index = 1;
	}
	else // (cu_width == 16 && cu_height == 16)
	{
		max_num_coef = 64;
		scan_tbl_index = 4;
	}

	for (U9 i = 0; i < 256; i++)
	{
#pragma HLS UNROLL
		scan[i] = scan_t[scan_tbl_index][i];
	}

	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	const int q_bits = QUANT_SHIFT + tr_shift;
	int num_nz_coef = 0;
	int scan_pos;
	s32 ctx_qt_cbf;
	int best_last_idx_p1 = 0;
	static s16 tmp_coef[SIZE_16] = { 0 };
	static U36 tmp_level_double[SIZE_16] = { 0 };
	static s16 tmp_dst_coef[SIZE_16] = { 0 };
	const s64 lambda = (d_lambda * (1 << 15) + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
	//const s64 lambda = (s64)(d_lambda * (double)(1 << SCALE_BITS) + 0.5);
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };

	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	s64 d64_best_cost = 0;
	s64 d64_base_cost[16 * 16] = { 0 };
	s64 d64_coded_cost = 0;
	s64 d64_uncoded_cost = 0;

#pragma HLS ARRAY_PARTITION variable=tmp_coef complete dim=0
#pragma HLS ARRAY_PARTITION variable=tmp_level_double complete dim=0
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=0
#pragma HLS ARRAY_PARTITION variable=d64_base_cost complete dim=0

	/* ===== quantization ===== */
	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
#pragma HLS UNROLL
		u32 blk_pos = scan[scan_pos];
		u8 x = blk_pos % cu_width;
		u8 y = blk_pos >> cu_width_log2;
		U36 level_double = src_coef[y][x];
		U24 max_abs_level;
		U1 lower_int;
		U36 temp_level;
		temp_level = ((s64)COM_ABS(src_coef[y][x]) * (s64)q_value);
		level_double = (int)COM_MIN(((s64)temp_level), (s64)COM_INT32_MAX - ((s64)1 << (q_bits - 1)));
		tmp_level_double[blk_pos] = level_double;
		max_abs_level = (u32)(level_double >> q_bits);
		lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
		if (!lower_int)
		{
			max_abs_level++;
		}
		tmp_coef[blk_pos] = src_coef[y][x] > 0 ? (s16)max_abs_level : -(s16)(max_abs_level);
	}

	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		for (scan_pos = 0; scan_pos < 64; scan_pos++)
		{
#pragma HLS UNROLL
			d64_base_cost[scan_pos] = 0;
		}
	}
	else
	{
		ctx_qt_cbf = ch_type;
		d64_best_cost = GET_I_COST(rdoq_array->rdoq_est_cbf[ctx_qt_cbf][0], lambda);
		//d64_best_cost = d64_best_cost >> 24;
		for (scan_pos = 0; scan_pos < 64; scan_pos++)
		{
#pragma HLS UNROLL
			d64_base_cost[scan_pos] = GET_I_COST(rdoq_array->rdoq_est_cbf[ctx_qt_cbf][1], lambda);
			//d64_base_cost[scan_pos] = d64_base_cost[scan_pos] >> 24;
		}
	}

	static U24 mat_prev_level[SIZE_16] = { 0 };
	static U1 mat_run[SIZE_16] = { 0 };
	mat_prev_level[0] = 6;
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=0

	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
#pragma HLS UNROLL
		u32 blk_pos = scan[scan_pos];

		if (COM_ABS(tmp_coef[blk_pos]))
		{
			mat_prev_level[scan_pos] = COM_ABS(tmp_coef[blk_pos]);
			mat_run[scan_pos] = 0;
		}
		else
		{
			mat_prev_level[scan_pos] = 1;
			mat_run[scan_pos] = 1;
		}
	}

	static s64 mat_uncoded_cost[SIZE_16] = { 0 };
	static s64 mat_coded_cost[SIZE_16] = { 0 };
	static U24 lev_opt[SIZE_16] = { 0 };
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=lev_opt complete dim=0

	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
#pragma HLS UNROLL
		u32 blk_pos = scan[scan_pos];
		U24 level;
		U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5)) << 1) + (ch_type == Y_C ? 0 : 12);
		int iflast = 0;
		level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[blk_pos], COM_ABS(tmp_coef[blk_pos]),
			mat_run[scan_pos], (u16)ctx_run, (u16)ctx_run, q_bits, err_scale, lambda, iflast, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level);
		tmp_dst_coef[blk_pos] = (s16)(tmp_coef[blk_pos] < 0 ? -(s16)(level) : (s16)level);

		mat_uncoded_cost[scan_pos] = d64_uncoded_cost;
		mat_coded_cost[scan_pos] = d64_coded_cost;
		lev_opt[scan_pos] = level;
	}

	static s64 d64_cost_last_zero[SIZE_16] = { 0 };
	d64_cost_last_zero[0] = 0;
	int ace_log2 = 0;
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_zero complete dim=0

	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
#pragma HLS UNROLL
		u32 blk_pos = scan[scan_pos];
		if ((scan_pos) < 2)
		{
			ace_log2 = 0;
		}
		else if ((scan_pos) < 4)
		{
			ace_log2 = 1;
		}
		else if ((scan_pos) < 8)
		{
			ace_log2 = 2;
		}
		else if ((scan_pos) < 16)
		{
			ace_log2 = 3;
		}
		else if ((scan_pos) < 32)
		{
			ace_log2 = 4;
		}
		else if ((scan_pos) < 64)
		{
			ace_log2 = 5;
		}
		else if ((scan_pos) < 128)
		{
			ace_log2 = 6;
		}
		else if ((scan_pos) < 256)
		{
			ace_log2 = 7;
		}
		else if ((scan_pos) < 512)
		{
			ace_log2 = 8;
		}
		else if ((scan_pos) < 1024)
		{
			ace_log2 = 9;
		}
		else if ((scan_pos) < 2048)
		{
			ace_log2 = 10;
		}
		else if ((scan_pos) < 4096)
		{
			ace_log2 = 11;
		}
		else
		{
			ace_log2 = 11;
		}
		d64_cost_last_zero[scan_pos] = GET_I_COST(rdoq_array->rdoq_est_last[ctx_last][COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5)][ace_log2][0], lambda);
		//d64_cost_last_zero[scan_pos] = d64_cost_last_zero[scan_pos] >> 24;
	}
	for (scan_pos = 0; scan_pos < max_num_coef; scan_pos++)
	{
#pragma HLS loop_tripcount max=64
#pragma HLS pipeline
		for (int i = 0; i <= 64; i++)
		{
#pragma HLS loop_tripcount max=64
#pragma HLS UNROLL
			if (i <= scan_pos)
				d64_base_cost[scan_pos] += mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i] * !!(lev_opt[i]);
		}
	}
	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
#pragma HLS loop_tripcount max=64
#pragma HLS UNROLL
		if (scan_pos >= max_num_coef)
			break;

		u32 blk_pos = scan[scan_pos];
		if ((scan_pos + 1) < 2)
		{
			ace_log2 = 0;
		}
		else if ((scan_pos + 1) < 4)
		{
			ace_log2 = 1;
		}
		else if ((scan_pos + 1) < 8)
		{
			ace_log2 = 2;
		}
		else if ((scan_pos + 1) < 16)
		{
			ace_log2 = 3;
		}
		else if ((scan_pos + 1) < 32)
		{
			ace_log2 = 4;
		}
		else if ((scan_pos + 1) < 64)
		{
			ace_log2 = 5;
		}
		else if ((scan_pos + 1) < 128)
		{
			ace_log2 = 6;
		}
		else if ((scan_pos + 1) < 256)
		{
			ace_log2 = 7;
		}
		else if ((scan_pos + 1) < 512)
		{
			ace_log2 = 8;
		}
		else if ((scan_pos + 1) < 1024)
		{
			ace_log2 = 9;
		}
		else if ((scan_pos + 1) < 2048)
		{
			ace_log2 = 10;
		}
		else if ((scan_pos + 1) < 4096)
		{
			ace_log2 = 11;
		}
		else
		{
			ace_log2 = 11;
		}
		U24 prev_level = mat_prev_level[scan_pos];
		s64 d64_cost_last_one = GET_I_COST(rdoq_array->rdoq_est_last[ctx_last][COM_MIN((U24)(prev_level - 1), (U24)5)][ace_log2][1], lambda);
		//d64_cost_last_one = d64_cost_last_one >> 24;
		if (COM_ABS(tmp_dst_coef[blk_pos]))
		{
			s64 d64_cur_is_last_cost = d64_base_cost[scan_pos] + d64_cost_last_one;

			if (d64_cur_is_last_cost < d64_best_cost)
			{
				d64_best_cost = d64_cur_is_last_cost;
				best_last_idx_p1 = scan_pos + 1;
			}
		}
	}

	model_update_16(wxh, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level, mat_run, mat_prev_level, ch_type, max_num_coef);

	static int mask[SIZE_16] = { 0 };
#pragma HLS ARRAY_PARTITION variable=mask complete dim=0

	for (scan_pos = 0; scan_pos < 256; scan_pos++)
	{
#pragma HLS UNROLL
		if (scan_pos < wxh)
		{
			u32 blk_pos = scan[scan_pos];
			u8 x = blk_pos % cu_width;
			u8 y = blk_pos >> cu_width_log2;

			dst_tmp[y][x] = scan_pos < best_last_idx_p1 ? tmp_dst_coef[blk_pos] : 0;
			num_nz_coef += !!(dst_tmp[y][x]);
		}
	}
	return num_nz_coef;
}

static void memcpy_rewrintra_2d_to_1d_16(s16* des, s16 src[16][16], U3 cu_width_log2, U3 cu_height_log2)
{
	int w = 1 << cu_width_log2;
	int h = 1 << cu_height_log2;

#pragma HLS INLINE off
	int i, j;
	for (i = 0; i < h; i++) {
#pragma HLS LOOP_TRIPCOUNT max=16
		for (j = 0; j < w; j++) {
#pragma HLS LOOP_TRIPCOUNT max=16
			des[(i << cu_width_log2) + j] = src[i][j];
		}

	}
}

static int quant_16(U7 w, U7 h, U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth, s16 coef[16][16], s16 coef_out[16][16], s16 coef_out1[16][16], s16 coef_out2[16][16], s16 coef_out3[16][16], U2 slice_type, U14 scale)
{
	int offset;
	int i, j;
	int shift;
	int sign;
	s16 lev;
	int tr_shift;
	int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	int num_nz_coef = 0;
	int scale_x_ns_scale = scale * ns_scale;

	tr_shift = get_transform_shift(bit_depth, log2_size - ns_shift);
	shift = QUANT_SHIFT + tr_shift;
	offset = (s64)((slice_type == SLICE_I) ? 171 : 85) << (s64)(shift - 9);

	for (i = 0; i < h; i++)
	{
#pragma HLS LOOP_TRIPCOUNT max=64
#pragma HLS PIPELINE
		for (j = 0; j < w; j++)
		{
#pragma HLS LOOP_TRIPCOUNT max=64
			sign = COM_SIGN_GET(coef[i][j]);
			lev = ((int)(COM_ABS(coef[i][j]) * scale_x_ns_scale + offset) >> shift);
			coef_out[i][j] = COM_SIGN_SET(lev, sign);
			coef_out1[i][j] = COM_SIGN_SET(lev, sign);
			coef_out2[i][j] = COM_SIGN_SET(lev, sign);
			coef_out3[i][j] = COM_SIGN_SET(lev, sign);
			//bug fix for rate estimation
			//if ((i + j) >= w)
			//{
			//	coef[i][j] = 0;
			//}

			num_nz_coef += !!(coef_out[i][j]);
		}
	}
	return num_nz_coef;
}

static void quant_nnz_8_16_luma(int num_nz_rate[MAX_NUM_TB][N_C], int* num_nz_itv, U8 cu_width, U8 cu_height, RDOQ_ARRAY* rdoq_array, U4 md_fw_ptr_bit_depth_internal,
	U6 qp, s64 lambda, U1 is_intra_quant, U1* is_intra_rate, s16 coef_tmp_v[16][16], s16 coef_tmp_itv[16][16], s16 dst_for_itv[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type,
	U2 slice_type, s16 coef_pb_part[16][16], s16 coef_update[16][16], u8 iQuant, u8* iUpdate)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_run core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_cbf core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_level core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_last core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_pb_part core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_update core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=num_nz_itv
#pragma HLS INTERFACE axis port=is_intra_quant
#pragma HLS INTERFACE axis port=is_intra_rate
#pragma HLS INTERFACE axis port=iQuant
#pragma HLS INTERFACE axis port=iUpdate
#endif
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=2
//#pragma HLS ARRAY_PARTITION variable=dst_for_itv complete dim=2
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_v complete dim=2
//#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete  dim=2
//#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2

	// STREAM BUFFER
	U1 is_intra_read = is_intra_quant;
	u8 rdo_idx = iQuant;
	int num_nz_write;

	int i;
#pragma HLS INLINE off
	if (ch_type == 0)
	{
		cu_nz_cln(num_nz_rate);
	}
	else
	{
		if (rdo_idx == 0)
		{
			num_nz_rate[0][1] = 0;
			num_nz_rate[0][2] = 0;
		}
	}
	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	U14 scale = quant_scale[qp];

	/*for (i = 0; i < SIZE_16; i++) {
		coef_pb_part[i] = 0;
	}*/

#if RDOQ_OPEN
	num_nz_write = //rdoq_top_8_16_luma(cu_width, cu_height, qp, lambda, is_intra_read, coef_tmp_v, coef_tmp_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr_bit_depth_internal, rdoq_array);
					rdoq_top_8_16_luma(cu_width, cu_height, qp, lambda, is_intra_read, coef_tmp_v, coef_tmp_itv, coef_pb_part, coef_update, dst_for_itv, cu_width_log2, cu_height_log2, ch_type,
						md_fw_ptr_bit_depth_internal, rdoq_array);
#else
	num_nz_write = quant_16(cu_width, cu_height, cu_width_log2, cu_height_log2, md_fw_ptr_bit_depth_internal, coef_tmp_v, coef_tmp_itv, coef_pb_part, coef_update, dst_for_itv, slice_type, scale);
#endif
	//memcpy_rewrintra_2d_to_1d_16(coef_pb_part, coef_tmp_itv, cu_width_log2, cu_height_log2);
	//memcpy_rewrintra_2d_to_1d_16(coef_update, coef_tmp_itv, cu_width_log2, cu_height_log2);
	/*for (i = 0; i < cu_height; i++) {
		for (int j = 0; j < cu_width; j++)
		{
			coef_pb_part[i][j] = coef_tmp_itv[i][j];
			coef_update[i][j] = coef_tmp_itv[i][j];
			dst_for_itv[i][j] = coef_tmp_itv[i][j];
		}

	}*/
	// WRITE STREAMS
	*is_intra_rate = is_intra_read;
	*num_nz_itv = num_nz_write;
	*iUpdate = rdo_idx;

	num_nz_rate[0][ch_type] = num_nz_write;
}

static void quant_nnz_16_8_luma(int num_nz_rate[MAX_NUM_TB][N_C], int* num_nz_itv, U8 cu_width, U8 cu_height, RDOQ_ARRAY* rdoq_array, U4 md_fw_ptr_bit_depth_internal,
	U6 qp, s64 lambda, U1 is_intra_quant, U1* is_intra_rate, s16 coef_tmp_v[16][16], s16 dst_for_itv[16][16], s16 coef_tmp_itv[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type,
	U2 slice_type, s16 coef_pb_part[16][16], s16 coef_update[16][16], u8 iQuant, u8* iUpdate)
{
#pragma HLS INLINE OFF
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_run core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_cbf core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_level core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_last core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_pb_part core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_update core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=num_nz_itv
#pragma HLS INTERFACE axis port=is_intra_quant
#pragma HLS INTERFACE axis port=is_intra_rate
#pragma HLS INTERFACE axis port=iQuant
#pragma HLS INTERFACE axis port=iUpdate
#endif
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=0
//#pragma HLS ARRAY_PARTITION variable=num_nz_update complete dim=0

	// STREAM BUFFER
	U1 is_intra_read = is_intra_quant;
	u8 rdo_idx = iQuant;
	int num_nz_write;

	int i;
#pragma HLS INLINE off
	if (ch_type == 0)
	{
		cu_nz_cln(num_nz_rate);
	}
	else
	{
		if (rdo_idx == 0)
		{
			num_nz_rate[0][1] = 0;
			num_nz_rate[0][2] = 0;
		}
	}
	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	U14 scale = quant_scale[qp];

	/*for (i = 0; i < SIZE_16; i++) {
		coef_pb_part[i] = 0;
	}*/

#if RDOQ_OPEN
	num_nz_write = //rdoq_top_16_8_luma(cu_width, cu_height, qp, lambda, is_intra_read, coef_tmp_v, coef_tmp_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr_bit_depth_internal, rdoq_array);
		rdoq_top_16_8_luma(cu_width, cu_height, qp, lambda, is_intra_read, coef_tmp_v, coef_tmp_itv, coef_pb_part, coef_update, dst_for_itv, cu_width_log2, cu_height_log2, ch_type,
		md_fw_ptr_bit_depth_internal, rdoq_array);
#else
	num_nz_write = quant_16(cu_width, cu_height, cu_width_log2, cu_height_log2, md_fw_ptr_bit_depth_internal, coef_tmp_v, coef_tmp_itv, coef_pb_part, coef_update, dst_for_itv, slice_type, scale);
#endif
	//memcpy_rewrintra_2d_to_1d_16(coef_pb_part, coef_tmp_itv, cu_width_log2, cu_height_log2);
	//memcpy_rewrintra_2d_to_1d_16(coef_update, coef_tmp_itv, cu_width_log2, cu_height_log2);
	//for (i = 0; i < cu_height; i++) {
	//	for (int j = 0; j < cu_width; j++)
	//	{
	//		coef_pb_part[i][j] = coef_tmp_itv[i][j];
	//		coef_update[i][j] = coef_tmp_itv[i][j];
	//		dst_for_itv[i][j] = coef_tmp_itv[i][j];
	//	}

	//}
	// WRITE STREAMS
	*is_intra_rate = is_intra_read;
	*num_nz_itv = num_nz_write;
	*iUpdate = rdo_idx;

	num_nz_rate[0][ch_type] = num_nz_write;
}

static void quant_nnz_16_16_luma(int num_nz_rate[MAX_NUM_TB][N_C], int* num_nz_itv, U8 cu_width, U8 cu_height, RDOQ_ARRAY* rdoq_array, U4 md_fw_ptr_bit_depth_internal,
	U6 qp, s64 lambda, U1 is_intra_quant, U1* is_intra_rate, s16 coef_tmp_v[16][16], s16 coef_tmp_itv[16][16], s16 dst_for_itv[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type,
	U2 slice_type, s16 coef_pb_part[16][16], s16 coef_update[16][16], u8 iQuant, u8* iUpdate)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=num_nz_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_run core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_cbf core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_level core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdoq_est_last core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_pb_part core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_update core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=num_nz_itv
#pragma HLS INTERFACE axis port=is_intra_quant
#pragma HLS INTERFACE axis port=is_intra_rate
#pragma HLS INTERFACE axis port=iQuant
#pragma HLS INTERFACE axis port=iUpdate
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst_for_itv complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete  dim=2
#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=num_nz_update complete dim=0

	// STREAM BUFFER
	U1 is_intra_read = is_intra_quant;
	u8 rdo_idx = iQuant;
	int num_nz_write;

	int i;
#pragma HLS INLINE off
	if (ch_type == 0)
	{
		cu_nz_cln(num_nz_rate);
	
	}
	else
	{
		if (rdo_idx == 0)
		{
			num_nz_rate[0][1] = 0;
			num_nz_rate[0][2] = 0;
		}
	}
	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	U14 scale = quant_scale[qp];

	/*for (i = 0; i < SIZE_16; i++) {
		coef_pb_part[i] = 0;
	}*/

#if RDOQ_OPEN
	num_nz_write = rdoq_top_16_16_luma(cu_width, cu_height, qp, lambda, is_intra_read, coef_tmp_v, coef_tmp_itv, coef_pb_part, coef_update, dst_for_itv, cu_width_log2, cu_height_log2, ch_type,
		md_fw_ptr_bit_depth_internal, rdoq_array);
#else
	num_nz_write = quant_16(cu_width, cu_height, cu_width_log2, cu_height_log2, md_fw_ptr_bit_depth_internal, coef_tmp_v, coef_tmp_itv, coef_pb_part, coef_update, dst_for_itv, slice_type, scale);
#endif
	//memcpy_rewrintra_2d_to_1d_16(coef_pb_part, coef_tmp_itv, cu_width_log2, cu_height_log2);
	//memcpy_rewrintra_2d_to_1d_16(coef_update, coef_tmp_itv, cu_width_log2, cu_height_log2);
//	for (i = 0; i < cu_height; i++) {
//#pragma HLS PIPELINE
//		for (int j = 0; j < cu_width; j++)
//		{
//			coef_pb_part[i][j] = coef_tmp_itv[i][j];
//			coef_update[i][j] = coef_tmp_itv[i][j];
//			dst_for_itv[i][j] = coef_tmp_itv[i][j];
//		}
//
//	}
	// WRITE STREAMS
	*is_intra_rate = is_intra_read;
	*num_nz_itv = num_nz_write;
	*iUpdate = rdo_idx;

	num_nz_rate[0][ch_type] = num_nz_write;
}


//static void quant_nnz_16(int num_nz_rate[MAX_NUM_TB][N_C], int num_nz_update[MAX_NUM_TB][N_C], int* num_nz_itv, U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, RDOQ_ARRAY* rdoq_array, U4 md_fw_ptr_bit_depth_internal,
//	U6 qp, s64 lambda, U1 is_intra_quant, U1* is_intra_rate, s16 coef_tmp_v[16][16], s16 coef_tmp_itv[16][16], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type,
//	U2 slice_type, s16 coef_pb_part[SIZE_16], s16 coef_update[SIZE_16], u8 iQuant, u8* iUpdate)
//{
//#if MD_KERNEL_16_INTERFACE
//#pragma HLS RESOURCE variable=num_nz_rate core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=num_nz_update core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=rdoq_est_run core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=rdoq_est_cbf core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=rdoq_est_level core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=rdoq_est_last core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=coef_pb_part core=RAM_1P_BRAM
//#pragma HLS RESOURCE variable=coef_update core=RAM_1P_BRAM
//#pragma HLS INTERFACE axis port=num_nz_itv
//#pragma HLS INTERFACE axis port=is_intra_quant
//#pragma HLS INTERFACE axis port=is_intra_rate
//#pragma HLS INTERFACE axis port=iQuant
//#pragma HLS INTERFACE axis port=iUpdate
//#endif
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=0
//#pragma HLS ARRAY_PARTITION variable=num_nz_update complete dim=0
//
//	// STREAM BUFFER
//	U1 is_intra_read = is_intra_quant;
//	u8 rdo_idx = iQuant;
//	int num_nz_write;
//
//	int i;
//#pragma HLS INLINE off
//	if (ch_type == 0)
//	{
//		cu_nz_cln(num_nz_rate);
//		cu_nz_cln(num_nz_update);
//	}
//	else
//	{
//		if (rdo_idx == 0)
//		{
//			num_nz_rate[0][1] = 0;
//			num_nz_rate[0][2] = 0;
//			num_nz_update[0][1] = 0;
//			num_nz_update[0][2] = 0;
//		}
//	}
//	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
//
//	U14 scale = quant_scale[qp];
//
//	for (i = 0; i < SIZE_16; i++) {
//		coef_pb_part[i] = 0;
//	}
//
//#if RDOQ_OPEN
//	num_nz_write = rdoq_top_16(cu_width, cu_height, model_cnt, qp, lambda, is_intra_read, coef_tmp_v, coef_tmp_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr_bit_depth_internal, rdoq_array);
//#else
//	num_nz_write = quant_16(cu_width, cu_height, cu_width_log2, cu_height_log2, md_fw_ptr_bit_depth_internal, coef_tmp_v, coef_tmp_itv, slice_type, scale);
//#endif
//	memcpy_rewrintra_2d_to_1d_16(coef_pb_part, coef_tmp_itv, cu_width_log2, cu_height_log2);
//	memcpy_rewrintra_2d_to_1d_16(coef_update, coef_tmp_itv, cu_width_log2, cu_height_log2);
//
//	// WRITE STREAMS
//	*is_intra_rate = is_intra_read;
//	*num_nz_itv = num_nz_write;
//	*iUpdate = rdo_idx;
//
//	num_nz_rate[0][ch_type] = num_nz_write;
//	num_nz_update[0][ch_type] = num_nz_write;
//}
static void init_scan(u16* scan, int size_x, int size_y, int scan_type)
{

#pragma HLS INLINE off
	int x;
	int y;
	int l;
	int pos;
	int num_line;
	pos = 0;
	num_line = size_x + size_y - 1;
	if (scan_type == 0) {
		/* starting point */
		scan[pos] = ((u16)0);
		pos++;
		/* loop */
		for (l = 1; l < num_line; l++) {

#pragma HLS LOOP_TRIPCOUNT max=127
			/* decreasing loop */
			if (l % 2) {
				x = (l < size_x - 1 ? l : size_x - 1);
				y = (0 > l - (size_x - 1) ? 0 : l - (size_x - 1));
				while (x >= 0 && y < size_y) {

#pragma HLS LOOP_TRIPCOUNT max=64
					scan[pos] = ((u16)(y * size_x + x));
					pos++;
					x--;
					y++;
				}
			}
			else
				/* increasing loop */
			{
				y = (l < size_y - 1 ? l : size_y - 1);
				x = (0 > l - (size_y - 1) ? 0 : l - (size_y - 1));
				while (y >= 0 && x < size_x) {

#pragma HLS LOOP_TRIPCOUNT max=64
					scan[pos] = ((u16)(y * size_x + x));
					pos++;
					x++;
					y--;
				}
			}
		}
	}
}
static int enc_eco_run_est(u32 sym)
{

#pragma HLS INLINE
	int exp_golomb_order = 0;
	int enc_est = 0;
	if (sym < (16)) {
		enc_est += sbac_write_truncate_unary_sym_est(sym, (u32)17);
	}
	else {
		sym -= (16);
		enc_est += sbac_write_truncate_unary_sym_est((u32)16, (u32)17);
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 1;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 3;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 5;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 7;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 9;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 11;
		}
		enc_est += 2 * exp_golomb_order;
		/*sbac_write_unary_sym_ep_est(exp_golomb_order);
		sbac_encode_bins_ep_msb_est(exp_golomb_order);*/
	}
	return enc_est;
}

static int enc_eco_level_est(u32 sym)
{

#pragma HLS INLINE
	int exp_golomb_order = 0;
	int enc_est = 0;
	if (sym < ((unsigned int)8)) {
		enc_est += sbac_write_truncate_unary_sym_est(sym, (u32)9);
	}
	else {
		sym -= ((unsigned int)8);
		enc_est += sbac_write_truncate_unary_sym_est((u32)8, (u32)9);
		//		while ((int)sym >= (1 << exp_golomb_order))
		//		{
		//#pragma HLS LOOP_TRIPCOUNT max=11
		//			sym = sym - (1 << exp_golomb_order);
		//			exp_golomb_order++;
		//		}
		if (sym == ((unsigned int)0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= ((unsigned int)1) && sym < ((unsigned int)3)) {
			exp_golomb_order = 1;
		}
		else if (sym >= ((unsigned int)3) && sym < ((unsigned int)7)) {
			exp_golomb_order = 2;
		}
		else if (sym >= ((unsigned int)7) && sym < ((unsigned int)15)) {
			exp_golomb_order = 3;
		}
		else if (sym >= ((unsigned int)15) && sym < ((unsigned int)31)) {
			exp_golomb_order = 4;
		}
		else if (sym >= ((unsigned int)31) && sym < ((unsigned int)63)) {
			exp_golomb_order = 5;
		}
		else if (sym >= ((unsigned int)63) && sym < ((unsigned int)127)) {
			exp_golomb_order = 6;
		}
		else if (sym >= ((unsigned int)127) && sym < ((unsigned int)255)) {
			exp_golomb_order = 7;
		}
		else if (sym >= ((unsigned int)255) && sym < ((unsigned int)511)) {
			exp_golomb_order = 8;
		}
		else if (sym >= ((unsigned int)512) && sym < ((unsigned int)1023)) {
			exp_golomb_order = 9;
		}
		else if (sym >= ((unsigned int)1023) && sym < ((unsigned int)2047)) {
			exp_golomb_order = 10;
		}
		else if (sym >= ((unsigned int)2047) && sym < ((unsigned int)4095)) {
			exp_golomb_order = 11;
		}
		enc_est += 2 * exp_golomb_order;
		//sbac_write_unary_sym_ep_est(exp_golomb_order);
		//sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}
static int enc_eco_run_length_cc_est_2(s16* coef, int log2_w, int log2_h, int num_sig)
{
	int enc_est = 0;
	u32 num_coeff;
	u32 scan_pos;
	u32 level;
	u32 prev_level;
	u32 run;
	u32 last_flag;
	s16 coef_cur;
	num_coeff = ((u32)(1 << (log2_w + log2_h)));
	static u16 scanp[1 << 12];
	init_scan(scanp, 1 << log2_w, 1 << log2_h, 0);
	run = 0;
	prev_level = ((u32)6);
	int run_1 = 0;
	s16 coef_cur_1;
	static s16 run_num[1 << 12];
	static int num_sig_num[1 << 12];
	u32 scan_pos_1;
	for (scan_pos_1 = 0; scan_pos_1 < num_coeff; scan_pos_1++) {

#pragma HLS loop_tripcount max=4096
		coef_cur_1 = coef[scanp[scan_pos_1]];
		if (coef_cur_1) {
			run_num[scan_pos_1] = ((s16)run_1);
			if (scan_pos_1 == num_coeff - ((unsigned int)1)) {
				break;
			}
			run_1 = 0;
			num_sig_num[scan_pos_1] = --num_sig;
			if (!num_sig) {
				break;
			}
		}
		else {
			run_1++;
			run_num[scan_pos_1] = 0;
		}
	}
	for (scan_pos = 0; scan_pos < num_coeff; scan_pos++) {

#pragma HLS loop_tripcount max=4096
		coef_cur = coef[scanp[scan_pos]];
		if (coef_cur) {
			level = ((u32)((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15)));
			enc_est += enc_eco_run_est((u32)run_num[scan_pos]);
			enc_est += enc_eco_level_est(level - ((unsigned int)1));
			enc_est++;
			if (scan_pos == num_coeff - ((unsigned int)1)) {
				break;
			}
			last_flag = ((u32)((num_sig_num[scan_pos] == 0 ? 1 : 0)));
			enc_est++;
			if (last_flag) {
				break;
			}
		}


	}
	return enc_est;
}


static void cu_plane_nz_cln(int dst[4][3], U3 plane)
{

#pragma HLS INLINE off
	int i;
	for (i = 0; i < 4; i++) {

#pragma HLS LOOP_TRIPCOUNT max=4
		dst[i][plane] = 0;
	}
}

static void dct_row_16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	static int E[16][8], O[16][8];
	static int EE[16][4], EO[16][4];
	static int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
		if (j >= cu_height)
			break;
		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			//#pragma HLS UNROLL
			E[j][k] = src[j][k] + src[j][15 - k];
			O[j][k] = src[j][k] - src[j][15 - k];
		}
		/* EE and EO */
		if (cu_width == 16) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_width == 8) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = src[j][k] + src[j][7 - k];
				EO[j][k] = src[j][k] - src[j][7 - k];
			}
		}

		/* EEE and EEO */
		if (cu_width == 16 || cu_width == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_width == 4) {
			EEE[j][0] = src[j][0] + src[j][3];
			EEO[j][0] = src[j][0] - src[j][3];
			EEE[j][1] = src[j][1] + src[j][2];
			EEO[j][1] = src[j][1] - src[j][2];
		}

		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_width == 4) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[2][(j + 2) & size_b] = tmp[1];
			dst[1][(j + 1) & size_b] = tmp[2];
			dst[3][(j + 3) & size_b] = tmp[3];
		}
		else if (cu_width == 8) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[4][(j + 4) & size_b] = tmp[1];
			dst[2][(j + 2) & size_b] = tmp[2];
			dst[6][(j + 6) & size_b] = tmp[3];
			dst[1][(j + 1) & size_b] = tmp[4];
			dst[3][(j + 3) & size_b] = tmp[5];
			dst[5][(j + 5) & size_b] = tmp[6];
			dst[7][(j + 7) & size_b] = tmp[7];
		}
		else if (cu_width == 16) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[8][(j + 8) & size_b] = tmp[1];
			dst[4][(j + 4) & size_b] = tmp[2];
			dst[12][(j + 12) & size_b] = tmp[3];
			dst[2][(j + 2) & size_b] = tmp[4];
			dst[6][(j + 6) & size_b] = tmp[5];
			dst[10][(j + 10) & size_b] = tmp[6];
			dst[14][(j + 14) & size_b] = tmp[7];
			dst[1][(j + 1) & size_b] = tmp[8];
			dst[3][(j + 3) & size_b] = tmp[9];
			dst[5][(j + 5) & size_b] = tmp[10];
			dst[7][(j + 7) & size_b] = tmp[11];
			dst[9][(j + 9) & size_b] = tmp[12];
			dst[11][(j + 11) & size_b] = tmp[13];
			dst[13][(j + 13) & size_b] = tmp[14];
			dst[15][(j + 15) & size_b] = tmp[15];
		}
	}
}


static void dct_row_8_16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	static int E[16][8], O[16][8];
	static int EE[16][4], EO[16][4];
	static int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
		if (j >= cu_height)
			break;
		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			//#pragma HLS UNROLL
			E[j][k] = src[j][k] + src[j][15 - k];
			O[j][k] = src[j][k] - src[j][15 - k];
		}
		/* EE and EO */
		if (cu_width == 16) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_width == 8) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = src[j][k] + src[j][7 - k];
				EO[j][k] = src[j][k] - src[j][7 - k];
			}
		}

		/* EEE and EEO */
		if (cu_width == 16 || cu_width == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_width == 4) {
			EEE[j][0] = src[j][0] + src[j][3];
			EEO[j][0] = src[j][0] - src[j][3];
			EEE[j][1] = src[j][1] + src[j][2];
			EEO[j][1] = src[j][1] - src[j][2];
		}

		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_width == 4) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[2][(j + 2) & size_b] = tmp[1];
			dst[1][(j + 1) & size_b] = tmp[2];
			dst[3][(j + 3) & size_b] = tmp[3];
		}
		else if (cu_width == 8) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[4][(j + 4) & size_b] = tmp[1];
			dst[2][(j + 2) & size_b] = tmp[2];
			dst[6][(j + 6) & size_b] = tmp[3];
			dst[1][(j + 1) & size_b] = tmp[4];
			dst[3][(j + 3) & size_b] = tmp[5];
			dst[5][(j + 5) & size_b] = tmp[6];
			dst[7][(j + 7) & size_b] = tmp[7];
		}
		else if (cu_width == 16) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[8][(j + 8) & size_b] = tmp[1];
			dst[4][(j + 4) & size_b] = tmp[2];
			dst[12][(j + 12) & size_b] = tmp[3];
			dst[2][(j + 2) & size_b] = tmp[4];
			dst[6][(j + 6) & size_b] = tmp[5];
			dst[10][(j + 10) & size_b] = tmp[6];
			dst[14][(j + 14) & size_b] = tmp[7];
			dst[1][(j + 1) & size_b] = tmp[8];
			dst[3][(j + 3) & size_b] = tmp[9];
			dst[5][(j + 5) & size_b] = tmp[10];
			dst[7][(j + 7) & size_b] = tmp[11];
			dst[9][(j + 9) & size_b] = tmp[12];
			dst[11][(j + 11) & size_b] = tmp[13];
			dst[13][(j + 13) & size_b] = tmp[14];
			dst[15][(j + 15) & size_b] = tmp[15];
		}
	}
}

static void dct_row_16_8(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	static int E[16][8], O[16][8];
	static int EE[16][4], EO[16][4];
	static int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
		if (j >= cu_height)
			break;
		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			//#pragma HLS UNROLL
			E[j][k] = src[j][k] + src[j][15 - k];
			O[j][k] = src[j][k] - src[j][15 - k];
		}
		/* EE and EO */
		if (cu_width == 16) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_width == 8) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = src[j][k] + src[j][7 - k];
				EO[j][k] = src[j][k] - src[j][7 - k];
			}
		}

		/* EEE and EEO */
		if (cu_width == 16 || cu_width == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_width == 4) {
			EEE[j][0] = src[j][0] + src[j][3];
			EEO[j][0] = src[j][0] - src[j][3];
			EEE[j][1] = src[j][1] + src[j][2];
			EEO[j][1] = src[j][1] - src[j][2];
		}

		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_width == 4) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[2][(j + 2) & size_b] = tmp[1];
			dst[1][(j + 1) & size_b] = tmp[2];
			dst[3][(j + 3) & size_b] = tmp[3];
		}
		else if (cu_width == 8) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[4][(j + 4) & size_b] = tmp[1];
			dst[2][(j + 2) & size_b] = tmp[2];
			dst[6][(j + 6) & size_b] = tmp[3];
			dst[1][(j + 1) & size_b] = tmp[4];
			dst[3][(j + 3) & size_b] = tmp[5];
			dst[5][(j + 5) & size_b] = tmp[6];
			dst[7][(j + 7) & size_b] = tmp[7];
		}
		else if (cu_width == 16) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[8][(j + 8) & size_b] = tmp[1];
			dst[4][(j + 4) & size_b] = tmp[2];
			dst[12][(j + 12) & size_b] = tmp[3];
			dst[2][(j + 2) & size_b] = tmp[4];
			dst[6][(j + 6) & size_b] = tmp[5];
			dst[10][(j + 10) & size_b] = tmp[6];
			dst[14][(j + 14) & size_b] = tmp[7];
			dst[1][(j + 1) & size_b] = tmp[8];
			dst[3][(j + 3) & size_b] = tmp[9];
			dst[5][(j + 5) & size_b] = tmp[10];
			dst[7][(j + 7) & size_b] = tmp[11];
			dst[9][(j + 9) & size_b] = tmp[12];
			dst[11][(j + 11) & size_b] = tmp[13];
			dst[13][(j + 13) & size_b] = tmp[14];
			dst[15][(j + 15) & size_b] = tmp[15];
		}
	}
}

static void dct_row_16_16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	static int E[16][8], O[16][8];
	static int EE[16][4], EO[16][4];
	static int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		if (j >= cu_height)
			break;
		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			//#pragma HLS UNROLL
			E[j][k] = src[j][k] + src[j][15 - k];
			O[j][k] = src[j][k] - src[j][15 - k];
		}
		/* EE and EO */
		if (cu_width == 16) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_width == 8) {
			for (k = 0; k < 4; k++)
			{
				//#pragma HLS UNROLL
				EE[j][k] = src[j][k] + src[j][7 - k];
				EO[j][k] = src[j][k] - src[j][7 - k];
			}
		}

		/* EEE and EEO */
		if (cu_width == 16 || cu_width == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_width == 4) {
			EEE[j][0] = src[j][0] + src[j][3];
			EEO[j][0] = src[j][0] - src[j][3];
			EEE[j][1] = src[j][1] + src[j][2];
			EEO[j][1] = src[j][1] - src[j][2];
		}

		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_width == 4) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[2][(j + 2) & size_b] = tmp[1];
			dst[1][(j + 1) & size_b] = tmp[2];
			dst[3][(j + 3) & size_b] = tmp[3];
		}
		else if (cu_width == 8) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[4][(j + 4) & size_b] = tmp[1];
			dst[2][(j + 2) & size_b] = tmp[2];
			dst[6][(j + 6) & size_b] = tmp[3];
			dst[1][(j + 1) & size_b] = tmp[4];
			dst[3][(j + 3) & size_b] = tmp[5];
			dst[5][(j + 5) & size_b] = tmp[6];
			dst[7][(j + 7) & size_b] = tmp[7];
		}
		else if (cu_width == 16) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[8][(j + 8) & size_b] = tmp[1];
			dst[4][(j + 4) & size_b] = tmp[2];
			dst[12][(j + 12) & size_b] = tmp[3];
			dst[2][(j + 2) & size_b] = tmp[4];
			dst[6][(j + 6) & size_b] = tmp[5];
			dst[10][(j + 10) & size_b] = tmp[6];
			dst[14][(j + 14) & size_b] = tmp[7];
			dst[1][(j + 1) & size_b] = tmp[8];
			dst[3][(j + 3) & size_b] = tmp[9];
			dst[5][(j + 5) & size_b] = tmp[10];
			dst[7][(j + 7) & size_b] = tmp[11];
			dst[9][(j + 9) & size_b] = tmp[12];
			dst[11][(j + 11) & size_b] = tmp[13];
			dst[13][(j + 13) & size_b] = tmp[14];
			dst[15][(j + 15) & size_b] = tmp[15];
		}
	}
}

static void dct_col_16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	int E[16][8], O[16][8];
	int EE[16][4], EO[16][4];
	int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_height == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
		if (j >= cu_width)
			break;

		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			E[j][k] = src[j][(k + j) & size_b] + src[j][(15 - k + j) & size_b];
			O[j][k] = src[j][(k + j) & size_b] - src[j][(15 - k + j) & size_b];
		}
		/* EE and EO */
		if (cu_height == 16) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_height == 8) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = src[j][(k + j) & size_b] + src[j][(7 - k + j) & size_b];
				EO[j][k] = src[j][(k + j) & size_b] - src[j][(7 - k + j) & size_b];
			}
		}

		/* EEE and EEO */
		if (cu_height == 16 || cu_height == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_height == 4) {
			EEE[j][0] = src[j][(0 + j) & size_b] + src[j][(3 + j) & size_b];
			EEO[j][0] = src[j][(0 + j) & size_b] - src[j][(3 + j) & size_b];
			EEE[j][1] = src[j][(1 + j) & size_b] + src[j][(2 + j) & size_b];
			EEO[j][1] = src[j][(1 + j) & size_b] - src[j][(2 + j) & size_b];
		}
		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_height == 4) {
			dst[0][j] = tmp[0];
			dst[2][j] = tmp[1];
			dst[1][j] = tmp[2];
			dst[3][j] = tmp[3];
		}
		else if (cu_height == 8) {
			dst[0][j] = tmp[0];
			dst[4][j] = tmp[1];
			dst[2][j] = tmp[2];
			dst[6][j] = tmp[3];
			dst[1][j] = tmp[4];
			dst[3][j] = tmp[5];
			dst[5][j] = tmp[6];
			dst[7][j] = tmp[7];
		}
		else if (cu_height == 16) {
			dst[0][j] = tmp[0];
			dst[8][j] = tmp[1];
			dst[4][j] = tmp[2];
			dst[12][j] = tmp[3];
			dst[2][j] = tmp[4];
			dst[6][j] = tmp[5];
			dst[10][j] = tmp[6];
			dst[14][j] = tmp[7];
			dst[1][j] = tmp[8];
			dst[3][j] = tmp[9];
			dst[5][j] = tmp[10];
			dst[7][j] = tmp[11];
			dst[9][j] = tmp[12];
			dst[11][j] = tmp[13];
			dst[13][j] = tmp[14];
			dst[15][j] = tmp[15];
		}
	}
}


static void dct_col_8_16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	int E[16][8], O[16][8];
	int EE[16][4], EO[16][4];
	int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_height == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
		if (j >= cu_width)
			break;

		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			E[j][k] = src[j][(k + j) & size_b] + src[j][(15 - k + j) & size_b];
			O[j][k] = src[j][(k + j) & size_b] - src[j][(15 - k + j) & size_b];
		}
		/* EE and EO */
		if (cu_height == 16) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_height == 8) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = src[j][(k + j) & size_b] + src[j][(7 - k + j) & size_b];
				EO[j][k] = src[j][(k + j) & size_b] - src[j][(7 - k + j) & size_b];
			}
		}

		/* EEE and EEO */
		if (cu_height == 16 || cu_height == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_height == 4) {
			EEE[j][0] = src[j][(0 + j) & size_b] + src[j][(3 + j) & size_b];
			EEO[j][0] = src[j][(0 + j) & size_b] - src[j][(3 + j) & size_b];
			EEE[j][1] = src[j][(1 + j) & size_b] + src[j][(2 + j) & size_b];
			EEO[j][1] = src[j][(1 + j) & size_b] - src[j][(2 + j) & size_b];
		}
		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_height == 4) {
			dst[0][j] = tmp[0];
			dst[2][j] = tmp[1];
			dst[1][j] = tmp[2];
			dst[3][j] = tmp[3];
		}
		else if (cu_height == 8) {
			dst[0][j] = tmp[0];
			dst[4][j] = tmp[1];
			dst[2][j] = tmp[2];
			dst[6][j] = tmp[3];
			dst[1][j] = tmp[4];
			dst[3][j] = tmp[5];
			dst[5][j] = tmp[6];
			dst[7][j] = tmp[7];
		}
		else if (cu_height == 16) {
			dst[0][j] = tmp[0];
			dst[8][j] = tmp[1];
			dst[4][j] = tmp[2];
			dst[12][j] = tmp[3];
			dst[2][j] = tmp[4];
			dst[6][j] = tmp[5];
			dst[10][j] = tmp[6];
			dst[14][j] = tmp[7];
			dst[1][j] = tmp[8];
			dst[3][j] = tmp[9];
			dst[5][j] = tmp[10];
			dst[7][j] = tmp[11];
			dst[9][j] = tmp[12];
			dst[11][j] = tmp[13];
			dst[13][j] = tmp[14];
			dst[15][j] = tmp[15];
		}
	}
}

static void dct_col_16_8(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	int E[16][8], O[16][8];
	int EE[16][4], EO[16][4];
	int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_height == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
		if (j >= cu_width)
			break;

		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			E[j][k] = src[j][(k + j) & size_b] + src[j][(15 - k + j) & size_b];
			O[j][k] = src[j][(k + j) & size_b] - src[j][(15 - k + j) & size_b];
		}
		/* EE and EO */
		if (cu_height == 16) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_height == 8) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = src[j][(k + j) & size_b] + src[j][(7 - k + j) & size_b];
				EO[j][k] = src[j][(k + j) & size_b] - src[j][(7 - k + j) & size_b];
			}
		}

		/* EEE and EEO */
		if (cu_height == 16 || cu_height == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_height == 4) {
			EEE[j][0] = src[j][(0 + j) & size_b] + src[j][(3 + j) & size_b];
			EEO[j][0] = src[j][(0 + j) & size_b] - src[j][(3 + j) & size_b];
			EEE[j][1] = src[j][(1 + j) & size_b] + src[j][(2 + j) & size_b];
			EEO[j][1] = src[j][(1 + j) & size_b] - src[j][(2 + j) & size_b];
		}
		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_height == 4) {
			dst[0][j] = tmp[0];
			dst[2][j] = tmp[1];
			dst[1][j] = tmp[2];
			dst[3][j] = tmp[3];
		}
		else if (cu_height == 8) {
			dst[0][j] = tmp[0];
			dst[4][j] = tmp[1];
			dst[2][j] = tmp[2];
			dst[6][j] = tmp[3];
			dst[1][j] = tmp[4];
			dst[3][j] = tmp[5];
			dst[5][j] = tmp[6];
			dst[7][j] = tmp[7];
		}
		else if (cu_height == 16) {
			dst[0][j] = tmp[0];
			dst[8][j] = tmp[1];
			dst[4][j] = tmp[2];
			dst[12][j] = tmp[3];
			dst[2][j] = tmp[4];
			dst[6][j] = tmp[5];
			dst[10][j] = tmp[6];
			dst[14][j] = tmp[7];
			dst[1][j] = tmp[8];
			dst[3][j] = tmp[9];
			dst[5][j] = tmp[10];
			dst[7][j] = tmp[11];
			dst[9][j] = tmp[12];
			dst[11][j] = tmp[13];
			dst[13][j] = tmp[14];
			dst[15][j] = tmp[15];
		}
	}
}

static void dct_col_16_16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	int E[16][8], O[16][8];
	int EE[16][4], EO[16][4];
	int EEE[16][2], EEO[16][2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_height == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		if (j >= cu_width)
			break;

		/* E and O*/
		for (k = 0; k < 8; k++)
		{
			E[j][k] = src[j][(k + j) & size_b] + src[j][(15 - k + j) & size_b];
			O[j][k] = src[j][(k + j) & size_b] - src[j][(15 - k + j) & size_b];
		}
		/* EE and EO */
		if (cu_height == 16) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = E[j][k] + E[j][7 - k];
				EO[j][k] = E[j][k] - E[j][7 - k];
			}
		}
		else if (cu_height == 8) {
			for (k = 0; k < 4; k++)
			{
				EE[j][k] = src[j][(k + j) & size_b] + src[j][(7 - k + j) & size_b];
				EO[j][k] = src[j][(k + j) & size_b] - src[j][(7 - k + j) & size_b];
			}
		}

		/* EEE and EEO */
		if (cu_height == 16 || cu_height == 8) {
			EEE[j][0] = EE[j][0] + EE[j][3];
			EEO[j][0] = EE[j][0] - EE[j][3];
			EEE[j][1] = EE[j][1] + EE[j][2];
			EEO[j][1] = EE[j][1] - EE[j][2];
		}
		else if (cu_height == 4) {
			EEE[j][0] = src[j][(0 + j) & size_b] + src[j][(3 + j) & size_b];
			EEO[j][0] = src[j][(0 + j) & size_b] - src[j][(3 + j) & size_b];
			EEE[j][1] = src[j][(1 + j) & size_b] + src[j][(2 + j) & size_b];
			EEO[j][1] = src[j][(1 + j) & size_b] - src[j][(2 + j) & size_b];
		}
		tmp[0] = ((32 * EEE[j][0] + 32 * EEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEE[j][0] - 32 * EEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEO[j][0] + 17 * EEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEO[j][0] - 42 * EEO[j][1] + add) >> shift);
		tmp[4] = ((44 * EO[j][0] + 38 * EO[j][1] + 25 * EO[j][2] + 9 * EO[j][3] + add) >> shift);
		tmp[5] = ((38 * EO[j][0] - 9 * EO[j][1] - 44 * EO[j][2] - 25 * EO[j][3] + add) >> shift);
		tmp[6] = ((25 * EO[j][0] - 44 * EO[j][1] + 9 * EO[j][2] + 38 * EO[j][3] + add) >> shift);
		tmp[7] = ((9 * EO[j][0] - 25 * EO[j][1] + 38 * EO[j][2] - 44 * EO[j][3] + add) >> shift);
		tmp[8] = (((45) * O[j][0] + (43) * O[j][1] + (40) * O[j][2] + (35) * O[j][3] + (29) * O[j][4] + (21) * O[j][5] + (13) * O[j][6] + (4) * O[j][7] + add) >> shift);
		tmp[9] = (((43) * O[j][0] + (29) * O[j][1] + (4) * O[j][2] + (-21) * O[j][3] + (-40) * O[j][4] + (-45) * O[j][5] + (-35) * O[j][6] + (-13) * O[j][7] + add) >> shift);
		tmp[10] = (((40) * O[j][0] + (4) * O[j][1] + (-35) * O[j][2] + (-43) * O[j][3] + (-13) * O[j][4] + (29) * O[j][5] + (45) * O[j][6] + (21) * O[j][7] + add) >> shift);
		tmp[11] = (((35) * O[j][0] + (-21) * O[j][1] + (-43) * O[j][2] + (4) * O[j][3] + (45) * O[j][4] + (13) * O[j][5] + (-40) * O[j][6] + (-29) * O[j][7] + add) >> shift);
		tmp[12] = (((29) * O[j][0] + (-40) * O[j][1] + (-13) * O[j][2] + (45) * O[j][3] + (-4) * O[j][4] + (-43) * O[j][5] + (21) * O[j][6] + (35) * O[j][7] + add) >> shift);
		tmp[13] = (((21) * O[j][0] + (-45) * O[j][1] + (29) * O[j][2] + (13) * O[j][3] + (-43) * O[j][4] + (35) * O[j][5] + (4) * O[j][6] + (-40) * O[j][7] + add) >> shift);
		tmp[14] = (((13) * O[j][0] + (-35) * O[j][1] + (45) * O[j][2] + (-40) * O[j][3] + (21) * O[j][4] + (4) * O[j][5] + (-29) * O[j][6] + (43) * O[j][7] + add) >> shift);
		tmp[15] = (((4) * O[j][0] + (-13) * O[j][1] + (21) * O[j][2] + (-29) * O[j][3] + (35) * O[j][4] + (-40) * O[j][5] + (43) * O[j][6] + (-45) * O[j][7] + add) >> shift);

		if (cu_height == 4) {
			dst[0][j] = tmp[0];
			dst[2][j] = tmp[1];
			dst[1][j] = tmp[2];
			dst[3][j] = tmp[3];
		}
		else if (cu_height == 8) {
			dst[0][j] = tmp[0];
			dst[4][j] = tmp[1];
			dst[2][j] = tmp[2];
			dst[6][j] = tmp[3];
			dst[1][j] = tmp[4];
			dst[3][j] = tmp[5];
			dst[5][j] = tmp[6];
			dst[7][j] = tmp[7];
		}
		else if (cu_height == 16) {
			dst[0][j] = tmp[0];
			dst[8][j] = tmp[1];
			dst[4][j] = tmp[2];
			dst[12][j] = tmp[3];
			dst[2][j] = tmp[4];
			dst[6][j] = tmp[5];
			dst[10][j] = tmp[6];
			dst[14][j] = tmp[7];
			dst[1][j] = tmp[8];
			dst[3][j] = tmp[9];
			dst[5][j] = tmp[10];
			dst[7][j] = tmp[11];
			dst[9][j] = tmp[12];
			dst[11][j] = tmp[13];
			dst[13][j] = tmp[14];
			dst[15][j] = tmp[15];
		}
	}
}


static u8 transform_hor_16(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp[16][16], s16 coef_tmp_h[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=0

	//cu_plane_nz_cln(num_nz, type);
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];
	//s16 coef_temp[16][16];

	U7 size = 16;
	U8 size_b = size - 1;
	U4 shift1;

	shift1 = com_get_forward_trans_shift(tb_width_log2, 0, md_fw_ptr_bit_depth_internal);
#if	0
	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, bit_depth);
	if (slice_type == 2) {
		if (tree_status == TREE_L && type != 0) {
			num_nz[0][type] = 0;
			return 0;
		}
		if (tree_status == TREE_C && type == 0) {
			num_nz[0][type] = 0;
			return 0;
		}
	}
#endif
	dct_row_16(w, h, coef_tmp, coef_tmp_h, shift1);
#if 0
	for (i = 0; i < cu_width; i++) {
#pragma HLS loop_tripcount max = 16
#pragma HLS pipeline
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_height)
				coef_tmp[i][j] = coef_temp[i][(j + i) & size_b];
		}
	}
#endif
	return 1;
}


static u8 transform_hor_8_16(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp[16][16], s16 coef_tmp_h_for_ver[16][16], s16 coef_tmp_h[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h_for_ver complete dim=1

	//cu_plane_nz_cln(num_nz, type);
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];
	//s16 coef_temp[16][16];

	U7 size = 16;
	U8 size_b = size - 1;
	U4 shift1;

	shift1 = com_get_forward_trans_shift(tb_width_log2, 0, md_fw_ptr_bit_depth_internal);
#if	0
	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, bit_depth);
	if (slice_type == 2) {
		if (tree_status == TREE_L && type != 0) {
			num_nz[0][type] = 0;
			return 0;
		}
		if (tree_status == TREE_C && type == 0) {
			num_nz[0][type] = 0;
			return 0;
		}
	}
#endif
	dct_row_8_16(w, h, coef_tmp, coef_tmp_h, shift1);
	for (int j = 0; j < 16; j++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS pipeline
		for (int i = 0; i < 16; i++) {
			//#pragma HLS UNROLL

			coef_tmp_h_for_ver[i][j] = coef_tmp_h[i][j];
		}
	}
#if 0
	for (i = 0; i < cu_width; i++) {
#pragma HLS loop_tripcount max = 16
#pragma HLS pipeline
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_height)
				coef_tmp[i][j] = coef_temp[i][(j + i) & size_b];
		}
	}
#endif
	return 1;
}

static u8 transform_hor_16_8(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp[16][16], s16 coef_tmp_h_for_ver[16][16], s16 coef_tmp_h[16][16])
{
#pragma HLS INLINE OFF
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h_for_ver complete dim=1

	//cu_plane_nz_cln(num_nz, type);
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];
	//s16 coef_temp[16][16];

	U7 size = 16;
	U8 size_b = size - 1;
	U4 shift1;

	shift1 = com_get_forward_trans_shift(tb_width_log2, 0, md_fw_ptr_bit_depth_internal);
#if	0
	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, bit_depth);
	if (slice_type == 2) {
		if (tree_status == TREE_L && type != 0) {
			num_nz[0][type] = 0;
			return 0;
		}
		if (tree_status == TREE_C && type == 0) {
			num_nz[0][type] = 0;
			return 0;
		}
	}
#endif
	dct_row_16_8(w, h, coef_tmp, coef_tmp_h, shift1);
	for (int j = 0; j < 16; j++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS pipeline
		for (int i = 0; i < 16; i++) {
			//#pragma HLS UNROLL

			coef_tmp_h_for_ver[i][j] = coef_tmp_h[i][j];
		}
	}
#if 0
	for (i = 0; i < cu_width; i++) {
#pragma HLS loop_tripcount max = 16
#pragma HLS pipeline
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_height)
				coef_tmp[i][j] = coef_temp[i][(j + i) & size_b];
		}
	}
#endif
	return 1;
}

static u8 transform_hor_16_16(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp[16][16], s16 coef_tmp_h_for_ver[16][16], s16 coef_tmp_h[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=2
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_h complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h_for_ver complete dim=2

	//cu_plane_nz_cln(num_nz, type);
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];
	//s16 coef_temp[16][16];

	U7 size = 16;
	U8 size_b = size - 1;
	U4 shift1;

	shift1 = com_get_forward_trans_shift(tb_width_log2, 0, md_fw_ptr_bit_depth_internal);
#if	0
	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, bit_depth);
	if (slice_type == 2) {
		if (tree_status == TREE_L && type != 0) {
			num_nz[0][type] = 0;
			return 0;
		}
		if (tree_status == TREE_C && type == 0) {
			num_nz[0][type] = 0;
			return 0;
		}
	}
#endif
	dct_row_16_16(w, h, coef_tmp, coef_tmp_h_for_ver, shift1);
/*	for (int j = 0; j < 16; j++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS pipeline
		for (int i = 0; i < 16; i++) {
			//#pragma HLS UNROLL

			coef_tmp_h_for_ver[i][j] = coef_tmp_h[i][j];
		}
	}*/
#if 0
	for (i = 0; i < cu_width; i++) {
#pragma HLS loop_tripcount max = 16
#pragma HLS pipeline
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_height)
				coef_tmp[i][j] = coef_temp[i][(j + i) & size_b];
		}
	}
#endif
	return 1;
}

static u8 transform_ver_16(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp_h[16][16], s16 coef_tmp_v[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
#endif
	//#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=0
	//#pragma HLS ARRAY_PARTITION variable=coef complete dim=0
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];

	U4 shift2;
	U7 size = 16;
	U8 size_b = size - 1;

	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, md_fw_ptr_bit_depth_internal);
	dct_col_16(w, h, coef_tmp_h, coef_tmp_v, shift2);

	return 1;
}

static u8 transform_ver_8_16(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp_h[16][16], s16 coef_tmp_v[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_v complete dim=1
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];

	U4 shift2;
	U7 size = 16;
	U8 size_b = size - 1;

	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, md_fw_ptr_bit_depth_internal);
	dct_col_8_16(w, h, coef_tmp_h, coef_tmp_v, shift2);

	return 1;
}

static u8 transform_ver_16_8(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp_h[16][16], s16 coef_tmp_v[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_v complete dim=1
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];

	U4 shift2;
	U7 size = 16;
	U8 size_b = size - 1;

	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, md_fw_ptr_bit_depth_internal);
	dct_col_16_8(w, h, coef_tmp_h, coef_tmp_v, shift2);

	return 1;
}

static u8 transform_ver_16_16(U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp_h[16][16], s16 coef_tmp_v[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_v core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h complete dim=2

//#pragma HLS ARRAY_PARTITION variable=coef_tmp_h complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_v complete dim=1
	U3 tb_width_log2 = com_tbl_log2[w];
	U3 tb_height_log2 = com_tbl_log2[h];

	U4 shift2;
	U7 size = 16;
	U8 size_b = size - 1;

	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, md_fw_ptr_bit_depth_internal);
	dct_col_16_16(w, h, coef_tmp_h, coef_tmp_v, shift2);

	return 1;
}

static void inv_dct_col_Chroma16(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=1
	U7 size = 16;

	if (cu_height == 4)
	{
		int E[2], O[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
		int rnd_factor = 1 << (shift - 1);

		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			//if (i >= cu_width) break;

			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];

			if (i == 0) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 1) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 2) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 3) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 4) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 5) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 6) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 7) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 8) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 9) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 10) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 11) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 12) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 13) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 14) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 15) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}


		}
	}
	else if (cu_height == 8)
	{
		int E[4], O[4];
		int EE[2], EO[2];
#pragma HLS ARRAY_PARTITION variable = E complete dim = 1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			//if (i >= cu_width) break;
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];

			if (i == 0) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 1) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 2) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 3) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 4) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 5) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 6) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 7) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 8) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 9) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 10) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 11) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 12) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 13) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 14) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 15) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
		}
	}
	else
	{
		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			//if (i >= cu_width) break;
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}

			if (i == 0) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 1) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 2) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 3) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 4) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 5) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 6) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 7) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 8) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 9) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 10) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 11) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 12) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 13) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 14) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 15) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
		}
	}
}


static void inv_dct_col_8_16(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS INLINE
	U7 size = 16;

	if (cu_height == 4)
	{
		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);

		for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=4
#pragma HLS PIPELINE
			if (i >= cu_width) break;

			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_height == 8)
	{
		int E[4], O[4];
		int EE[2], EO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=4
#pragma HLS PIPELINE
			if (i >= cu_width) break;
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else
	{
		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=4
#pragma HLS PIPELINE
			if (i >= cu_width) break;
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
}

static void inv_dct_col_16_8(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS INLINE
	U7 size = 16;

	if (cu_height == 4)
	{
		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);

		for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=4
#pragma HLS PIPELINE
			if (i >= cu_width) break;

			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_height == 8)
	{
		int E[4], O[4];
		int EE[2], EO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;

#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
		for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
			if (i >= cu_width) break;
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else
	{
		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=4
#pragma HLS PIPELINE
			if (i >= cu_width) break;
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
}
static void inv_dct_col_16_16luma(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#if CLOSE_MD_HLS
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=1
#endif
	U7 size = 16;

	if (cu_height == 4)
	{
		int E[2], O[2];
#if CLOSE_MD_HLS
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#endif
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			if (i == 0) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 1) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 2) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 3) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 4) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 5) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 6) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 7) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 8) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 9) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 10) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 11) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 12) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 13) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 14) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
			else if (i == 15) {
				block[(i + 0) & 15][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift); block[(i + 1) & 15][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift); block[(i + 2) & 15][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift); block[(i + 3) & 15][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
			}
		}
	}
	else if (cu_height == 8)
	{
		int E[4], O[4];
		int EE[2], EO[2];
#if CLOSE_MD_HLS
#pragma HLS ARRAY_PARTITION variable = E complete dim = 1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#endif
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];
			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];
			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			if (i == 0) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 1) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 2) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 3) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 4) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 5) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 6) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 7) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 8) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 9) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 10) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 11) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 12) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 13) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 14) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 15) {
				for (k = 0; k < 4; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 15][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
		}
	}
	else
	{
		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
#if CLOSE_MD_HLS
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
#endif
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];
			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];
			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];
			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			if (i == 0) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 1) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 2) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 3) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 4) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 5) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 6) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 7) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 8) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 9) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 10) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 11) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 12) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 13) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 14) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 15) {
				for (k = 0; k < 8; k++) { block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
		}
	}
}
static void inv_dct_col_16_16(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS INLINE off
	U7 size = 16;

	if (cu_height == 4)
	{
		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);

		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			if (i >= cu_width) break;

			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_height == 8)
	{
		int E[4], O[4];
		int EE[2], EO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=4
#pragma HLS PIPELINE
			if (i >= cu_width) break;
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else
	{
		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			if (i >= cu_width) break;
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			/*for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}*/
			for (k = 0; k < 8; k++) {
				block[(i + k) & 15][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[(i + k + 8) & 15][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		
		}
	}
}

static void inv_dct_row_Chroma16(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=2
	U7 size = 16;

	if (cu_width == 4)
	{
		int E[2], O[2];
#pragma HLS ARRAY_PARTITION variable = E complete dim = 0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			O[0] = (42) * coeff[(i+1)&15][i] + (17) * coeff[(i+3)&15][i];
			O[1] = (17) * coeff[(i+1)&15][i] + (-42) * coeff[(i+3)&15][i];
			E[0] = (32) * coeff[(i+0)&15][i] + (32) * coeff[(i+2)&15][i];
			E[1] = (32) * coeff[(i+0)&15][i] + (-32) * coeff[(i+2)&15][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_width == 8)
	{
		static int E[4], O[4];
		static int EE[2], EO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			O[0] = (44) * coeff[(i+1)&15][i] + (38) * coeff[(i+3)&15][i] + (25) * coeff[(i+5)&15][i] + (9) * coeff[(i+7)&15][i];
			O[1] = (38) * coeff[(i+1)&15][i] + (-9) * coeff[(i+3)&15][i] + (-44) * coeff[(i+5)&15][i] + (-25) * coeff[(i+7)&15][i];
			O[2] = (25) * coeff[(i+1)&15][i] + (-44) * coeff[(i+3)&15][i] + (9) * coeff[(i+5)&15][i] + (38) * coeff[(i+7)&15][i];
			O[3] = (9) * coeff[(i+1)&15][i] + (-25) * coeff[(i+3)&15][i] + (38) * coeff[(i+5)&15][i] + (-44) * coeff[(i+7)&15][i];

			EO[0] = (42) * coeff[(i+2)&15][i] + (17) * coeff[(i+6)&15][i];
			EO[1] = (17) * coeff[(i+2)&15][i] + (-42) * coeff[(i+6)&15][i];
			EE[0] = (32) * coeff[(i+0)&15][i] + (32) * coeff[(i+4)&15][i];
			EE[1] = (32) * coeff[(i+0)&15][i] + (-32) * coeff[(i+4)&15][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else
	{
		static int E[8], O[8];
		static int EE[4], EO[4];
		static int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[(i+1)&15][i] + (43) * coeff[(i+3)&15][i] + (40) * coeff[(i+5)&15][i] + (35) * coeff[(i+7)&15][i] + (29) * coeff[(i+9)&15][i] + (21) * coeff[(i+11)&15][i] + (13) * coeff[(i+13)&15][i] + (4) * coeff[(i+15)&15][i];
			O[1] = (43) * coeff[(i+1)&15][i] + (29) * coeff[(i+3)&15][i] + (4) * coeff[(i+5)&15][i] + (-21) * coeff[(i+7)&15][i] + (-40) * coeff[(i+9)&15][i] + (-45) * coeff[(i+11)&15][i] + (-35) * coeff[(i+13)&15][i] + (-13) * coeff[(i+15)&15][i];
			O[2] = (40) * coeff[(i+1)&15][i] + (4) * coeff[(i+3)&15][i] + (-35) * coeff[(i+5)&15][i] + (-43) * coeff[(i+7)&15][i] + (-13) * coeff[(i+9)&15][i] + (29) * coeff[(i+11)&15][i] + (45) * coeff[(i+13)&15][i] + (21) * coeff[(i+15)&15][i];
			O[3] = (35) * coeff[(i+1)&15][i] + (-21) * coeff[(i+3)&15][i] + (-43) * coeff[(i+5)&15][i] + (4) * coeff[(i+7)&15][i] + (45) * coeff[(i+9)&15][i] + (13) * coeff[(i+11)&15][i] + (-40) * coeff[(i+13)&15][i] + (-29) * coeff[(i+15)&15][i];
			O[4] = (29) * coeff[(i+1)&15][i] + (-40) * coeff[(i+3)&15][i] + (-13) * coeff[(i+5)&15][i] + (45) * coeff[(i+7)&15][i] + (-4) * coeff[(i+9)&15][i] + (-43) * coeff[(i+11)&15][i] + (21) * coeff[(i+13)&15][i] + (35) * coeff[(i+15)&15][i];
			O[5] = (21) * coeff[(i+1)&15][i] + (-45) * coeff[(i+3)&15][i] + (29) * coeff[(i+5)&15][i] + (13) * coeff[(i+7)&15][i] + (-43) * coeff[(i+9)&15][i] + (35) * coeff[(i+11)&15][i] + (4) * coeff[(i+13)&15][i] + (-40) * coeff[(i+15)&15][i];
			O[6] = (13) * coeff[(i+1)&15][i] + (-35) * coeff[(i+3)&15][i] + (45) * coeff[(i+5)&15][i] + (-40) * coeff[(i+7)&15][i] + (21) * coeff[(i+9)&15][i] + (4) * coeff[(i+11)&15][i] + (-29) * coeff[(i+13)&15][i] + (43) * coeff[(i+15)&15][i];
			O[7] = (4) * coeff[(i+1)&15][i] + (-13) * coeff[(i+3)&15][i] + (21) * coeff[(i+5)&15][i] + (-29) * coeff[(i+7)&15][i] + (35) * coeff[(i+9)&15][i] + (-40) * coeff[(i+11)&15][i] + (43) * coeff[(i+13)&15][i] + (-45) * coeff[(i+15)&15][i];

			EO[0] = (44) * coeff[(i+2)&15][i] + (38) * coeff[(i+6)&15][i] + (25) * coeff[(i+10)&15][i] + (9) * coeff[(i+14)&15][i];
			EO[1] = (38) * coeff[(i+2)&15][i] + (-9) * coeff[(i+6)&15][i] + (-44) * coeff[(i+10)&15][i] + (-25) * coeff[(i+14)&15][i];
			EO[2] = (25) * coeff[(i+2)&15][i] + (-44) * coeff[(i+6)&15][i] + (9) * coeff[(i+10)&15][i] + (38) * coeff[(i+14)&15][i];
			EO[3] = (9) * coeff[(i+2)&15][i] + (-25) * coeff[(i+6)&15][i] + (38) * coeff[(i+10)&15][i] + (-44) * coeff[(i+14)&15][i];

			EEO[0] = (42) * coeff[(i+4)&15][i] + (17) * coeff[(i+12)&15][i];
			EEE[0] = (32) * coeff[(i+0)&15][i] + (32) * coeff[(i+8)&15][i];
			EEO[1] = (17) * coeff[(i+4)&15][i] + (-42) * coeff[(i+12)&15][i];
			EEE[1] = (32) * coeff[(i+0)&15][i] + (-32) * coeff[(i+8)&15][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
}


static void inv_dct_row_8_16(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=2
	U7 size = 16;

	if (cu_width == 4)
	{
		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
#pragma HLS UNROLL factor=8
			if (i >= cu_height) break;
			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_width == 8)
	{
		static int E[4], O[4];
		static int EE[2], EO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0

		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
//#pragma HLS UNROLL factor=8
			if (i >= cu_height) break;
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else
	{
		static int E[8], O[8];
		static int EE[4], EO[4];
		static int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
#pragma HLS UNROLL factor=8
			if (i >= cu_height) break;
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
}

static void inv_dct_row_16_8(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=2
	U7 size = 16;

	if (cu_width == 4)
	{
		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
#pragma HLS UNROLL factor=8
			if (i >= cu_height) break;
			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_width == 8)
	{
		static int E[4], O[4];
		static int EE[2], EO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
#pragma HLS UNROLL factor=8
			if (i >= cu_height) break;
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else
	{
		static int E[8], O[8];
		static int EE[4], EO[4];
		static int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;

#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
#pragma HLS UNROLL factor=2
			if (i >= cu_height) break;
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
}

static void inv_dct_row_16_16(U8 cu_width, U8 cu_height, s16 coeff[16][16], s16 block[16][16], U4 shift)
{
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=2
	U7 size = 16;

	if (cu_width == 4)
	{
		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			if (i >= cu_height) break;
			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_width == 8)
	{
		static int E[4], O[4];
		static int EE[2], EO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			if (i >= cu_height) break;
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else
	{
		static int E[8], O[8];
		static int EE[4], EO[4];
		static int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
		for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
			if (i >= cu_height) break;
			O[0] = (45) * coeff[(i + 1) & 15][i] + (43) * coeff[(i + 3) & 15][i] + (40) * coeff[(i + 5) & 15][i] + (35) * coeff[(i + 7) & 15][i] + (29) * coeff[(i + 9) & 15][i] + (21) * coeff[(i + 11) & 15][i] + (13) * coeff[(i + 13) & 15][i] + (4) * coeff[(i + 15) & 15][i];
			O[1] = (43) * coeff[(i + 1) & 15][i] + (29) * coeff[(i + 3) & 15][i] + (4) * coeff[(i + 5) & 15][i] + (-21) * coeff[(i + 7) & 15][i] + (-40) * coeff[(i + 9) & 15][i] + (-45) * coeff[(i + 11) & 15][i] + (-35) * coeff[(i + 13) & 15][i] + (-13) * coeff[(i + 15) & 15][i];
			O[2] = (40) * coeff[(i + 1) & 15][i] + (4) * coeff[(i + 3) & 15][i] + (-35) * coeff[(i + 5) & 15][i] + (-43) * coeff[(i + 7) & 15][i] + (-13) * coeff[(i + 9) & 15][i] + (29) * coeff[(i + 11) & 15][i] + (45) * coeff[(i + 13) & 15][i] + (21) * coeff[(i + 15) & 15][i];
			O[3] = (35) * coeff[(i + 1) & 15][i] + (-21) * coeff[(i + 3) & 15][i] + (-43) * coeff[(i + 5) & 15][i] + (4) * coeff[(i + 7) & 15][i] + (45) * coeff[(i + 9) & 15][i] + (13) * coeff[(i + 11) & 15][i] + (-40) * coeff[(i + 13) & 15][i] + (-29) * coeff[(i + 15) & 15][i];
			O[4] = (29) * coeff[(i + 1) & 15][i] + (-40) * coeff[(i + 3) & 15][i] + (-13) * coeff[(i + 5) & 15][i] + (45) * coeff[(i + 7) & 15][i] + (-4) * coeff[(i + 9) & 15][i] + (-43) * coeff[(i + 11) & 15][i] + (21) * coeff[(i + 13) & 15][i] + (35) * coeff[(i + 15) & 15][i];
			O[5] = (21) * coeff[(i + 1) & 15][i] + (-45) * coeff[(i + 3) & 15][i] + (29) * coeff[(i + 5) & 15][i] + (13) * coeff[(i + 7) & 15][i] + (-43) * coeff[(i + 9) & 15][i] + (35) * coeff[(i + 11) & 15][i] + (4) * coeff[(i + 13) & 15][i] + (-40) * coeff[(i + 15) & 15][i];
			O[6] = (13) * coeff[(i + 1) & 15][i] + (-35) * coeff[(i + 3) & 15][i] + (45) * coeff[(i + 5) & 15][i] + (-40) * coeff[(i + 7) & 15][i] + (21) * coeff[(i + 9) & 15][i] + (4) * coeff[(i + 11) & 15][i] + (-29) * coeff[(i + 13) & 15][i] + (43) * coeff[(i + 15) & 15][i];
			O[7] = (4) * coeff[(i + 1) & 15][i] + (-13) * coeff[(i + 3) & 15][i] + (21) * coeff[(i + 5) & 15][i] + (-29) * coeff[(i + 7) & 15][i] + (35) * coeff[(i + 9) & 15][i] + (-40) * coeff[(i + 11) & 15][i] + (43) * coeff[(i + 13) & 15][i] + (-45) * coeff[(i + 15) & 15][i];

			EO[0] = (44) * coeff[(i + 2) & 15][i] + (38) * coeff[(i + 6) & 15][i] + (25) * coeff[(i + 10) & 15][i] + (9) * coeff[(i + 14) & 15][i];
			EO[1] = (38) * coeff[(i + 2) & 15][i] + (-9) * coeff[(i + 6) & 15][i] + (-44) * coeff[(i + 10) & 15][i] + (-25) * coeff[(i + 14) & 15][i];
			EO[2] = (25) * coeff[(i + 2) & 15][i] + (-44) * coeff[(i + 6) & 15][i] + (9) * coeff[(i + 10) & 15][i] + (38) * coeff[(i + 14) & 15][i];
			EO[3] = (9) * coeff[(i + 2) & 15][i] + (-25) * coeff[(i + 6) & 15][i] + (38) * coeff[(i + 10) & 15][i] + (-44) * coeff[(i + 14) & 15][i];

			EEO[0] = (42) * coeff[(i + 4) & 15][i] + (17) * coeff[(i + 12) & 15][i];
			EEE[0] = (32) * coeff[(i + 0) & 15][i] + (32) * coeff[(i + 8) & 15][i];
			EEO[1] = (17) * coeff[(i + 4) & 15][i] + (-42) * coeff[(i + 12) & 15][i];
			EEE[1] = (32) * coeff[(i + 0) & 15][i] + (-32) * coeff[(i + 8) & 15][i];


			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
}

void recon_Chroma16(s16 resi[16][16], pel pred[16][16], int num, U7 cu_width, U7 cu_height,  pel rec[16][16],U4 bit_depth, U8 rdo_idx, U8 all_rdo_num)
{
#pragma HLS ARRAY_PARTITION variable=pred complete dim=2		
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
#pragma HLS ARRAY_PARTITION variable=resi complete dim=2	

	int i;
	int j;
	//get_part_num(part);

	pel p, p_tmp;

	//r = rec/* + tb_y * s_rec + tb_x*/;
	/* just copy pred to rec */
	U1 is_coef_not_zero = num != 0;


	const int shift = (bit_depth - 8) << 1;
	if (rdo_idx < all_rdo_num) {
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (j = 0; j < 16; j++) {
			if (is_coef_not_zero)
			{
				p = pred[i][j] + resi[i][j];
			}
			else {
				p = pred[i][j];
			}
			p_tmp = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
			if ((j < cu_width) && (i < cu_height))
			{
				rec[i][j] = p_tmp;// (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));

			}
			}
		}
		//for (j = 0; j < 16; j++) {
		//	ssd += (diff[j] * diff[j] >> shift);
		//}
	}
	//*dist_value = ssd;
}

static int recon_8_16(PART_SIZE part, s16 resi[16][16], pel pred[16][16], int num, U3 plane, U7 cu_width, U7 cu_height, int s_rec, pel rec[16][16], U4 bit_depth, s16 org[16][16])
{
#pragma HLS INLINE off
	int i;
	int j;
	//get_part_num(part);
	const int shift = (bit_depth - 8) << 1;
	pel p;
	pel rec_tmp[16][16];
	int diff;
	s64 ssd = 0;
	//r = rec/* + tb_y * s_rec + tb_x*/;
	/* just copy pred to rec */
	U1 is_coef_not_zero = num != 0;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		if (i >= cu_height) break;
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
			{
				p = pred[i][j];
				if (is_coef_not_zero)
					p += resi[i][j];
				rec_tmp[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
				rec[i][j] = rec_tmp[i][j];
				diff = (/*(int)*/rec_tmp[i][j]) - (/*(int)*/org[i][j]);
				ssd += ((diff * diff >> shift));
			}

		}
		//r += s_rec;
	}
	return ssd;
}

static int recon_16_8(PART_SIZE part, s16 resi[16][16], pel pred[16][16], int num, U3 plane, U7 cu_width, U7 cu_height, int s_rec, pel rec[16][16], U4 bit_depth, s16 org[16][16])
{
#pragma HLS INLINE off
	int i;
	int j;
	//get_part_num(part);
	const int shift = (bit_depth - 8) << 1;
	pel p;
	pel rec_tmp[16][16];
	int diff;
	s64 ssd = 0;
	//r = rec/* + tb_y * s_rec + tb_x*/;
	/* just copy pred to rec */
	U1 is_coef_not_zero = num != 0;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		if (i >= cu_height) break;
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
			{
				p = pred[i][j];
				if (is_coef_not_zero)
					p += resi[i][j];
				rec_tmp[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
				rec[i][j] = rec_tmp[i][j];
				diff = (/*(int)*/rec_tmp[i][j]) - (/*(int)*/org[i][j]);
				ssd += ((diff * diff >> shift));
			}

		}
		//r += s_rec;
	}
	return ssd;
}

static int recon_16_16(PART_SIZE part, s16 resi[16][16], pel pred[16][16], int num, U3 plane, U7 cu_width, U7 cu_height, int s_rec, pel rec[16][16], U4 bit_depth, s16 org[16][16])
{
#pragma HLS INLINE off
	int i;
	int j;
	//get_part_num(part);
	const int shift = (bit_depth - 8) << 1;
	pel p;
	pel rec_tmp[16][16];
	int diff;
	s64 ssd = 0;
	//r = rec/* + tb_y * s_rec + tb_x*/;
	/* just copy pred to rec */
	U1 is_coef_not_zero = num != 0;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		if (i >= cu_height) break;
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
			{
				p = pred[i][j];
				if (is_coef_not_zero)
					p += resi[i][j];
				rec_tmp[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
				rec[i][j] = rec_tmp[i][j];
				diff = (/*(int)*/rec_tmp[i][j]) - (/*(int)*/org[i][j]);
				ssd += ((diff * diff >> shift));
			}

		}
		//r += s_rec;
	}
	return ssd;
}

void itrans_h_Chroma16(U8 cu_width, U8 cu_height, s16 resi[16][16], s16 coef_temp[16][16],  U3 cu_height_log2, U4 bit_depth, int num_nz_ith, int *num_nz_ith1, U8 rdo_idx, U8 all_rdo_num)
{
	if (rdo_idx < all_rdo_num) {
		*num_nz_ith1 = num_nz_ith;
	if (num_nz_ith) {
		U4 shift2;
		//s16 rec1[16][16];

		//s16 coef_temp[MAX_TR_DIM];
		shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);


		inv_dct_row_Chroma16(cu_width, cu_height, coef_temp, resi, shift2);
		}
	}
}



static void itrans_h_8_16(U8 cu_width, U8 cu_height, s16 resi[16][16], s16 coef_temp[16][16], U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth)
{
	U4 shift2;
	//s16 rec1[16][16];
	U7 size = 16;

#pragma HLS INLINE off
	//s16 coef_temp[MAX_TR_DIM];
	{
		shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);


		inv_dct_row_8_16(cu_width, cu_height, coef_temp, resi, shift2);
#if 0
		for (int i = 0; i < cu_height; i++)
#pragma HLS loop_tripcount max = 16
#pragma HLS PIPELINE
			for (int j = 0; j < 16; j++) {
#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
				if (j < cu_width)
					resi[i][j] = rec1[i][j];
			}

#endif
	}
}

static void itrans_h_16_8(U8 cu_width, U8 cu_height, s16 resi[16][16], s16 coef_temp[16][16], U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth)
{
	U4 shift2;
	//s16 rec1[16][16];
	U7 size = 16;

#pragma HLS INLINE off
	//s16 coef_temp[MAX_TR_DIM];
	{
		shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);


		inv_dct_row_16_8(cu_width, cu_height, coef_temp, resi, shift2);
#if 0
		for (int i = 0; i < cu_height; i++)
#pragma HLS loop_tripcount max = 16
#pragma HLS PIPELINE
			for (int j = 0; j < 16; j++) {
#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
				if (j < cu_width)
					resi[i][j] = rec1[i][j];
			}

#endif
	}
}

static void itrans_h_16_16(U8 cu_width, U8 cu_height, s16 resi[16][16], s16 coef_temp[16][16], U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth)
{
	U4 shift2;
	//s16 rec1[16][16];
	U7 size = 16;

#pragma HLS INLINE off
	//s16 coef_temp[MAX_TR_DIM];
	{
		shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);


		inv_dct_row_16_16(cu_width, cu_height, coef_temp, resi, shift2);
#if 0
		for (int i = 0; i < cu_height; i++)
#pragma HLS loop_tripcount max = 16
#pragma HLS PIPELINE
			for (int j = 0; j < 16; j++) {
#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
				if (j < cu_width)
					resi[i][j] = rec1[i][j];
			}

#endif
	}
}

void itrans_v_Chroma16(U8 cu_width, U8 cu_height, s16 coef_dq[16][16], s16 coef_temp[16][16], U3 cu_width_log2,
	U4 bit_depth, int num_nz_itv, int *num_nz_itv0, U8 rdo_idx, U8 all_rdo_num)
{
	if (rdo_idx < all_rdo_num) {
		*num_nz_itv0 = num_nz_itv;
	if (num_nz_itv) {
		U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);


		inv_dct_col_Chroma16(cu_width, cu_height, coef_dq, coef_temp, shift1);
		}
	}
}

static void itrans_v_8_16(U8 cu_width, U8 cu_height, s16 coef_dq[16][16], s16 coef_temp[16][16], U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth)
{

#pragma HLS INLINE off
	U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);

	U7 size = 16;

	inv_dct_col_8_16(cu_width, cu_height, coef_dq, coef_temp, shift1);
}

static void itrans_v_16_8(U8 cu_width, U8 cu_height, s16 coef_dq[16][16], s16 coef_temp[16][16], U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth)
{

#pragma HLS INLINE off
	U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);

	U7 size = 16;

	inv_dct_col_16_8(cu_width, cu_height, coef_dq, coef_temp, shift1);
}

static void itrans_v_16_16(U8 cu_width, U8 cu_height, s16 coef_dq[16][16], s16 coef_temp[16][16], U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth)
{

#pragma HLS INLINE off
	U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);

	U7 size = 16;

	inv_dct_col_16_16luma(cu_width, cu_height, coef_dq, coef_temp, shift1);
}


static void dquant_Chroma16(U6 qp, s16 coef[16][16], s16 coef_out[16][16], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith, int num_nz_itv )
{

	int i;
	int j;
	int w = 1 << log2_w;
	int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix = (log2_w + log2_h) & 1;
	const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
#pragma HLS ARRAY_PARTITION variable=com_tbl_dq_scale complete dim=1
	const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
	int scale = com_tbl_dq_scale[qp];
	// +1 is used to compensate for the mismatching of shifts in quantization and inverse quantization
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
	int offset = shift == 0 ? 0 : 1 << (shift - 1);
	int sr_x = 0;
	int sr_y = 0;


	s16 coef_tmp[16];
	int lev_tmp;
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=0
	s16 i_tmp[16];
#pragma HLS ARRAY_PARTITION variable=i_tmp complete dim=0
	U1 sr_x_flag;
	int sr_y_tmp;
	for (j = 0; j < 16; j++) 
	{
#pragma HLS PIPELINE
		for (int i = 0; i < 16; i++) {
			coef_tmp[i] = coef[i][j];
		}
		sr_x_flag = 0;
		for (i = 0; i < 16; i++)
			{
			if ((i < h) && (j < w)) {
				//int lev = (((coef[i][j] * weight >> 2) * scale >> 4) + offset) >> shift;
				if (coef_tmp[i]) {
					//sr_y = i > sr_y ? i : sr_y;
					i_tmp[i] = 1;
					//sr_x = j > sr_x ? j : sr_x;
					sr_x_flag = 1;
				}
				else {
					i_tmp[i] = 0;
				}
				int weight = (i | j) & 0xE0 ? 0 : coef_tmp[i];
				int lev = (weight * scale + offset) >> shift;
				lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
				if (refix) {
					lev = (lev * 181 + 128) >> 8;
				}
				lev_tmp = lev;
			}
			else {
				lev_tmp = 0;
				i_tmp[i] = 0;
			}
			coef_out[i][j] = lev_tmp;
		}
		sr_y_tmp = 0;
		for (int i = 15; i >= 0; i--) {
			if (i_tmp[i] == 1) {
				sr_y_tmp = i;
				break;
			}
		}
		if (sr_y < sr_y_tmp) {
			sr_y = sr_y_tmp;
		}
		if (sr_x_flag) {
			sr_x = j;
		}
	}
	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + num_nz_itv;
}


static void dquant_8_16(U6 qp, s16 coef[16][16], s16 coef_out[16][16], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith)
{

#pragma HLS INLINE off
	int i;
	int j;
	int w = 1 << log2_w;
	int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix = (log2_w + log2_h) & 1;
	const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
//#pragma HLS ARRAY_PARTITION variable=com_tbl_dq_scale complete dim=1
	const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
//#pragma HLS ARRAY_PARTITION variable=com_tbl_dq_shift complete dim=1
	int scale = com_tbl_dq_scale[qp];
	// +1 is used to compensate for the mismatching of shifts in quantization and inverse quantization
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
	int offset = shift == 0 ? 0 : 1 << (shift - 1);
	int sr_x = 0;
	int sr_y = 0;
	for (i = 0; i < 16; i++) {
//#pragma HLS UNROLL factor=8
#pragma HLS PIPELINE
		if (i >= h) break;
		for (j = 0; j < 16; j++) {
			if (j < w)
			{
				//int weight = (i | j) & 0xE0 ? 0 : 64;
				//int lev = (((coef[i][j] * weight >> 2) * scale >> 4) + offset) >> shift;
				if (coef[i][j]) {
					sr_y = i > sr_y ? i : sr_y;
					sr_x = j > sr_x ? j : sr_x;
				}
				int weight = (i | j) & 0xE0 ? 0 : coef[i][j];
				int lev = (weight * scale + offset) >> shift;
				lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
				if (refix) {
					lev = (lev * 181 + 128) >> 8;
				}
				coef_out[i][j] = (lev);
			}
		}
	}
	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + *num_nz_ith;
}

static void dquant_16_8(U6 qp, s16 coef[16][16], s16 coef_out[16][16], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith)
{

#pragma HLS INLINE off
	int i;
	int j;
	int w = 1 << log2_w;
	int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix = (log2_w + log2_h) & 1;
	const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
#pragma HLS ARRAY_PARTITION variable=com_tbl_dq_scale complete dim=1
	const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
#pragma HLS ARRAY_PARTITION variable=com_tbl_dq_shift complete dim=1
	int scale = com_tbl_dq_scale[qp];
	// +1 is used to compensate for the mismatching of shifts in quantization and inverse quantization
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
	int offset = shift == 0 ? 0 : 1 << (shift - 1);
	int sr_x = 0;
	int sr_y = 0;
	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL factor=2
#pragma HLS PIPELINE
		if (i >= h) break;
		for (j = 0; j < 16; j++) {
			if (j < w)
			{
				//int weight = (i | j) & 0xE0 ? 0 : 64;
				//int lev = (((coef[i][j] * weight >> 2) * scale >> 4) + offset) >> shift;
				if (coef[i][j]) {
					sr_y = i > sr_y ? i : sr_y;
					sr_x = j > sr_x ? j : sr_x;
				}
				int weight = (i | j) & 0xE0 ? 0 : coef[i][j];
				int lev = (weight * scale + offset) >> shift;
				lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
				if (refix) {
					lev = (lev * 181 + 128) >> 8;
				}
				coef_out[i][j] = (lev);
			}
		}
	}
	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + *num_nz_ith;
}

static void dquant_16_16(U6 qp, s16 coef[16][16], s16 coef_out[16][16], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith)
{

#pragma HLS INLINE off
	int i;
	int j;
	int w = 1 << log2_w;
	int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix = (log2_w + log2_h) & 1;
	const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
#pragma HLS ARRAY_PARTITION variable=com_tbl_dq_scale complete dim=1
	const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
#pragma HLS ARRAY_PARTITION variable=com_tbl_dq_shift complete dim=1
	int scale = com_tbl_dq_scale[qp];
	// +1 is used to compensate for the mismatching of shifts in quantization and inverse quantization
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
	int offset = shift == 0 ? 0 : 1 << (shift - 1);
	int sr_x = 0;
	int sr_y = 0;
	s16 coef_tmp[16];
	int lev_tmp;
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=0
	s16 i_tmp[16];
#pragma HLS ARRAY_PARTITION variable=i_tmp complete dim=0
	U1 sr_x_flag;
	int sr_y_tmp;
	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		for (int i = 0; i < 16; i++) {
			coef_tmp[i] = coef[i][j];
		}
		sr_x_flag = 0;
		for (i = 0; i < 16; i++)
			{
			if ((i < h) && (j < w)) {
				//int lev = (((coef[i][j] * weight >> 2) * scale >> 4) + offset) >> shift;
				if (coef_tmp[i]) {
					//sr_y = i > sr_y ? i : sr_y;
					i_tmp[i] = 1;
					//sr_x = j > sr_x ? j : sr_x;
					sr_x_flag = 1;
				}
				else {
					i_tmp[i] = 0;
				}
				int weight = (i | j) & 0xE0 ? 0 : coef_tmp[i];
				int lev = (weight * scale + offset) >> shift;
				lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
				if (refix) {
					lev = (lev * 181 + 128) >> 8;
				}
				lev_tmp = lev;
			}
			else {
				lev_tmp = 0;
				i_tmp[i] = 0;
			}
			coef_out[i][j] = lev_tmp;
		}
		sr_y_tmp = 0;
		for (int i = 15; i >= 0; i--) {
			if (i_tmp[i] == 1) {
				sr_y_tmp = i;
				break;
			}
		}
		if (sr_y < sr_y_tmp) {
			sr_y = sr_y_tmp;
		}
		if (sr_x_flag) {
			sr_x = j;
		}
	}
	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + *num_nz_ith;
}

void Dq_16_chroma(U8 cu_width, U8 cu_height, U4 md_fw_ptr_bit_depth_internal, U6 qp, int num_nz_itv, int* num_nz_ith,
	int* num_nz_update, s16 coef_tmp_itv[16][16], s16 coef_dq[16][16], U3 cu_width_log2_c, U3 cu_height_log2_c, U8 rdo_idx, U8 all_rdo_num)
{
#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_dq complete dim=1

	// STREAM BUFFER
	int num_nz_read;

	U3 tb_width_log2 = cu_width_log2_c;// com_tbl_log2[cu_width];
	U3 tb_height_log2 = cu_height_log2_c;// com_tbl_log2[cu_height];
	if (rdo_idx < all_rdo_num) {
	if (num_nz_itv) {
		dquant_Chroma16(qp, coef_tmp_itv, coef_dq, tb_width_log2, tb_height_log2, md_fw_ptr_bit_depth_internal, &num_nz_read, num_nz_itv);
	}
	else {
		num_nz_read = 0;
	}
	*num_nz_ith = num_nz_read;
	*num_nz_update = num_nz_read;
	}
}


static void inv_transform_ver_8_16(U8 cu_width, U8 cu_height, U4 md_fw_ptr_bit_depth_internal, U6 qp, int num_nz_itv, int* num_nz_ith,
	int num_nz_update[MAX_NUM_TB][N_C], s16 coef_tmp_itv[16][16], s16 coef_tmp_ith[16][16], s16 coef_tmp_for_ith[16][16], U3 cu_width_log2, U3 cu_height_log2)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=num_nz_itv
#pragma HLS INTERFACE axis port=num_nz_ith
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_ith complete dim=2
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_for_ith complete dim=2

	// STREAM BUFFER
	int num_nz_read = num_nz_itv;

	U3 tb_width_log2 = com_tbl_log2[cu_width];
	U3 tb_height_log2 = com_tbl_log2[cu_height];
	static s16 coef_dq[16][16];
#pragma HLS ARRAY_PARTITION variable=coef_dq complete dim=0
	if (num_nz_read) {
		dquant_8_16(qp, coef_tmp_itv, coef_dq, tb_width_log2, tb_height_log2, md_fw_ptr_bit_depth_internal, &num_nz_read);
		itrans_v_8_16(cu_width, cu_height, coef_dq, coef_tmp_ith, tb_width_log2, tb_height_log2, md_fw_ptr_bit_depth_internal);
	}

	// WRITE STREAMS
	*num_nz_ith = num_nz_read;
	num_nz_update[0][0] = num_nz_read;
//	for (int i = 0; i < 16; i++)
//#pragma HLS PIPELINE
//		for (int j = 0; j < 16; j++) {
			//#pragma HLS UNROLL
//			coef_tmp_for_ith[i][j] = coef_tmp_ith[i][j];
//		}
}
static void inv_transform_ver_16_8(U8 cu_width, U8 cu_height, U4 md_fw_ptr_bit_depth_internal, U6 qp, int num_nz_itv, int* num_nz_ith, 
	int num_nz_update[MAX_NUM_TB][N_C], s16 coef_tmp_itv[16][16], s16 coef_tmp_ith[16][16], s16 coef_tmp_for_ith[16][16], U3 cu_width_log2, U3 cu_height_log2)
{
#pragma HLS INLINE OFF
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=num_nz_itv
#pragma HLS INTERFACE axis port=num_nz_ith
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_ith complete dim=2
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_for_ith complete dim=2

	// STREAM BUFFER
	int num_nz_read = num_nz_itv;

	U3 tb_width_log2 = com_tbl_log2[cu_width];
	U3 tb_height_log2 = com_tbl_log2[cu_height];
	static s16 coef_dq[16][16];
#pragma HLS ARRAY_PARTITION variable=coef_dq complete dim=0
	if (num_nz_read) {
		dquant_16_8(qp, coef_tmp_itv, coef_dq, tb_width_log2, tb_height_log2, md_fw_ptr_bit_depth_internal, &num_nz_read);
		itrans_v_16_8(cu_width, cu_height, coef_dq, coef_tmp_ith, tb_width_log2, tb_height_log2, md_fw_ptr_bit_depth_internal);
	}
	/*for (int i = 0; i < 16; i++)
#pragma HLS PIPELINE
		for (int j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
				coef_tmp_for_ith[i][j] = coef_tmp_ith[i][j];
		}*/
	// WRITE STREAMS
	*num_nz_ith = num_nz_read;
	num_nz_update[0][0] = num_nz_read;
}

static void inv_transform_ver_16_16(U8 cu_width, U8 cu_height, U4 md_fw_ptr_bit_depth_internal, U6 qp, int num_nz_itv, int* num_nz_ith, int num_nz_update[MAX_NUM_TB][N_C], s16 coef_tmp_itv[16][16], s16 coef_tmp_ith[16][16], s16 coef_tmp_for_ith[16][16], U3 cu_width_log2, U3 cu_height_log2)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=num_nz_itv
#pragma HLS INTERFACE axis port=num_nz_ith
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_1P_BRAM
#endif
// #pragma HLS pipeline
#pragma HLS ARRAY_PARTITION variable=coef_tmp_itv complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_tmp_ith complete dim=1
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_for_ith complete dim=2

	// STREAM BUFFER
	int num_nz_read = num_nz_itv;

	U3 tb_width_log2 = com_tbl_log2[cu_width];
	U3 tb_height_log2 = com_tbl_log2[cu_height];
	s16 coef_dq[16][16];
#pragma HLS ARRAY_PARTITION variable=coef_dq complete dim=1
	if (num_nz_read) {
		dquant_16_16(qp, coef_tmp_itv, coef_dq, tb_width_log2, tb_height_log2, md_fw_ptr_bit_depth_internal, &num_nz_read);
		itrans_v_16_16(cu_width, cu_height, coef_dq, coef_tmp_ith, tb_width_log2, tb_height_log2, md_fw_ptr_bit_depth_internal);
	}
	/*for (int i = 0; i < 16; i++)
#pragma HLS PIPELINE
		for (int j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
				coef_tmp_for_ith[i][j] = coef_tmp_ith[i][j];
		}*/
	// WRITE STREAMS
	*num_nz_ith = num_nz_read;
	num_nz_update[0][0] = num_nz_read;
}


static s64 enc_ssd_16b_1_8_16_wsc(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
#pragma HLS ARRAY_PARTITION variable=ssd4 complete dim=0
// #pragma HLS ARRAY_PARTITION variable=src2 cyclic factor=4  dim=1
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
// #pragma HLS ARRAY_PARTITION variable=src1 cyclic factor=4  dim=1
	for (int i = 0; i < 16; i++)
	{
#pragma HLS PIPELINE
		b4x = (i & 0x3);
		b4y = (i >> 2);
		ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);
			diff = (/*(int)*/src1[by][bx]) - (/*(int)*/src2[by][bx]);
			ssd += ((diff * diff >> shift));
		}
		ssd4[b4y][b4x] = ssd;
	}
	int w4 = w >> 2;
	int h4 = h >> 2;
	if (h4 == 1)
	{
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3];
	}
	else if (h4 == 2)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[1][0] + ssd4[1][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3];
	}
	else if (h4 == 4)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0] +
			ssd4[0][1] + ssd4[1][1] + ssd4[2][1] + ssd4[3][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3] +
			ssd4[2][0] + ssd4[2][1] + ssd4[2][2] + ssd4[2][3] +
			ssd4[3][0] + ssd4[3][1] + ssd4[3][2] + ssd4[3][3];
	}

	return ssd;
}

static s64 enc_ssd_16b_1_8_16_lxy(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
#pragma HLS ARRAY_PARTITION variable=ssd4 complete dim=0
	//#pragma HLS ARRAY_PARTITION variable=src2 cyclic factor=4  dim=1
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
//#pragma HLS ARRAY_PARTITION variable=src1 cyclic factor=4  dim=1
	for (int i = 0; i < 16; i++)
	{
#pragma HLS PIPELINE
		/*b4x = (i & 0x3);
		b4y = (i >> 2);*/
		//ssd = 0;
		for (int j = 0; j < 8; j++)
		{
			/*bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);*/
			diff = (/*(int)*/src1[i][j]) - (/*(int)*/src2[i][j]);
			ssd += ((diff * diff >> shift));
		}
		//ssd4[b4y][b4x] = ssd;
	}
	return ssd;
}
static s64 enc_ssd_16b_1_16_8_wsc(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
#pragma HLS ARRAY_PARTITION variable=ssd4 complete dim=0
// #pragma HLS ARRAY_PARTITION variable=src2 cyclic factor=4  dim=1
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
// #pragma HLS ARRAY_PARTITION variable=src1 cyclic factor=4  dim=1
	for (int i = 0; i < 16; i++)
	{
#pragma HLS PIPELINE
		b4x = (i & 0x3);
		b4y = (i >> 2);
		ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);
			diff = (/*(int)*/src1[by][bx]) - (/*(int)*/src2[by][bx]);
			ssd += ((diff * diff >> shift));
		}
		ssd4[b4y][b4x] = ssd;
	}
	int w4 = w >> 2;
	int h4 = h >> 2;
	if (h4 == 1)
	{
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3];
	}
	else if (h4 == 2)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[1][0] + ssd4[1][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3];
	}
	else if (h4 == 4)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0] +
			ssd4[0][1] + ssd4[1][1] + ssd4[2][1] + ssd4[3][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3] +
			ssd4[2][0] + ssd4[2][1] + ssd4[2][2] + ssd4[2][3] +
			ssd4[3][0] + ssd4[3][1] + ssd4[3][2] + ssd4[3][3];
	}

	return ssd;
}

static s64 enc_ssd_16b_1_16_8_lxy(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
#pragma HLS ARRAY_PARTITION variable=ssd4 complete dim=0
//#pragma HLS ARRAY_PARTITION variable=src2 cyclic factor=4  dim=1
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
//#pragma HLS ARRAY_PARTITION variable=src1 cyclic factor=4  dim=1
	for (int i = 0; i < 8; i++)
	{
#pragma HLS PIPELINE
		/*b4x = (i & 0x3);
		b4y = (i >> 2);*/
		//ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			/*bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);*/
			diff = (/*(int)*/src1[i][j]) - (/*(int)*/src2[i][j]);
			ssd += ((diff * diff >> shift));
		}
		//ssd4[b4y][b4x] = ssd;
	}
	return ssd;
}

static s64 enc_ssd_16b_1_16_16_wsc(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
#pragma HLS ARRAY_PARTITION variable=ssd4 complete dim=0
//#pragma HLS ARRAY_PARTITION variable=src2 cyclic factor=4  dim=1
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
//#pragma HLS ARRAY_PARTITION variable=src1 cyclic factor=4  dim=1
	for (int i = 0; i < 16; i++)
	{
		b4x = (i & 0x3);
		b4y = (i >> 2);
		ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);
			diff = (/*(int)*/src1[by][bx]) - (/*(int)*/src2[by][bx]);
			ssd += ((diff * diff >> shift));
		}
		ssd4[b4y][b4x] = ssd;
	}
	int w4 = w >> 2;
	int h4 = h >> 2;
	if (h4 == 1)
	{
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3];
	}
	else if (h4 == 2)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[1][0] + ssd4[1][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3];
	}
	else if (h4 == 4)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0] +
			ssd4[0][1] + ssd4[1][1] + ssd4[2][1] + ssd4[3][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3] +
			ssd4[2][0] + ssd4[2][1] + ssd4[2][2] + ssd4[2][3] +
			ssd4[3][0] + ssd4[3][1] + ssd4[3][2] + ssd4[3][3];
	}

	return ssd;
}
static s64 enc_ssd_16b_1_16_16_lxy(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
#pragma HLS ARRAY_PARTITION variable=ssd4 complete dim=0
	//#pragma HLS ARRAY_PARTITION variable=src2 cyclic factor=4  dim=1
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
//#pragma HLS ARRAY_PARTITION variable=src1 cyclic factor=4  dim=1
	for (int i = 0; i < 16; i++)
	{
#pragma HLS PIPELINE
		/*b4x = (i & 0x3);
		b4y = (i >> 2);*/
		//ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			/*bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);*/
			diff = (/*(int)*/src1[i][j]) - (/*(int)*/src2[i][j]);
			ssd += ((diff * diff >> shift));
		}
		//ssd4[b4y][b4x] = ssd;
	}
	return ssd;
}
static s64 enc_ssd_16b_1_16(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL factor=8
#pragma HLS PIPELINE
		b4x = (i & 0x3);
		b4y = (i >> 2);
		ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);
			diff = (/*(int)*/src1[by][bx]) - (/*(int)*/src2[by][bx]);
			ssd += ((diff * diff >> shift));
		}
		ssd4[b4y][b4x] = ssd;
	}
	int w4 = w >> 2;
	int h4 = h >> 2;
	if (h4 == 1)
	{
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3];
	}
	else if (h4 == 2)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[1][0] + ssd4[1][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3];
	}
	else if (h4 == 4)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0] +
			ssd4[0][1] + ssd4[1][1] + ssd4[2][1] + ssd4[3][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3] +
			ssd4[2][0] + ssd4[2][1] + ssd4[2][2] + ssd4[2][3] +
			ssd4[3][0] + ssd4[3][1] + ssd4[3][2] + ssd4[3][3];
	}

	return ssd;
	//add by xujch
}


static s64 enc_ssd_16b_1_8_16(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
	for (int i = 0; i < 16; i++)
	{
#pragma HLS UNROLL factor=8
#pragma HLS PIPELINE
		b4x = (i & 0x3);
		b4y = (i >> 2);
		ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);
			diff = (/*(int)*/src1[by][bx]) - (/*(int)*/src2[by][bx]);
			ssd += ((diff * diff >> shift));
		}
		ssd4[b4y][b4x] = ssd;
	}
	int w4 = w >> 2;
	int h4 = h >> 2;
	if (h4 == 1)
	{
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3];
	}
	else if (h4 == 2)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[1][0] + ssd4[1][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3];
	}
	else if (h4 == 4)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0] +
			ssd4[0][1] + ssd4[1][1] + ssd4[2][1] + ssd4[3][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3] +
			ssd4[2][0] + ssd4[2][1] + ssd4[2][2] + ssd4[2][3] +
			ssd4[3][0] + ssd4[3][1] + ssd4[3][2] + ssd4[3][3];
	}

	return ssd;
	//add by xujch
}

static s64 enc_ssd_16b_1_16_8(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
	for (int i = 0; i < 16; i++)
	{
//#pragma HLS UNROLL factor=8
#pragma HLS PIPELINE
		b4x = (i & 0x3);
		b4y = (i >> 2);
		ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);
			diff = (/*(int)*/src1[by][bx]) - (/*(int)*/src2[by][bx]);
			ssd += ((diff * diff >> shift));
		}
		ssd4[b4y][b4x] = ssd;
	}
	int w4 = w >> 2;
	int h4 = h >> 2;
	if (h4 == 1)
	{
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3];
	}
	else if (h4 == 2)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[1][0] + ssd4[1][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3];
	}
	else if (h4 == 4)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0] +
			ssd4[0][1] + ssd4[1][1] + ssd4[2][1] + ssd4[3][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3] +
			ssd4[2][0] + ssd4[2][1] + ssd4[2][2] + ssd4[2][3] +
			ssd4[3][0] + ssd4[3][1] + ssd4[3][2] + ssd4[3][3];
	}

	return ssd;
	//add by xujch
}

static s64 enc_ssd_16b_1_16_16(U3 w_log2, U3 h_log2, s16 src1[16][16], s16 src2[16][16], int s_src1, int s_src2, U4 bit_depth)
{
	int offset2 = 0;
#pragma HLS INLINE off
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	int diff;

	int b4x, b4y, bx, by;
	s64 ssd4[4][4];
	for (int i = 0; i < 16; i++)
	{
//#pragma HLS UNROLL factor=8
#pragma HLS PIPELINE
		b4x = (i & 0x3);
		b4y = (i >> 2);
		ssd = 0;
		for (int j = 0; j < 16; j++)
		{
			bx = (b4x << 2) + (j & 0x3);
			by = (b4y << 2) + (j >> 2);
			diff = (/*(int)*/src1[by][bx]) - (/*(int)*/src2[by][bx]);
			ssd += ((diff * diff >> shift));
		}
		ssd4[b4y][b4x] = ssd;
	}
	int w4 = w >> 2;
	int h4 = h >> 2;
	if (h4 == 1)
	{
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3];
	}
	else if (h4 == 2)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[1][0] + ssd4[1][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3];
	}
	else if (h4 == 4)
	{
		if (w4 == 1) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0];
		if (w4 == 2) ssd = ssd4[0][0] + ssd4[1][0] + ssd4[2][0] + ssd4[3][0] +
			ssd4[0][1] + ssd4[1][1] + ssd4[2][1] + ssd4[3][1];
		if (w4 == 4) ssd = ssd4[0][0] + ssd4[0][1] + ssd4[0][2] + ssd4[0][3] +
			ssd4[1][0] + ssd4[1][1] + ssd4[1][2] + ssd4[1][3] +
			ssd4[2][0] + ssd4[2][1] + ssd4[2][2] + ssd4[2][3] +
			ssd4[3][0] + ssd4[3][1] + ssd4[3][2] + ssd4[3][3];
	}

	return ssd;
	//add by xujch
}




static void inv_transform_hor_8_16(U8 cu_width, U8 cu_height, U4 md_fw_ptr_bit_depth_internal, int num_nz_ith, int mod_info_nz_tb_part,
	U3 cu_width_log2, U3 cu_height_log2, pel pred_cache_ith[16][16], s32* dist_value, pel rec[16][16], pel rec_for_update[16][16], s16 coef_tmp_ith[16][16], U3 ch_type, pel org_diff[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=num_nz_ith
#pragma HLS INTERFACE axis port=dist_value
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rec core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=org_diff core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=org_diff  complete dim=2
//#pragma HLS ARRAY_PARTITION variable=org_diff  complete dim=1
	//#pragma HLS ARRAY_PARTITION variable=rec cyclic factor=4 dim=1
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
//#pragma HLS ARRAY_PARTITION variable=rec complete dim=1
//#pragma HLS ARRAY_PARTITION variable=pred_cache_ith cyclic factor=4 dim=1
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_ith complete dim=2
//#pragma HLS ARRAY_PARTITION variable=rec_for_update complete dim=2
//#pragma HLS ARRAY_PARTITION variable=rec_for_update complete dim=1

	// STREAM BUFFER
	s32 dist_write = 0;
	int num_nz_read = num_nz_ith;

	static s16 resi[16][16];

#pragma HLS ARRAY_PARTITION variable=resi complete dim=0
	int s_org = 16;

	s32 cost = 0;

	if (num_nz_read) {
		itrans_h_8_16(cu_width, cu_height, resi, coef_tmp_ith, cu_width_log2, cu_height_log2, md_fw_ptr_bit_depth_internal);
	}
	if (ch_type) {
		//printf("resi rec:\n");
		//for (int i = 0; i < cu_height; ++i){
		//	for (int j = 0; j < cu_width; ++j){
		//		printf("%d ", resi[i][j]);
		//	}
		//	printf("\n");
		//}
	}
	/*recon_8_16((PART_SIZE)(ch_type == 0 ? mod_info_nz_tb_part : (SIZE_2Nx2N)), resi, pred_cache_ith,
		num_nz_read, ch_type, cu_width, cu_height, cu_width, rec, md_fw_ptr_bit_depth_internal);*/
	dist_write = recon_8_16((PART_SIZE)(ch_type == 0 ? mod_info_nz_tb_part : (SIZE_2Nx2N)), resi, pred_cache_ith,
		num_nz_read, ch_type, cu_width, cu_height, cu_width, rec, md_fw_ptr_bit_depth_internal, org_diff);
	/*dist_write = enc_ssd_16b_1_8_16_wsc(cu_width_log2, cu_height_log2, rec, org_diff, cu_width, s_org, md_fw_ptr_bit_depth_internal);
	for (int i = 0; i < 16; ++i) {
#pragma HLS PIPELINE
		for (int j = 0; j < 16; ++j) {
#pragma HLS UNROLL
			rec_for_update[i][j] = rec[i][j];
		}
	}*/
	// WRITE STREAMS
	*dist_value = dist_write;
}

static void inv_transform_hor_16_8(U8 cu_width, U8 cu_height, U4 md_fw_ptr_bit_depth_internal, int num_nz_ith, int mod_info_nz_tb_part,
	U3 cu_width_log2, U3 cu_height_log2, pel pred_cache_ith[16][16], s32* dist_value, pel rec[16][16], pel rec_for_update[16][16], s16 coef_tmp_ith[16][16], U3 ch_type, pel org_diff[16][16])
{
#pragma HLS INLINE OFF
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=num_nz_ith
#pragma HLS INTERFACE axis port=dist_value
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rec core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=org_diff core=RAM_1P_BRAM
#endif
#pragma HLS ARRAY_PARTITION variable=org_diff  complete dim=2
//#pragma HLS ARRAY_PARTITION variable=org_diff  complete dim=1
	//#pragma HLS ARRAY_PARTITION variable=rec cyclic factor=4 dim=1
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
//#pragma HLS ARRAY_PARTITION variable=rec complete dim=1
//#pragma HLS ARRAY_PARTITION variable=pred_cache_ith cyclic factor=4 dim=1
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_ith complete dim=2
//#pragma HLS ARRAY_PARTITION variable=rec_for_update complete dim=2

	// STREAM BUFFER
	s32 dist_write = 0;
	int num_nz_read = num_nz_ith;

	static s16 resi[16][16];

#pragma HLS ARRAY_PARTITION variable=resi complete dim=0
	int s_org = 16;

	s32 cost = 0;

	if (num_nz_read) {
		itrans_h_16_8(cu_width, cu_height, resi, coef_tmp_ith, cu_width_log2, cu_height_log2, md_fw_ptr_bit_depth_internal);
	}
	if (ch_type) {
		//printf("resi rec:\n");
		//for (int i = 0; i < cu_height; ++i){
		//	for (int j = 0; j < cu_width; ++j){
		//		printf("%d ", resi[i][j]);
		//	}
		//	printf("\n");
		//}
	}
	/*recon_16_8((PART_SIZE)(ch_type == 0 ? mod_info_nz_tb_part : (SIZE_2Nx2N)), resi, pred_cache_ith,
		num_nz_read, ch_type, cu_width, cu_height, cu_width, rec, md_fw_ptr_bit_depth_internal);*/
	dist_write = recon_16_8((PART_SIZE)(ch_type == 0 ? mod_info_nz_tb_part : (SIZE_2Nx2N)), resi, pred_cache_ith,
		num_nz_read, ch_type, cu_width, cu_height, cu_width, rec, md_fw_ptr_bit_depth_internal, org_diff);
	//dist_write = enc_ssd_16b_1_16_8_wsc(cu_width_log2, cu_height_log2, rec, org_diff, cu_width, s_org, md_fw_ptr_bit_depth_internal);
	/*for (int i = 0; i < 16; ++i) {
#pragma HLS PIPELINE
		for (int j = 0; j < 16; ++j) {
#pragma HLS UNROLL
			rec_for_update[i][j] = rec[i][j];
		}
	}*/
	// WRITE STREAMS
	*dist_value = dist_write;
}

static void inv_transform_hor_16_16(U8 cu_width, U8 cu_height, U4 md_fw_ptr_bit_depth_internal, int num_nz_ith, int mod_info_nz_tb_part,
	U3 cu_width_log2, U3 cu_height_log2, pel pred_cache_ith[16][16], s32* dist_value, pel rec[16][16], pel rec_for_update[16][16], s16 coef_tmp_ith[16][16], U3 ch_type, pel org_diff[16][16])
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=num_nz_ith
#pragma HLS INTERFACE axis port=dist_value
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rec core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=org_diff core=RAM_1P_BRAM
#endif
// #pragma HLS pipeline
#pragma HLS ARRAY_PARTITION variable=org_diff  complete dim=2
	// #pragma HLS ARRAY_PARTITION variable=rec cyclic factor=4 dim=1
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
// #pragma HLS ARRAY_PARTITION variable=pred_cache_ith cyclic factor=4 dim=1
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp_ith complete dim=1
#pragma HLS ARRAY_PARTITION variable=rec_for_update complete dim=2

	// STREAM BUFFER
	s32 dist_write = 0;
	int num_nz_read = num_nz_ith;

	s16 resi[16][16];

#pragma HLS ARRAY_PARTITION variable=resi complete dim=2
	int s_org = 16;

	s32 cost = 0;

	if (num_nz_read) {
		itrans_h_16_16(cu_width, cu_height, resi, coef_tmp_ith, cu_width_log2, cu_height_log2, md_fw_ptr_bit_depth_internal);
	}
	if (ch_type) {
		//printf("resi rec:\n");
		//for (int i = 0; i < cu_height; ++i){
		//	for (int j = 0; j < cu_width; ++j){
		//		printf("%d ", resi[i][j]);
		//	}
		//	printf("\n");
		//}
	}
	dist_write = recon_16_16((PART_SIZE)(ch_type == 0 ? mod_info_nz_tb_part : (SIZE_2Nx2N)), resi, pred_cache_ith,
		num_nz_read, ch_type, cu_width, cu_height, cu_width, rec, md_fw_ptr_bit_depth_internal, org_diff);

	//dist_write = enc_ssd_16b_1_16_16_wsc(cu_width_log2, cu_height_log2, rec, org_diff, cu_width, s_org, md_fw_ptr_bit_depth_internal);
	/*for (int i = 0; i < 16; ++i) {
#pragma HLS PIPELINE
		for (int j = 0; j < 16; ++j) {
			rec_for_update[i][j] = rec[i][j];
		}
	}*/
	// WRITE STREAMS
	*dist_value = dist_write;
}

void Ipred_vert_Chroma16(U8 cu_width, U8 cu_height, pel src_up[16 * 2 + 3],  pel pred_cache_16x16[16][16], pel pred[16][16])
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable = src_up complete dim=0

#pragma HLS ARRAY_PARTITION variable = pred_cache_16x16 complete dim=2
#pragma HLS ARRAY_PARTITION variable = pred complete dim=2

	int i, j;
	for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
			//#pragma HLS loop_tripcount max = 16
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
			for (j = 0; j < 16; j++) {
				//#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = src_up[j];
					pred[i][j] = src_up[j];
				//coef_tmp_16x16[i][j] = orgY[i][j] - pred_cache_16x16[i][j];
				}
			}
	}
}
void Ipred_hor_Chroma16(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3],  pel pred_cache_16x16[16][16], pel pred[16][16])
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable = src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = pred_cache_16x16 complete dim=2
#pragma HLS ARRAY_PARTITION variable = pred complete dim=2

	int i, j;
	for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
			for (j = 0; j < 16; j++) {
				//#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = src_le[i];
					pred[i][j] = src_le[i];
					//coef_tmp_16x16[i][j] = orgY[i][j] - pred_cache_16x16[i][j];
				}
			}
		
	}
}
void Ipred_dc_Chroma16(U3 cu_width_log2, U3 cu_height_log2, U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, u16 avail_cu,
	 pel pred_cache_16x16[16][16], pel pred[16][16])
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable = src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable = pred complete dim=2
#pragma HLS ARRAY_PARTITION variable = pred_cache_16x16 complete dim=2


	int dc = 0;
	//	int wh;
	int i;
	int j;
	int offset_s1 = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
	if (((avail_cu) & 1 << 1) == 1 << 1) {
		for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
			if (i < cu_height)
				dc += (src_le[i]);
		}
		if (((avail_cu) & 1 << 0) == 1 << 0) {
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
					dc += (src_up[j]);
			}
			//dc = (dc + ((cu_width + cu_height) >> 1)) * (4096 / (cu_width + cu_height)) >> 12;
			if (cu_width == cu_height)
				dc = (dc + ((32) >> 1)) * (128) >> 12;
			if ((cu_width + cu_height) == 20)
				dc = (dc + ((20) >> 1)) * (204) >> 12;
			if ((cu_width + cu_height) == 24)
				dc = (dc + ((24) >> 1)) * (170) >> 12;
		}
		else {
			dc = (dc + (cu_height >> 1)) >> cu_height_log2;// (com_tbl_log2[cu_height]);
		}
	}
	else if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
				dc += (src_up[j]);
		}
		dc = (dc + (cu_width >> 1)) >> cu_width_log2;// (com_tbl_log2[cu_width]);
	}
	else {
		dc = 1 << (bit_depth - 1);
	}

	for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
			//#pragma HLS loop_tripcount max = 16
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = dc;
					pred[i][j] = dc;
					//coef_tmp_16x16[i][j] = orgY[i][j] - dc;
				}
			}
		
	}

}
void Ipred_plane_Chroma16(U3 cu_width_log2, U3 cu_height_log2, U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth,  pel pred_cache_16x16[16][16], pel pred[16][16])
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_cache_16x16 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred complete dim=2
	//pel *rsrc;
	int coef_h = 0;
	int coef_v = 0;
	int a;
	int b;
	int c;
	int x;
	int y;
	//int w2 = W >> 1;
	//int h2 = H >> 1;
	int ib_mult[5] = { (13), (17), (5), (11), (23) };
	int ib_shift[5] = { (7), (10), (11), (15), (19) };
#pragma HLS ARRAY_PARTITION variable=ib_mult complete dim=0
#pragma HLS ARRAY_PARTITION variable=ib_shift complete dim=0
	int idx_w = cu_width_log2 - 2;// (com_tbl_log2[cu_width]) - 2;
	int idx_h = cu_height_log2 - 2;// (com_tbl_log2[cu_height]) - 2;
	int im_h;
	int is_h;
	int im_v;
	int is_v;
	int temp;

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
	int pred_cache;



	im_h = ib_mult[idx_w];
	is_h = ib_shift[idx_w];
	im_v = ib_mult[idx_h];
	is_v = ib_shift[idx_h];
	//rsrc = src_up + (w2 - 1);
	//rsrc = src_up;
	for (x = 1; x < (16 >> 1) + 1; x++) {
#pragma HLS UNROLL
		if (x < (cu_width >> 1) + 1)
			coef_h += x * ((src_up[(cu_width >> 1) + x]) - (src_up[(cu_width >> 1) - x]));
	}
	//rsrc = src_le + (h2 - 1);
	//rsrc = src_le;
	for (y = 1; y < (16 >> 1) + 1; y++) {
#pragma HLS UNROLL
		if (y < (cu_height >> 1) + 1)
			coef_v += y * ((src_le[(cu_height >> 1) + y]) - (src_le[(cu_height >> 1) - y]));
	}
	a = (src_le[cu_height] + src_up[cu_width]) << 4;
	b = ((coef_h << 5) * im_h + (1 << (is_h - 1))) >> is_h;
	c = ((coef_v << 5) * im_v + (1 << (is_v - 1))) >> is_v;
	temp = a - ((cu_height >> 1) - 1) * c - ((cu_width >> 1) - 1) * b + 16;

	int i, j;
	int temp2;
	pel tmp_a_buf[16];
	for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE II=1
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
		//if( i < cu_height){
//#pragma HLS loop_tripcount max = 16
		temp2 = temp;
		for (j = 0; j < 16; j++) {
			if (j < cu_width)
			{
				tmp_a_buf[j] = (temp2 >> 5);
				temp2 += b;
			}
			else {
				tmp_a_buf[j] = 0;
			}
		}
		for (j = 0; j < 16; j++) {
			pred_cache = tmp_a_buf[j];
				pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))) ? 0 : (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))))));
				pred[i][j] = (((0 > (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))) ? 0 : (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))))));
				//temp2 += b;
				//coef_tmp_16x16[i][j] = orgY[i][j] - pred_cache_16x16[i][j];
			}

		temp += c;
		//}
	}

}
void Ipred_bi_Chroma16(U3 cu_width_log2, U3 cu_height_log2, U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, pel pred_cache_16x16[16][16], pel pred[16][16])
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable = src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable = pred_cache_16x16 complete dim=2
#pragma HLS ARRAY_PARTITION variable = pred complete dim=2

	int x;
	int y;
	int ishift_x = cu_width_log2;// com_tbl_log2[cu_width];
	int ishift_y = cu_height_log2;// com_tbl_log2[cu_height];
	int ishift = ishift_x < ishift_y ? ishift_x : ishift_y;
	int ishift_xy = ishift_x + ishift_y + 1;
	int offset = 1 << (ishift_x + ishift_y);
	int a;
	int b;
	int c;
	int wt;
	int wxy;
	int tmp;
	int predx;
	static int ref_up[16];
	static int ref_le[16];
	static int up[16];
	static int le[16];
	static int wy[16];
	int wc;
	int tbl_wc[6] = { (-1), (21), (13), (7), (4), (2) };

#pragma HLS ARRAY_PARTITION variable = ref_up complete dim=0
#pragma HLS ARRAY_PARTITION variable = ref_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = up complete dim=0
#pragma HLS ARRAY_PARTITION variable = le complete dim=0
#pragma HLS ARRAY_PARTITION variable = wy complete dim=0
	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;

	wc = (ishift_x > ishift_y ? ishift_x - ishift_y : ishift_y - ishift_x);
	wc = tbl_wc[wc];
	a = (src_up[cu_width - 1]);
	b = (src_le[cu_height - 1]);
	c = (cu_width == cu_height ? (a + b + 1) >> 1 : (((a << ishift_x) + (b << ishift_y)) * wc + (1 << (ishift + 5))) >> (ishift + 6));
	wt = (c << 1) - a - b;
	for (x = 0; x < 16; x++) {
#pragma HLS UNROLL
		if (x < cu_width)
		{
			ref_up[x] = src_up[x];
		}
	}
	for (x = 0; x < 16; x++) {
#pragma HLS UNROLL
		if (x < cu_width)
		{
			up[x] = b - src_up[x];
			//		ref_up[x] = src_up[x] << ishift_y;
			ref_up[x] <<= ishift_y;
		}
	}
	for (y = 0; y < 16; y++) {
#pragma HLS UNROLL
		if (y < cu_height)
		{
			ref_le[y] = src_le[y];
		}
	}
	tmp = 0;
	for (y = 0; y < 16; y++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
		if (y < cu_height)
		{
			le[y] = a - src_le[y];
			//		ref_le[y] = src_le[y] << ishift_x;
			ref_le[y] <<= ishift_x;
			wy[y] = tmp;// wt* y;
			tmp += wt;
		}
	}
	int i, j; int temp;
	pel tmp_a_buf[16];
	for (i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
		predx = ref_le[i];
		wxy = 0;
			for (j = 0; j < 16; j++) {
				if (j < cu_width)
				{
				predx += le[i];
					ref_up[j] += up[j];
				tmp_a_buf[j] = ((predx << ishift_y) + (ref_up[j] << ishift_x) + wxy + offset) >> ishift_xy;
				wxy += wy[i];
			}
			else {
				tmp_a_buf[j] = 0;
			}
		}
		for (j = 0; j < 16; j++) {
			temp = tmp_a_buf[j];
					pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))) ? 0 : (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))))));
					pred[i][j] = (((0 > (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))) ? 0 : (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))))));
					//coef_tmp_16x16[i][j] = orgY[i][j] - pred_cache_16x16[i][j];
				}
			}
		

}

void ipred_ang_val_Chroma16(s16 pred_cache_16x16[16][16], pel pred[16][16], pel src_up[35], pel src_le[35], s8 ipm, U4 bit_depth, int m, int n, int w, int h
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_cache_16x16 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred complete dim=2
	u8 i, j;
	//static const s16 com_tbl_ipred_dxdy[33][2] = { { 0, 0 }, { 0, 0 }, { 0, 0 }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) }, { 0, 0 }, { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) }, { 0, 0 }, { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};

#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_bilinear complete dim=0
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_extra_smooth complete dim=0
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_semi_sharp complete dim=0
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_hp complete dim=0
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
#pragma HLS ARRAY_PARTITION variable=filter_offset_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=filter_bits_list complete dim=0
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;

	static const s16 ipred_dxdy1[9] =
	{ (2816),
	  (2048),
	  (1408),
	  (1024),
	  (744),
	  (512),
	  (372),
	  (256),
	  (128) };
	static const s16 ipred_dxdy2[8] =
	{ (128) ,
	   (256) ,
	   (372) ,
	   (512) ,
	   (744) ,
	   (1024),
	  (1408) ,
	  (2048) };
	static const s16 ipred_dxdy3[11][2] = { { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) } };


#pragma HLS ARRAY_PARTITION variable=ipred_dxdy1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy2 complete dim=0
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy3 complete dim=0

	int offset;
	int offset_x;
	int offset_y;
	int t_dx;
	int t_dy;
	int xx;
	int xy;
	int yx;
	int yy;
	int x;
	int y;
	int xn;
	int yn;
	int xn_n1;
	int yn_n1;
	int xn_p2;
	int yn_p2;
	int p;
	int pn;
	int pn_n1;
	int pn_p2;
	x = 2147483647;
	xn = 2147483647;
	xn_n1 = 2147483647;
	xn_p2 = 2147483647;
	y = 2147483647;
	yn = 2147483647;
	yn_n1 = 2147483647;
	yn_p2 = 2147483647;
	xx = 2147483647;
	yy = 2147483647;
	pel temp_pel = (pel)0;
	int use_x = -1;
	int pos_max;
	int filter_idx;

	//int h_flag = ((ipm >= 3 && ipm <= 11) || (ipm >= 25 && ipm <= 32)) ? h : 16;
	//int w_flag = ((ipm >= 3 && ipm <= 11) || (ipm >= 25 && ipm <= 32)) ? w : 16;
	//printf("%d\n", ipm);
	const int dxy = ipm > 24 || ipm < 12 ? -1 : 1;
	pel tmp_a[16];
  s16 temp1,temp2,temp3,temp4;
#pragma HLS ARRAY_PARTITION variable=tmp_a complete dim=0
	for (j = 0; j < h; j++) {
#pragma HLS PIPELINE II=1
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
			for (i = 0; i < 16; i++) {

				if (i < w)
				{

					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;// MIPF
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;// MIPF
					}

					//pel * src_ch = NULL;
					int num_selections = 0;


					//if (ipm == 12) {
					//	return src_up[i + 3];
					//}
					//else if (ipm == 24) {
					//	return src_le[j + 3];
					//}
					if (ipm >= 3 && ipm <= 11) {
						/* case x-line */
						t_dx = (j + 1) * ipred_dxdy1[ipm - 3] >> 10;
						offset = ((j + 1) * ipred_dxdy1[ipm - 3] >> 5) - (t_dx << 5);
						;
						x = i + t_dx;
						y = -1;
					}
					else if (ipm >= 25 && ipm <= 32) {
						t_dy = (i + 1) * ipred_dxdy2[ipm - 25] >> 10;
						offset = ((i + 1) * ipred_dxdy2[ipm - 25] >> 5) - (t_dy << 5);
						;
						x = -1;
						y = j + t_dy;
					}
					else {
						t_dx = (j + 1) * ipred_dxdy3[ipm - 13][0] >> 10;
						offset_x = ((j + 1) * ipred_dxdy3[ipm - 13][0] >> 5) - (t_dx << 5);
						;
						t_dx = -t_dx;
						xx = i + t_dx;
						yx = -1;
						t_dy = (i + 1) * ipred_dxdy3[ipm - 13][1] >> 10;
						offset_y = ((i + 1) * ipred_dxdy3[ipm - 13][1] >> 5) - (t_dy << 5);
						;
						t_dy = -t_dy;
						xy = -1;
						yy = j + t_dy;

						if (yy <= -1) {
							x = xx;
							y = yx;
							offset = offset_x;
						}
						else {
							x = xy;
							y = yy;
							offset = offset_y;
						}
					}
					//com_assert(x != INT_MAX);
					//com_assert(y != INT_MAX);
					if (y == -1) {
						pos_max = w * 2 - 1;
						if (dxy < 0) {
							xn_n1 = x - 1;
							xn = x + 1;
							xn_p2 = x + 2;
							//xn_n1 = (xn_n1 < pos_max ? xn_n1 : pos_max);
						}
						else {
							xn_n1 = x + 1;
							xn = x - 1;
							xn_p2 = x - 2;
						}
						use_x = 1;
						++num_selections;
						//src_ch = src_up;
					}
					else if (x == -1) {
						pos_max = h * 2 - 1;
						if (dxy < 0) {
							yn_n1 = y - 1;
							yn = y + 1;
							yn_p2 = y + 2;
							//yn_n1 = (yn_n1 < pos_max ? yn_n1 : pos_max);
						}
						else {
							yn_n1 = y + 1;
							yn = y - 1;
							yn_p2 = y - 2;
						}
						use_x = 0;
						++num_selections;
						//src_ch = src_le;

					}
					//com_assert(num_selections == 1);
					//com_assert(src_ch != NULL);
					if (use_x == 1) {
						pn_n1 = xn_n1;
						p = x;
						pn = xn;
						pn_p2 = xn_p2;
					}
					else {
						pn_n1 = yn_n1;
						p = y;
						pn = yn;
						pn_p2 = yn_p2;
					}
					if (dxy < 0) {
						pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
						p = (p < pos_max ? p : pos_max);
						pn = (pn < pos_max ? pn : pos_max);
						pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);
					}
					pn_n1 += 3;
					p += 3;
					pn += 3;
					pn_p2 += 3;

					int src_p, src_pn, src_pn_n1, src_pn_p2;

					if (y == -1) {
						src_pn_n1 = src_up[pn_n1];
						src_p = src_up[p];
						src_pn = src_up[pn];
						src_pn_p2 = src_up[pn_p2];
					}
					else if (x == -1) {
						src_pn_n1 = src_le[pn_n1];
						src_p = src_le[p];
						src_pn = src_le[pn];
						src_pn_p2 = src_le[pn_p2];
					}
					else {
						src_pn_n1 = 0;
						src_p = 0;
						src_pn = 0;
						src_pn_p2 = 0;
					}
          if (filter_idx == 0) {
            temp1 = com_tbl_ipred_adi_extra_smooth[offset][0];
            temp2 = com_tbl_ipred_adi_extra_smooth[offset][1];
            temp3 = com_tbl_ipred_adi_extra_smooth[offset][2];
            temp4 = com_tbl_ipred_adi_extra_smooth[offset][3];
          } else if (filter_idx == 1) {
            temp1 = com_tbl_ipred_adi_semi_sharp[offset][0];
            temp2 = com_tbl_ipred_adi_semi_sharp[offset][1];
            temp3 = com_tbl_ipred_adi_semi_sharp[offset][2];
            temp4 = com_tbl_ipred_adi_semi_sharp[offset][3];
          } else if (filter_idx == 2) {
            temp1 = tbl_mc_c_coeff_hp[offset][0];
            temp2 = tbl_mc_c_coeff_hp[offset][1];
            temp3 = tbl_mc_c_coeff_hp[offset][2];
            temp4 = tbl_mc_c_coeff_hp[offset][3];
          } else if (filter_idx == 3) {
            temp1 = com_tbl_ipred_adi_bilinear[offset][0];
            temp2 = com_tbl_ipred_adi_bilinear[offset][1];
            temp3 = com_tbl_ipred_adi_bilinear[offset][2];
            temp4 = com_tbl_ipred_adi_bilinear[offset][3];
          }
            tmp_a[i] = (pel)((src_pn_n1 * temp1 + src_p * temp2 +
              src_pn * temp3 + src_pn_p2 * temp4 +
              filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					// if (filter_idx == 0)
						// tmp_a[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_extra_smooth[offset][0] + src_p * com_tbl_ipred_adi_extra_smooth[offset][1] +
							// src_pn * com_tbl_ipred_adi_extra_smooth[offset][2] + src_pn_p2 * com_tbl_ipred_adi_extra_smooth[offset][3] +
							// filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					// else if (filter_idx == 1)
						// tmp_a[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_semi_sharp[offset][0] + src_p * com_tbl_ipred_adi_semi_sharp[offset][1] +
							// src_pn * com_tbl_ipred_adi_semi_sharp[offset][2] + src_pn_p2 * com_tbl_ipred_adi_semi_sharp[offset][3] +
							// filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					// else if (filter_idx == 2)
						// tmp_a[i] = (pel)((src_pn_n1 * tbl_mc_c_coeff_hp[offset][0] + src_p * tbl_mc_c_coeff_hp[offset][1] +
							// src_pn * tbl_mc_c_coeff_hp[offset][2] + src_pn_p2 * tbl_mc_c_coeff_hp[offset][3] +
							// filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					// else if (filter_idx == 3)
						// tmp_a[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_bilinear[offset][0] + src_p * com_tbl_ipred_adi_bilinear[offset][1] +
							// src_pn * com_tbl_ipred_adi_bilinear[offset][2] + src_pn_p2 * com_tbl_ipred_adi_bilinear[offset][3] +
							// filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
				}
			}

			for (i = 0; i < 16; i++) {
				if (i < w) {
					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp_a[i]);
					//printf("%d", temp_pel);
					pred_cache_16x16[j][i] = temp_pel;
					pred[j][i] = temp_pel;
					//dst[j][i] = ((pel)((0 > (((1 << bit_depth) - 1 < ((int)temp_pel) ? (1 << bit_depth) - 1 : ((int)temp_pel))) ? 0 : (((1 << bit_depth) - 1 < ((
							//int)temp_pel) ? (1 << bit_depth) - 1 : ((int)temp_pel))))));
					//coef_tmp_16x16[j][i] = orgY[j][i] - temp_pel;
				}
			}
		
	}
	//printf("\n");
}



void ipred_ang_Chroma16(pel src_le[35], pel src_up[35], s16 dst[16][16], pel pred[16][16],U4 bit_depth, U7 w, U7 h, S8 ipm
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS INLINE
	ipred_ang_val_Chroma16(dst, pred, src_up, src_le, ipm, bit_depth, 0, 0, w, h
#if MIPF
		, is_luma, mipf_enable_flag
#endif
	);
}


void ipred_ang1_16(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, s16 orgY[256], pel pred_cache_16x16[16][16], s16 coef_tmp_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	// const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	// const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[9][2] = { { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) } };

	int i, j, t_dx, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int x = 2147483647;
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE
#pragma HLS array_partition variable = orgY cyclic factor=64  dim=1
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#else
#pragma HLS array_partition variable = orgY complete  dim=0
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=0
#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height) {
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					/* case x-line */
					t_dx = (j + 1) * ipred_dxdy[ipm - 3][0] >> 10;
					offset = ((j + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dx << 5);
					x = i + t_dx;

					pn_n1 = x - 1;
					p = x;
					pn = x + 1;
					pn_p2 = x + 2;
					pos_max = cu_width * 2 - 1;

					pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
					p = (p < pos_max ? p : pos_max);
					pn = (pn < pos_max ? pn : pos_max);
					pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF
					filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
					//temp_pel = (pel)((src_up[pn_n1 + 3] * filter[0] + src_up[p + 3] * filter[1] +
					   // src_up[pn + 3] * filter[2] + src_up[pn_p2 + 3] * filter[3] +
					   // filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1

					if (filter_idx == 0)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 1)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 2)
						temp_pel = (pel)((src_up[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_up[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
							src_up[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 3)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
					pred_cache_16x16[j][i] = temp_pel;
					coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#else

					pred_cache_16x16[j][i] = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + (src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
					coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#endif

				}
			}
		}
	}

}

void ipred_ang2_16(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, s16 orgY[256], pel pred_cache_16x16[16][16], s16 coef_tmp_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[8][2] = { { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };
	//#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	int i, j, t_dy, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int y = 2147483647;

#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE
#pragma HLS array_partition variable = orgY cyclic factor=64  dim=1
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#else
#pragma HLS array_partition variable = orgY complete  dim=0
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=0
#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height) {
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					t_dy = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
					offset = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dy << 5);
					y = j + t_dy;
					pn_n1 = y - 1;
					p = y;
					pn = y + 1;
					pn_p2 = y + 2;
					pos_max = cu_height * 2 - 1;

					pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
					p = (p < pos_max ? p : pos_max);
					pn = (pn < pos_max ? pn : pos_max);
					pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF									
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
					//temp_pel = (pel)((src_le[pn_n1 + 3] * filter[0] + src_le[p + 3] * filter[1] +
					   // src_le[pn + 3] * filter[2] + src_le[pn_p2 + 3] * filter[3] +
					   // filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

					if (filter_idx == 0)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 1)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 2)
						temp_pel = (pel)((src_le[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_le[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
							src_le[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 3)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
					pred_cache_16x16[j][i] = temp_pel;
					coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];

#else
					pred_cache_16x16[j][i] = ((src_le[pn_n1 + 3]) * (32 - offset) + (src_le[p + 3]) * (64 - offset) + (src_le[pn + 3]) * (32 + offset) + (src_le[pn_p2 + 3]) * offset + 64) >> 7;
					coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#endif
				}
			}
		}
	}

}

void ipred_ang3_16(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, s16 orgY[256], pel pred_cache_16x16[16][16], s16 coef_tmp_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF

	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	//pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[11][2] = { { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) } };
	//#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	int i, j;
	int offset, offset_x, offset_y, xx, yy, t_dx, t_dy;
	int p, pn, pn_n1, pn_p2, pos_max;
	pel temp_pel = 0;
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE
#pragma HLS array_partition variable = orgY cyclic factor=64  dim=1
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#else
#pragma HLS array_partition variable = orgY complete  dim=0
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=0
#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height)
		{
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					t_dx = (j + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_x = ((j + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dx << 5);
					t_dx = -t_dx;
					xx = i + t_dx;
					t_dy = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_y = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dy << 5);
					t_dy = -t_dy;
					yy = j + t_dy;

					if (yy <= -1) {
						offset = offset_x;
						pn_n1 = xx + 1;
						p = xx;
						pn = xx - 1;
						pn_p2 = xx - 2;
						pos_max = cu_width * 2 - 1;

#if MIPF
						if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
							filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
						}
						else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
							filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
						}
						/*filter = (tbl_filt_list[filter_idx] + offset)[0];
						temp_pel = (pel)((src_up[pn_n1 + 3] * filter[0] + src_up[p + 3] * filter[1] +
							src_up[pn + 3] * filter[2] + src_up[pn_p2 + 3] * filter[3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

						if (filter_idx == 0)
							temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_up[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_up[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							temp_pel = (pel)((src_up[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_up[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
								src_up[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_up[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);

						temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
#else
						temp_pel = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + ((
							int)src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
#endif
					}
					else {
						offset = offset_y;
						pn_n1 = yy + 1;
						p = yy;
						pn = yy - 1;
						pn_p2 = yy - 2;
						pos_max = cu_height * 2 - 1;

#if MIPF
						if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
							filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
						}
						else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
							filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
						}
						//filter = (tbl_filt_list[filter_idx] + offset)[0];
						/*temp_pel = (pel)((src_le[pn_n1 + 3] * filter[0] + src_le[p + 3] * filter[1] +
							src_le[pn + 3] * filter[2] + src_le[pn_p2 + 3] * filter[3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

						if (filter_idx == 0)
							temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_le[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
						else if (filter_idx == 1)
							temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_le[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
						else if (filter_idx == 2)
							temp_pel = (pel)((src_le[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_le[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
								src_le[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
						else if (filter_idx == 3)
							temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_le[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

						temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);

#else					
						temp_pel = ((src_le[pn_n1 + 3]) * (32 - offset) + (src_le[p + 3]) * (64 - offset) + (src_le[pn + 3]) * (32 + offset) + (src_le[pn_p2 + 3]) * offset + 64) >> 7;

#endif
					}
					pred_cache_16x16[j][i] = temp_pel;
					coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
				}
			}
		}
	}
}


void Ipred_8_16_diff(U8 cu_width, U8 cu_height, s16 orgY[256], pel pred_cache_16x16[16][16], s16 coef_tmp_16x16[16][16])
{

#if CMOD_LUMA_16_LITE
#pragma HLS array_partition variable = orgY cyclic factor=64  dim=1
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#else
#pragma HLS array_partition variable = orgY complete  dim=0
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#endif

	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		if (i < cu_height) {
			for (j = 0; j < 16; j++) {
				if (j < cu_width)
				{
					coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}
}

void Ipred_16_8_diff(U8 cu_width, U8 cu_height, s16 orgY[256], pel pred_cache_16x16[16][16], s16 coef_tmp_16x16[16][16])
{

#if CMOD_LUMA_16_LITE
#pragma HLS array_partition variable = orgY cyclic factor=64  dim=1
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#else
#pragma HLS array_partition variable = orgY complete  dim=0
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#endif

	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		if (i < cu_height) {
			for (j = 0; j < 16; j++) {
				if (j < cu_width)
				{
					coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}
}

void Ipred_16_16_diff(U8 cu_width, U8 cu_height, s16 orgY[256], pel pred_cache_16x16[16][16], s16 coef_tmp_16x16[16][16])
{
//#pragma HLS PIPELINE
#if CMOD_LUMA_16_LITE
#pragma HLS array_partition variable = orgY cyclic factor=64  dim=1
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#else
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = coef_tmp_16x16 complete dim=2
#endif

	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		if (i < cu_height) {
			for (j = 0; j < 16; j++) {
				if (j < cu_width)
				{
					coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}
}



void ipred_ang_eipm_8_16_pred(pel src_le[35], pel src_up[35], int w, int h, int ipm
#if MIPF
	, int is_luma, int mipf_enable_flag, U4 bit_depth, pel pred_for_diff[16][16]
#endif
)
{
	pel tmp, tmp1;
	static const int com_tbl_ipred_dxdy[IPD_CNT][2] = /* {dx/dy, dy/dx} */
	{
		{0, 0},{0, 0},{0, 0},                                 //0~2
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //3~6
		{744, 1408},{512, 2048},                              //7~8
		{372, 2816},                                          //9
		{256, 4096},                                          //10
		{128, 8192},{0, 0},{128, 8192},{256, 4096},           //11~14
		{372, 2816},{512, 2048},{744, 1408},{1024, 1024},     //15~18
		{1408, 744},{2048, 512},{2816, 372},                  //19~21
		{4096, 256},                                          //22
		{8192, 128},{0, 0},{8192, 128},{4096, 256},           //23~26
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //27~30
		{744, 1408},{ 512, 2048 },{0, 0},{2340, 448},         //31~34
		{1640, 640},                                          //35
		{1168, 898},{898, 1168},{640, 1640},{448, 2340},      //36~39
		{320, 3276},{192, 5460},{64, 16384},{32, 32768},      //40~43
		{32, 32768},{64, 16384},{192, 5460},{320, 3276},      //44~47
		{448, 2340},                                          //48
		{640, 1640},{898, 1168},{1168, 898},{1640, 640},      //49~52
		{2340, 448},{3276, 320},{5460, 192},{16384, 64},      //53~56
		{32768, 32},{32768, 32},{16384, 64},{5460, 192},      //57~60
		{3276, 320},{2340, 448},                              //61~62
		{1640, 640},{1168, 898},{898, 1168}                   //63~65
	};
#if MIPF

	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#else
	static const s16 com_tbl_ipred_adi[32][4] = { { (32), (64), (32), 0 }, { (31), (63), (33), (1) }, { (30), (62), (34), (2) }, { (29), (61), (35), (3) }, { (28), (60), (36), (4) }, { (27), (59), (37), (5) }, { (26), (58), (38), (6) }, { (25), (57), (39), (7) }, { (24), (56), (40), (8) }, { (23), (55), (41), (9) }, { (22), (54), (42), (10) }, { (21), (53), (43), (11) }, { (20), (52), (44), (12) }, { (19), (51), (45), (13) }, { (18), (50), (46), (14) }, { (17), (49), (47), (15) }, { (16), (48), (48), (16) }, { (15), (47), (49), (17) }, { (14), (46), (50), (18) }, { (13), (45), (51), (19) }, { (12), (44), (52), (20) }, { (11), (43), (53), (21) }, { (10), (42), (54), (22) }, { (9), (41), (55), (23) }, { (8), (40), (56), (24) }, { (7), (39), (57), (25) }, { (6), (38), (58), (26) }, { (5), (37), (59), (27) }, { (4), (36), (60), (28) }, { (3), (35), (61), (29) }, { (2), (34), (62), (30) }, { (1), (33), (63), (31) } };
#endif

#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
#else
	const s16(*tbl_filt)[4] = com_tbl_ipred_adi;
	const int filter_offset = ADI_4T_FILTER_OFFSET;
	const int filter_bits = ADI_4T_FILTER_BITS;
#endif

	const int* mt = com_tbl_ipred_dxdy[ipm];

	//const pel* src_ch = NULL;
	//const s16* filter;

	int offset_x[MAX_CU_SIZE], offset_y[MAX_CU_SIZE];
	int t_dx[MAX_CU_SIZE], t_dy[MAX_CU_SIZE];
	int i, j;
	int offset;
	int pos_max = w + h - 1;
	int p, pn, pn_n1, pn_p2;

#if EIPM
	if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT))
#else
	if (ipm < IPD_VER)
#endif
	{
		//src_ch = src_up;
		pos_max = w * 2 - 1;

		for (j = 0; j < h; j++)
		{
			int dx;
			GET_REF_POS(mt[0], j + 1, dx, offset);
#if MIPF
			filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
			//filter = (tbl_filt_list[filter_idx] + offset)[0];
#else
			filter = (tbl_filt + offset)[0];
#endif
			for (i = 0; i < w; i++)
			{
				int x = i + dx;
				pn_n1 = x - 1;
				p = x;
				pn = x + 1;
				pn_p2 = x + 2;

				pn_n1 = COM_MIN(pn_n1, pos_max);
				p = COM_MIN(p, pos_max);
				pn = COM_MIN(pn, pos_max);
				pn_p2 = COM_MIN(pn_p2, pos_max);

#if MIPF
				/*dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

				if (filter_idx == 0)
					tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
						src_up[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 1)
					tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
						src_up[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 2)
					tmp = (pel)((src_up[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_up[p] * tbl_mc_c_coeff_hp[offset][1] +
						src_up[pn] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 3)
					tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p] * com_tbl_ipred_adi_bilinear[offset][1] +
						src_up[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				//diff[j][i] = orgY[(j * 16) + i] - tmp1;
				pred_for_diff[j][i] = tmp1;
#else
				dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					filter_offset) >> filter_bits);
#endif
			}
			//dst += w;
		}
	}
#if EIPM
	else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
#else
	else if (ipm > IPD_HOR)
#endif
	{
		//src_ch = src_le;
		pos_max = h * 2 - 1;

		for (i = 0; i < w; i++)
		{
			GET_REF_POS(mt[1], i + 1, t_dy[i], offset_y[i]);
		}

		for (j = 0; j < h; j++)
		{
			for (i = 0; i < w; i++)
			{
				int y = j + t_dy[i];
				pn_n1 = y - 1;
				p = y;
				pn = y + 1;
				pn_p2 = y + 2;

#if  MIPF
				filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offset_y[i])[0];
#else
				filter = (tbl_filt + offset_y[i])[0];
#endif

				pn_n1 = COM_MIN(pn_n1, pos_max);
				p = COM_MIN(p, pos_max);
				pn = COM_MIN(pn, pos_max);
				pn_p2 = COM_MIN(pn_p2, pos_max);

#if MIPF

				/*  dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					  src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					  filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

				int offset_y_new = offset_y[i];
				if (filter_idx == 0)
					tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset_y_new][0] + src_le[p] * com_tbl_ipred_adi_extra_smooth[offset_y_new][1] +
						src_le[pn] * com_tbl_ipred_adi_extra_smooth[offset_y_new][2] + src_le[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 1)
					tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset_y_new][0] + src_le[p] * com_tbl_ipred_adi_semi_sharp[offset_y_new][1] +
						src_le[pn] * com_tbl_ipred_adi_semi_sharp[offset_y_new][2] + src_le[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 2)
					tmp = (pel)((src_le[pn_n1] * tbl_mc_c_coeff_hp[offset_y_new][0] + src_le[p] * tbl_mc_c_coeff_hp[offset_y_new][1] +
						src_le[pn] * tbl_mc_c_coeff_hp[offset_y_new][2] + src_le[pn_p2] * tbl_mc_c_coeff_hp[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 3)
					tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_bilinear[offset_y_new][0] + src_le[p] * com_tbl_ipred_adi_bilinear[offset_y_new][1] +
						src_le[pn] * com_tbl_ipred_adi_bilinear[offset_y_new][2] + src_le[pn_p2] * com_tbl_ipred_adi_bilinear[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				//diff[j][i] = orgY[(j * 16) + i] - tmp1;
				pred_for_diff[j][i] = tmp1;

#else
				dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					filter_offset) >> filter_bits);
#endif
			}
			//dst += w;
		}
	}
	else
	{
		for (i = 0; i < w; i++)
		{
			GET_REF_POS(mt[1], i + 1, t_dy[i], offset_y[i]);
			t_dy[i] = -t_dy[i];
		}
		for (j = 0; j < h; j++)
		{
			GET_REF_POS(mt[0], j + 1, t_dx[j], offset_x[j]);
			t_dx[j] = -t_dx[j];
		}
#if MIPF
#if EIPM
		if (ipm < IPD_DIA_R || (ipm > IPD_VER_EXT && ipm <= IPD_DIA_R_EXT))
#else
		if (ipm < IPD_DIA_R)
#endif
		{
#endif
			for (j = 0; j < h; j++)
			{
#if  MIPF
				filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
#endif
				for (i = 0; i < w; i++)
				{
					int x = i + t_dx[j];
					int y = j + t_dy[i];

					if (y <= -1)
					{
						//src_ch = src_up;
						offset = offset_x[j];
						pos_max = w * 2 - 1;

						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
					}
					else
					{
						//src_ch = src_le;
						offset = offset_y[i];
						pos_max = h * 2 - 1;

						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
					}

#if  MIPF
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
#else
					filter = (tbl_filt + offset)[0];
#endif

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);

#if MIPF

					/*dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/
					if (y <= -1) {
						if (filter_idx == 0)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_up[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_up[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_up[pn] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					else {
						if (filter_idx == 0)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_le[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_le[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_le[pn] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
					//diff[j][i] = orgY[(j * 16) + i] - tmp1;
					pred_for_diff[j][i] = tmp1;
#else
					dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset) >> filter_bits);
#endif
				}
				//dst += w;	com_assert(NULL != dst);
			}
#if MIPF
		}
		else
		{
			for (j = 0; j < h; j++)
			{
				for (i = 0; i < w; i++)
				{
					int x = i + t_dx[j];
					int y = j + t_dy[i];

					if (y <= -1)
					{
						//src_ch = src_up;
						offset = offset_x[j];
						pos_max = w * 2 - 1;

						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
					}
					else
					{
						//src_ch = src_le;
						offset = offset_y[i];
						pos_max = h * 2 - 1;

						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
					}

#if  MIPF
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;

					//filter = (tbl_filt_list[filter_idx] + offset)[0];

#else
					filter = (tbl_filt + offset)[0];
#endif

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);
#if MIPF

					/*dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/
					if (y <= -1) {
						if (filter_idx == 0)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_up[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_up[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_up[pn] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					else {
						if (filter_idx == 0)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_le[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_le[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_le[pn] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
					//diff[j][i] = orgY[(j * 16) + i] - tmp1;
					pred_for_diff[j][i] = tmp1;
#else
					dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset) >> filter_bits);
#endif
				}
				//dst += w;
			}
		}
#endif
	}
}
void ipred_ang_eipm_16_8_pred(pel src_le[35], pel src_up[35], int w, int h, int ipm
#if MIPF
	, int is_luma, int mipf_enable_flag, U4 bit_depth, pel pred_for_diff[16][16]
#endif
)
{
	pel tmp, tmp1;
	static const int com_tbl_ipred_dxdy[IPD_CNT][2] = /* {dx/dy, dy/dx} */
	{
		{0, 0},{0, 0},{0, 0},                                 //0~2
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //3~6
		{744, 1408},{512, 2048},                              //7~8
		{372, 2816},                                          //9
		{256, 4096},                                          //10
		{128, 8192},{0, 0},{128, 8192},{256, 4096},           //11~14
		{372, 2816},{512, 2048},{744, 1408},{1024, 1024},     //15~18
		{1408, 744},{2048, 512},{2816, 372},                  //19~21
		{4096, 256},                                          //22
		{8192, 128},{0, 0},{8192, 128},{4096, 256},           //23~26
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //27~30
		{744, 1408},{ 512, 2048 },{0, 0},{2340, 448},         //31~34
		{1640, 640},                                          //35
		{1168, 898},{898, 1168},{640, 1640},{448, 2340},      //36~39
		{320, 3276},{192, 5460},{64, 16384},{32, 32768},      //40~43
		{32, 32768},{64, 16384},{192, 5460},{320, 3276},      //44~47
		{448, 2340},                                          //48
		{640, 1640},{898, 1168},{1168, 898},{1640, 640},      //49~52
		{2340, 448},{3276, 320},{5460, 192},{16384, 64},      //53~56
		{32768, 32},{32768, 32},{16384, 64},{5460, 192},      //57~60
		{3276, 320},{2340, 448},                              //61~62
		{1640, 640},{1168, 898},{898, 1168}                   //63~65
	};
#if MIPF

	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#else
	static const s16 com_tbl_ipred_adi[32][4] = { { (32), (64), (32), 0 }, { (31), (63), (33), (1) }, { (30), (62), (34), (2) }, { (29), (61), (35), (3) }, { (28), (60), (36), (4) }, { (27), (59), (37), (5) }, { (26), (58), (38), (6) }, { (25), (57), (39), (7) }, { (24), (56), (40), (8) }, { (23), (55), (41), (9) }, { (22), (54), (42), (10) }, { (21), (53), (43), (11) }, { (20), (52), (44), (12) }, { (19), (51), (45), (13) }, { (18), (50), (46), (14) }, { (17), (49), (47), (15) }, { (16), (48), (48), (16) }, { (15), (47), (49), (17) }, { (14), (46), (50), (18) }, { (13), (45), (51), (19) }, { (12), (44), (52), (20) }, { (11), (43), (53), (21) }, { (10), (42), (54), (22) }, { (9), (41), (55), (23) }, { (8), (40), (56), (24) }, { (7), (39), (57), (25) }, { (6), (38), (58), (26) }, { (5), (37), (59), (27) }, { (4), (36), (60), (28) }, { (3), (35), (61), (29) }, { (2), (34), (62), (30) }, { (1), (33), (63), (31) } };
#endif

#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
#else
	const s16(*tbl_filt)[4] = com_tbl_ipred_adi;
	const int filter_offset = ADI_4T_FILTER_OFFSET;
	const int filter_bits = ADI_4T_FILTER_BITS;
#endif

	const int* mt = com_tbl_ipred_dxdy[ipm];

	//const pel* src_ch = NULL;
	//const s16* filter;

	int offset_x[MAX_CU_SIZE], offset_y[MAX_CU_SIZE];
	int t_dx[MAX_CU_SIZE], t_dy[MAX_CU_SIZE];
	int i, j;
	int offset;
	int pos_max = w + h - 1;
	int p, pn, pn_n1, pn_p2;

#if EIPM
	if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT))
#else
	if (ipm < IPD_VER)
#endif
	{
		//src_ch = src_up;
		pos_max = w * 2 - 1;

		for (j = 0; j < h; j++)
		{
			int dx;
			GET_REF_POS(mt[0], j + 1, dx, offset);
#if MIPF
			filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
			//filter = (tbl_filt_list[filter_idx] + offset)[0];
#else
			filter = (tbl_filt + offset)[0];
#endif
			for (i = 0; i < w; i++)
			{
				int x = i + dx;
				pn_n1 = x - 1;
				p = x;
				pn = x + 1;
				pn_p2 = x + 2;

				pn_n1 = COM_MIN(pn_n1, pos_max);
				p = COM_MIN(p, pos_max);
				pn = COM_MIN(pn, pos_max);
				pn_p2 = COM_MIN(pn_p2, pos_max);

#if MIPF
				/*dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

				if (filter_idx == 0)
					tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
						src_up[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 1)
					tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
						src_up[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 2)
					tmp = (pel)((src_up[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_up[p] * tbl_mc_c_coeff_hp[offset][1] +
						src_up[pn] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 3)
					tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p] * com_tbl_ipred_adi_bilinear[offset][1] +
						src_up[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				//diff[j][i] = orgY[(j * 16) + i] - tmp1;
				pred_for_diff[j][i] = tmp1;
#else
				dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					filter_offset) >> filter_bits);
#endif
			}
			//dst += w;
		}
	}
#if EIPM
	else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
#else
	else if (ipm > IPD_HOR)
#endif
	{
		//src_ch = src_le;
		pos_max = h * 2 - 1;

		for (i = 0; i < w; i++)
		{
			GET_REF_POS(mt[1], i + 1, t_dy[i], offset_y[i]);
		}

		for (j = 0; j < h; j++)
		{
			for (i = 0; i < w; i++)
			{
				int y = j + t_dy[i];
				pn_n1 = y - 1;
				p = y;
				pn = y + 1;
				pn_p2 = y + 2;

#if  MIPF
				filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offset_y[i])[0];
#else
				filter = (tbl_filt + offset_y[i])[0];
#endif

				pn_n1 = COM_MIN(pn_n1, pos_max);
				p = COM_MIN(p, pos_max);
				pn = COM_MIN(pn, pos_max);
				pn_p2 = COM_MIN(pn_p2, pos_max);

#if MIPF

				/*  dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					  src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					  filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

				int offset_y_new = offset_y[i];
				if (filter_idx == 0)
					tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset_y_new][0] + src_le[p] * com_tbl_ipred_adi_extra_smooth[offset_y_new][1] +
						src_le[pn] * com_tbl_ipred_adi_extra_smooth[offset_y_new][2] + src_le[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 1)
					tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset_y_new][0] + src_le[p] * com_tbl_ipred_adi_semi_sharp[offset_y_new][1] +
						src_le[pn] * com_tbl_ipred_adi_semi_sharp[offset_y_new][2] + src_le[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 2)
					tmp = (pel)((src_le[pn_n1] * tbl_mc_c_coeff_hp[offset_y_new][0] + src_le[p] * tbl_mc_c_coeff_hp[offset_y_new][1] +
						src_le[pn] * tbl_mc_c_coeff_hp[offset_y_new][2] + src_le[pn_p2] * tbl_mc_c_coeff_hp[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				else if (filter_idx == 3)
					tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_bilinear[offset_y_new][0] + src_le[p] * com_tbl_ipred_adi_bilinear[offset_y_new][1] +
						src_le[pn] * com_tbl_ipred_adi_bilinear[offset_y_new][2] + src_le[pn_p2] * com_tbl_ipred_adi_bilinear[offset_y_new][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				//diff[j][i] = orgY[(j * 16) + i] - tmp1;
				pred_for_diff[j][i] = tmp1;

#else
				dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
					src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
					filter_offset) >> filter_bits);
#endif
			}
			//dst += w;
		}
	}
	else
	{
		for (i = 0; i < w; i++)
		{
			GET_REF_POS(mt[1], i + 1, t_dy[i], offset_y[i]);
			t_dy[i] = -t_dy[i];
		}
		for (j = 0; j < h; j++)
		{
			GET_REF_POS(mt[0], j + 1, t_dx[j], offset_x[j]);
			t_dx[j] = -t_dx[j];
		}
#if MIPF
#if EIPM
		if (ipm < IPD_DIA_R || (ipm > IPD_VER_EXT && ipm <= IPD_DIA_R_EXT))
#else
		if (ipm < IPD_DIA_R)
#endif
		{
#endif
			for (j = 0; j < h; j++)
			{
#if  MIPF
				filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
#endif
				for (i = 0; i < w; i++)
				{
					int x = i + t_dx[j];
					int y = j + t_dy[i];

					if (y <= -1)
					{
						//src_ch = src_up;
						offset = offset_x[j];
						pos_max = w * 2 - 1;

						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
					}
					else
					{
						//src_ch = src_le;
						offset = offset_y[i];
						pos_max = h * 2 - 1;

						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
					}

#if  MIPF
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
#else
					filter = (tbl_filt + offset)[0];
#endif

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);

#if MIPF

					/*dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/
					if (y <= -1) {
						if (filter_idx == 0)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_up[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_up[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_up[pn] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					else {
						if (filter_idx == 0)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_le[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_le[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_le[pn] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
					//diff[j][i] = orgY[(j * 16) + i] - tmp1;
					pred_for_diff[j][i] = tmp1;
#else
					dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset) >> filter_bits);
#endif
				}
				//dst += w;	com_assert(NULL != dst);
			}
#if MIPF
		}
		else
		{
			for (j = 0; j < h; j++)
			{
				for (i = 0; i < w; i++)
				{
					int x = i + t_dx[j];
					int y = j + t_dy[i];

					if (y <= -1)
					{
						//src_ch = src_up;
						offset = offset_x[j];
						pos_max = w * 2 - 1;

						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
					}
					else
					{
						//src_ch = src_le;
						offset = offset_y[i];
						pos_max = h * 2 - 1;

						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
					}

#if  MIPF
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;

					//filter = (tbl_filt_list[filter_idx] + offset)[0];

#else
					filter = (tbl_filt + offset)[0];
#endif

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);
#if MIPF

					/*dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/
					if (y <= -1) {
						if (filter_idx == 0)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_up[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_up[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_up[pn] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_up[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_up[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					else {
						if (filter_idx == 0)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p] * com_tbl_ipred_adi_extra_smooth[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_extra_smooth[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 1)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p] * com_tbl_ipred_adi_semi_sharp[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_semi_sharp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 2)
							tmp = (pel)((src_le[pn_n1] * tbl_mc_c_coeff_hp[offset][0] + src_le[p] * tbl_mc_c_coeff_hp[offset][1] +
								src_le[pn] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2] * tbl_mc_c_coeff_hp[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
						else if (filter_idx == 3)
							tmp = (pel)((src_le[pn_n1] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p] * com_tbl_ipred_adi_bilinear[offset][1] +
								src_le[pn] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2] * com_tbl_ipred_adi_bilinear[offset][3] +
								filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					}
					tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
					//diff[j][i] = orgY[(j * 16) + i] - tmp1;
					pred_for_diff[j][i] = tmp1;
#else
					dst[i] = (pel)((src_ch[pn_n1] * filter[0] + src_ch[p] * filter[1] +
						src_ch[pn] * filter[2] + src_ch[pn_p2] * filter[3] +
						filter_offset) >> filter_bits);
#endif
				}
				//dst += w;
			}
		}
#endif
	}
}
void ipred_ang_eipm_16_16_pred(pel src_le[35], pel src_up[35], int w, int h, int ipm
#if MIPF
	, int is_luma, int mipf_enable_flag, U4 bit_depth, pel diff[16][16]
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=diff complete dim=2
	pel tmp, tmp1;
	static const int com_tbl_ipred_dxdy[IPD_CNT][2] = /* {dx/dy, dy/dx} */
	{
		{0, 0},{0, 0},{0, 0},                                 //0~2
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //3~6
		{744, 1408},{512, 2048},                              //7~8
		{372, 2816},                                          //9
		{256, 4096},                                          //10
		{128, 8192},{0, 0},{128, 8192},{256, 4096},           //11~14
		{372, 2816},{512, 2048},{744, 1408},{1024, 1024},     //15~18
		{1408, 744},{2048, 512},{2816, 372},                  //19~21
		{4096, 256},                                          //22
		{8192, 128},{0, 0},{8192, 128},{4096, 256},           //23~26
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //27~30
		{744, 1408},{ 512, 2048 },{0, 0},{2340, 448},         //31~34
		{1640, 640},                                          //35
		{1168, 898},{898, 1168},{640, 1640},{448, 2340},      //36~39
		{320, 3276},{192, 5460},{64, 16384},{32, 32768},      //40~43
		{32, 32768},{64, 16384},{192, 5460},{320, 3276},      //44~47
		{448, 2340},                                          //48
		{640, 1640},{898, 1168},{1168, 898},{1640, 640},      //49~52
		{2340, 448},{3276, 320},{5460, 192},{16384, 64},      //53~56
		{32768, 32},{32768, 32},{16384, 64},{5460, 192},      //57~60
		{3276, 320},{2340, 448},                              //61~62
		{1640, 640},{1168, 898},{898, 1168}                   //63~65
	};
#if MIPF

	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#else
	static const s16 com_tbl_ipred_adi[32][4] = { { (32), (64), (32), 0 }, { (31), (63), (33), (1) }, { (30), (62), (34), (2) }, { (29), (61), (35), (3) }, { (28), (60), (36), (4) }, { (27), (59), (37), (5) }, { (26), (58), (38), (6) }, { (25), (57), (39), (7) }, { (24), (56), (40), (8) }, { (23), (55), (41), (9) }, { (22), (54), (42), (10) }, { (21), (53), (43), (11) }, { (20), (52), (44), (12) }, { (19), (51), (45), (13) }, { (18), (50), (46), (14) }, { (17), (49), (47), (15) }, { (16), (48), (48), (16) }, { (15), (47), (49), (17) }, { (14), (46), (50), (18) }, { (13), (45), (51), (19) }, { (12), (44), (52), (20) }, { (11), (43), (53), (21) }, { (10), (42), (54), (22) }, { (9), (41), (55), (23) }, { (8), (40), (56), (24) }, { (7), (39), (57), (25) }, { (6), (38), (58), (26) }, { (5), (37), (59), (27) }, { (4), (36), (60), (28) }, { (3), (35), (61), (29) }, { (2), (34), (62), (30) }, { (1), (33), (63), (31) } };
#endif

#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_adi_bilinear complete dim=2
#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_dxdy complete dim=2
#pragma HLS   ARRAY_PARTITION variable=tbl_mc_c_coeff_hp complete dim=2
#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_adi_extra_smooth complete dim=2
#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_adi_semi_sharp complete dim=2

#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
#else
	const s16(*tbl_filt)[4] = com_tbl_ipred_adi;
	const int filter_offset = ADI_4T_FILTER_OFFSET;
	const int filter_bits = ADI_4T_FILTER_BITS;
#endif

	const int* mt = com_tbl_ipred_dxdy[ipm];

	//const pel* src_ch = NULL;
	//const s16* filter;

	int offset_x[MAX_CU_SIZE], offset_y[MAX_CU_SIZE];
	int t_dx[MAX_CU_SIZE], t_dy[MAX_CU_SIZE];
	int i, j;
	int offset;
	int pos_max = w + h - 1;
	int p, pn, pn_n1, pn_p2;
#pragma HLS ARRAY_PARTITION variable=t_dx complete dim=0
#pragma HLS ARRAY_PARTITION variable=t_dy complete dim=0
#pragma HLS ARRAY_PARTITION variable=offset_x complete dim=0
#pragma HLS ARRAY_PARTITION variable=offset_y complete dim=0
	if (((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT)) || (((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))))
	{
		if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT))
			pos_max = w * 2 - 1;
		else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
			pos_max = h * 2 - 1;

		for (j = 0; j < 16; j++)
		{
#pragma HLS PIPELINE
			int dx;

			for (i = 0; i < 16; i++)
			{
				if(i<w&&j<h){
				int x;
				int src_p, src_pn, src_pn_n1, src_pn_p2;

				if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT)) {
					GET_REF_POS(mt[0], j + 1, dx, offset);
					filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;

					x = i + dx;

					pn_n1 = x - 1;
					p = x;
					pn = x + 1;
					pn_p2 = x + 2;

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);

					src_pn_n1 = src_up[pn_n1];
					src_p = src_up[p];
					src_pn = src_up[pn];
					src_pn_p2 = src_up[pn_p2];
				}
				else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
				{
					GET_REF_POS(mt[1], i + 1, dx, offset);
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;

					x = j + dx;

					pn_n1 = x - 1;
					p = x;
					pn = x + 1;
					pn_p2 = x + 2;

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);

					src_pn_n1 = src_le[pn_n1];
					src_p = src_le[p];
					src_pn = src_le[pn];
					src_pn_p2 = src_le[pn_p2];

				}

				s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][0] : com_tbl_ipred_adi_bilinear[offset][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][1] : com_tbl_ipred_adi_bilinear[offset][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][2] : com_tbl_ipred_adi_bilinear[offset][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][3] : com_tbl_ipred_adi_bilinear[offset][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];
				s32 buffer1 = src_pn_n1 * data1;
				s32 buffer2 = src_p * data2;
				s32 buffer3 = src_pn * data3;
				s32 buffer4 = src_pn_p2 * data4;
				tmp = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
				tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				diff[j][i] = tmp1;
				}
				}
			}
	}
	else
	{
		for (i = 0; i < 16; i++)
		{
#pragma HLS UNROLL
			if(i<w){
			GET_REF_POS(mt[1], i + 1, t_dy[i], offset_y[i]);
			t_dy[i] = -t_dy[i];}
		}
		for (j = 0; j < 16; j++)
		{
#pragma HLS UNROLL
			if(j<h){
			GET_REF_POS(mt[0], j + 1, t_dx[j], offset_x[j]);
			t_dx[j] = -t_dx[j];}
		}

		for (j = 0; j < 16; j++)
		{
#pragma HLS PIPELINE
			for (i = 0; i < 16; i++)
			{
				if(i < w && j < h){
				int x = i + t_dx[j];
				int y = j + t_dy[i];
				int src_p, src_pn, src_pn_n1, src_pn_p2;

				if (y <= -1)
				{
					offset = offset_x[j];
					pos_max = w * 2 - 1;

					pn_n1 = x + 1;
					p = x;
					pn = x - 1;
					pn_p2 = x - 2;

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);

					src_pn_n1 = src_up[pn_n1];
					src_p = src_up[p];
					src_pn = src_up[pn];
					src_pn_p2 = src_up[pn_p2];

				}
				else
				{
					offset = offset_y[i];
					pos_max = h * 2 - 1;

					pn_n1 = y + 1;
					p = y;
					pn = y - 1;
					pn_p2 = y - 2;

					pn_n1 = COM_MIN(pn_n1, pos_max);
					p = COM_MIN(p, pos_max);
					pn = COM_MIN(pn, pos_max);
					pn_p2 = COM_MIN(pn_p2, pos_max);

					src_pn_n1 = src_le[pn_n1];
					src_p = src_le[p];
					src_pn = src_le[pn];
					src_pn_p2 = src_le[pn_p2];

				}

				if (ipm < IPD_DIA_R || (ipm > IPD_VER_EXT && ipm <= IPD_DIA_R_EXT)) {
					filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
				}
				else
				{
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				}

				s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][0] : com_tbl_ipred_adi_bilinear[offset][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][1] : com_tbl_ipred_adi_bilinear[offset][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][2] : com_tbl_ipred_adi_bilinear[offset][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][3] : com_tbl_ipred_adi_bilinear[offset][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];
				s32 buffer1 = src_pn_n1 * data1;
				s32 buffer2 = src_p * data2;
				s32 buffer3 = src_pn * data3;
				s32 buffer4 = src_pn_p2 * data4;
				tmp = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
				tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				diff[j][i] = tmp1;
				}
			}
		}
	}
}





void Ipred_vert_8_16_pred(U8 cu_width, U8 cu_height, pel src_up[16 * 2 + 3], pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE
#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
	int i, j;
	for (i = 0; i < 16; i++) {
		if (i < cu_height) {
			//#pragma HLS PIPELINE
			//#pragma HLS loop_tripcount max = 16

			for (j = 0; j < 16; j++) {
				//#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = src_up[j];
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}
}

void Ipred_vert_16_8_pred(U8 cu_width, U8 cu_height, pel src_up[16 * 2 + 3], pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE
#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
	int i, j;
	for (i = 0; i < 16; i++) {
		if (i < cu_height) {
			//#pragma HLS PIPELINE
			//#pragma HLS loop_tripcount max = 16

			for (j = 0; j < 16; j++) {
				//#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = src_up[j];
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}
}

void Ipred_vert_16_16_pred(U8 cu_width, U8 cu_height, pel src_up[16 * 2 + 3], pel pred_cache_16x16[16][16])
{
#pragma HLS ARRAY_PARTITION variable=pred_cache_16x16 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0

	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (j = 0; j < 16; j++) {
			if (j < cu_width && i < cu_height)
			{
				pred_cache_16x16[i][j] = src_up[j];
			}
		}
	}
}

void Ipred_hor_8_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel pred_cache_16x16[16][16])
{

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0
#pragma HLS array_partition variable = src_le complete dim=1
	int i, j;
	for (i = 0; i < 16; i++) {
		if (i < cu_height) {
			//#pragma HLS PIPELINE
#pragma HLS loop_tripcount max = 16
			for (j = 0; j < 16; j++) {
				//#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = src_le[i];
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}
}
void Ipred_hor_16_8_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE
#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_le complete dim=1
	int i, j;
	for (i = 0; i < 16; i++) {
		if (i < cu_height) {
			//#pragma HLS PIPELINE
#pragma HLS loop_tripcount max = 16
			for (j = 0; j < 16; j++) {
				//#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = src_le[i];
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}
}
void Ipred_hor_16_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel pred_cache_16x16[16][16])
{
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=1
	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (j = 0; j < 16; j++) {
			if (j < cu_width && i < cu_height)
			{
				pred_cache_16x16[i][j] = src_le[i];
			}
		}
	}
}
void Ipred_dc_8_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, u16 avail_cu, pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif

#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	int dc = 0;
	//	int wh;
	int i;
	int j;
	int offset_s1 = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
	if (((avail_cu) & 1 << 1) == 1 << 1) {
		for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
			if (i < cu_height)
				dc += (src_le[i]);
		}
		if (((avail_cu) & 1 << 0) == 1 << 0) {
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
					dc += (src_up[j]);
			}
			//dc = (dc + ((cu_width + cu_height) >> 1)) * (4096 / (cu_width + cu_height)) >> 12;
			if (cu_width == cu_height)
				dc = (dc + ((32) >> 1)) * (4096 / (32)) >> 12;
			if ((cu_width + cu_height) == 20)
				dc = (dc + ((20) >> 1)) * (4096 / (20)) >> 12;
			if ((cu_width + cu_height) == 24)
				dc = (dc + ((24) >> 1)) * (4096 / (24)) >> 12;
		}
		else {
			dc = (dc + (cu_height >> 1)) >> (com_tbl_log2[cu_height]);
		}
	}
	else if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
				dc += (src_up[j]);
		}
		dc = (dc + (cu_width >> 1)) >> (com_tbl_log2[cu_width]);
	}
	else {
		dc = 1 << (bit_depth - 1);
	}

	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
		//#pragma HLS PIPELINE
		if (i < cu_height) {
			//#pragma HLS loop_tripcount max = 16
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = dc;
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}

}

void Ipred_dc_16_8_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, u16 avail_cu, pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif

#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	int dc = 0;
	//	int wh;
	int i;
	int j;
	int offset_s1 = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
	if (((avail_cu) & 1 << 1) == 1 << 1) {
		for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
			if (i < cu_height)
				dc += (src_le[i]);
		}
		if (((avail_cu) & 1 << 0) == 1 << 0) {
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
					dc += (src_up[j]);
			}
			//dc = (dc + ((cu_width + cu_height) >> 1)) * (4096 / (cu_width + cu_height)) >> 12;
			if (cu_width == cu_height)
				dc = (dc + ((32) >> 1)) * (4096 / (32)) >> 12;
			if ((cu_width + cu_height) == 20)
				dc = (dc + ((20) >> 1)) * (4096 / (20)) >> 12;
			if ((cu_width + cu_height) == 24)
				dc = (dc + ((24) >> 1)) * (4096 / (24)) >> 12;
		}
		else {
			dc = (dc + (cu_height >> 1)) >> (com_tbl_log2[cu_height]);
		}
	}
	else if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
				dc += (src_up[j]);
		}
		dc = (dc + (cu_width >> 1)) >> (com_tbl_log2[cu_width]);
	}
	else {
		dc = 1 << (bit_depth - 1);
	}

	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
		//#pragma HLS PIPELINE
		if (i < cu_height) {
			//#pragma HLS loop_tripcount max = 16
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
				{
					pred_cache_16x16[i][j] = dc;
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}

}

void Ipred_dc_16_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, u16 avail_cu, pel pred_cache_16x16[16][16])
{

	int dc = 0;
	//	int wh;
	int i;
	int j;
	int offset_s1 = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0

	if (((avail_cu) & 1 << 1) == 1 << 1) {
		for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
			if (i < cu_height)
				dc += (src_le[i]);
		}
		if (((avail_cu) & 1 << 0) == 1 << 0) {
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
					dc += (src_up[j]);
			}
			//dc = (dc + ((cu_width + cu_height) >> 1)) * (4096 / (cu_width + cu_height)) >> 12;
			if (cu_width == cu_height)
				dc = (dc + ((32) >> 1)) * (4096 / (32)) >> 12;
			if ((cu_width + cu_height) == 20)
				dc = (dc + ((20) >> 1)) * (4096 / (20)) >> 12;
			if ((cu_width + cu_height) == 24)
				dc = (dc + ((24) >> 1)) * (4096 / (24)) >> 12;
		}
		else {
			dc = (dc + (cu_height >> 1)) >> (com_tbl_log2[cu_height]);
		}
	}
	else if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
				dc += (src_up[j]);
		}
		dc = (dc + (cu_width >> 1)) >> (com_tbl_log2[cu_width]);
	}
	else {
		dc = 1 << (bit_depth - 1);
	}

	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (j = 0; j < 16; j++) {
			if (j < cu_width && i < cu_height)
			{
				pred_cache_16x16[i][j] = dc;
			}
		}
	}

}

void Ipred_plane_8_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE
	//pel *rsrc;
	int coef_h = 0;
	int coef_v = 0;
	int a;
	int b;
	int c;
	int x;
	int y;
	//int w2 = W >> 1;
	//int h2 = H >> 1;
	int ib_mult[5] = { (13), (17), (5), (11), (23) };
	int ib_shift[5] = { (7), (10), (11), (15), (19) };
	int idx_w = (com_tbl_log2[cu_width]) - 2;
	int idx_h = (com_tbl_log2[cu_height]) - 2;
	int im_h;
	int is_h;
	int im_v;
	int is_v;
	int temp;

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
	int pred_cache;

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
#pragma HLS array_partition variable = ib_mult complete dim=1
#pragma HLS array_partition variable = ib_shift complete dim=1
#pragma HLS array_partition variable = com_tbl_log2 complete dim=1
	im_h = ib_mult[idx_w];
	is_h = ib_shift[idx_w];
	im_v = ib_mult[idx_h];
	is_v = ib_shift[idx_h];
	//rsrc = src_up + (w2 - 1);
	//rsrc = src_up;
	for (x = 1; x < (16 >> 1) + 1; x++) {
#pragma HLS UNROLL
		if (x < (cu_width >> 1) + 1)
			coef_h += x * ((src_up[(cu_width >> 1) + x]) - (src_up[(cu_width >> 1) - x]));
	}
	//rsrc = src_le + (h2 - 1);
	//rsrc = src_le;
	for (y = 1; y < (16 >> 1) + 1; y++) {
#pragma HLS UNROLL
		if (y < (cu_height >> 1) + 1)
			coef_v += y * ((src_le[(cu_height >> 1) + y]) - (src_le[(cu_height >> 1) - y]));
	}
	a = (src_le[cu_height] + src_up[cu_width]) << 4;
	b = ((coef_h << 5) * im_h + (1 << (is_h - 1))) >> is_h;
	c = ((coef_v << 5) * im_v + (1 << (is_v - 1))) >> is_v;
	temp = a - ((cu_height >> 1) - 1) * c - ((cu_width >> 1) - 1) * b + 16;

	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
		//if( i < cu_height){
//#pragma HLS loop_tripcount max = 16
		//temp2 = temp;
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
			{
				pred_cache = ((temp + j * b) >> 5);
				pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))) ? 0 : (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))))));
				//temp2 += b;
				//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
			}
		}
		temp += c;
		//}
	}

}
void Ipred_plane_16_8_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE
	//pel *rsrc;
	int coef_h = 0;
	int coef_v = 0;
	int a;
	int b;
	int c;
	int x;
	int y;
	//int w2 = W >> 1;
	//int h2 = H >> 1;
	int ib_mult[5] = { (13), (17), (5), (11), (23) };
	int ib_shift[5] = { (7), (10), (11), (15), (19) };
	int idx_w = (com_tbl_log2[cu_width]) - 2;
	int idx_h = (com_tbl_log2[cu_height]) - 2;
	int im_h;
	int is_h;
	int im_v;
	int is_v;
	int temp;

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
	int pred_cache;

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
#pragma HLS array_partition variable = ib_mult complete dim=1
#pragma HLS array_partition variable = ib_shift complete dim=1
#pragma HLS array_partition variable = com_tbl_log2 complete dim=1
	im_h = ib_mult[idx_w];
	is_h = ib_shift[idx_w];
	im_v = ib_mult[idx_h];
	is_v = ib_shift[idx_h];
	//rsrc = src_up + (w2 - 1);
	//rsrc = src_up;
	for (x = 1; x < (16 >> 1) + 1; x++) {
#pragma HLS UNROLL
		if (x < (cu_width >> 1) + 1)
			coef_h += x * ((src_up[(cu_width >> 1) + x]) - (src_up[(cu_width >> 1) - x]));
	}
	//rsrc = src_le + (h2 - 1);
	//rsrc = src_le;
	for (y = 1; y < (16 >> 1) + 1; y++) {
#pragma HLS UNROLL
		if (y < (cu_height >> 1) + 1)
			coef_v += y * ((src_le[(cu_height >> 1) + y]) - (src_le[(cu_height >> 1) - y]));
	}
	a = (src_le[cu_height] + src_up[cu_width]) << 4;
	b = ((coef_h << 5) * im_h + (1 << (is_h - 1))) >> is_h;
	c = ((coef_v << 5) * im_v + (1 << (is_v - 1))) >> is_v;
	temp = a - ((cu_height >> 1) - 1) * c - ((cu_width >> 1) - 1) * b + 16;

	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
		//if( i < cu_height){
//#pragma HLS loop_tripcount max = 16
		//temp2 = temp;
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (j < cu_width)
			{
				pred_cache = ((temp + j * b) >> 5);
				pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))) ? 0 : (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))))));
				//temp2 += b;
				//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
			}
		}
		temp += c;
		//}
	}

}
void Ipred_plane_16_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, pel pred_cache_16x16[16][16])
{

	int coef_h = 0;
	int coef_v = 0;
	int a;
	int b;
	int c;
	int x;
	int y;

	int ib_mult[5] = { (13), (17), (5), (11), (23) };
	int ib_shift[5] = { (7), (10), (11), (15), (19) };
	int idx_w = (com_tbl_log2[cu_width]) - 2;
	int idx_h = (com_tbl_log2[cu_height]) - 2;
	int im_h;
	int is_h;
	int im_v;
	int is_v;
	int temp;

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
	int pred_cache;


	im_h = ib_mult[idx_w];
	is_h = ib_shift[idx_w];
	im_v = ib_mult[idx_h];
	is_v = ib_shift[idx_h];

#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
#pragma HLS array_partition variable = ib_mult complete dim=0
#pragma HLS array_partition variable = ib_shift complete dim=0
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
	//rsrc = src_up + (w2 - 1);
	//rsrc = src_up;
	for (x = 1; x < (16 >> 1) + 1; x++) {
#pragma HLS UNROLL
		if (x < (cu_width >> 1) + 1)
			coef_h += x * ((src_up[(cu_width >> 1) + x]) - (src_up[(cu_width >> 1) - x]));
	}
	//rsrc = src_le + (h2 - 1);
	//rsrc = src_le;
	for (y = 1; y < (16 >> 1) + 1; y++) {
#pragma HLS UNROLL
		if (y < (cu_height >> 1) + 1)
			coef_v += y * ((src_le[(cu_height >> 1) + y]) - (src_le[(cu_height >> 1) - y]));
	}
	a = (src_le[cu_height] + src_up[cu_width]) << 4;
	b = ((coef_h << 5) * im_h + (1 << (is_h - 1))) >> is_h;
	c = ((coef_v << 5) * im_v + (1 << (is_v - 1))) >> is_v;
	temp = a - ((cu_height >> 1) - 1) * c - ((cu_width >> 1) - 1) * b + 16;

	int i, j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		//if( i < cu_height){
		//temp2 = temp;
		for (j = 0; j < 16; j++) {
			if (j < cu_width)
			{
				pred_cache = ((temp + j * b) >> 5);
				pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))) ? 0 : (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))))));
				//temp2 += b;
				//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
			}
		}
		temp += c;
		//}
	}

}
void Ipred_bi_8_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE
	int x;
	int y;
	int ishift_x = com_tbl_log2[cu_width];
	int ishift_y = com_tbl_log2[cu_height];
	int ishift = ishift_x < ishift_y ? ishift_x : ishift_y;
	int ishift_xy = ishift_x + ishift_y + 1;
	int offset = 1 << (ishift_x + ishift_y);
	int a;
	int b;
	int c;
	int wt;
	int wxy;
	int tmp;
	int predx;
	static int ref_up[128 >> 1];
	static int ref_le[128 >> 1];
	static int up[128 >> 1];
	static int le[128 >> 1];
	static int wy[128 >> 1];
	int wc;
	int tbl_wc[6] = { (-1), (21), (13), (7), (4), (2) };

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	wc = (ishift_x > ishift_y ? ishift_x - ishift_y : ishift_y - ishift_x);
	wc = tbl_wc[wc];
	a = (src_up[cu_width - 1]);
	b = (src_le[cu_height - 1]);
	c = (cu_width == cu_height ? (a + b + 1) >> 1 : (((a << ishift_x) + (b << ishift_y)) * wc + (1 << (ishift + 5))) >> (ishift + 6));
	wt = (c << 1) - a - b;
	for (x = 0; x < 16; x++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
		if (x < cu_width)
		{
			up[x] = b - src_up[x];
			//		ref_up[x] = src_up[x] << ishift_y;
			ref_up[x] = src_up[x];
			ref_up[x] <<= ishift_y;
		}
	}
	tmp = 0;
	for (y = 0; y < 16; y++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
		if (y < cu_height)
		{
			le[y] = a - src_le[y];
			//		ref_le[y] = src_le[y] << ishift_x;
			ref_le[y] = src_le[y];
			ref_le[y] <<= ishift_x;
			wy[y] = wt * y;
		}
	}
	int i, j; int temp;
	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL

		if (i < cu_height)
		{
			//#pragma HLS loop_tripcount max = 16
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
				{
					predx = ref_le[i] + (j + 1) * le[i];
					ref_up[j] += up[j];
					wxy = j * wy[i];
					temp = ((predx << ishift_y) + (ref_up[j] << ishift_x) + wxy + offset) >> ishift_xy;
					pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))) ? 0 : (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))))));
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}

}
void Ipred_bi_16_8_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, pel pred_cache_16x16[16][16])
{
#pragma HLS PIPELINE
	int x;
	int y;
	int ishift_x = com_tbl_log2[cu_width];
	int ishift_y = com_tbl_log2[cu_height];
	int ishift = ishift_x < ishift_y ? ishift_x : ishift_y;
	int ishift_xy = ishift_x + ishift_y + 1;
	int offset = 1 << (ishift_x + ishift_y);
	int a;
	int b;
	int c;
	int wt;
	int wxy;
	int tmp;
	int predx;
	static int ref_up[128 >> 1];
	static int ref_le[128 >> 1];
	static int up[128 >> 1];
	static int le[128 >> 1];
	static int wy[128 >> 1];
	int wc;
	int tbl_wc[6] = { (-1), (21), (13), (7), (4), (2) };

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;
#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	wc = (ishift_x > ishift_y ? ishift_x - ishift_y : ishift_y - ishift_x);
	wc = tbl_wc[wc];
	a = (src_up[cu_width - 1]);
	b = (src_le[cu_height - 1]);
	c = (cu_width == cu_height ? (a + b + 1) >> 1 : (((a << ishift_x) + (b << ishift_y)) * wc + (1 << (ishift + 5))) >> (ishift + 6));
	wt = (c << 1) - a - b;
	for (x = 0; x < 16; x++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
		if (x < cu_width)
		{
			up[x] = b - src_up[x];
			//		ref_up[x] = src_up[x] << ishift_y;
			ref_up[x] = src_up[x];
			ref_up[x] <<= ishift_y;
		}
	}
	tmp = 0;
	for (y = 0; y < 16; y++) {
		//#pragma HLS loop_tripcount max = 16
#pragma HLS UNROLL
		if (y < cu_height)
		{
			le[y] = a - src_le[y];
			//		ref_le[y] = src_le[y] << ishift_x;
			ref_le[y] = src_le[y];
			ref_le[y] <<= ishift_x;
			wy[y] = wt * y;
		}
	}
	int i, j; int temp;
	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL

		if (i < cu_height)
		{
			//#pragma HLS loop_tripcount max = 16
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
				if (j < cu_width)
				{
					predx = ref_le[i] + (j + 1) * le[i];
					ref_up[j] += up[j];
					wxy = j * wy[i];
					temp = ((predx << ishift_y) + (ref_up[j] << ishift_x) + wxy + offset) >> ishift_xy;
					pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))) ? 0 : (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))))));
					//coef_tmp_16x16[i][j] = orgY[(i << 4) + j] - pred_cache_16x16[i][j];
				}
			}
		}
	}

}
void Ipred_bi_16_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, pel pred_cache_16x16[16][16])
{
	int x;
	int y;
	int ishift_x = com_tbl_log2[cu_width];
	int ishift_y = com_tbl_log2[cu_height];
	int ishift = ishift_x < ishift_y ? ishift_x : ishift_y;
	int ishift_xy = ishift_x + ishift_y + 1;
	int offset = 1 << (ishift_x + ishift_y);
	int a;
	int b;
	int c;
	int wt;
	int wxy;
	int tmp;
	int predx;
	static int ref_up[128 >> 1];
	static int ref_le[128 >> 1];
	static int up[128 >> 1];
	static int le[128 >> 1];
	static int wy[128 >> 1];
	int wc;
	int tbl_wc[6] = { (-1), (21), (13), (7), (4), (2) };

#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
#pragma HLS array_partition variable = ref_up complete dim=0
#pragma HLS array_partition variable = ref_le complete dim=0
#pragma HLS array_partition variable = up complete dim=0
#pragma HLS array_partition variable = le complete dim=0
#pragma HLS array_partition variable = wy complete dim=0

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = cu_width;
	int s_diff = cu_width;

	wc = (ishift_x > ishift_y ? ishift_x - ishift_y : ishift_y - ishift_x);
	wc = tbl_wc[wc];
	a = (src_up[cu_width - 1]);
	b = (src_le[cu_height - 1]);
	c = (cu_width == cu_height ? (a + b + 1) >> 1 : (((a << ishift_x) + (b << ishift_y)) * wc + (1 << (ishift + 5))) >> (ishift + 6));
	wt = (c << 1) - a - b;
	for (x = 0; x < 16; x++) {
#pragma HLS UNROLL
		if (x < cu_width)
		{
			up[x] = b - src_up[x];
			//		ref_up[x] = src_up[x] << ishift_y;
			ref_up[x] = src_up[x];
			ref_up[x] <<= ishift_y;
		}
	}
	tmp = 0;
	for (y = 0; y < 16; y++) {
#pragma HLS UNROLL
		if (y < cu_height)
		{
			le[y] = a - src_le[y];
			//		ref_le[y] = src_le[y] << ishift_x;
			ref_le[y] = src_le[y];
			ref_le[y] <<= ishift_x;
			wy[y] = wt * y;
		}
	}
	int i, j; int temp;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (j = 0; j < 16; j++) {
			if (j < cu_width && i < cu_height)
			{
				predx = ref_le[i] + (j + 1) * le[i];
				ref_up[j] += up[j];
				wxy = j * wy[i];
				temp = ((predx << ishift_y) + (ref_up[j] << ishift_x) + wxy + offset) >> ishift_xy;
				pred_cache_16x16[i][j] = (((0 > (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))) ? 0 : (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))))));
			}
		}
	}

}
void ipred_ang1_8_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	// const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	// const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[9][2] = { { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) } };

	int i, j, t_dx, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int x = 2147483647;
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height) {
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					/* case x-line */
					t_dx = (j + 1) * ipred_dxdy[ipm - 3][0] >> 10;
					offset = ((j + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dx << 5);
					x = i + t_dx;

					pn_n1 = x - 1;
					p = x;
					pn = x + 1;
					pn_p2 = x + 2;
					pos_max = cu_width * 2 - 1;

					pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
					p = (p < pos_max ? p : pos_max);
					pn = (pn < pos_max ? pn : pos_max);
					pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF
					filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
					//temp_pel = (pel)((src_up[pn_n1 + 3] * filter[0] + src_up[p + 3] * filter[1] +
					   // src_up[pn + 3] * filter[2] + src_up[pn_p2 + 3] * filter[3] +
					   // filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1

					if (filter_idx == 0)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 1)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 2)
						temp_pel = (pel)((src_up[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_up[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
							src_up[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 3)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
					pred_cache_16x16[j][i] = temp_pel;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#else

					pred_cache_16x16[j][i] = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + (src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#endif

				}
			}
		}
	}

}

void ipred_ang1_16_8_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	// const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	// const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[9][2] = { { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) } };

	int i, j, t_dx, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int x = 2147483647;
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height) {
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					/* case x-line */
					t_dx = (j + 1) * ipred_dxdy[ipm - 3][0] >> 10;
					offset = ((j + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dx << 5);
					x = i + t_dx;

					pn_n1 = x - 1;
					p = x;
					pn = x + 1;
					pn_p2 = x + 2;
					pos_max = cu_width * 2 - 1;

					pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
					p = (p < pos_max ? p : pos_max);
					pn = (pn < pos_max ? pn : pos_max);
					pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF
					filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
					//temp_pel = (pel)((src_up[pn_n1 + 3] * filter[0] + src_up[p + 3] * filter[1] +
					   // src_up[pn + 3] * filter[2] + src_up[pn_p2 + 3] * filter[3] +
					   // filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1

					if (filter_idx == 0)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 1)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 2)
						temp_pel = (pel)((src_up[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_up[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
							src_up[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_up[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
					else if (filter_idx == 3)
						temp_pel = (pel)((src_up[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_up[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
							src_up[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_up[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
					pred_cache_16x16[j][i] = temp_pel;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#else

					pred_cache_16x16[j][i] = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + (src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#endif

				}
			}
		}
	}

}

void ipred_ang1_16_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	// const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	// const s16* filter;
#endif

	static const int ipred_dxdy[9][2] = { { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) } };

	int i, j, t_dx, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int x = 2147483647;

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		for (i = 0; i < 16; i++)
		{
			if (i < cu_width && j < cu_height)
			{
					/* case x-line */
				t_dx = (j + 1) * ipred_dxdy[ipm - 3][0] >> 10;
				offset = ((j + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dx << 5);
				x = i + t_dx;

				pn_n1 = x - 1;
				p = x;
				pn = x + 1;
				pn_p2 = x + 2;
				pos_max = cu_width * 2 - 1;

				pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
				p = (p < pos_max ? p : pos_max);
				pn = (pn < pos_max ? pn : pos_max);
				pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF
				filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;

				s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][0] : com_tbl_ipred_adi_bilinear[offset][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][1] : com_tbl_ipred_adi_bilinear[offset][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][2] : com_tbl_ipred_adi_bilinear[offset][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][3] : com_tbl_ipred_adi_bilinear[offset][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];

				s32 buffer1 = src_up[pn_n1 + 3] * data1;
				s32 buffer2 = src_up[p + 3] * data2;
				s32 buffer3 = src_up[pn + 3] * data3;
				s32 buffer4 = src_up[pn_p2 + 3] * data4;

				pel tmp = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);

				pel tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				pred_cache_16x16[j][i] = tmp1;
#else

				pred_cache_16x16[j][i] = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + (src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
#endif

			}
		}
	}

}

void ipred_ang2_8_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[8][2] = { { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };
	//#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	int i, j, t_dy, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int y = 2147483647;

#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height) {
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					t_dy = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
					offset = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dy << 5);
					y = j + t_dy;
					pn_n1 = y - 1;
					p = y;
					pn = y + 1;
					pn_p2 = y + 2;
					pos_max = cu_height * 2 - 1;

					pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
					p = (p < pos_max ? p : pos_max);
					pn = (pn < pos_max ? pn : pos_max);
					pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF									
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
					//temp_pel = (pel)((src_le[pn_n1 + 3] * filter[0] + src_le[p + 3] * filter[1] +
					   // src_le[pn + 3] * filter[2] + src_le[pn_p2 + 3] * filter[3] +
					   // filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

					if (filter_idx == 0)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 1)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 2)
						temp_pel = (pel)((src_le[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_le[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
							src_le[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 3)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
					pred_cache_16x16[j][i] = temp_pel;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];

#else
					pred_cache_16x16[j][i] = ((src_le[pn_n1 + 3]) * (32 - offset) + (src_le[p + 3]) * (64 - offset) + (src_le[pn + 3]) * (32 + offset) + (src_le[pn_p2 + 3]) * offset + 64) >> 7;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#endif
				}
			}
		}
	}

}
void ipred_ang2_16_8_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[8][2] = { { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };
	//#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	int i, j, t_dy, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int y = 2147483647;

#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height) {
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					t_dy = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
					offset = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dy << 5);
					y = j + t_dy;
					pn_n1 = y - 1;
					p = y;
					pn = y + 1;
					pn_p2 = y + 2;
					pos_max = cu_height * 2 - 1;

					pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
					p = (p < pos_max ? p : pos_max);
					pn = (pn < pos_max ? pn : pos_max);
					pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF									
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					//filter = (tbl_filt_list[filter_idx] + offset)[0];
					//temp_pel = (pel)((src_le[pn_n1 + 3] * filter[0] + src_le[p + 3] * filter[1] +
					   // src_le[pn + 3] * filter[2] + src_le[pn_p2 + 3] * filter[3] +
					   // filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

					if (filter_idx == 0)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_extra_smooth[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_extra_smooth[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 1)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_semi_sharp[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_semi_sharp[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 2)
						temp_pel = (pel)((src_le[pn_n1 + 3] * tbl_mc_c_coeff_hp[offset][0] + src_le[p + 3] * tbl_mc_c_coeff_hp[offset][1] +
							src_le[pn + 3] * tbl_mc_c_coeff_hp[offset][2] + src_le[pn_p2 + 3] * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
					else if (filter_idx == 3)
						temp_pel = (pel)((src_le[pn_n1 + 3] * com_tbl_ipred_adi_bilinear[offset][0] + src_le[p + 3] * com_tbl_ipred_adi_bilinear[offset][1] +
							src_le[pn + 3] * com_tbl_ipred_adi_bilinear[offset][2] + src_le[pn_p2 + 3] * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
					pred_cache_16x16[j][i] = temp_pel;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];

#else
					pred_cache_16x16[j][i] = ((src_le[pn_n1 + 3]) * (32 - offset) + (src_le[p + 3]) * (64 - offset) + (src_le[pn + 3]) * (32 + offset) + (src_le[pn_p2 + 3]) * offset + 64) >> 7;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
#endif
				}
			}
		}
	}

}
void ipred_ang2_16_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{

#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
#endif

	static const int ipred_dxdy[8][2] = { { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };
	int i, j, t_dy, offset;
	int p, pn, pn_n1, pn_p2, pos_max;
	int y = 2147483647;

#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_cache_16x16 complete dim=2
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		for (i = 0; i < 16; i++)
		{
			if (i < cu_width && j<cu_height)
			{
				t_dy = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
				offset = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dy << 5);
				y = j + t_dy;
				pn_n1 = y - 1;
				p = y;
				pn = y + 1;
				pn_p2 = y + 2;
				pos_max = cu_height * 2 - 1;

					pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
					p = (p < pos_max ? p : pos_max);
					pn = (pn < pos_max ? pn : pos_max);
					pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

#if MIPF									
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;

				s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][0] : com_tbl_ipred_adi_bilinear[offset][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][1] : com_tbl_ipred_adi_bilinear[offset][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][2] : com_tbl_ipred_adi_bilinear[offset][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][3] : com_tbl_ipred_adi_bilinear[offset][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];
				s32 buffer1 = src_le[pn_n1+3] * data1;
				s32 buffer2 = src_le[p+3] * data2;
				s32 buffer3 = src_le[pn+3] * data3;
				s32 buffer4 = src_le[pn_p2+3] * data4;
				pel tmp = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
				pel tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				pred_cache_16x16[j][i] = tmp1;

#else
					pred_cache_16x16[j][i] = ((src_le[pn_n1 + 3]) * (32 - offset) + (src_le[p + 3]) * (64 - offset) + (src_le[pn + 3]) * (32 + offset) + (src_le[pn_p2 + 3]) * offset + 64) >> 7;
#endif
			}
		}
	}

}

void ipred_ang3_8_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF

	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	//pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[11][2] = { { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) } };
	//#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	int i, j;
	int offset, offset_x, offset_y, xx, yy, t_dx, t_dy;
	int xy = -1, yx = -1;
	int x, y;
	int p, pn, pn_n1, pn_p2, pos_max;
	pel temp_pel = 0;
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height)
		{
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					}

					t_dx = (j + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_x = ((j + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dx << 5);
					t_dx = -t_dx;
					xx = i + t_dx;
					t_dy = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_y = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dy << 5);
					t_dy = -t_dy;
					yy = j + t_dy;

					if (yy <= -1) {
						offset = offset_x;
						x = xx;
						y = yx;
					}
					else {
						offset = offset_y;
						y = yy;
						x = xy;
					}
					if (y == -1) {
						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
						pos_max = cu_width * 2 - 1;
					}
					else {
						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
						pos_max = cu_height * 2 - 1;
					}

					pn_n1 += 3;
					p += 3;
					pn += 3;
					pn_p2 += 3;

					int src_p, src_pn, src_pn_n1, src_pn_p2;

					if (y == -1) {
						src_pn_n1 = src_up[pn_n1];
						src_p = src_up[p];
						src_pn = src_up[pn];
						src_pn_p2 = src_up[pn_p2];
					}
					else if (x == -1) {
						src_pn_n1 = src_le[pn_n1];
						src_p = src_le[p];
						src_pn = src_le[pn];
						src_pn_p2 = src_le[pn_p2];
					}
					else {
						src_pn_n1 = 0;
						src_p = 0;
						src_pn = 0;
						src_pn_p2 = 0;
					}
#if MIPF

					if (filter_idx == 0)
						temp_pel = (pel)((src_pn_n1 * com_tbl_ipred_adi_extra_smooth[offset][0] + src_p * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_pn * com_tbl_ipred_adi_extra_smooth[offset][2] + src_pn_p2 * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 1)
						temp_pel = (pel)((src_pn_n1 * com_tbl_ipred_adi_semi_sharp[offset][0] + src_p * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_pn * com_tbl_ipred_adi_semi_sharp[offset][2] + src_pn_p2 * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 2)
						temp_pel = (pel)((src_pn_n1 * tbl_mc_c_coeff_hp[offset][0] + src_p * tbl_mc_c_coeff_hp[offset][1] +
							src_pn * tbl_mc_c_coeff_hp[offset][2] + src_pn_p2 * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 3)
						temp_pel = (pel)((src_pn_n1 * com_tbl_ipred_adi_bilinear[offset][0] + src_p * com_tbl_ipred_adi_bilinear[offset][1] +
							src_pn * com_tbl_ipred_adi_bilinear[offset][2] + src_pn_p2 * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
#else
					temp_pel = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + ((
						int)src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
#endif
					pred_cache_16x16[j][i] = temp_pel;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
				}
			}
		}
	}
}
void ipred_ang3_16_8_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS PIPELINE

#if MIPF

	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	//pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[11][2] = { { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) } };
	//#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	int i, j;
	int offset, offset_x, offset_y, xx, yy, t_dx, t_dy;
	int xy = -1, yx = -1;
	int x, y;
	int p, pn, pn_n1, pn_p2, pos_max;
	pel temp_pel = 0;
#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0

#if CMOD_LUMA_16_LITE

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=2

#else

#pragma HLS array_partition variable = pred_cache_16x16 complete dim=0

#endif
#pragma HLS array_partition variable = src_up complete dim=1
#pragma HLS array_partition variable = src_le complete dim=1
	for (j = 0; j < 16; j++)
	{
#pragma HLS UNROLL
		//#pragma HLS loop_tripcount max = 16
		if (j < cu_height)
		{
			for (i = 0; i < 16; i++)
			{
#pragma HLS UNROLL
				if (i < cu_width)
				{
					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					}

					t_dx = (j + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_x = ((j + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dx << 5);
					t_dx = -t_dx;
					xx = i + t_dx;
					t_dy = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_y = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dy << 5);
					t_dy = -t_dy;
					yy = j + t_dy;

					if (yy <= -1) {
						offset = offset_x;
						x = xx;
						y = yx;
					}
					else {
						offset = offset_y;
						y = yy;
						x = xy;
					}
					if (y == -1) {
						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
						pos_max = cu_width * 2 - 1;
					}
					else {
						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
						pos_max = cu_height * 2 - 1;
					}

					pn_n1 += 3;
					p += 3;
					pn += 3;
					pn_p2 += 3;

					int src_p, src_pn, src_pn_n1, src_pn_p2;

					if (y == -1) {
						src_pn_n1 = src_up[pn_n1];
						src_p = src_up[p];
						src_pn = src_up[pn];
						src_pn_p2 = src_up[pn_p2];
					}
					else if (x == -1) {
						src_pn_n1 = src_le[pn_n1];
						src_p = src_le[p];
						src_pn = src_le[pn];
						src_pn_p2 = src_le[pn_p2];
					}
					else {
						src_pn_n1 = 0;
						src_p = 0;
						src_pn = 0;
						src_pn_p2 = 0;
					}
#if MIPF

					if (filter_idx == 0)
						temp_pel = (pel)((src_pn_n1 * com_tbl_ipred_adi_extra_smooth[offset][0] + src_p * com_tbl_ipred_adi_extra_smooth[offset][1] +
							src_pn * com_tbl_ipred_adi_extra_smooth[offset][2] + src_pn_p2 * com_tbl_ipred_adi_extra_smooth[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 1)
						temp_pel = (pel)((src_pn_n1 * com_tbl_ipred_adi_semi_sharp[offset][0] + src_p * com_tbl_ipred_adi_semi_sharp[offset][1] +
							src_pn * com_tbl_ipred_adi_semi_sharp[offset][2] + src_pn_p2 * com_tbl_ipred_adi_semi_sharp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 2)
						temp_pel = (pel)((src_pn_n1 * tbl_mc_c_coeff_hp[offset][0] + src_p * tbl_mc_c_coeff_hp[offset][1] +
							src_pn * tbl_mc_c_coeff_hp[offset][2] + src_pn_p2 * tbl_mc_c_coeff_hp[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 3)
						temp_pel = (pel)((src_pn_n1 * com_tbl_ipred_adi_bilinear[offset][0] + src_p * com_tbl_ipred_adi_bilinear[offset][1] +
							src_pn * com_tbl_ipred_adi_bilinear[offset][2] + src_pn_p2 * com_tbl_ipred_adi_bilinear[offset][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF

					temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
#else
					temp_pel = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + ((
						int)src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
#endif
					pred_cache_16x16[j][i] = temp_pel;
					//coef_tmp_16x16[j][i] = orgY[(j << 4) + i] - pred_cache_16x16[j][i];
				}
			}
		}
	}
}
void ipred_ang3_16_16_pred(U8 cu_width, U8 cu_height, pel src_le[16 * 2 + 3], pel src_up[16 * 2 + 3], U4 bit_depth, int ipm, pel pred_cache_16x16[16][16]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{

#if MIPF

	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = cu_width * cu_height <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	//pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[11][2] = { { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) } };
	//#pragma HLS ARRAY_PARTITION variable=ipred_dxdy complete dim=0
	int i, j;
	int offset, offset_x, offset_y, xx, yy, t_dx, t_dy;
	int xy = -1, yx = -1;
	int x, y;
	int p, pn, pn_n1, pn_p2, pos_max;
	pel temp_pel = 0;

#pragma HLS   ARRAY_PARTITION variable=ipred_dxdy complete dim=0
#pragma HLS   ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS   ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS   ARRAY_PARTITION variable=pred_cache_16x16 complete dim=2

	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		for (i = 0; i < 16; i++)
		{
			if (i < cu_width && j < cu_height)
			{
				if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
					filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
				}
				else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				}

					t_dx = (j + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_x = ((j + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dx << 5);
					t_dx = -t_dx;
					xx = i + t_dx;
					t_dy = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_y = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dy << 5);
					t_dy = -t_dy;
					yy = j + t_dy;

					if (yy <= -1) {
						offset = offset_x;
						x = xx;
						y = yx;
					}
					else {
						offset = offset_y;
						y = yy;
						x = xy;
					}
					if (y == -1) {
						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
						pos_max = cu_width * 2 - 1;
					}
					else {
						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
						pos_max = cu_height * 2 - 1;
					}

					pn_n1 += 3;
					p += 3;
					pn += 3;
					pn_p2 += 3;


				pel src_pn_n1 = (y == -1) ? src_up[pn_n1] : (x == -1) ? src_le[pn_n1] :0;
				pel src_p = (y == -1) ? src_up[p] : (x == -1) ? src_le[p] : 0;
				pel src_pn = (y == -1) ? src_up[pn] : (x == -1) ? src_le[pn] : 0;
				pel src_pn_p2 = (y == -1) ? src_up[pn_p2] : (x == -1) ? src_le[pn_p2] : 0;
#if MIPF

				s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][0] : com_tbl_ipred_adi_bilinear[offset][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][1] : com_tbl_ipred_adi_bilinear[offset][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][2] : com_tbl_ipred_adi_bilinear[offset][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][3] : com_tbl_ipred_adi_bilinear[offset][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];

				s32 buffer1 = src_pn_n1 * data1;
				s32 buffer2 = src_p * data2;
				s32 buffer3 = src_pn * data3;
				s32 buffer4 = src_pn_p2 * data4;

				pel tmp = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
				pel tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
				pred_cache_16x16[j][i] = tmp1;
#else
					pel temp_pel = ((src_up[pn_n1 + 3]) * (32 - offset) + (src_up[p + 3]) * (64 - offset) + ((
						int)src_up[pn + 3]) * (32 + offset) + (src_up[pn_p2 + 3]) * offset + 64) >> 7;
					pred_cache_16x16[j][i] = temp_pel;
#endif
			}
		}
	}
}





static void com_mc_l_00_16(pel* ref, int gmv_x, int gmv_y, int s_ref, int s_pred, pel pred[16][16], U7 w_l, U7 h_u, u8 w, u8 h, U1 bHpFilter)
{
	int i;
	int j;
	int offset_ref = 0;
	int offset_pred = 0;
	if (bHpFilter) {
		gmv_x >>= 4;
		gmv_y >>= 4;
	}
	else {
		gmv_x >>= 2;
		gmv_y >>= 2;
	}
	offset_ref += gmv_y * s_ref + gmv_x;
	{
		for (i = 0; i < h; i++) {

#pragma HLS loop_tripcount max = 16
			for (j = 0; j < w; j++) {

#pragma HLS loop_tripcount max = 16
				//pred[j + offset_pred] = ref[j + offset_ref];
				pred[i + h_u][j + w_l] = ref[j + offset_ref];
			}
			offset_pred += s_pred;
			offset_ref += s_ref;
		}
	}
}

static void com_mc_l_n0_0n_16(pel* ref, int gmv_x, int gmv_y, int s_ref, int s_pred, pel pred[16][16], U7 w_l, U7 h_u, u8 w, u8 h, U4 bit_depth, U1 bHpFilter, U1 b_n0, const s16 tbl_mc_l_coeff_all_2[2][16][8])
{
	//s16 tbl_mc_l_coeff_all_2[2][16][8] = { { { 0, 0, 0, (64), 0, 0, 0, 0 }, { ((-1)), (4), ((-10)), (57), (19), ((-7)), (3), ((-1)) }, { ((-1)), (4), ((-11)), (40), (40), ((-11)), (4), ((-1)) }, { ((-1)), (3), ((-7)), (19), (57), ((-10)), (4), ((-1)) }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 } }, { { 0, 0, 0, (64), 0, 0, 0, 0 }, { 0, (1), ((-3)), (63), (4), ((-2)), (1), 0 }, { ((-1)), (2), ((-5)), (62), (8), ((-3)), (1), 0 }, { ((-1)), (3), ((-8)), (60), (13), ((-4)), (1), 0 }, { ((-1)), (4), ((-10)), (58), (17), ((-5)), (1), 0 }, { ((-1)), (4), ((-11)), (52), (26), ((-8)), (3), ((-1)) }, { ((-1)), (3), ((-9)), (47), (31), ((-10)), (4), ((-1)) }, { ((-1)), (4), ((-11)), (45), (34), ((-10)), (4), ((-1)) }, { ((-1)), (4), ((-11)), (40), (40), ((-11)), (4), ((-1)) }, { ((-1)), (4), ((-10)), (34), (45), ((-11)), (4), ((-1)) }, { ((-1)), (4), ((-10)), (31), (47), ((-9)), (3), ((-1)) }, { ((-1)), (3), ((-8)), (26), (52), ((-11)), (4), ((-1)) }, { 0, (1), ((-5)), (17), (58), ((-10)), (4), ((-1)) }, { 0, (1), ((-4)), (13), (60), ((-8)), (3), ((-1)) }, { 0, (1), ((-3)), (8), (62), ((-5)), (2), ((-1)) }, { 0, (1), ((-2)), (4), (63), ((-3)), (1), 0 } } };

	U4 dxy;
	int offset_ref = 0;
	int offset_pred = 0;
	u8 i;
	u8 j;
	int stride = s_ref;
	s32 pt, index;
	if (bHpFilter)
	{
		if (b_n0) {
			dxy = gmv_x & 15;
			offset_ref += (gmv_y >> 4) * s_ref + (gmv_x >> 4) - 3;
			stride = 1;
		}
		else
		{
			dxy = gmv_y & 15;
			offset_ref += ((gmv_y >> 4) - 3) * s_ref + (gmv_x >> 4);
		}
	}
	else
	{
		if (b_n0) {
			dxy = gmv_x & 0x3;
			offset_ref += (gmv_y >> 2) * s_ref + (gmv_x >> 2) - 3;
			stride = 1;
		}
		else {
			dxy = gmv_y & 0x3;
			offset_ref += ((gmv_y >> 2) - 3) * s_ref + (gmv_x >> 2);
		}
	}

	{

		for (i = 0; i < h; i++) {

#pragma HLS loop_tripcount max = 16
			for (j = 0; j < w; j++) {

#pragma HLS loop_tripcount max = 16

				index = j + offset_ref;
				pt = 0;
				for (u8 k = 0; k < 8; k++)
				{
#pragma HLS UNROLL
					pt += tbl_mc_l_coeff_all_2[bHpFilter][dxy][k] * ref[index];
					index += stride;
				}


				pt = (pt + (1 << 5)) >> 6;

				pred[i + h_u][j + w_l] = ((pel)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
					1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
			}
			offset_ref += s_ref;
			offset_pred += s_pred;
		}
	}
}


static void com_mc_l_nn_16(pel* ref, int gmv_x, int gmv_y, int s_ref, int s_pred, s16 pred[16][16], U7 w_l, U7 h_u, u8 w, u8 h, U4 bit_depth,
	U1 bHpFilter, const s16 tbl_mc_l_coeff_all_3[2][16][8])
{
	static s32 buf[64 + 8][128 >> 1];
	//s16 tbl_mc_l_coeff_all_3[2][16][8] = { { { 0, 0, 0, (64), 0, 0, 0, 0 }, { ((s16)(-1)), (4), ((s16)(-10)), (57), (19), ((s16)(-7)), (3), ((s16)(-1)) }, { ((s16)(-1)), (4), ((s16)(-11)), (40), (40), ((s16)(-11)), (4), ((s16)(-1)) }, { ((s16)(-1)), (3), ((s16)(-7)), (19), (57), ((s16)(-10)), (4), ((s16)(-1)) }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 } }, { { 0, 0, 0, (64), 0, 0, 0, 0 }, { 0, (1), ((s16)(-3)), (63), (4), ((s16)(-2)), (1), 0 }, { ((s16)(-1)), (2), ((s16)(-5)), (62), (8), ((s16)(-3)), (1), 0 }, { ((s16)(-1)), (3), ((s16)(-8)), (60), (13), ((s16)(-4)), (1), 0 }, { ((s16)(-1)), (4), ((s16)(-10)), (58), (17), ((s16)(-5)), (1), 0 }, { ((s16)(-1)), (4), ((s16)(-11)), (52), (26), ((s16)(-8)), (3), ((s16)(-1)) }, { ((s16)(-1)), (3), ((s16)(-9)), (47), (31), ((s16)(-10)), (4), ((s16)(-1)) }, { ((s16)(-1)), (4), ((s16)(-11)), (45), (34), ((s16)(-10)), (4), ((s16)(-1)) }, { ((s16)(-1)), (4), ((s16)(-11)), (40), (40), ((s16)(-11)), (4), ((s16)(-1)) }, { ((s16)(-1)), (4), ((s16)(-10)), (34), (45), ((s16)(-11)), (4), ((s16)(-1)) }, { ((s16)(-1)), (4), ((s16)(-10)), (31), (47), ((s16)(-9)), (3), ((s16)(-1)) }, { ((s16)(-1)), (3), ((s16)(-8)), (26), (52), ((s16)(-11)), (4), ((s16)(-1)) }, { 0, (1), ((s16)(-5)), (17), (58), ((s16)(-10)), (4), ((s16)(-1)) }, { 0, (1), ((s16)(-4)), (13), (60), ((s16)(-8)), (3), ((s16)(-1)) }, { 0, (1), ((s16)(-3)), (8), (62), ((s16)(-5)), (2), ((s16)(-1)) }, { 0, (1), ((s16)(-2)), (4), (63), ((s16)(-3)), (1), 0 } } };


#pragma HLS ARRAY_PARTITION variable=buf block factor=72 dim=1 partition
	int dx;
	int dy;
	int offset_ref = 0;
	int offset_pred = 0;
	const int shift1 = bit_depth - 8;
	const int shift2 = 20 - bit_depth;
	const int add1 = 1 << shift1 >> 1;
	const int add2 = (1 << (shift2 - 1));
	static s32 ref_temp[8];
	u8 i, j, k;
	s32 pt;

	if (bHpFilter) {
		dx = gmv_x & 15;
		dy = gmv_y & 15;
		offset_ref += ((gmv_y >> 4) - 3) * s_ref + (gmv_x >> 4) - 3;
	}
	else {
		dx = gmv_x & 0x3;
		dy = gmv_y & 0x3;
		offset_ref += ((gmv_y >> 2) - 3) * s_ref + (gmv_x >> 2) - 3;
	}


#pragma HLS ARRAY_PARTITION variable=ref_temp complete dim=0
	{

		//b = buf;
		for (i = 0; i < h + 7; i++) {

#pragma HLS loop_tripcount max = 23
			ref_temp[0] = ref[offset_ref];
			ref_temp[1] = ref[1 + offset_ref];
			ref_temp[2] = ref[2 + offset_ref];
			ref_temp[3] = ref[3 + offset_ref];
			ref_temp[4] = ref[4 + offset_ref];
			ref_temp[5] = ref[5 + offset_ref];
			ref_temp[6] = ref[6 + offset_ref];
			for (j = 0; j < w; j++) {

#pragma HLS loop_tripcount max = 16
				ref_temp[7] = ref[j + 7 + offset_ref];
				//buf[i][j] = ((s16)(((tbl_mc_l_coeff_all_3[bHpFilter][dx][0]) * (ref_temp[0]) + (
				//	tbl_mc_l_coeff_all_3[bHpFilter][dx][1]) * (ref_temp[1]) + (tbl_mc_l_coeff_all_3[bHpFilter][dx][2]) * (
				//	ref_temp[2]) + (tbl_mc_l_coeff_all_3[bHpFilter][dx][3]) * (ref_temp[3]) + (
				//	tbl_mc_l_coeff_all_3[bHpFilter][dx][4]) * (ref_temp[4]) + (tbl_mc_l_coeff_all_3[bHpFilter][dx][5]) * (
				//	ref_temp[5]) + (tbl_mc_l_coeff_all_3[bHpFilter][dx][6]) * (ref_temp[6]) + (
				//	tbl_mc_l_coeff_all_3[bHpFilter][dx][7]) * (ref_temp[7]) + add1) >> shift1));

				buf[i][j] = 0;
				for (k = 0; k < 8; k++)
				{
#pragma HLS UNROLL
					buf[i][j] += tbl_mc_l_coeff_all_3[bHpFilter][dx][k] * ref_temp[k];
				}
				buf[i][j] = (buf[i][j] + add1) >> shift1;

				ref_temp[0] = ref_temp[1];
				ref_temp[1] = ref_temp[2];
				ref_temp[2] = ref_temp[3];
				ref_temp[3] = ref_temp[4];
				ref_temp[4] = ref_temp[5];
				ref_temp[5] = ref_temp[6];
				ref_temp[6] = ref_temp[7];
			}
			offset_ref += s_ref;
		}
		//b = buf;
		for (i = 0; i < h; i++) {

#pragma HLS loop_tripcount max = 16
			for (j = 0; j < w; j++) {

#pragma HLS loop_tripcount max = 16
				//pt = (MAC_8TAP(tbl_mc_l_coeff_all_3[bHpFilter][dy], buf[j + offset_buf], buf[j + w + offset_buf], buf[j + w * 2 + offset_buf], buf[j + w * 3 + offset_buf], buf[j + w * 4 + offset_buf], buf[j + w * 5 + offset_buf], buf[j + w * 6 + offset_buf], buf[j + w * 7 + offset_buf]) + add2) >> shift2;
				//pt = ((tbl_mc_l_coeff_all_3[bHpFilter][dy][0]) * (buf[i][j]) + (tbl_mc_l_coeff_all_3[bHpFilter][dy][1])
				//	* (buf[i + 1][j]) + (tbl_mc_l_coeff_all_3[bHpFilter][dy][2]) * (buf[i + 2][j]) + (
				//	tbl_mc_l_coeff_all_3[bHpFilter][dy][3]) * (buf[i + 3][j]) + (tbl_mc_l_coeff_all_3[bHpFilter][dy][4]) * (
				//	buf[i + 4][j]) + (tbl_mc_l_coeff_all_3[bHpFilter][dy][5]) * (buf[i + 5][j]) + (
				//	tbl_mc_l_coeff_all_3[bHpFilter][dy][6]) * (buf[i + 6][j]) + (tbl_mc_l_coeff_all_3[bHpFilter][dy][7]) * (
				//	buf[i + 7][j]) + add2) >> shift2;

				pt = 0;
				for (k = 0; k < 8; k++)
				{
#pragma HLS UNROLL
					pt += tbl_mc_l_coeff_all_3[bHpFilter][dy][k] * buf[i + k][j];
				}
				pt = (pt + add2) >> shift2;

				pred[i + h_u][j + w_l] = ((pel)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
					1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
			}
			offset_pred += s_pred;
		}
	}
}

static void com_tbl_mc_l_1_16(int ori_mv_x, int ori_mv_y, pel* ref, int gmv_x, int gmv_y, int s_ref, int s_pred, s16 pred[16][16],
	U7 w_l, U7 h_u, U7 w, U7 h, U4 bit_depth, U1 bHpFilter)
{
	int dx;
	int dy;

	if (bHpFilter == 1)
	{
		dx = ori_mv_x & 0xF;
		dy = ori_mv_y & 0xF;
	}
	else
	{
		dx = ori_mv_x & 0x3;
		dy = ori_mv_y & 0x3;
	}

	static s16 tbl_mc_l_coeff_all[2][16][8] = { { { 0, 0, 0, (64), 0, 0, 0, 0 }, { ((-1)), (4), ((-10)), (57), (19), ((-7)), (3), ((-1)) }, { ((-1)), (4), ((-11)), (40), (40), ((-11)), (4), ((-1)) }, { ((-1)), (3), ((-7)), (19), (57), ((-10)), (4), ((-1)) }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 } }, { { 0, 0, 0, (64), 0, 0, 0, 0 }, { 0, (1), ((-3)), (63), (4), ((-2)), (1), 0 }, { ((-1)), (2), ((-5)), (62), (8), ((-3)), (1), 0 }, { ((-1)), (3), ((-8)), (60), (13), ((-4)), (1), 0 }, { ((-1)), (4), ((-10)), (58), (17), ((-5)), (1), 0 }, { ((-1)), (4), ((-11)), (52), (26), ((-8)), (3), ((-1)) }, { ((-1)), (3), ((-9)), (47), (31), ((-10)), (4), ((-1)) }, { ((-1)), (4), ((-11)), (45), (34), ((-10)), (4), ((-1)) }, { ((-1)), (4), ((-11)), (40), (40), ((-11)), (4), ((-1)) }, { ((-1)), (4), ((-10)), (34), (45), ((-11)), (4), ((-1)) }, { ((-1)), (4), ((-10)), (31), (47), ((-9)), (3), ((-1)) }, { ((-1)), (3), ((-8)), (26), (52), ((-11)), (4), ((-1)) }, { 0, (1), ((-5)), (17), (58), ((-10)), (4), ((-1)) }, { 0, (1), ((-4)), (13), (60), ((-8)), (3), ((-1)) }, { 0, (1), ((-3)), (8), (62), ((-5)), (2), ((-1)) }, { 0, (1), ((-2)), (4), (63), ((-3)), (1), 0 } } };

	if (dx == 0 && dy == 0) {
		com_mc_l_00_16(ref, gmv_x, gmv_y, s_ref, s_pred, pred, w_l, h_u, w, h, bHpFilter);
	}
	else if (dx != 0 && dy != 0) {
		com_mc_l_nn_16(ref, gmv_x, gmv_y, s_ref, s_pred, pred, w_l, h_u, w, h, bit_depth, bHpFilter, tbl_mc_l_coeff_all);
	}
	else
		com_mc_l_n0_0n_16(ref, gmv_x, gmv_y, s_ref, s_pred, pred, w_l, h_u, w, h, bit_depth, bHpFilter, dx != 0 && dy == 0, tbl_mc_l_coeff_all);
}

static void com_tbl_mc_l_1_16_ME(int ori_mv_x, int ori_mv_y, pel refwin_md[88][88], int gmv_x, int gmv_y, int s_ref, int s_pred, s16 pred[16][16],
	U7 w_l, U7 h_u, U7 w, U7 h, U4 bit_depth, U1 bHpFilter)
{
	int dx;
	int dy;

	if (bHpFilter == 1)
	{
		dx = ori_mv_x & 0xF;
		dy = ori_mv_y & 0xF;
	}
	else
	{
		dx = ori_mv_x & 0x3;
		dy = ori_mv_y & 0x3;
	}

	static s16 tbl_mc_l_coeff_all[2][16][8] = { { { 0, 0, 0, (64), 0, 0, 0, 0 }, { ((-1)), (4), ((-10)), (57), (19), ((-7)), (3), ((-1)) }, { ((-1)), (4), ((-11)), (40), (40), ((-11)), (4), ((-1)) }, { ((-1)), (3), ((-7)), (19), (57), ((-10)), (4), ((-1)) }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0 } }, { { 0, 0, 0, (64), 0, 0, 0, 0 }, { 0, (1), ((-3)), (63), (4), ((-2)), (1), 0 }, { ((-1)), (2), ((-5)), (62), (8), ((-3)), (1), 0 }, { ((-1)), (3), ((-8)), (60), (13), ((-4)), (1), 0 }, { ((-1)), (4), ((-10)), (58), (17), ((-5)), (1), 0 }, { ((-1)), (4), ((-11)), (52), (26), ((-8)), (3), ((-1)) }, { ((-1)), (3), ((-9)), (47), (31), ((-10)), (4), ((-1)) }, { ((-1)), (4), ((-11)), (45), (34), ((-10)), (4), ((-1)) }, { ((-1)), (4), ((-11)), (40), (40), ((-11)), (4), ((-1)) }, { ((-1)), (4), ((-10)), (34), (45), ((-11)), (4), ((-1)) }, { ((-1)), (4), ((-10)), (31), (47), ((-9)), (3), ((-1)) }, { ((-1)), (3), ((-8)), (26), (52), ((-11)), (4), ((-1)) }, { 0, (1), ((-5)), (17), (58), ((-10)), (4), ((-1)) }, { 0, (1), ((-4)), (13), (60), ((-8)), (3), ((-1)) }, { 0, (1), ((-3)), (8), (62), ((-5)), (2), ((-1)) }, { 0, (1), ((-2)), (4), (63), ((-3)), (1), 0 } } };

	static pel ref[88 * 88];
	for (int i = 0; i < 88; i++)
	{
		for (int j = 0; j < 88; j++)
		{
			ref[i * 88 + j] = refwin_md[i][j];
		}
	}

	if (dx == 0 && dy == 0) {
		com_mc_l_00_16(ref, gmv_x, gmv_y, s_ref, s_pred, pred, w_l, h_u, w, h, bHpFilter);
	}
	else if (dx != 0 && dy != 0) {
		com_mc_l_nn_16(ref, gmv_x, gmv_y, s_ref, s_pred, pred, w_l, h_u, w, h, bit_depth, bHpFilter, tbl_mc_l_coeff_all);
	}
	else
		com_mc_l_n0_0n_16(ref, gmv_x, gmv_y, s_ref, s_pred, pred, w_l, h_u, w, h, bit_depth, bHpFilter, dx != 0 && dy == 0, tbl_mc_l_coeff_all);
}

void refwin_copy_line_16(U6 x, U6 y, pel refwin_md[512 * 512], pel refwin_line[24], pel refwin_line2[24])
{
#pragma HLS INLINE OFF
#pragma HLS array_partition variable=refwin_md cyclic factor=512 dim=1
#pragma HLS array_partition variable=refwin_line complete dim=0
#pragma HLS array_partition variable=refwin_line2 complete dim=0
	static pel ref_line[512];
	static pel ref_line2[512];
#pragma HLS array_partition variable=ref_line complete dim=0
#pragma HLS array_partition variable=ref_line2 complete dim=0
	for (int i = 0; i < 512; i++)
	{
#pragma HLS UNROLL
		ref_line[i] = refwin_md[y * 512 + i];
		ref_line2[i] = refwin_md[(y + 1) * 512 + i];
	}
	for (int j = 0; j < 24; j++)
	{
#pragma HLS UNROLL
		refwin_line[j] = ref_line[x + j];
		refwin_line2[j] = ref_line2[x + j];
	}
}

static void refwin_copy_16(U6 ref_offsetx, U6 ref_offsety, pel refwin_md[512 * 512], pel refwin[24][24])
{
#pragma HLS INLINE OFF
#pragma HLS array_partition variable=refwin complete dim=0
	for (int i = 0; i < 12; i++)
	{
#pragma HLS PIPELINE
		refwin_copy_line_16(ref_offsetx, i * 2 + ref_offsety, refwin_md, refwin[i * 2], refwin[i * 2 + 1]);
	}
}

static void com_tbl_mc_l_1_16_t(int x_pos, int y_pos, int ori_mv_x, int ori_mv_y, pel ref[SWW * SWH], int gmv_x, int gmv_y, int s_ref, int s_pred, s16 pred[16][16],
	U7 w_l, U7 h_u, U7 w, U7 h, U4 bit_depth, U1 bHpFilter, pel RefWindowLCU_t[512 * 512])
{
#pragma HLS array_partition variable=RefWindowLCU_t cyclic factor=512 dim=1
#pragma HLS array_partition variable=pred complete dim=0

	int         i, j;
	S32         pt;
	int dx;
	int dy;
	if (bHpFilter == 1)
	{
		dx = ori_mv_x & 0xF;
		dy = ori_mv_y & 0xF;
	}
	else
	{
		dx = ori_mv_x & 0x3;
		dy = ori_mv_y & 0x3;
	}
	int x_pos_inlcu = x_pos % 64;
	int y_pos_inlcu = y_pos % 64;

	const int shift1 = bit_depth - 8;
	const int shift2 = 20 - bit_depth;
	const int add1 = 1 << shift1 >> 1;
	const int add2 = (1 << (shift2 - 1));

	static S32 hor_buf[16][24];
	static pel refwin[24][24];
	static S8 tbl_mc_l_coeff[4][8] =
	{
		{ 0, 0, 0, 64, 0, 0, 0, 0 },
		{ -1, 4, -10, 57, 19, -7, 3, -1 },
		{ -1, 4, -11, 40, 40, -11, 4, -1 },
		{ -1, 3, -7, 19, 57, -10, 4, -1 }
	};
#pragma HLS array_partition variable=hor_buf complete dim=0
#pragma HLS array_partition variable=refwin complete dim=0
#pragma HLS array_partition variable=tbl_mc_l_coeff complete dim=0

	//U6 ref_offsetx = 9 + x_pos_inlcu + (ori_mv_x >> 2) + sw_offset_x_md;
	//U6 ref_offsety = 9 + y_pos_inlcu + (ori_mv_y >> 2) + sw_offset_y_md;

	refwin_copy_16((gmv_x >> 2) - 3, (gmv_y >> 2) - 3, RefWindowLCU_t, refwin);

	for (i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		for (j = 0; j < 23; j++)
		{
#pragma HLS UNROLL
			hor_buf[i][j] = (MAC_8TAP(tbl_mc_l_coeff[dx], refwin[j], i) + add1) >> shift1;
		}
	}

	for (i = 0; i < 16; i++)
	{
#pragma HLS UNROLL
		for (j = 0; j < 16; j++)
		{
#pragma HLS UNROLL
			pt = (MAC_8TAP(tbl_mc_l_coeff[dy], hor_buf[i], j) + add2) >> shift2;
			pred[j][i] = (s16)COM_CLIP3(0, (1 << bit_depth) - 1, pt);
		}
	}

	//	for (i = 0; i < 16; i++)
	//	{
	//#pragma HLS UNROLL
	//		for (j = 0; j < 16; j++)
	//		{
	//#pragma HLS UNROLL
	//			if (i >= h || j >= w)
	//			{
	//				pred[i][j] = 0;
	//			}
	//		}
	//	}


}

static void diff_16b_16(U7 w, U7 h, s16 src1[256], s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
#pragma HLS array_partition variable=diff complete dim=0
#pragma HLS array_partition variable=src1 complete dim=0
#pragma HLS array_partition variable=src2 complete dim=0
	int i;
	int j;
	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			diff[i][j] = ((s16)(((int)src1[j + i * 16]) - ((int)src2[i][j])));
		}
	}

	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			if (i >= h || j >= w)
			{
				diff[i][j] = 0;
			}
		}
	}
}


static void diff_16b_8_16(U7 w, U7 h, s16 src1[256], s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
#pragma HLS array_partition variable=diff complete dim=2
#pragma HLS array_partition variable=src1 complete dim=0
#pragma HLS array_partition variable=src2 complete dim=2
	int i;
	int j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			diff[i][j] = ((s16)(((int)src1[j + i * 16]) - ((int)src2[i][j])));

			if (i >= h || j >= w)
			{
				diff[i][j] = 0;
			}
		}
	}
}

static void diff_16b_16_8(U7 w, U7 h, s16 src1[256], s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
#pragma HLS array_partition variable=diff complete dim=2
#pragma HLS array_partition variable=src1 complete dim=0
#pragma HLS array_partition variable=src2 complete dim=2
	int i;
	int j;
	for (i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			diff[i][j] = ((s16)(((int)src1[j + i * 16]) - ((int)src2[i][j])));

			if (i >= h || j >= w)
			{
				diff[i][j] = 0;
			}
		}
	}
}

static void diff_16b_16_16(U7 w, U7 h, s16 src1[256], s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
#pragma HLS array_partition variable=diff complete dim=0
//#pragma HLS array_partition variable=src1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=src1 dim=1 cyclic factor=16
#pragma HLS array_partition variable=src2 complete dim=0
	int i;
	int j;
	for (i = 0; i < 16; i++) {
	#pragma HLS PIPELINE
#pragma HLS UNROLL
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
			diff[i][j] = ((s16)(((int)src1[j + i * 16]) - ((int)src2[i][j])));
		}
	}

//	for (i = 0; i < 16; i++) {
//#pragma HLS UNROLL
//		for (j = 0; j < 16; j++) {
//#pragma HLS UNROLL
//			if (i >= h || j >= w)
//			{
//				diff[i][j] = 0;
//			}
//		}
//	}
}

static void enc_diff_16b_16(U3 log2w, U3 log2h, s16* src1, s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
	//int x = log2w;
	//int y = log2h;
	U7 w = 1 << log2w;
	U7 h = 1 << log2h;

	diff_16b_16(w, h, src1, src2, s_src1, s_src2, s_diff, diff);
}

static void enc_diff_16b_8_16(U3 log2w, U3 log2h, s16* src1, s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
	//int x = log2w;
	//int y = log2h;
	U7 w = 1 << log2w;
	U7 h = 1 << log2h;

	diff_16b_8_16(w, h, src1, src2, s_src1, s_src2, s_diff, diff);
}

static void enc_diff_16b_16_8(U3 log2w, U3 log2h, s16* src1, s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
	//int x = log2w;
	//int y = log2h;
	U7 w = 1 << log2w;
	U7 h = 1 << log2h;

	diff_16b_16_8(w, h, src1, src2, s_src1, s_src2, s_diff, diff);
}

static void enc_diff_16b_16_16(U3 log2w, U3 log2h, s16* src1, s16 src2[16][16], int s_src1, int s_src2, int s_diff, s16 diff[16][16])
{

#pragma HLS INLINE off
	//int x = log2w;
	//int y = log2h;
	U7 w = 1 << log2w;
	U7 h = 1 << log2h;

	diff_16b_16_16(w, h, src1, src2, s_src1, s_src2, s_diff, diff);
}

void const_up_16x16(pel* up, IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_16x16->up_line[i];
		}
		for (int i = 0; i < (16 >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (16 >> 2) + i < pic_width_in_scu : pic_x_scu + (16 >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_16x16->map_scu_up_line[(16 >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (16 >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[16 + (i << 2) + j + 3] = IP_buffer_ptr_16x16->up_line[16 + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[16 + (i << 2) + j + 3] = up[16 + (i << 2) + 2];
				}
			}
		}
	}
}
void const_up_16x8(pel* up, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8, int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_16x8->up_line[i];
		}
		for (int i = 0; i < (16 >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (16 >> 2) + i < pic_width_in_scu : pic_x_scu + (16 >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_16x8->map_scu_up_line[(16 >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (16 >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[16 + (i << 2) + j + 3] = IP_buffer_ptr_16x8->up_line[16 + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[16 + (i << 2) + j + 3] = up[16 + (i << 2) + 2];
				}
			}
		}
	}
}
void const_up_8x16(pel* up, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < 8; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_8x16->up_line[i];
		}
		for (int i = 0; i < (8 >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (8 >> 2) + i < pic_width_in_scu : pic_x_scu + (8 >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_8x16->map_scu_up_line[(8 >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (8 >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[8 + (i << 2) + j + 3] = IP_buffer_ptr_8x16->up_line[8 + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[8 + (i << 2) + j + 3] = up[8 + (i << 2) + 2];
				}
			}
		}
	}
}

void const_left_16x16(pel* left, IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_16x16->left_line[i];
		}
		for (int i = 0; i < (16 >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (16 >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_16x16->map_scu_left_line_new[(16 >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (16 >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[16 + (i << 2) + j + 3] = IP_buffer_ptr_16x16->left_line[16 + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[16 + (i << 2) + j + 3] = left[16 + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_16x8(pel* left, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8, int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < 8; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_16x8->left_line[i];
		}
		for (int i = 0; i < (8 >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (8 >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_16x8->map_scu_left_line_new[(8 >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (8 >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[8 + (i << 2) + j + 3] = IP_buffer_ptr_16x8->left_line[8 + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[8 + (i << 2) + j + 3] = left[8 + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_8x16(pel* left, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_8x16->left_line[i];
		}
		for (int i = 0; i < (16 >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (16 >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_8x16->map_scu_left_line_new[(16 >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (16 >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[16 + (i << 2) + j + 3] = IP_buffer_ptr_8x16->left_line[16 + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[16 + (i << 2) + j + 3] = left[16 + (i << 2) + 2];
				}
			}
		}
	}
}

void const_top_left_16x16(pel* up, pel* left, IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, int avail_cu)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_16x16->top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}
void const_top_left_16x8(pel* up, pel* left, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8, int avail_cu)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_16x8->top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}
void const_top_left_8x16(pel* up, pel* left, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, int avail_cu)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_8x16->top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}

void get_IP_pixel_8_16(U8 cu_width, U8 cu_height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu, U4 bit_depth, U2 ch_type, pel left[2 * 16 + 3], pel up[2 * 16 + 3], U14 x, U14 y,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8)
{
#pragma HLS inline off
	U12 i;
	U12 j;
	int width_in_scu = ch_type == 0 ? cu_width >> 2 : cu_width >> (2 - 1);
	int height_in_scu = ch_type == 0 ? cu_height >> 2 : cu_height >> (2 - 1);
	//4
	U8 unit_size = ch_type == 0 ? 1 << 2 : 1 << 2 >> 1;
	U2 unit_size_bit = ch_type == 0 ? 2 : 1;
	//x/4
	int x_scu = ((ch_type == 0 ? x : x << 1)) >> 2;
	//y/4
	int y_scu = ((ch_type == 0 ? y : y << 1)) >> 2;
	//number of padding pixel in the left column   64
	int pad_le = cu_height;
	//number of padding pixel in the upper row     64
	int pad_up = cu_width;
	//16
	int pad_le_in_scu = height_in_scu;
	//16
	int pad_up_in_scu = width_in_scu;
	U8 pic_x = x & 63;
	U8 pic_y = y & 63;
	s16 pic_x_scu = (pic_x >> 2);
	s16 pic_y_scu = (pic_y >> 2);
	int flag;
	//U8 *up_temp_line;
	static pel up_temp_line[128];
	static pel left_line[64];

	S7 ip_array_size_idx = get_ip_array_size_idx(cu_width, cu_height);
#if MD_PRINT
	assert(ip_array_size_idx != -1);
#endif

#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=up_temp_line cyclic factor=64 dim=1
#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->up_temp_size cyclic factor=64 dim=2
#else
#pragma HLS ARRAY_PARTITION variable=up_temp_line complete dim=0
	//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->up_temp_size complete dim=2
#endif // CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->left_size complete dim=2

#if CDEBUG
	loop_1 : for (int i = 0; i < 128; i++)
#pragma HLS UNROLL
		up_temp_line[i] = IP_buffer_ptr->up_temp_size[ip_array_size_idx][i];
loop_2:	for (int i = 0; i < 64; i++)
#pragma HLS UNROLL
	left_line[i] = IP_buffer_ptr->left_size[ip_array_size_idx][i];

#endif // CDEBUG

#pragma HLS ARRAY_PARTITION variable=up complete dim=0


	const_up_8x16(up, IP_buffer_ptr_8x16, IP_map_scu_ptr_8x16, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
	const_left_8x16(left, IP_buffer_ptr_8x16, IP_map_scu_ptr_8x16, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
	const_top_left_8x16(up, left, IP_buffer_ptr_8x16, avail_cu);


#if CDEBUG
if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
	if (pic_y == 0) {
		for (i = 0; i < 16; i++) {
			if (i >= cu_width)
				break;
			assert(up[i + 3] == up_temp_line[pic_x + i]);
		}
		for (i = 0; i < 8; i++) {
			if (i < pad_up_in_scu) {
				if (x_scu + width_in_scu + i < pic_width_in_scu) {
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_above_line[MAP_SCU_IP_ptr->above_line_idx][x_scu + width_in_scu + i] >> 31 & ((
						unsigned int)1)));
				}
				else {
					flag = 0;
				}
				if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
					for (j = 0; j < 4; j++) {
						if (j < unit_size)
							assert(up[cu_width + (i << unit_size_bit) + j + 3] == up_temp_line[pic_x + cu_width + (i << unit_size_bit) + j]);
					}
				}
				else {
					for (j = 0; j < 4; j++) {
						if (j < unit_size)
							assert(up[cu_width + (i << unit_size_bit) + j + 3] == up[cu_width + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
	}
	else {
		for (i = 0; i < 16; i++) {
			if (i >= cu_width)
				break;
			assert(up[i + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + i]);
		}
		for (i = 0; i < 8; i++) {
			if (i < pad_up_in_scu) {
				if (pic_x_scu + width_in_scu + i < 16) {
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu + width_in_scu + i][pic_y_scu - 1]
						>> 31 & ((unsigned int)1)));
				}
				else {
					flag = 0;
				}
				if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
					for (j = 0; j < 4; j++) {
						if (j < unit_size)
							assert(up[cu_width + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + cu_width + (i << unit_size_bit) + j]);
					}
				}
				else {
					for (j = 0; j < 4; j++) {
						if (j < unit_size)
							assert(up[cu_width + (i << unit_size_bit) + j + 3] == up[cu_width + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
	}
}
if ((((int)avail_cu) & 1 << 1) == 1 << 1)
{
	if (pic_x == 0)
	{
		for (i = 0; i < 16; i++)
		{
			if (i >= cu_height)
				break;
			assert(left[i + 3] == left_line[pic_y + i]);
		}
		for (i = 0; i < 8; i++)
		{
			if (i < pad_le_in_scu)
			{
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[1 - MAP_SCU_IP_ptr->curr_ctu_idx][15][pic_y_scu + height_in_scu + i] >> 31
						& ((unsigned int)1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < 4; j++)
					{
						if (j < unit_size)
							assert(left[cu_height + (i << unit_size_bit) + j + 3] == left_line[pic_y + cu_height + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < 4; j++)
					{
						if (j < unit_size)
							assert(left[cu_height + (i << unit_size_bit) + j + 3] == left[cu_height + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
	}
	else
	{
		for (i = 0; i < 16; i++)
		{
			if (i >= cu_height)
				break;
			assert(left[i + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][pic_y + i][(pic_x >> 2) - 1]);
		}
		for (i = 0; i < 8; i++)
		{
			if (i < pad_le_in_scu)
			{
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu - 1][pic_y_scu + height_in_scu + i]
						>> 31 & ((unsigned int)1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < 4; j++)
					{
						if (j < unit_size)
							assert(left[cu_height + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][cu_height + (i << unit_size_bit) + j + pic_y][(pic_x >>
								2) - 1]);
					}
				}
				else
				{
					for (j = 0; j < 4; j++)
					{
						if (j < unit_size)
							assert(left[cu_height + (i << unit_size_bit) + j + 3] == left[cu_height + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
	}
}
if ((((int)avail_cu) & 1 << 2) == 1 << 2)
{
	if (pic_y == 0 && pic_x == 0)
	{
		assert(up[2] == ((pel)(IP_buffer_ptr->top_left)));
	}
	else if (pic_y == 0)
	{
		assert(up[2] == up_temp_line[pic_x - 1]);
	}
	else if (pic_x == 0)
	{
		assert(up[2] == left_line[pic_y - 1]);
	}
	else
	{
		assert(up[2] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x - 1]);
	}
}
#endif

up[1] = left[3];
left[1] = up[3];
up[0] = left[4];
left[0] = up[4];
}

void get_IP_pixel_16_8(U8 cu_width, U8 cu_height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu, U4 bit_depth, U2 ch_type, pel left[2 * 16 + 3], pel up[2 * 16 + 3], U14 x, U14 y,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8)
{
#pragma HLS inline off
	U12 i;
	U12 j;
	int width_in_scu = ch_type == 0 ? cu_width >> 2 : cu_width >> (2 - 1);
	int height_in_scu = ch_type == 0 ? cu_height >> 2 : cu_height >> (2 - 1);
	//4
	U8 unit_size = ch_type == 0 ? 1 << 2 : 1 << 2 >> 1;
	U2 unit_size_bit = ch_type == 0 ? 2 : 1;
	//x/4
	int x_scu = ((ch_type == 0 ? x : x << 1)) >> 2;
	//y/4
	int y_scu = ((ch_type == 0 ? y : y << 1)) >> 2;
	//number of padding pixel in the left column   64
	int pad_le = cu_height;
	//number of padding pixel in the upper row     64
	int pad_up = cu_width;
	//16
	int pad_le_in_scu = height_in_scu;
	//16
	int pad_up_in_scu = width_in_scu;
	U8 pic_x = x & 63;
	U8 pic_y = y & 63;
	s16 pic_x_scu = (pic_x >> 2);
	s16 pic_y_scu = (pic_y >> 2);
	int flag;
	//U8 *up_temp_line;
	static pel up_temp_line[128];
	static pel left_line[64];

	S7 ip_array_size_idx = get_ip_array_size_idx(cu_width, cu_height);
#if MD_PRINT
	assert(ip_array_size_idx != -1);
#endif

#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=up_temp_line cyclic factor=64 dim=1
#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->up_temp_size cyclic factor=64 dim=2
#else
#pragma HLS ARRAY_PARTITION variable=up_temp_line complete dim=0
	//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->up_temp_size complete dim=2
#endif // CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->left_size complete dim=2

#if CDEBUG
	loop_1 : for (int i = 0; i < 128; i++)
#pragma HLS UNROLL
		up_temp_line[i] = IP_buffer_ptr->up_temp_size[ip_array_size_idx][i];
		 loop_2:	for (int i = 0; i < 64; i++)
#pragma HLS UNROLL
			 left_line[i] = IP_buffer_ptr->left_size[ip_array_size_idx][i];

#endif // CDEBUG

#pragma HLS ARRAY_PARTITION variable=up complete dim=0

					
						const_up_16x8(up, IP_buffer_ptr_16x8, IP_map_scu_ptr_16x8, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
						const_left_16x8(left, IP_buffer_ptr_16x8, IP_map_scu_ptr_16x8, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
						const_top_left_16x8(up, left, IP_buffer_ptr_16x8, avail_cu);

#if CDEBUG
					if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
						if (pic_y == 0) {
							for (i = 0; i < 16; i++) {
								if (i >= cu_width)
									break;
								assert(up[i + 3] == up_temp_line[pic_x + i]);
							}
							for (i = 0; i < 8; i++) {
								if (i < pad_up_in_scu) {
									if (x_scu + width_in_scu + i < pic_width_in_scu) {
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_above_line[MAP_SCU_IP_ptr->above_line_idx][x_scu + width_in_scu + i] >> 31 & ((
											unsigned int)1)));
									}
									else {
										flag = 0;
									}
									if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == up_temp_line[pic_x + cu_width + (i << unit_size_bit) + j]);
										}
									}
									else {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == up[cu_width + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
						else {
							for (i = 0; i < 16; i++) {
								if (i >= cu_width)
									break;
								assert(up[i + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + i]);
							}
							for (i = 0; i < 8; i++) {
								if (i < pad_up_in_scu) {
									if (pic_x_scu + width_in_scu + i < 16) {
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu + width_in_scu + i][pic_y_scu - 1]
											>> 31 & ((unsigned int)1)));
									}
									else {
										flag = 0;
									}
									if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + cu_width + (i << unit_size_bit) + j]);
										}
									}
									else {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == up[cu_width + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
					}
					if ((((int)avail_cu) & 1 << 1) == 1 << 1)
					{
						if (pic_x == 0)
						{
							for (i = 0; i < 16; i++)
							{
								if (i >= cu_height)
									break;
								assert(left[i + 3] == left_line[pic_y + i]);
							}
							for (i = 0; i < 8; i++)
							{
								if (i < pad_le_in_scu)
								{
									if (pic_y_scu + height_in_scu + i < 16)
									{
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[1 - MAP_SCU_IP_ptr->curr_ctu_idx][15][pic_y_scu + height_in_scu + i] >> 31
											& ((unsigned int)1)));
									}
									else
									{
										flag = 0;
									}
									if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == left_line[pic_y + cu_height + (i << unit_size_bit) + j]);
										}
									}
									else
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == left[cu_height + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
						else
						{
							for (i = 0; i < 16; i++)
							{
								if (i >= cu_height)
									break;
								assert(left[i + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][pic_y + i][(pic_x >> 2) - 1]);
							}
							for (i = 0; i < 8; i++)
							{
								if (i < pad_le_in_scu)
								{
									if (pic_y_scu + height_in_scu + i < 16)
									{
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu - 1][pic_y_scu + height_in_scu + i]
											>> 31 & ((unsigned int)1)));
									}
									else
									{
										flag = 0;
									}
									if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][cu_height + (i << unit_size_bit) + j + pic_y][(pic_x >>
													2) - 1]);
										}
									}
									else
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == left[cu_height + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
					}
					if ((((int)avail_cu) & 1 << 2) == 1 << 2)
					{
						if (pic_y == 0 && pic_x == 0)
						{
							assert(up[2] == ((pel)(IP_buffer_ptr->top_left)));
						}
						else if (pic_y == 0)
						{
							assert(up[2] == up_temp_line[pic_x - 1]);
						}
						else if (pic_x == 0)
						{
							assert(up[2] == left_line[pic_y - 1]);
						}
						else
						{
							assert(up[2] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x - 1]);
						}
					}
#endif

					up[1] = left[3];
					left[1] = up[3];
					up[0] = left[4];
					left[0] = up[4];
}

void get_IP_pixel_16_16(U8 cu_width, U8 cu_height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu, U4 bit_depth, U2 ch_type, pel left[2 * 16 + 3], pel up[2 * 16 + 3], U14 x, U14 y,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8)
{
#pragma HLS inline off
	U12 i;
	U12 j;
	int width_in_scu = ch_type == 0 ? cu_width >> 2 : cu_width >> (2 - 1);
	int height_in_scu = ch_type == 0 ? cu_height >> 2 : cu_height >> (2 - 1);
	//4
	U8 unit_size = ch_type == 0 ? 1 << 2 : 1 << 2 >> 1;
	U2 unit_size_bit = ch_type == 0 ? 2 : 1;
	//x/4
	int x_scu = ((ch_type == 0 ? x : x << 1)) >> 2;
	//y/4
	int y_scu = ((ch_type == 0 ? y : y << 1)) >> 2;
	//number of padding pixel in the left column   64
	int pad_le = cu_height;
	//number of padding pixel in the upper row     64
	int pad_up = cu_width;
	//16
	int pad_le_in_scu = height_in_scu;
	//16
	int pad_up_in_scu = width_in_scu;
	U8 pic_x = x & 63;
	U8 pic_y = y & 63;
	s16 pic_x_scu = (pic_x >> 2);
	s16 pic_y_scu = (pic_y >> 2);
	int flag;
	//U8 *up_temp_line;
	static pel up_temp_line[128];
	static pel left_line[64];

	S7 ip_array_size_idx = get_ip_array_size_idx(cu_width, cu_height);
#if MD_PRINT
	assert(ip_array_size_idx != -1);
#endif

#if CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=up_temp_line cyclic factor=64 dim=1
#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->up_temp_size cyclic factor=64 dim=2
#else
#pragma HLS ARRAY_PARTITION variable=up_temp_line complete dim=0
	//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->up_temp_size complete dim=2
#endif // CMOD_LUMA_16_LITE
#pragma HLS ARRAY_PARTITION variable=left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr->left_size complete dim=2

#if CDEBUG
	loop_1 : for (int i = 0; i < 128; i++)
#pragma HLS UNROLL
		up_temp_line[i] = IP_buffer_ptr->up_temp_size[ip_array_size_idx][i];
		 loop_2:	for (int i = 0; i < 64; i++)
#pragma HLS UNROLL
			 left_line[i] = IP_buffer_ptr->left_size[ip_array_size_idx][i];

#endif // CDEBUG

#pragma HLS ARRAY_PARTITION variable=up complete dim=0
#pragma HLS ARRAY_PARTITION variable=left complete dim=0
#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_16x16->left_line complete dim=0
#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x16->map_scu_left_line_new complete dim=0
#pragma HLS ARRAY_PARTITION variable=left complete dim=0
#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_16x16->up_line complete dim=0
#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_16x16->up_line complete dim=0
#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x16->map_scu_up_line complete dim=0
						const_up_16x16(up, IP_buffer_ptr_16x16, IP_map_scu_ptr_16x16, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
						const_left_16x16(left, IP_buffer_ptr_16x16, IP_map_scu_ptr_16x16, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
						const_top_left_16x16(up, left, IP_buffer_ptr_16x16, avail_cu);
					

#if CDEBUG
					if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
						if (pic_y == 0) {
							for (i = 0; i < 16; i++) {
								if (i >= cu_width)
									break;
								assert(up[i + 3] == up_temp_line[pic_x + i]);
							}
							for (i = 0; i < 8; i++) {
								if (i < pad_up_in_scu) {
									if (x_scu + width_in_scu + i < pic_width_in_scu) {
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_above_line[MAP_SCU_IP_ptr->above_line_idx][x_scu + width_in_scu + i] >> 31 & ((
											unsigned int)1)));
									}
									else {
										flag = 0;
									}
									if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == up_temp_line[pic_x + cu_width + (i << unit_size_bit) + j]);
										}
									}
									else {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == up[cu_width + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
						else {
							for (i = 0; i < 16; i++) {
								if (i >= cu_width)
									break;
								assert(up[i + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + i]);
							}
							for (i = 0; i < 8; i++) {
								if (i < pad_up_in_scu) {
									if (pic_x_scu + width_in_scu + i < 16) {
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu + width_in_scu + i][pic_y_scu - 1]
											>> 31 & ((unsigned int)1)));
									}
									else {
										flag = 0;
									}
									if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + cu_width + (i << unit_size_bit) + j]);
										}
									}
									else {
										for (j = 0; j < 4; j++) {
											if (j < unit_size)
												assert(up[cu_width + (i << unit_size_bit) + j + 3] == up[cu_width + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
					}
					if ((((int)avail_cu) & 1 << 1) == 1 << 1)
					{
						if (pic_x == 0)
						{
							for (i = 0; i < 16; i++)
							{
								if (i >= cu_height)
									break;
								assert(left[i + 3] == left_line[pic_y + i]);
							}
							for (i = 0; i < 8; i++)
							{
								if (i < pad_le_in_scu)
								{
									if (pic_y_scu + height_in_scu + i < 16)
									{
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[1 - MAP_SCU_IP_ptr->curr_ctu_idx][15][pic_y_scu + height_in_scu + i] >> 31
											& ((unsigned int)1)));
									}
									else
									{
										flag = 0;
									}
									if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == left_line[pic_y + cu_height + (i << unit_size_bit) + j]);
										}
									}
									else
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == left[cu_height + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
						else
						{
							for (i = 0; i < 16; i++)
							{
								if (i >= cu_height)
									break;
								assert(left[i + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][pic_y + i][(pic_x >> 2) - 1]);
							}
							for (i = 0; i < 8; i++)
							{
								if (i < pad_le_in_scu)
								{
									if (pic_y_scu + height_in_scu + i < 16)
									{
										flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu - 1][pic_y_scu + height_in_scu + i]
											>> 31 & ((unsigned int)1)));
									}
									else
									{
										flag = 0;
									}
									if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][cu_height + (i << unit_size_bit) + j + pic_y][(pic_x >>
													2) - 1]);
										}
									}
									else
									{
										for (j = 0; j < 4; j++)
										{
											if (j < unit_size)
												assert(left[cu_height + (i << unit_size_bit) + j + 3] == left[cu_height + (i << unit_size_bit) + 2]);
										}
									}
								}
							}
						}
					}
					if ((((int)avail_cu) & 1 << 2) == 1 << 2)
					{
						if (pic_y == 0 && pic_x == 0)
						{
							assert(up[2] == ((pel)(IP_buffer_ptr->top_left)));
						}
						else if (pic_y == 0)
						{
							assert(up[2] == up_temp_line[pic_x - 1]);
						}
						else if (pic_x == 0)
						{
							assert(up[2] == left_line[pic_y - 1]);
						}
						else
						{
							assert(up[2] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x - 1]);
						}
					}
#endif

					up[1] = left[3];
					left[1] = up[3];
					up[0] = left[4];
					left[0] = up[4];
}


static void com_mc_fetch_16(pel* refpic_y, MD_COM_MODE* mod_info_curr, U2 channel, U4 bit_depth, U13 pic_width,
	U13 pic_height, u8 curr_mvr, S14 CtrPos[2][2][2], pel pred_cache[16][16],
	pel refwin_md[88][88], S14 CtrPosFME[RANGE_NUM][DIR_DIM][MAP_DIMS], pel RefWindowLCU_t[512 * 512])
{
#pragma HLS array_partition variable=mod_info_curr->refi complete dim=0
#pragma HLS array_partition variable=CtrPos complete dim=0
#pragma HLS array_partition variable=mod_info_curr->mv complete dim=0

	//int scup = mod_info_curr->scup;
	int x = mod_info_curr->x_pos;
	int y = mod_info_curr->y_pos;
	int w = mod_info_curr->cu_width;
	int h = mod_info_curr->cu_height;
	int pic_w = pic_width;
	int pic_h = pic_height;
	S3* refi = mod_info_curr->refi;
	int pred_stride = mod_info_curr->cu_width;
	int qpel_gmv_x;
	int qpel_gmv_y;
	s16 mv_t[2][2];
#pragma HLS array_partition variable=mv_t complete dim=0
	int stride_l = SWW;
	int qpel_gmv_x_in_sw = 0;
	int qpel_gmv_y_in_sw = 0;
	int fme = 0;
	int out = 0;
	int dx;
	int dy;
	int x_offset_min = 0;
	int x_offset_max = 0;
	int y_offset_min = 0;
	int y_offset_max = 0;

	mv_clip_1(x, y, pic_w, pic_h, w, h, refi, mod_info_curr->mv, mv_t);
	if (((int)refi[0]) >= 0) {
		/* forward */
		//ref_pic = refp_f.pic;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0][0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[0][1]);
		qpel_gmv_x_in_sw = qpel_gmv_x - (((int)CtrPos[0][0][0]) << 2) + (((int)CtrPos[0][0][1]) << 2);
		qpel_gmv_y_in_sw = qpel_gmv_y - (((int)CtrPos[0][1][0]) << 2) + (((int)CtrPos[0][1][1]) << 2);
		dx = qpel_gmv_x & 0x3;
		dy = qpel_gmv_y & 0x3;
		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			x_offset_max = 0;
			y_offset_min = 0;
			y_offset_max = 0;
			fme = 0;
		}
		else if (dx != 0 && dy == 0) {
			x_offset_min = -3;
			x_offset_max = 4;
			y_offset_min = 0;
			y_offset_max = 0;
			fme = 1;
		}
		else if (dx == 0 && dy != 0) {
			x_offset_min = 0;
			x_offset_max = 0;
			y_offset_min = -3;
			y_offset_max = 4;
			fme = 1;
		}
		else {
			x_offset_min = -3;
			x_offset_max = 4;
			y_offset_min = -3;
			y_offset_max = 4;
			fme = 1;
		}
#if MD_PRINT
		if (x_offset_min + (qpel_gmv_x >> 2) < ((int)CtrPos[0][0][0])
			|| x_offset_max + (qpel_gmv_x >> 2) > ((int)CtrPos[1][0][0])) {
			printf("X out->[%d,%d],", (int)CtrPos[0][0][0], (int)CtrPos[1][0][0]);
			out = 1;
		}
		if (y_offset_min + (qpel_gmv_y >> 2) < ((int)CtrPos[0][1][0])
			|| y_offset_max + (qpel_gmv_y >> 2) > ((int)CtrPos[1][1][0])) {
			printf("Y out->[%d,%d],", (int)CtrPos[0][1][0], (int)CtrPos[1][1][0]);
			out = 1;
		}
		if (out) {
			printf("Pos->[%d,%d],Level:%d\n", qpel_gmv_x, qpel_gmv_y, fme);
		}
		out == 0 ? ((void)0) : __assert_HLS("out == 0", "../separate/com_mc.c", (unsigned int)3518, __FUNCTION__);
#endif
		if (((unsigned int)channel) != ((unsigned int)CHANNEL_C)) {
			//com_mc_l( mv[REFP_0][0], mv[REFP_0][1], ref_pic->y, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_luma, pred_stride, pred[Y_C], w, h, bit_depth );
			//add by luke

			//com_tbl_mc_l_1_16(mod_info_curr->mv[REFP_0][0], mod_info_curr->mv[REFP_0][1], refpic_y, qpel_gmv_x_in_sw, qpel_gmv_y_in_sw, stride_l, pred_stride, pred_cache, 0, 0, w, h, bit_depth, 0);
			com_tbl_mc_l_1_16_t(x, y, mod_info_curr->mv[REFP_0][0], mod_info_curr->mv[REFP_0][1], refpic_y, qpel_gmv_x_in_sw, qpel_gmv_y_in_sw, stride_l, pred_stride, pred_cache, 0, 0, w, h, bit_depth, 0,
				RefWindowLCU_t);
			// Output pred from fme, mc only when fme was skipped.
			//com_mc_l_00(refpic_y, qpel_gmv_x_in_sw, qpel_gmv_y_in_sw, stride_l, pred_stride, pred_cache, w, h, 0);
		}
	}
}

static void init_inter_data_8_16(MD_KERNEL_MODE* mod_info_curr_ptr, /*COM_PART_INFO* mod_info_curr_pb_info,*/ U11 pic_width_in_scu)
{
#pragma HLS array_partition variable=mod_info_curr_ptr->mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->mvd complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mvd complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->refi complete dim=0
	mod_info_curr_ptr->skip_idx = 0;
	mod_info_curr_ptr->smvd_flag = 0;

	for (int i = 0; i < 2; i++) {

#pragma HLS UNROLL
		for (int j = 0; j < 2; j++) {

#pragma HLS UNROLL
			mod_info_curr_ptr->mv[i][j] = 0;
			mod_info_curr_ptr->mvd[i][j] = 0;
		}
		mod_info_curr_ptr->refi[i] = 0;
		//add by xujch
	}

	for (int c = 0; c < 2; c++) {

#pragma HLS UNROLL
		for (int d = 0; d < 4; d++) {

#pragma HLS UNROLL
			for (int e = 0; e < 2; e++) {

#pragma HLS UNROLL
				mod_info_curr_ptr->affine_mv[c][d][e] = 0;
				mod_info_curr_ptr->affine_mvd[c][d][e] = 0;
			}
		}
		//add by xujch
	}
}

static void init_inter_data_16_8(MD_KERNEL_MODE* mod_info_curr_ptr, /*COM_PART_INFO* mod_info_curr_pb_info,*/ U11 pic_width_in_scu)
{
#pragma HLS array_partition variable=mod_info_curr_ptr->mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->mvd complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mvd complete dim=0

	mod_info_curr_ptr->skip_idx = 0;
	mod_info_curr_ptr->smvd_flag = 0;

	for (int i = 0; i < 2; i++) {

#pragma HLS UNROLL
		for (int j = 0; j < 2; j++) {

#pragma HLS UNROLL
			mod_info_curr_ptr->mv[i][j] = 0;
			mod_info_curr_ptr->mvd[i][j] = 0;
		}
		mod_info_curr_ptr->refi[i] = 0;
		//add by xujch
	}

	for (int c = 0; c < 2; c++) {

#pragma HLS UNROLL
		for (int d = 0; d < 4; d++) {

#pragma HLS UNROLL
			for (int e = 0; e < 2; e++) {

#pragma HLS UNROLL
				mod_info_curr_ptr->affine_mv[c][d][e] = 0;
				mod_info_curr_ptr->affine_mvd[c][d][e] = 0;
			}
		}
		//add by xujch
	}
}

static void init_inter_data_16_16(MD_KERNEL_MODE* mod_info_curr_ptr, /*COM_PART_INFO* mod_info_curr_pb_info,*/ U11 pic_width_in_scu)
{
#pragma HLS array_partition variable=mod_info_curr_ptr->mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->mvd complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mvd complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->refi complete dim=0
	mod_info_curr_ptr->skip_idx = 0;
	mod_info_curr_ptr->smvd_flag = 0;

	for (int i = 0; i < 2; i++) {
#pragma HLS UNROLL
		for (int j = 0; j < 2; j++) {
			mod_info_curr_ptr->mv[i][j] = 0;
			mod_info_curr_ptr->mvd[i][j] = 0;
		}
		mod_info_curr_ptr->refi[i] = 0;
		//add by xujch
	}

	for (int c = 0; c < 2; c++) {
#pragma HLS UNROLL
		for (int d = 0; d < 4; d++) {
			for (int e = 0; e < 2; e++) {
				mod_info_curr_ptr->affine_mv[c][d][e] = 0;
				mod_info_curr_ptr->affine_mvd[c][d][e] = 0;
			}
		}
		//add by xujch
	}
}


static int com_affine_mc_pred_y_16(pel RefWindowLCU[SWW * SWH], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS], MD_COM_MODE* mod_info_curr,
	pel pred[16][16], U3 sub_w, U3 sub_h, U1 lidx, U4 bit_depth, U13 pic_w, U13 pic_h)
{
	U13 x = mod_info_curr->x_pos;
	U13 y = mod_info_curr->y_pos;
	U7 cu_width = mod_info_curr->cu_width;
	U7 cu_height = mod_info_curr->cu_height;
	U2 cp_num = ((int)(mod_info_curr->affine_flag)) + 1;
	S3* refi = mod_info_curr->refi;
	CPMV(*ac_mv)[2] = mod_info_curr->affine_mv[lidx];
	pel* pic_y = RefWindowLCU;
	//int y_offset = 0;
	//int uv_offset = 0;
	int qpel_gmv_x_in_sw = 0;
	int qpel_gmv_y_in_sw = 0;
#if MD_PRINT
	(com_tbl_log2[cu_width]) >= 4 ? ((void)0) : __assert_HLS("com_tbl_log2[cu_width] >= 4", "../separate/com_mc.c",
		3936, __FUNCTION__);
	(com_tbl_log2[cu_height]) >= 4 ? ((void)0) : __assert_HLS("com_tbl_log2[cu_height] >= 4",
		"../separate/com_mc.c", 3937, __FUNCTION__);
#endif
	int qpel_gmv_x;
	int qpel_gmv_y;
	//int predy_offset = 0;
	U7 w;
	U7 h;
	U3 half_w;
	U3 half_h;
	int dmv_hor_x;
	int dmv_ver_x;
	int dmv_hor_y;
	int dmv_ver_y;
	s32 mv_scale_hor = ((s32)ac_mv[0][0]) << 7;
	s32 mv_scale_ver = ((s32)ac_mv[0][1]) << 7;
	CPMV mv_scale_tmp_hor;
	CPMV mv_scale_tmp_ver;
	s32 hor_max;
	s32 hor_min;
	s32 ver_max;
	s32 ver_min;
	s32 mv_scale_tmp_hor_ori;
	s32 mv_scale_tmp_ver_ori;
	static s32 mv_save[64 >> 2][64 >> 2][2];
	U9 stride_l = SWW;
	// get clip MV Range
	hor_max = (pic_w + (1 << 7) + 4 - x - cu_width + 1) << 4;
	ver_max = (pic_h + (1 << 7) + 4 - y - cu_height + 1) << 4;
	hor_min = (-(1 << 7) - 4 - x) << 4;
	ver_min = (-(1 << 7) - 4 - y) << 4;
	// get sub block size
	half_w = sub_w >> 1;
	half_h = sub_h >> 1;
	// convert to 2^(storeBit + bit) precision
	// deltaMvHor
	dmv_hor_x = (ac_mv[1][0] - ac_mv[0][0]) << 7 >> (com_tbl_log2[cu_width]);
	dmv_hor_y = (ac_mv[1][1] - ac_mv[0][1]) << 7 >> (com_tbl_log2[cu_width]);
	if (cp_num == 3) {
		// deltaMvVer
		dmv_ver_x = (ac_mv[2][0] - ac_mv[0][0]) << 7 >> (com_tbl_log2[cu_height]);
		dmv_ver_y = (ac_mv[2][1] - ac_mv[0][1]) << 7 >> (com_tbl_log2[cu_height]);
	}
	else {
		// deltaMvVer
		dmv_ver_x = -dmv_hor_y;
		dmv_ver_y = dmv_hor_x;
	}
	// get prediction block by block (luma)
	for (h = 0; h < cu_height; h += sub_h) {

#pragma HLS loop_tripcount max = 4
		for (w = 0; w < cu_width; w += sub_w) {

#pragma HLS loop_tripcount max = 4
			int pos_x = w + half_w;
			int pos_y = h + half_h;
			if (w == 0 && h == 0) {
				pos_x = 0;
				pos_y = 0;
			}
			else if (w + sub_w == cu_width && h == 0) {
				pos_x = cu_width;
				pos_y = 0;
			}
			else if (w == 0 && h + sub_h == cu_height && cp_num == 3) {
				pos_x = 0;
				pos_y = cu_height;
			}
			mv_scale_tmp_hor = mv_scale_hor + dmv_hor_x * pos_x + dmv_ver_x * pos_y;
			mv_scale_tmp_ver = mv_scale_ver + dmv_hor_y * pos_x + dmv_ver_y * pos_y;
			// 1/16 precision, 18 bits, for MC
			com_mv_rounding_s32(mv_scale_tmp_hor, mv_scale_tmp_ver, &mv_scale_tmp_hor, &mv_scale_tmp_ver, 7, 0);
			mv_scale_tmp_hor = ((-131072) > ((131071 < mv_scale_tmp_hor ? (CPMV)131071 : mv_scale_tmp_hor)) ? (CPMV)(-131072) : (CPMV)((131071 < mv_scale_tmp_hor ? (CPMV)131071 : mv_scale_tmp_hor)));
			mv_scale_tmp_ver = ((-131072) > ((131071 < mv_scale_tmp_ver ? (CPMV)131071 : mv_scale_tmp_ver)) ? (CPMV)(-131072) : (CPMV)((131071 < mv_scale_tmp_ver ? (CPMV)131071 : mv_scale_tmp_ver)));
			// save MVF for chroma interpolation
			int w_scu = w >> 2;
			int h_scu = h >> 2;
			mv_save[w_scu][h_scu][0] = mv_scale_tmp_hor;
			mv_save[w_scu][h_scu][1] = mv_scale_tmp_ver;
			if (sub_w == 8 && sub_h == 8) {
				mv_save[w_scu + 1][h_scu][0] = mv_scale_tmp_hor;
				mv_save[w_scu + 1][h_scu][1] = mv_scale_tmp_ver;
				mv_save[w_scu][h_scu + 1][0] = mv_scale_tmp_hor;
				mv_save[w_scu][h_scu + 1][1] = mv_scale_tmp_ver;
				mv_save[w_scu + 1][h_scu + 1][0] = mv_scale_tmp_hor;
				mv_save[w_scu + 1][h_scu + 1][1] = mv_scale_tmp_ver;
			}
			// clip
			mv_scale_tmp_hor_ori = mv_scale_tmp_hor;
			mv_scale_tmp_ver_ori = mv_scale_tmp_ver;
			mv_scale_tmp_hor = (hor_max < ((hor_min > mv_scale_tmp_hor ? (CPMV)hor_min : mv_scale_tmp_hor)) ? (CPMV)hor_max : (CPMV)((hor_min > mv_scale_tmp_hor ? (CPMV)hor_min : mv_scale_tmp_hor)));
			mv_scale_tmp_ver = (ver_max < ((ver_min > mv_scale_tmp_ver ? (CPMV)ver_min : mv_scale_tmp_ver)) ? (CPMV)ver_max : (CPMV)((ver_min > mv_scale_tmp_ver ? (CPMV)ver_min : mv_scale_tmp_ver)));
			qpel_gmv_x = ((x + w) << 4) + mv_scale_tmp_hor;
			qpel_gmv_y = ((y + h) << 4) + mv_scale_tmp_ver;
			//convert to qpel_gmv in ref window
			qpel_gmv_x_in_sw = qpel_gmv_x - (((int)CtrPos[0][0][0]) << 4) + (((
				int)CtrPos[0][0][1]) << 4);
			qpel_gmv_y_in_sw = qpel_gmv_y - (((int)CtrPos[0][1][0]) << 4) + (((
				int)CtrPos[0][1][1]) << 4);
			if (!mv_inbound_new(qpel_gmv_x, qpel_gmv_y, CtrPos, sub_w, sub_h, mod_info_curr->x_chroma, mod_info_curr->y_chroma, x, y, 0, 4)) {
				printf("%s:%d: Affine motion is out of ref window!\npos=(%d %d) size=(%d %d) scu=(%d %d) ac_mv=(", __FUNCTION__, __LINE__, x, y, cu_width, cu_height, w >> 2, w >> 2);
				for (int i = 0; i < cp_num; ++i) {
					printf("(%d %d)", ac_mv[i][MV_X], ac_mv[i][MV_Y]);
				}
				printf(") gmv=(%d %d)\n", (qpel_gmv_x >> 4), (qpel_gmv_y >> 4));
				return 0;
			}

			com_tbl_mc_l_1_16(mv_scale_tmp_hor_ori, mv_scale_tmp_ver_ori, pic_y, qpel_gmv_x_in_sw, qpel_gmv_y_in_sw, stride_l,
				cu_width, pred, w, h, sub_w, sub_h, bit_depth, 1);

		}
		//pred += cu_width * sub_h;
	}

	if (mod_info_curr->chroma_motion)
	{
		sub_w = 8;
		sub_h = 8;
		int w_scu;
		int h_scu;
		for (h = 0; h < cu_height; h += sub_h) {

#pragma HLS loop_tripcount max = 64
			for (w = 0; w < cu_width; w += sub_w) {

#pragma HLS loop_tripcount max = 64
				w_scu = w >> 2;
				h_scu = h >> 2;
				mv_scale_tmp_hor = (mv_save[w_scu][h_scu][0] + mv_save[w_scu + 1][h_scu][0] + mv_save[w_scu][h_scu + 1][0] +
					mv_save[w_scu + 1][h_scu + 1][0] + 2) >> 2;
				mv_scale_tmp_ver = (mv_save[w_scu][h_scu][1] + mv_save[w_scu + 1][h_scu][1] + mv_save[w_scu][h_scu + 1][1] +
					mv_save[w_scu + 1][h_scu + 1][1] + 2) >> 2;
				mv_scale_tmp_hor_ori = mv_scale_tmp_hor;
				mv_scale_tmp_ver_ori = mv_scale_tmp_ver;
				mv_scale_tmp_hor = (hor_max < ((hor_min > mv_scale_tmp_hor ? hor_min : mv_scale_tmp_hor)) ? hor_max : ((
					hor_min > mv_scale_tmp_hor ? hor_min : mv_scale_tmp_hor)));
				mv_scale_tmp_ver = (ver_max < ((ver_min > mv_scale_tmp_ver ? ver_min : mv_scale_tmp_ver)) ? ver_max : ((
					ver_min > mv_scale_tmp_ver ? ver_min : mv_scale_tmp_ver)));
				qpel_gmv_x = ((mod_info_curr->x_chroma + w) << 4) + mv_scale_tmp_hor;
				qpel_gmv_y = ((mod_info_curr->y_chroma + h) << 4) + mv_scale_tmp_ver;
				//com_mc_c_hp( mv_scale_tmp_hor_ori, mv_scale_tmp_ver_ori, ref_pic->u, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, cu_width >> 1, pred_u + (w >> 1), sub_w >> 1, sub_h >> 1, bit_depth );
				//com_mc_c_hp( mv_scale_tmp_hor_ori, mv_scale_tmp_ver_ori, ref_pic->v, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, cu_width >> 1, pred_v + (w >> 1), sub_w >> 1, sub_h >> 1, bit_depth );
				//add by luke
				/* add_yrb */
				//qpel_gmv_x_in_sw = qpel_gmv_x - (((int)Fetch_Refwin_ptr->CtrPos[0][0][0]) << 4) + (((
				//	int)Fetch_Refwin_ptr->CtrPos[0][0][1]) << 4);
				//qpel_gmv_y_in_sw = qpel_gmv_y - (((int)Fetch_Refwin_ptr->CtrPos[0][1][0]) << 4) + (((
				//	int)Fetch_Refwin_ptr->CtrPos[0][1][1]) << 4);
				if (!mv_inbound_new(qpel_gmv_x, qpel_gmv_y, CtrPos, sub_w, sub_h, mod_info_curr->x_chroma, mod_info_curr->y_chroma, x, y, 0, 4)) {
					//printf("%s:%d: Affine motion is out of ref window!\npos=(%d %d) size=(%d %d) scu=(%d %d) ac_mv=(", __FUNCTION__, __LINE__, x, y, cu_width, cu_height, w_scu, h_scu);
					//for (int i = 0; i < cp_num; ++i) {
					//	printf("(%d %d)", ac_mv[i][MV_X], ac_mv[i][MV_Y]);
					//}
					//printf(") gmv=(%d %d)\n", (qpel_gmv_x >> 4), (qpel_gmv_y >> 4));
					return 0;
				}
			}
		}
	}

	return 1;
}
void get_pred_y_8_8(int w, int h, int x_refp, int y_refp, int dx, int dy, Arbitor& ref,
#if ENABLE_BFRAME
	U1 cur_refw_idx,
#endif
	pel pred[8][8])
{

//#pragma HLS INTERFACE m_axi port=ref->ref_0_0 offset=off name=ref_0_0
//#pragma HLS INTERFACE m_axi port=ref->ref_0_1 offset=off name=ref_0_1
//#pragma HLS INTERFACE m_axi port=ref->ref_1_0 offset=off name=ref_1_0
//#pragma HLS INTERFACE m_axi port=ref->ref_1_1 offset=off name=ref_1_1
//#pragma HLS INTERFACE m_axi port=ref->ref_2_0 offset=off name=ref_2_0
//#pragma HLS INTERFACE m_axi port=ref->ref_2_1 offset=off name=ref_2_1
//#pragma HLS INTERFACE m_axi port=ref->ref_3_0 offset=off name=ref_3_0
//#pragma HLS INTERFACE m_axi port=ref->ref_3_1 offset=off name=ref_3_1
//#pragma HLS INTERFACE m_axi port=ref->ref_4_0 offset=off name=ref_4_0
//#pragma HLS INTERFACE m_axi port=ref->ref_4_1 offset=off name=ref_4_1
//#pragma HLS INTERFACE m_axi port=ref->ref_5_0 offset=off name=ref_5_0
//#pragma HLS INTERFACE m_axi port=ref->ref_5_1 offset=off name=ref_5_1
//#pragma HLS INTERFACE m_axi port=ref->ref_6_0 offset=off name=ref_6_0
//#pragma HLS INTERFACE m_axi port=ref->ref_6_1 offset=off name=ref_6_1
//#pragma HLS INTERFACE m_axi port=ref->ref_7_0 offset=off name=ref_7_0
//#pragma HLS INTERFACE m_axi port=ref->ref_7_1 offset=off name=ref_7_1

#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_1 dim=2
//#pragma HLS ARRAY_PARTITION variable=pred complete dim=0
	int frac_idx = dy * 4 + dx;
	int gmvx_refp_int = x_refp >> 2;
	int gmvy_refp_int = y_refp >> 2;

	int m = (gmvx_refp_int & 31) + 7;
	int n = gmvy_refp_int & 7;

	pel buffer0[8][2][16];
#pragma HLS ARRAY_PARTITION variable= buffer0 complete dim=0
	if (m < 32) {

		if (n == 0) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				//buffer0[i][j][k] = refwin_mc[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][(gmvy_refp_int + i) & 7][j][k];
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 1) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 2) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 3) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 4) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 5) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 6) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}

		//buffer0[i][j][k] = refwin_mc[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][(gmvy_refp_int + i) & 7][j][k];

	}
	else {

		if (n == 0) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 1) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 2) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 3) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 4) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 5) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else if (n == 6) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}
		else {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 1) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
				buffer0[7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][k];
			}
		}

	}

	for (int i = 0; i < 8; i++) {
#pragma HLS UNROLL
		for (int j = 0; j < 8; j++) {
#if ENABLE_BFRAME
			pred[i][j] = buffer0[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[(k * 4 + i)][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + (k * 4 + i)) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + (k * 4 + i)) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif                    
		}
	}
	return;
}

void get_pred_y_16(int w, int h, int x_refp, int y_refp, int dx, int dy, pel refwin_mc[2560][8][2][16],
#if ENABLE_BFRAME
	U1 lidx,
#endif
	pel pred[16][16])
{
	int frac_idx = dy * 4 + dx;
	int gmvx_refp_int = x_refp >> 2;
	int gmvy_refp_int = y_refp >> 2;

#if 1
	pel buffer_0[3][8][2][16];
#pragma HLS ARRAY_PARTITION variable=buffer_0 complete dim=0
	int i, j, k, m;
	U6 gmvxdiv32 = gmvx_refp_int & 31;

	if (gmvxdiv32 < 17) {
		for (m = 0; m < 3; m++) {
#pragma HLS PIPELINE
			for (i = 0; i < 8; i++) {
#pragma HLS UNROLL
				for (j = 0; j < 2; j++) {
#pragma HLS UNROLL
					for (k = 0; k < 16; k++) {
#pragma HLS UNROLL
						buffer_0[m][i][j][k] = refwin_mc[gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][i][j][k];
					}
				}
			}
		}
	}
	else {
		for (m = 0; m < 3; m++) {
#pragma HLS PIPELINE
			for (i = 0; i < 8; i++) {
#pragma HLS UNROLL
				for (k = 0; k < 16; k++) {
#pragma HLS UNROLL
					buffer_0[m][i][1][k] = refwin_mc[gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][i][1][k];
					buffer_0[m][i][0][k] = refwin_mc[(gmvx_refp_int / 32 + 1) + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][i][0][k];
				}
			}
		}
	}

	for (k = 0; k < 4; k++) {
#pragma HLS PIPELINE
		for (i = 0; i < 4; i++) {
#pragma HLS UNROLL
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
#if ENABLE_BFRAME
				pred[(k * 4 + i)][j] = buffer_0[(((gmvy_refp_int & 7) + (k * 4 + i)) / 8)][(gmvy_refp_int + (k * 4 + i)) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
				pred[(k * 4 + i)][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx]
					[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif                    
			}
		}
	}
#else
	for (int i = 0; i < h; i++) {
		for (int j = 0; j < w; j++) {
#if ENABLE_BFRAME
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx + lidx * 1280]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif
		}
	}
#endif // 1
	return;
}

void get_pred_y_8_16(int w, int h, int x_refp, int y_refp, int dx, int dy, Arbitor& ref,
#if ENABLE_BFRAME
	U1 lidx,
#endif
	pel pred[16][16])
{
//#pragma HLS inline
	/*#pragma HLS INTERFACE m_axi port=ref->ref_0_0 offset=off name=ref_0_0
	#pragma HLS INTERFACE m_axi port=ref->ref_0_1 offset=off name=ref_0_1
	#pragma HLS INTERFACE m_axi port=ref->ref_1_0 offset=off name=ref_1_0
	#pragma HLS INTERFACE m_axi port=ref->ref_1_1 offset=off name=ref_1_1
	#pragma HLS INTERFACE m_axi port=ref->ref_2_0 offset=off name=ref_2_0
	#pragma HLS INTERFACE m_axi port=ref->ref_2_1 offset=off name=ref_2_1
	#pragma HLS INTERFACE m_axi port=ref->ref_3_0 offset=off name=ref_3_0
	#pragma HLS INTERFACE m_axi port=ref->ref_3_1 offset=off name=ref_3_1
	#pragma HLS INTERFACE m_axi port=ref->ref_4_0 offset=off name=ref_4_0
	#pragma HLS INTERFACE m_axi port=ref->ref_4_1 offset=off name=ref_4_1
	#pragma HLS INTERFACE m_axi port=ref->ref_5_0 offset=off name=ref_5_0
	#pragma HLS INTERFACE m_axi port=ref->ref_5_1 offset=off name=ref_5_1
	#pragma HLS INTERFACE m_axi port=ref->ref_6_0 offset=off name=ref_6_0
	#pragma HLS INTERFACE m_axi port=ref->ref_6_1 offset=off name=ref_6_1
	#pragma HLS INTERFACE m_axi port=ref->ref_7_0 offset=off name=ref_7_0
	#pragma HLS INTERFACE m_axi port=ref->ref_7_1 offset=off name=ref_7_1*/
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_1 dim=2
	int frac_idx = dy * 4 + dx;
	int gmvx_refp_int = x_refp >> 2;
	int gmvy_refp_int = y_refp >> 2;

#if 1
	pel buffer_0[3][8][2][16];
#pragma HLS ARRAY_PARTITION variable=buffer_0 complete dim=0
	int i, j, k, m;
	U6 gmvxdiv32 = gmvx_refp_int & 31;

	if (gmvxdiv32 < 17)
	{
		for (m = 0; m < 3; m++)
		{
#pragma HLS PIPELINE
			for (k = 0; k < 16; k++)
			{
#pragma HLS UNROLL
#define FLAT(i, j) buffer_0[m][i][j][k] = ref.ref_##i##_##j [gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][k];
				FLAT_8_2
#undef FLAT
			}
		}
	}
	else
	{
		for (m = 0; m < 3; m++)
		{
#pragma HLS PIPELINE
			for (k = 0; k < 16; k++)
			{
#pragma HLS UNROLL
#define FLAT(i) \
				buffer_0[m][i][1][k] = ref.ref_##i##_1[gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][k]; \
				buffer_0[m][i][0][k] = ref.ref_##i##_0[(gmvx_refp_int / 32 + 1) + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][k];
				FLAT_8
#undef FLAT
			}
		}
	}

	for (k = 0; k < 4; k++) {
#pragma HLS PIPELINE
		for (i = 0; i < 4; i++) {
#pragma HLS UNROLL
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
#if ENABLE_BFRAME
				pred[(k * 4 + i)][j] = buffer_0[(((gmvy_refp_int & 7) + (k * 4 + i)) / 8)][(gmvy_refp_int + (k * 4 + i)) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
				pred[(k * 4 + i)][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + (k * 4 + i)) >> 3) * 5) + 80 * frac_idx]
					[(gmvy_refp_int + (k * 4 + i)) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif                    
			}
		}
	}
#else
	for (int i = 0; i < h; i++) {
		for (int j = 0; j < w; j++) {
#if ENABLE_BFRAME
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx + lidx * 1280]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif
		}
	}
#endif // 1
	return;
}
void get_pred_y_16_8(int w, int h, int x_refp, int y_refp, int dx, int dy, Arbitor& ref,
#if ENABLE_BFRAME
	U1 lidx,
#endif
	pel pred[16][16])
{
#pragma HLS INTERFACE m_axi port=ref->ref_0_0 offset=off name=ref_0_0
#pragma HLS INTERFACE m_axi port=ref->ref_0_1 offset=off name=ref_0_1
#pragma HLS INTERFACE m_axi port=ref->ref_1_0 offset=off name=ref_1_0
#pragma HLS INTERFACE m_axi port=ref->ref_1_1 offset=off name=ref_1_1
#pragma HLS INTERFACE m_axi port=ref->ref_2_0 offset=off name=ref_2_0
#pragma HLS INTERFACE m_axi port=ref->ref_2_1 offset=off name=ref_2_1
#pragma HLS INTERFACE m_axi port=ref->ref_3_0 offset=off name=ref_3_0
#pragma HLS INTERFACE m_axi port=ref->ref_3_1 offset=off name=ref_3_1
#pragma HLS INTERFACE m_axi port=ref->ref_4_0 offset=off name=ref_4_0
#pragma HLS INTERFACE m_axi port=ref->ref_4_1 offset=off name=ref_4_1
#pragma HLS INTERFACE m_axi port=ref->ref_5_0 offset=off name=ref_5_0
#pragma HLS INTERFACE m_axi port=ref->ref_5_1 offset=off name=ref_5_1
#pragma HLS INTERFACE m_axi port=ref->ref_6_0 offset=off name=ref_6_0
#pragma HLS INTERFACE m_axi port=ref->ref_6_1 offset=off name=ref_6_1
#pragma HLS INTERFACE m_axi port=ref->ref_7_0 offset=off name=ref_7_0
#pragma HLS INTERFACE m_axi port=ref->ref_7_1 offset=off name=ref_7_1
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_1 dim=2
	int frac_idx = dy * 4 + dx;
	int gmvx_refp_int = x_refp >> 2;
	int gmvy_refp_int = y_refp >> 2;

#if 1
	pel buffer_0[3][8][2][16];
#pragma HLS ARRAY_PARTITION variable=buffer_0 complete dim=0
	int i, j, k, m;
	U6 gmvxdiv32 = gmvx_refp_int & 31;

	if (gmvxdiv32 < 17)
	{
		for (m = 0; m < 3; m++)
		{
#pragma HLS PIPELINE
			for (k = 0; k < 16; k++)
			{
#pragma HLS UNROLL
#define FLAT(i, j) buffer_0[m][i][j][k] = ref.ref_##i##_##j [gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][k];
				FLAT_8_2
#undef FLAT
			}
		}
	}
	else
	{
		for (m = 0; m < 3; m++)
		{
#pragma HLS PIPELINE
			for (k = 0; k < 16; k++)
			{
#pragma HLS UNROLL
#define FLAT(i) \
				buffer_0[m][i][1][k] = ref.ref_##i##_1[gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][k]; \
				buffer_0[m][i][0][k] = ref.ref_##i##_0[(gmvx_refp_int / 32 + 1) + ((gmvy_refp_int / 8 + m) * 5) + 80 * frac_idx + lidx * 1280][k];
				FLAT_8
#undef FLAT
			}
		}
	}

	for (k = 0; k < 4; k++) {
#pragma HLS PIPELINE
		for (i = 0; i < 4; i++) {
#pragma HLS UNROLL
			for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
#if ENABLE_BFRAME
				pred[(k * 4 + i)][j] = buffer_0[(((gmvy_refp_int & 7) + (k * 4 + i)) / 8)][(gmvy_refp_int + (k * 4 + i)) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
				pred[(k * 4 + i)][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + (k * 4 + i)) >> 3) * 5) + 80 * frac_idx]
					[(gmvy_refp_int + (k * 4 + i)) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif                    
			}
		}
	}
#else
	for (int i = 0; i < h; i++) {
		for (int j = 0; j < w; j++) {
#if ENABLE_BFRAME
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx + lidx * 1280]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif
		}
	}
#endif // 1
	return;
}
void get_pred_y_16_16(int w, int h, int x_refp, int y_refp, int dx, int dy, Arbitor& ref,
#if ENABLE_BFRAME
	U1 lidx,
#endif
	pel pred[16][16])
{
/*#pragma HLS INTERFACE m_axi port=ref->ref_0_0 offset=off name=ref_0_0
#pragma HLS INTERFACE m_axi port=ref->ref_0_1 offset=off name=ref_0_1
#pragma HLS INTERFACE m_axi port=ref->ref_1_0 offset=off name=ref_1_0
#pragma HLS INTERFACE m_axi port=ref->ref_1_1 offset=off name=ref_1_1
#pragma HLS INTERFACE m_axi port=ref->ref_2_0 offset=off name=ref_2_0
#pragma HLS INTERFACE m_axi port=ref->ref_2_1 offset=off name=ref_2_1
#pragma HLS INTERFACE m_axi port=ref->ref_3_0 offset=off name=ref_3_0
#pragma HLS INTERFACE m_axi port=ref->ref_3_1 offset=off name=ref_3_1
#pragma HLS INTERFACE m_axi port=ref->ref_4_0 offset=off name=ref_4_0
#pragma HLS INTERFACE m_axi port=ref->ref_4_1 offset=off name=ref_4_1
#pragma HLS INTERFACE m_axi port=ref->ref_5_0 offset=off name=ref_5_0
#pragma HLS INTERFACE m_axi port=ref->ref_5_1 offset=off name=ref_5_1
#pragma HLS INTERFACE m_axi port=ref->ref_6_0 offset=off name=ref_6_0
#pragma HLS INTERFACE m_axi port=ref->ref_6_1 offset=off name=ref_6_1
#pragma HLS INTERFACE m_axi port=ref->ref_7_0 offset=off name=ref_7_0
#pragma HLS INTERFACE m_axi port=ref->ref_7_1 offset=off name=ref_7_1*/
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_1 dim=2
	int frac_idx = dy * 4 + dx;
	int gmvx_refp_int = x_refp >> 2;
	int gmvy_refp_int = y_refp >> 2;

#if 1
	pel buffer0[2][8][2][16];
#pragma HLS ARRAY_PARTITION variable=buffer_0 complete dim=0
//#pragma HLS ARRAY_PARTITION variable=pred complete dim=0

	int i, j, k, m;
	U6 gmvxdiv32 = gmvx_refp_int & 31;
	int n = gmvy_refp_int & 7;
	if (gmvxdiv32 < 17) {

		for (k = 0; k < 16; k++) {
#pragma HLS UNROLL
#define FLAT(i, j) buffer0[1][i][j][k] = ref.ref_##i##_##j [gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + 1) * 5) + 80 * frac_idx + lidx * 1280][k];
			FLAT_8_2
#undef FLAT
		}

		if (n == 0) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				//buffer0[i][j][k] = refwin_mc[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + cur_refw_idx * 1280][(gmvy_refp_int + i) & 7][j][k];
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 1) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 2) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 3) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 4) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 5) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 6) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
	}
	else {

		for (k = 0; k < 16; k++) {
#pragma HLS UNROLL
#define FLAT(i) \
				buffer0[1][i][1][k] = ref.ref_##i##_1[gmvx_refp_int / 32 + ((gmvy_refp_int / 8 + 1) * 5) + 80 * frac_idx + lidx * 1280][k]; \
				buffer0[1][i][0][k] = ref.ref_##i##_0[(gmvx_refp_int / 32 + 1) + ((gmvy_refp_int / 8 + 1) * 5) + 80 * frac_idx + lidx * 1280][k];
			FLAT_8
#undef FLAT
		}

		if (n == 0) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 1) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 2) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 3) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 4) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 5) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else if (n == 6) {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
		else {
			for (int k = 0; k < 16; k++) {
#pragma HLS UNROLL
				buffer0[0][0][0][k] = ref.ref_0_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][0][1][k] = ref.ref_0_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][0][k] = ref.ref_1_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][1][1][k] = ref.ref_1_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][0][k] = ref.ref_2_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][2][1][k] = ref.ref_2_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][0][k] = ref.ref_3_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][3][1][k] = ref.ref_3_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][0][k] = ref.ref_4_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][4][1][k] = ref.ref_4_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][0][k] = ref.ref_5_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][5][1][k] = ref.ref_5_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][0][k] = ref.ref_6_0[(gmvx_refp_int >> 5) + 1 + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][6][1][k] = ref.ref_6_1[(gmvx_refp_int >> 5) + (((gmvy_refp_int >> 3) + 2) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][0][k] = ref.ref_7_0[(gmvx_refp_int >> 5) + 1 + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
				buffer0[0][7][1][k] = ref.ref_7_1[(gmvx_refp_int >> 5) + ((gmvy_refp_int >> 3) * 5) + 80 * frac_idx + lidx * 1280][k];
			}
		}
	}


	for (i = 0; i < 16; i++) {
#pragma HLS UNROLL
		for (j = 0; j < 16; j++) {
#pragma HLS UNROLL
#if ENABLE_BFRAME
			if((((gmvy_refp_int & 7) + i) >= 8) && (((gmvy_refp_int & 7) + i) < 16)) 
				pred[i][j] = buffer0[1][(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
			else
				pred[i][j] = buffer0[0][(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[(k * 4 + i)][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + (k * 4 + i)) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + (k * 4 + i)) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif                    
		}
	}
#else
	for (int i = 0; i < h; i++) {
		for (int j = 0; j < w; j++) {
#if ENABLE_BFRAME
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx + lidx * 1280]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif
		}
	}
#endif // 1
	return;
}

static BOOL com_mc_cu_y_16(CU_POS* cu, U13 pic_w, U13 pic_h, S3 refi[REFP_NUM], s16 mv[REFP_NUM][2], U10 stride_luma,
	pel pred_y[16][16], U4 bit_depth, strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	pel fme2mdrefbuf[2560][8][2][16]
	, U2 mode_type
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int mode_idx, int umve_flag
#endif
)
{
	int scup = cu->scup;
	int x = cu->x_pos;
	int y = cu->y_pos;
	int w = cu->cu_width;
	int h = cu->cu_height;
	S14 mv_t[2];
	int min_clip[2];
	int max_clip[2];
	int x_ext = cu->x_pos << 2;
	int y_ext = cu->y_pos << 2;
	int w_ext = cu->cu_width << 2;
	int h_ext = cu->cu_height << 2;
	int x_ext_of_ctu;
	int y_ext_of_ctu;
	int qpel_gmv_x_of_ctu;
	int qpel_gmv_y_of_ctu;
	int qpel_gmv_x_of_refp_cu;
	int qpel_gmv_y_of_refp_cu;

	//int bidx = 0;
	U1 refi0_valid = 0, refi1_valid = 0;
	pel pred_ref0[16][16];

	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];
	if (refi[REFP_0] >= 0)
	{
		if (x_ext + (mv[REFP_0][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_0][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_0][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_0][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

#if ENABLE_BFRAME
		S2 cur_refw_idx = get_ref_idx_y_16(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
#if SUB_TMVP
		if (mode_idx == 0 && cu->cu_width >= SBTMVP_MIN_SIZE && cu->cu_height >= SBTMVP_MIN_SIZE && mode_type >= MODE_SKIP && umve_flag == 0)
		{
			if (!core_sbtmvp->isValid)
				return FALSE;
			core_sbtmvp->isValid = TRUE;

			int dx = qpel_gmv_x & 0x3;
			int dy = qpel_gmv_y & 0x3;
			int x_offset_min = 0;
			int x_offset_max = 0;
			int y_offset_min = 0;
			int y_offset_max = 0;

			if (dx == 0 && dy == 0) {
				x_offset_min = 0;
				y_offset_min = 0;
			}
			else {
				x_offset_min = -3;
				y_offset_min = -3;
			}
			x_offset_max = 4;
			y_offset_max = 4;

			int cu_width = cu->cu_width;
			int cu_height = cu->cu_height;
			//int x = cu->x_pos;
			//int y = cu->y_pos;
			int sub_w = cu_width >> 1;/// SBTMVP_NUM_1D
			int sub_h = cu_height >> 1;

			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp[16][16];
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + (mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + (mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + (mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + (mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}
					qpel_gmv_x = (x << 2) + ((int)mv_sbtmvp[0]);
					qpel_gmv_y = (y << 2) + ((int)mv_sbtmvp[1]);
					dx = qpel_gmv_x & 0x3;
					dy = qpel_gmv_y & 0x3;
					if (dx == 0 && dy == 0) {
						x_offset_min = 0;
						y_offset_min = 0;
					}
					else {
						x_offset_min = -3;
						y_offset_min = -3;
					}
#if ENABLE_BFRAME
					cur_refw_idx = get_ref_idx_y_16(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
					if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + x_offset_max <= (160 + 4) &&
						(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + sub_h + y_offset_max <= (128 + 4)))
					{
#if MD_PRINT_ENH
						if (mode_type == MODE_SKIP)
							printf("<MODE_SKIP:SUB_TMVP> ");
						else if (mode_type == MODE_DIR)
							printf("<MODE_DIR:SUB_TMVP> ");
						printf("out of ref0 window ERROR: sub cu %d=(%d %d %d %d)", k, x, y, sub_w, sub_h);
						printf("mv=(");
						printf("%d %d", mv_sbtmvp[MV_X], mv_sbtmvp[MV_Y]);
						printf(")\n ");
#if ENABLE_BFRAME
						printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
							cur_refw_idx,
							CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
							CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
						);
						printf("\n");
#endif 
						fflush(stdout);
#endif
						core_sbtmvp->isValid = FALSE;
						return FALSE;
					}

					get_pred_y_16(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, fme2mdrefbuf,
#if ENABLE_BFRAME
						cur_refw_idx,
#endif // ENABLE_BFRAME
						pred_tmp);

					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < sub_h; i++)
					{
						for (int j = 0; j < sub_w; j++)
						{
							pred_ref0[h + i][w + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
						}
					}

					/*FILE* sbtmvp = fopen("sbtmvp.csv", "w");
					for (int i = 0; i < 64; i++) {
						for (int j = 0; j < 64; j++) {
							pel curr = pred[i * 64 + j];
							fprintf(sbtmvp, "%d, ", (int)curr);
						}
						fprintf(sbtmvp, "\n");
					}
					fclose(sbtmvp);*/
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}
		}
		else {
#endif
			if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
				(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
			{
#if MD_PRINT
				if (mode_type == MODE_SKIP)
					printf("<MODE_SKIP> ");
				else if (mode_type == MODE_INTER)
					printf("<MODE_INTER> ");
				else if (mode_type == MODE_DIR)
					printf("<MODE_DIR> ");
				printf("out of ref0 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
				printf("mv=(");
				printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
				printf(")\n ");
#if ENABLE_BFRAME
				printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
					cur_refw_idx,
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
					CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
				);
				printf("\n");
#endif 
				fflush(stdout);
#endif
				return FALSE;
			}


			get_pred_y_16(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, fme2mdrefbuf,
#if ENABLE_BFRAME
				cur_refw_idx,
#endif // ENABLE_BFRAME
				pred_ref0);
#if SUB_TMVP
		}
#endif
		//++bidx;
		refi0_valid = 1;
	}
	if (refi0_valid)
	{
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				pred_y[i][j] = pred_ref0[i][j];
	}
#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	static pel pred_ref1[16][16];
	if (REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred)[16] = bidx ? pred_snd : pred_y;
		//COM_PIC* ref_pic;
		//ref_pic = refp[refi[REFP_1]][REFP_1].pic;
		if (x_ext + (mv[REFP_1][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_1][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_1][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_1][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		S2 cur_refw_idx = get_ref_idx_y_16(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));

		//if (channel != CHANNEL_C)
		//{
		//if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < SWH)) { return FALSE; }
		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			if (mode_type == MODE_SKIP)
				printf("<MODE_SKIP> ");
			else if (mode_type == MODE_INTER)
				printf("<MODE_INTER> ");
			else if (mode_type == MODE_DIR)
				printf("<MODE_DIR> ");
			printf("out of ref1 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
			printf("mv=(");
			printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
			printf(")\n");
			printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
				cur_refw_idx,
				CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
				CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
			);
			printf("\n");
			fflush(stdout);
#endif
			return FALSE;
		}

		get_pred_y_16(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, fme2mdrefbuf, cur_refw_idx, pred_ref1);
		//}

//		if (channel != CHANNEL_L)
//		{
//#if CHROMA_NOT_SPLIT
//			assert(w >= 8 && h >= 8);
//#endif
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->u, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[U_C], w >> 1, h >> 1, bit_depth);
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->v, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[V_C], w >> 1, h >> 1, bit_depth);
//		}
		//bidx++;
		refi1_valid = 1;
	}


	if (refi0_valid && refi1_valid)
	{
		//if (channel != CHANNEL_C)
		//{
#if SIMD_MC
		average_16b_no_clip_sse(pred_y[0], pred_snd[0], pred_y[0], 16, 16, 16, w, h);
#else
		//pel(*p0)[16] = pred_y;
		//pel(*p1)[16] = pred_snd;
		for (int j = 0; j < h; j++)
		{
			for (int i = 0; i < w; i++)
			{
				pred_y[j][i] = (pred_ref0[j][i] + pred_ref1[j][i] + 1) >> 1;
			}
		}
#endif
		//}

//		if (channel != CHANNEL_L)
//		{
//#if SIMD_MC
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			average_16b_no_clip_sse(pred_buf[U_C], pred_snd[U_C], pred_buf[U_C], pred_stride, pred_stride, pred_stride, w, h);
//			average_16b_no_clip_sse(pred_buf[V_C], pred_snd[V_C], pred_buf[V_C], pred_stride, pred_stride, pred_stride, w, h);
//#else
//			p0 = pred_buf[U_C];
//			p1 = pred_snd[U_C];
//			p2 = pred_buf[V_C];
//			p3 = pred_snd[V_C];
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			for (j = 0; j < h; j++)
//			{
//				for (i = 0; i < w; i++)
//				{
//					p0[i] = (p0[i] + p1[i] + 1) >> 1;
//					p2[i] = (p2[i] + p3[i] + 1) >> 1;
//				}
//				p0 += pred_stride;
//				p1 += pred_stride;
//				p2 += pred_stride;
//				p3 += pred_stride;
//			}
//#endif
//		}
	}
	else
	{
		if (refi0_valid)
		{
			/////
		}
		else if (refi1_valid)
		{
			for (int j = 0; j < h; j++)
			{
				for (int i = 0; i < w; i++)
				{
					pred_y[j][i] = pred_ref1[j][i];
				}
			}
		}
		else
		{
#if MD_PRINT
			printf("%s:%d:all refs are invalid\n", __FUNCTION__, 7922);
#endif
		}
	}
#endif
	return 1;
}

static BOOL com_mc_cu_y_8_16(CU_POS* cu, U13 pic_w, U13 pic_h, S3 refi[REFP_NUM], s16 mv[REFP_NUM][2], U10 stride_luma,
	pel pred_y[16][16], U4 bit_depth, strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	Arbitor& ref
	, U2 mode_type
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int mode_idx, int umve_flag
#endif
)
{
	int scup = cu->scup;
	int x = cu->x_pos;
	int y = cu->y_pos;
	int w = cu->cu_width;
	int h = cu->cu_height;
	S14 mv_t[2];
	int min_clip[2];
	int max_clip[2];
	int x_ext = cu->x_pos << 2;
	int y_ext = cu->y_pos << 2;
	int w_ext = cu->cu_width << 2;
	int h_ext = cu->cu_height << 2;
	int x_ext_of_ctu;
	int y_ext_of_ctu;
	int qpel_gmv_x_of_ctu;
	int qpel_gmv_y_of_ctu;
	int qpel_gmv_x_of_refp_cu;
	int qpel_gmv_y_of_refp_cu;

	//int bidx = 0;
	U1 refi0_valid = 0, refi1_valid = 0;
	pel pred_ref0[16][16];

	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];
	if (refi[REFP_0] >= 0)
	{
		if (x_ext + (mv[REFP_0][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_0][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_0][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_0][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

#if ENABLE_BFRAME
		S2 cur_refw_idx = get_ref_idx_y_8_16(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
#if SUB_TMVP
		if (mode_idx == 0 && cu->cu_width >= SBTMVP_MIN_SIZE && cu->cu_height >= SBTMVP_MIN_SIZE && mode_type >= MODE_SKIP && umve_flag == 0)
		{
			if (!core_sbtmvp->isValid)
				return FALSE;
			core_sbtmvp->isValid = TRUE;

			int dx = qpel_gmv_x & 0x3;
			int dy = qpel_gmv_y & 0x3;
			int x_offset_min = 0;
			int x_offset_max = 0;
			int y_offset_min = 0;
			int y_offset_max = 0;

			if (dx == 0 && dy == 0) {
				x_offset_min = 0;
				y_offset_min = 0;
			}
			else {
				x_offset_min = -3;
				y_offset_min = -3;
			}
			x_offset_max = 4;
			y_offset_max = 4;

			int cu_width = cu->cu_width;
			int cu_height = cu->cu_height;
			//int x = cu->x_pos;
			//int y = cu->y_pos;
			int sub_w = cu_width >> 1;/// SBTMVP_NUM_1D
			int sub_h = cu_height >> 1;

			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp[16][16];
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + (mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + (mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + (mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + (mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}
					qpel_gmv_x = (x << 2) + ((int)mv_sbtmvp[0]);
					qpel_gmv_y = (y << 2) + ((int)mv_sbtmvp[1]);
					dx = qpel_gmv_x & 0x3;
					dy = qpel_gmv_y & 0x3;
					if (dx == 0 && dy == 0) {
						x_offset_min = 0;
						y_offset_min = 0;
					}
					else {
						x_offset_min = -3;
						y_offset_min = -3;
					}
#if ENABLE_BFRAME
					cur_refw_idx = get_ref_idx_y_8_16(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
					if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + x_offset_max <= (160 + 4) &&
						(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + sub_h + y_offset_max <= (128 + 4)))
					{
#if MD_PRINT_ENH
						if (mode_type == MODE_SKIP)
							printf("<MODE_SKIP:SUB_TMVP> ");
						else if (mode_type == MODE_DIR)
							printf("<MODE_DIR:SUB_TMVP> ");
						printf("out of ref0 window ERROR: sub cu %d=(%d %d %d %d)", k, x, y, sub_w, sub_h);
						printf("mv=(");
						printf("%d %d", mv_sbtmvp[MV_X], mv_sbtmvp[MV_Y]);
						printf(")\n ");
#if ENABLE_BFRAME
						printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
							cur_refw_idx,
							CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
							CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
						);
						printf("\n");
#endif 
						fflush(stdout);
#endif
						core_sbtmvp->isValid = FALSE;
						return FALSE;
					}

					get_pred_y_8_16(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
						cur_refw_idx,
#endif // ENABLE_BFRAME
						pred_tmp);

					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < sub_h; i++)
					{
						for (int j = 0; j < sub_w; j++)
						{
							pred_ref0[h + i][w + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
						}
					}

					/*FILE* sbtmvp = fopen("sbtmvp.csv", "w");
					for (int i = 0; i < 64; i++) {
						for (int j = 0; j < 64; j++) {
							pel curr = pred[i * 64 + j];
							fprintf(sbtmvp, "%d, ", (int)curr);
						}
						fprintf(sbtmvp, "\n");
					}
					fclose(sbtmvp);*/
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}
		}
		else {
#endif
			if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
				(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
			{
#if MD_PRINT
				if (mode_type == MODE_SKIP)
					printf("<MODE_SKIP> ");
				else if (mode_type == MODE_INTER)
					printf("<MODE_INTER> ");
				else if (mode_type == MODE_DIR)
					printf("<MODE_DIR> ");
				printf("out of ref0 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
				printf("mv=(");
				printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
				printf(")\n ");
#if ENABLE_BFRAME
				printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
					cur_refw_idx,
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
					CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
				);
				printf("\n");
#endif 
				fflush(stdout);
#endif
				return FALSE;
			}


			get_pred_y_8_16(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
				cur_refw_idx,
#endif // ENABLE_BFRAME
				pred_ref0);
#if SUB_TMVP
		}
#endif
		//++bidx;
		refi0_valid = 1;
	}
	if (refi0_valid)
	{
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				pred_y[i][j] = pred_ref0[i][j];
	}
#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	static pel pred_ref1[16][16];
	if (REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred)[16] = bidx ? pred_snd : pred_y;
		//COM_PIC* ref_pic;
		//ref_pic = refp[refi[REFP_1]][REFP_1].pic;
		if (x_ext + (mv[REFP_1][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_1][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_1][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_1][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		S2 cur_refw_idx = get_ref_idx_y_8_16(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));

		//if (channel != CHANNEL_C)
		//{
		//if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < SWH)) { return FALSE; }
		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			if (mode_type == MODE_SKIP)
				printf("<MODE_SKIP> ");
			else if (mode_type == MODE_INTER)
				printf("<MODE_INTER> ");
			else if (mode_type == MODE_DIR)
				printf("<MODE_DIR> ");
			printf("out of ref1 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
			printf("mv=(");
			printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
			printf(")\n");
			printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
				cur_refw_idx,
				CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
				CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
			);
			printf("\n");
			fflush(stdout);
#endif
			return FALSE;
		}

		get_pred_y_8_16(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref, cur_refw_idx, pred_ref1);
		//}

//		if (channel != CHANNEL_L)
//		{
//#if CHROMA_NOT_SPLIT
//			assert(w >= 8 && h >= 8);
//#endif
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->u, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[U_C], w >> 1, h >> 1, bit_depth);
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->v, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[V_C], w >> 1, h >> 1, bit_depth);
//		}
		//bidx++;
		refi1_valid = 1;
	}


	if (refi0_valid && refi1_valid)
	{
		//if (channel != CHANNEL_C)
		//{
#if SIMD_MC
		average_16b_no_clip_sse(pred_y[0], pred_snd[0], pred_y[0], 16, 16, 16, w, h);
#else
		//pel(*p0)[16] = pred_y;
		//pel(*p1)[16] = pred_snd;
		for (int j = 0; j < h; j++)
		{
			for (int i = 0; i < w; i++)
			{
				pred_y[j][i] = (pred_ref0[j][i] + pred_ref1[j][i] + 1) >> 1;
			}
		}
#endif
		//}

//		if (channel != CHANNEL_L)
//		{
//#if SIMD_MC
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			average_16b_no_clip_sse(pred_buf[U_C], pred_snd[U_C], pred_buf[U_C], pred_stride, pred_stride, pred_stride, w, h);
//			average_16b_no_clip_sse(pred_buf[V_C], pred_snd[V_C], pred_buf[V_C], pred_stride, pred_stride, pred_stride, w, h);
//#else
//			p0 = pred_buf[U_C];
//			p1 = pred_snd[U_C];
//			p2 = pred_buf[V_C];
//			p3 = pred_snd[V_C];
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			for (j = 0; j < h; j++)
//			{
//				for (i = 0; i < w; i++)
//				{
//					p0[i] = (p0[i] + p1[i] + 1) >> 1;
//					p2[i] = (p2[i] + p3[i] + 1) >> 1;
//				}
//				p0 += pred_stride;
//				p1 += pred_stride;
//				p2 += pred_stride;
//				p3 += pred_stride;
//			}
//#endif
//		}
	}
	else
	{
		if (refi0_valid)
		{
			/////
		}
		else if (refi1_valid)
		{
			for (int j = 0; j < h; j++)
			{
				for (int i = 0; i < w; i++)
				{
					pred_y[j][i] = pred_ref1[j][i];
				}
			}
		}
		else
		{
#if MD_PRINT
			printf("%s:%d:all refs are invalid\n", __FUNCTION__, 7922);
#endif
		}
	}
#endif
	return 1;
}
static BOOL com_mc_cu_y_16_8(CU_POS* cu, U13 pic_w, U13 pic_h, S3 refi[REFP_NUM], s16 mv[REFP_NUM][2], U10 stride_luma,
	pel pred_y[16][16], U4 bit_depth, strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	Arbitor& ref
	, U2 mode_type
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int mode_idx, int umve_flag
#endif
)
{
	int scup = cu->scup;
	int x = cu->x_pos;
	int y = cu->y_pos;
	int w = cu->cu_width;
	int h = cu->cu_height;
	S14 mv_t[2];
	int min_clip[2];
	int max_clip[2];
	int x_ext = cu->x_pos << 2;
	int y_ext = cu->y_pos << 2;
	int w_ext = cu->cu_width << 2;
	int h_ext = cu->cu_height << 2;
	int x_ext_of_ctu;
	int y_ext_of_ctu;
	int qpel_gmv_x_of_ctu;
	int qpel_gmv_y_of_ctu;
	int qpel_gmv_x_of_refp_cu;
	int qpel_gmv_y_of_refp_cu;

	//int bidx = 0;
	U1 refi0_valid = 0, refi1_valid = 0;
	pel pred_ref0[16][16];

	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];
	if (refi[REFP_0] >= 0)
	{
		if (x_ext + (mv[REFP_0][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_0][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_0][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_0][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

#if ENABLE_BFRAME
		S2 cur_refw_idx = get_ref_idx_y_16_8(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
#if SUB_TMVP
		if (mode_idx == 0 && cu->cu_width >= SBTMVP_MIN_SIZE && cu->cu_height >= SBTMVP_MIN_SIZE && mode_type >= MODE_SKIP && umve_flag == 0)
		{
			if (!core_sbtmvp->isValid)
				return FALSE;
			core_sbtmvp->isValid = TRUE;

			int dx = qpel_gmv_x & 0x3;
			int dy = qpel_gmv_y & 0x3;
			int x_offset_min = 0;
			int x_offset_max = 0;
			int y_offset_min = 0;
			int y_offset_max = 0;

			if (dx == 0 && dy == 0) {
				x_offset_min = 0;
				y_offset_min = 0;
			}
			else {
				x_offset_min = -3;
				y_offset_min = -3;
			}
			x_offset_max = 4;
			y_offset_max = 4;

			int cu_width = cu->cu_width;
			int cu_height = cu->cu_height;
			//int x = cu->x_pos;
			//int y = cu->y_pos;
			int sub_w = cu_width >> 1;/// SBTMVP_NUM_1D
			int sub_h = cu_height >> 1;

			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp[16][16];
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + (mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + (mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + (mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + (mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}
					qpel_gmv_x = (x << 2) + ((int)mv_sbtmvp[0]);
					qpel_gmv_y = (y << 2) + ((int)mv_sbtmvp[1]);
					dx = qpel_gmv_x & 0x3;
					dy = qpel_gmv_y & 0x3;
					if (dx == 0 && dy == 0) {
						x_offset_min = 0;
						y_offset_min = 0;
					}
					else {
						x_offset_min = -3;
						y_offset_min = -3;
					}
#if ENABLE_BFRAME
					cur_refw_idx = get_ref_idx_y_16_8(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
					if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + x_offset_max <= (160 + 4) &&
						(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + sub_h + y_offset_max <= (128 + 4)))
					{
#if MD_PRINT_ENH
						if (mode_type == MODE_SKIP)
							printf("<MODE_SKIP:SUB_TMVP> ");
						else if (mode_type == MODE_DIR)
							printf("<MODE_DIR:SUB_TMVP> ");
						printf("out of ref0 window ERROR: sub cu %d=(%d %d %d %d)", k, x, y, sub_w, sub_h);
						printf("mv=(");
						printf("%d %d", mv_sbtmvp[MV_X], mv_sbtmvp[MV_Y]);
						printf(")\n ");
#if ENABLE_BFRAME
						printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
							cur_refw_idx,
							CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
							CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
						);
						printf("\n");
#endif 
						fflush(stdout);
#endif
						core_sbtmvp->isValid = FALSE;
						return FALSE;
					}

					get_pred_y_16_8(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
						cur_refw_idx,
#endif // ENABLE_BFRAME
						pred_tmp);

					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < sub_h; i++)
					{
						for (int j = 0; j < sub_w; j++)
						{
							pred_ref0[h + i][w + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
						}
					}

					/*FILE* sbtmvp = fopen("sbtmvp.csv", "w");
					for (int i = 0; i < 64; i++) {
						for (int j = 0; j < 64; j++) {
							pel curr = pred[i * 64 + j];
							fprintf(sbtmvp, "%d, ", (int)curr);
						}
						fprintf(sbtmvp, "\n");
					}
					fclose(sbtmvp);*/
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}
		}
		else {
#endif
			if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
				(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
			{
#if MD_PRINT
				if (mode_type == MODE_SKIP)
					printf("<MODE_SKIP> ");
				else if (mode_type == MODE_INTER)
					printf("<MODE_INTER> ");
				else if (mode_type == MODE_DIR)
					printf("<MODE_DIR> ");
				printf("out of ref0 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
				printf("mv=(");
				printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
				printf(")\n ");
#if ENABLE_BFRAME
				printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
					cur_refw_idx,
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
					CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
				);
				printf("\n");
#endif 
				fflush(stdout);
#endif
				return FALSE;
			}


			get_pred_y_16_8(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
				cur_refw_idx,
#endif // ENABLE_BFRAME
				pred_ref0);
#if SUB_TMVP
		}
#endif
		//++bidx;
		refi0_valid = 1;
	}
	if (refi0_valid)
	{
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				pred_y[i][j] = pred_ref0[i][j];
	}
#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	static pel pred_ref1[16][16];
	if (REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred)[16] = bidx ? pred_snd : pred_y;
		//COM_PIC* ref_pic;
		//ref_pic = refp[refi[REFP_1]][REFP_1].pic;
		if (x_ext + (mv[REFP_1][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_1][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_1][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_1][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		S2 cur_refw_idx = get_ref_idx_y_16_8(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));

		//if (channel != CHANNEL_C)
		//{
		//if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < SWH)) { return FALSE; }
		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			if (mode_type == MODE_SKIP)
				printf("<MODE_SKIP> ");
			else if (mode_type == MODE_INTER)
				printf("<MODE_INTER> ");
			else if (mode_type == MODE_DIR)
				printf("<MODE_DIR> ");
			printf("out of ref1 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
			printf("mv=(");
			printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
			printf(")\n");
			printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
				cur_refw_idx,
				CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
				CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
			);
			printf("\n");
			fflush(stdout);
#endif
			return FALSE;
		}

		get_pred_y_16_8(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref, cur_refw_idx, pred_ref1);
		//}

//		if (channel != CHANNEL_L)
//		{
//#if CHROMA_NOT_SPLIT
//			assert(w >= 8 && h >= 8);
//#endif
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->u, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[U_C], w >> 1, h >> 1, bit_depth);
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->v, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[V_C], w >> 1, h >> 1, bit_depth);
//		}
		//bidx++;
		refi1_valid = 1;
	}


	if (refi0_valid && refi1_valid)
	{
		//if (channel != CHANNEL_C)
		//{
#if SIMD_MC
		average_16b_no_clip_sse(pred_y[0], pred_snd[0], pred_y[0], 16, 16, 16, w, h);
#else
		//pel(*p0)[16] = pred_y;
		//pel(*p1)[16] = pred_snd;
		for (int j = 0; j < h; j++)
		{
			for (int i = 0; i < w; i++)
			{
				pred_y[j][i] = (pred_ref0[j][i] + pred_ref1[j][i] + 1) >> 1;
			}
		}
#endif
		//}

//		if (channel != CHANNEL_L)
//		{
//#if SIMD_MC
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			average_16b_no_clip_sse(pred_buf[U_C], pred_snd[U_C], pred_buf[U_C], pred_stride, pred_stride, pred_stride, w, h);
//			average_16b_no_clip_sse(pred_buf[V_C], pred_snd[V_C], pred_buf[V_C], pred_stride, pred_stride, pred_stride, w, h);
//#else
//			p0 = pred_buf[U_C];
//			p1 = pred_snd[U_C];
//			p2 = pred_buf[V_C];
//			p3 = pred_snd[V_C];
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			for (j = 0; j < h; j++)
//			{
//				for (i = 0; i < w; i++)
//				{
//					p0[i] = (p0[i] + p1[i] + 1) >> 1;
//					p2[i] = (p2[i] + p3[i] + 1) >> 1;
//				}
//				p0 += pred_stride;
//				p1 += pred_stride;
//				p2 += pred_stride;
//				p3 += pred_stride;
//			}
//#endif
//		}
	}
	else
	{
		if (refi0_valid)
		{
			/////
		}
		else if (refi1_valid)
		{
			for (int j = 0; j < h; j++)
			{
				for (int i = 0; i < w; i++)
				{
					pred_y[j][i] = pred_ref1[j][i];
				}
			}
		}
		else
		{
#if MD_PRINT
			printf("%s:%d:all refs are invalid\n", __FUNCTION__, 7922);
#endif
		}
	}
#endif
	return 1;
}
BOOL com_mc_cu_y_16_16(CU_POS* cu, U13 pic_w, U13 pic_h, S3 refi[REFP_NUM], s16 mv[REFP_NUM][2], U10 stride_luma,
	pel pred_y[16][16], U4 bit_depth, strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	Arbitor& ref
	, U2 mode_type
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int mode_idx, int umve_flag
#endif
	)
{
	int scup = cu->scup;
	int x = cu->x_pos;
	int y = cu->y_pos;
	int w = cu->cu_width;
	int h = cu->cu_height;
	S14 mv_t[2];
	int min_clip[2];
	int max_clip[2];
	int x_ext = cu->x_pos << 2;
	int y_ext = cu->y_pos << 2;
	int w_ext = cu->cu_width << 2;
	int h_ext = cu->cu_height << 2;
	int x_ext_of_ctu;
	int y_ext_of_ctu;
	int qpel_gmv_x_of_ctu;
	int qpel_gmv_y_of_ctu;
	int qpel_gmv_x_of_refp_cu;
	int qpel_gmv_y_of_refp_cu;
// #pragma HLS ARRAY_PARTITION variable=core_sbtmvp->sbTmvp complete dim=0
#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP complete dim=0
#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP_ref1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=mv_t complete dim=0
#pragma HLS ARRAY_PARTITION variable=min_clip complete dim=0
#pragma HLS ARRAY_PARTITION variable=max_clip complete dim=0
#pragma HLS ARRAY_PARTITION variable=mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=refi complete dim=0
	//int bidx = 0;
	static bool refi0_valid;
	static bool refi1_valid;
	pel pred_ref0[16][16];
#pragma HLS ARRAY_PARTITION variable=pred_ref0 complete dim=0
	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];

	// signed int refi_0 = (signed int)(refi[REFP_0]);
	// signed int refi_1 = (signed int)(refi[REFP_1]);
	ap_int<3> refi_0 = (ap_int<3>)refi[REFP_0];
	ap_int<3> refi_1 = (ap_int<3>)refi[REFP_1];

	refi0_valid = (refi_0 >= 0) ? 1 : 0;
	refi1_valid = (refi_1 >= 0) ? 1 : 0;

	if (refi0_valid) //(refi[REFP_0] >= 0)
	{
		if (x_ext + (mv[REFP_0][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_0][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_0][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_0][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

#if ENABLE_BFRAME
		S2 cur_refw_idx = get_ref_idx_y_16_16(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
#if SUB_TMVP
		if (mode_idx == 0 && cu->cu_width >= SBTMVP_MIN_SIZE && cu->cu_height >= SBTMVP_MIN_SIZE && mode_type >= MODE_SKIP && umve_flag == 0)
		{
			core_sbtmvp->isValid = TRUE;

			int dx = qpel_gmv_x & 0x3;
			int dy = qpel_gmv_y & 0x3;
			int x_offset_min = 0;
			int x_offset_max = 0;
			int y_offset_min = 0;
			int y_offset_max = 0;

			if (dx == 0 && dy == 0) {
				x_offset_min = 0;
				y_offset_min = 0;
			}
			else {
				x_offset_min = -3;
				y_offset_min = -3;
			}
			x_offset_max = 4;
			y_offset_max = 4;

			int cu_width = cu->cu_width;
			int cu_height = cu->cu_height;
			//int x = cu->x_pos;
			//int y = cu->y_pos;
			int sub_w = cu_width >> 1;/// SBTMVP_NUM_1D
			int sub_h = cu_height >> 1;

			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp[8][8];
#pragma HLS ARRAY_PARTITION variable=pred_tmp complete dim=0
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
#pragma HLS LOOP_TRIPCOUNT max=4
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + (mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + (mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + (mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + (mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}
					qpel_gmv_x = (x << 2) + ((int)mv_sbtmvp[0]);
					qpel_gmv_y = (y << 2) + ((int)mv_sbtmvp[1]);
					dx = qpel_gmv_x & 0x3;
					dy = qpel_gmv_y & 0x3;
					if (dx == 0 && dy == 0) {
						x_offset_min = 0;
						y_offset_min = 0;
					}
					else {
						x_offset_min = -3;
						y_offset_min = -3;
					}
#if ENABLE_BFRAME
					cur_refw_idx = get_ref_idx_y_16_16(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME
					if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + x_offset_max <= (160 + 4) &&
						(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + sub_h + y_offset_max <= (128 + 4)))
					{
#if MD_PRINT_ENH
						if (mode_type == MODE_SKIP)
							printf("<MODE_SKIP:SUB_TMVP> ");
						else if (mode_type == MODE_DIR)
							printf("<MODE_DIR:SUB_TMVP> ");
						printf("out of ref0 window ERROR: sub cu %d=(%d %d %d %d)", k, x, y, sub_w, sub_h);
						printf("mv=(");
						printf("%d %d", mv_sbtmvp[MV_X], mv_sbtmvp[MV_Y]);
						printf(")\n ");
#if ENABLE_BFRAME
						printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
							cur_refw_idx,
							CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
							CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
						);
						printf("\n");
#endif 
						fflush(stdout);
#endif
						core_sbtmvp->isValid = FALSE;
						return FALSE;
					}

					get_pred_y_8_8(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
						cur_refw_idx,
#endif // ENABLE_BFRAME
						pred_tmp);

					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < 8; i++)
					{
#pragma HLS UNROLL
						for (int j = 0; j < 8; j++)
						{
#pragma HLS UNROLL
						//	if(i<sub_h && j<sub_w){
							if (h == 0 && w == 0) {
								pred_ref0[0 + i][0 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
							else if (h == 8 && w == 0) {
								pred_ref0[8 + i][0 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
							else if (h == 0 && w == 8) {
								pred_ref0[0 + i][8 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
							else {
								pred_ref0[8 + i][8 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
						}
					}
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}
		}
		else {
#endif
			if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
				(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
			{
#if MD_PRINT
				if (mode_type == MODE_SKIP)
					printf("<MODE_SKIP> ");
				else if (mode_type == MODE_INTER)
					printf("<MODE_INTER> ");
				else if (mode_type == MODE_DIR)
					printf("<MODE_DIR> ");
				printf("out of ref0 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
				printf("mv=(");
				printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
				printf(")\n ");
#if ENABLE_BFRAME
				printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
					cur_refw_idx,
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
					CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
				);
				printf("\n");
#endif 
				fflush(stdout);
#endif
				return FALSE;
			}


			get_pred_y_16_16(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
				cur_refw_idx,
#endif // ENABLE_BFRAME
				pred_ref0);
#if SUB_TMVP
		}
#endif
		//++bidx;
		// refi0_valid = 1;
	}

#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	pel pred_ref1[16][16];
#pragma HLS ARRAY_PARTITION variable=pred_ref1 complete dim=0
	if (refi1_valid) //(REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred)[16] = bidx ? pred_snd : pred_y;
		//COM_PIC* ref_pic;
		//ref_pic = refp[refi[REFP_1]][REFP_1].pic;
		if (x_ext + (mv[REFP_1][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_1][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_1][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_1][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		S2 cur_refw_idx = get_ref_idx_y_16_16(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));

		//if (channel != CHANNEL_C)
		//{
		//if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < SWH)) { return FALSE; }
		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			if (mode_type == MODE_SKIP)
				printf("<MODE_SKIP> ");
			else if (mode_type == MODE_INTER)
				printf("<MODE_INTER> ");
			else if (mode_type == MODE_DIR)
				printf("<MODE_DIR> ");
			printf("out of ref1 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
			printf("mv=(");
			printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
			printf(")\n");
			printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
				cur_refw_idx,
				CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
				CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
			);
			printf("\n");
			fflush(stdout);
#endif
			return FALSE;
		}

		get_pred_y_16_16(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref, cur_refw_idx, pred_ref1);
		//}

//		if (channel != CHANNEL_L)
//		{
//#if CHROMA_NOT_SPLIT
//			assert(w >= 8 && h >= 8);
//#endif
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->u, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[U_C], w >> 1, h >> 1, bit_depth);
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->v, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[V_C], w >> 1, h >> 1, bit_depth);
//		}
		//bidx++;
		// refi1_valid = 1;
	}

#if 1
	for (int j = 0; j < 16; j++) {
		for (int i = 0; i < 16; i++) {
			if ((i<w) && (j<h)) {
				pel temp;
				if (refi0_valid && refi1_valid) {
					temp = (pred_ref0[j][i] + pred_ref1[j][i] + 1) >> 1;
				} else if (refi0_valid) {
					temp = pred_ref0[j][i];
				} else if (refi1_valid) {
					temp = pred_ref1[j][i];
				}

				if (refi0_valid || refi1_valid) {
					pred_y[j][i] = temp;
				}
			}
		}
	}
#else
	if (refi0_valid && refi1_valid)
	{
		//if (channel != CHANNEL_C)
		//{
#if SIMD_MC
		average_16b_no_clip_sse(pred_y[0], pred_snd[0], pred_y[0], 16, 16, 16, w, h);
#else
		//pel(*p0)[16] = pred_y;
		//pel(*p1)[16] = pred_snd;
		for (int j = 0; j < 16; j++)
		{
#pragma HLS UNROLL
			for (int i = 0; i < 16; i++)
			{
				if(i<w&&j<h){
				pred_y[j][i] = (pred_ref0[j][i] + pred_ref1[j][i] + 1) >> 1;
				}
			}
		}
#endif
		//}

//		if (channel != CHANNEL_L)
//		{
//#if SIMD_MC
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			average_16b_no_clip_sse(pred_buf[U_C], pred_snd[U_C], pred_buf[U_C], pred_stride, pred_stride, pred_stride, w, h);
//			average_16b_no_clip_sse(pred_buf[V_C], pred_snd[V_C], pred_buf[V_C], pred_stride, pred_stride, pred_stride, w, h);
//#else
//			p0 = pred_buf[U_C];
//			p1 = pred_snd[U_C];
//			p2 = pred_buf[V_C];
//			p3 = pred_snd[V_C];
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			for (j = 0; j < h; j++)
//			{
//				for (i = 0; i < w; i++)
//				{
//					p0[i] = (p0[i] + p1[i] + 1) >> 1;
//					p2[i] = (p2[i] + p3[i] + 1) >> 1;
//				}
//				p0 += pred_stride;
//				p1 += pred_stride;
//				p2 += pred_stride;
//				p3 += pred_stride;
//			}
//#endif
//		}
	}
	else
	{
		if (refi0_valid)
		{
			/////
		}
		else if (refi1_valid)
		{
			for (int j = 0; j < 16; j++)
			{
#pragma HLS UNROLL
				for (int i = 0; i < 16; i++)
				{
					if(i<w&&j<h)
					pred_y[j][i] = pred_ref1[j][i];
				}
			}
		}
		else
		{
#if MD_PRINT
			printf("%s:%d:all refs are invalid\n", __FUNCTION__, 7922);
#endif
		}
	}
#endif
#endif
	return 1;
}

BOOL rdo_mc_y_16(u8 mode_type,
	S14 CtrPosSKIP[2][2][2],
	pel fme2mdrefbuf[2560][8][2][16],
	int x_pos, int y_pos, int cu_width, int cu_height,
	s16 mv[2][2], s16 mv_t[2][2], U11 stride, U4 bit_depth, U2 channel,
#if ENABLE_BFRAME
	U1 lidx,
#endif
	pel pred_y[16][16]
#if SUB_TMVP
	, U13 pic_w, U13 pic_h, u8 skip_idx, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	int x = x_pos;
	int y = y_pos;
	int w = cu_width;
	int h = cu_height;

	if (mode_type == 0)
	{
		int dx;
		int dy;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0][0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[0][1]);
		int qpel_gmv_x_of_refp_cu = qpel_gmv_x - (((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2);
		int qpel_gmv_y_of_refp_cu = qpel_gmv_y - (((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2);
		dx = qpel_gmv_x & 0x3;
		dy = qpel_gmv_y & 0x3;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu_width + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu_height + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			printf("Error: cu=(%d %d %d %d)",
				x_pos,
				y_pos,
				cu_width,
				cu_height
			);
			printf("mv=(");
			printf("%d %d", mv_t[REFP_0][MV_X], mv_t[REFP_0][MV_Y]);
			printf(") ");
			printf("\n");
			fflush(stdout);
#endif
			return FALSE;
		}
#if SUB_TMVP
		if (skip_idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE)
		{
			int min_clip[2];
			int max_clip[2];
			min_clip[0] = (-(1 << 7) - 4) << 2;
			min_clip[1] = (-(1 << 7) - 4) << 2;
			max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
			max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
			int x_ext = x_pos << 2;
			int y_ext = y_pos << 2;
			int x_ext_of_ctu;
			int y_ext_of_ctu;
			int qpel_gmv_x_of_ctu;
			int qpel_gmv_y_of_ctu;
			int sub_w = cu_width / SBTMVP_NUM_1D;
			int sub_h = cu_height / SBTMVP_NUM_1D;
			int h_sb = 0;
			int w_sb = 0;
			int tmp_x = x;
			int tmp_y = y;
			static pel pred_tmp[16][16];
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w_sb = (k % 2) * sub_w;
					h_sb = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					x_ext = x << 2;
					y_ext = y << 2;
					int w_ext = sub_w << 2;
					int h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];
					x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
					y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);

					if (x_ext + (mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + (mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + (mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + (mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}

					qpel_gmv_x_of_ctu = x_ext_of_ctu + (mv_sbtmvp[0]);
					qpel_gmv_y_of_ctu = y_ext_of_ctu + (mv_sbtmvp[1]);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
					qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);

					if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + 4 <= SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 &&
						(qpel_gmv_y_of_refp_cu >> 2) + sub_h + 4 <= SWH)) {
						return FALSE;
					}

					get_pred_y_16(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, fme2mdrefbuf,
#if ENABLE_BFRAME
						0,
#endif // ENABLE_BFRAME
						pred_y);

					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < sub_h; i++)
					{
						for (int j = 0; j < sub_w; j++)
						{
							pred_y[h + i][w + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
						}
					}

					/*FILE* sbtmvp = fopen("sbtmvp.csv", "w");
					for (int i = 0; i < 64; i++) {
						for (int j = 0; j < 64; j++) {
							pel curr = pred[i * 64 + j];
							fprintf(sbtmvp, "%d, ", (int)curr);
						}
						fprintf(sbtmvp, "\n");
					}
					fclose(sbtmvp);*/
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}
		}
		else {
#endif
			get_pred_y_16(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, fme2mdrefbuf,
#if ENABLE_BFRAME
				0,
#endif // ENABLE_BFRAME
				pred_y);
#if SUB_TMVP
		}
#endif
	}
	else if (mode_type == 1)
	{
		int qpel_gmv_x;
		int qpel_gmv_y;
		int fme = 0;
		int out = 0;
		int dx;
		int dy;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;
		/* forward */
#if ENABLE_BFRAME
		qpel_gmv_x = (x << 2) + ((int)mv_t[lidx][0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[lidx][1]);
#else
		qpel_gmv_x = (x << 2) + ((int)mv_t[0][0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[0][1]);
#endif
		int qpel_gmv_x_of_refp_cu_16 = qpel_gmv_x - (((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2);
		int qpel_gmv_y_of_refp_cu_16 = qpel_gmv_y - (((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2);
		dx = qpel_gmv_x & 0x3;
		dy = qpel_gmv_y & 0x3;
		/*if (((unsigned int)channel) != ((unsigned int)CHANNEL_C))
		{
			mc_flag = 1;
		}*/
		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			x_offset_max = 0;
			y_offset_min = 0;
			y_offset_max = 0;
			fme = 0;
		}
		else if (dx != 0 && dy == 0) {
			x_offset_min = -3;
			x_offset_max = 4;
			y_offset_min = 0;
			y_offset_max = 0;
			fme = 1;
		}
		else if (dx == 0 && dy != 0) {
			x_offset_min = 0;
			x_offset_max = 0;
			y_offset_min = -3;
			y_offset_max = 4;
			fme = 1;
		}
		else {
			x_offset_min = -3;
			x_offset_max = 4;
			y_offset_min = -3;
			y_offset_max = 4;
			fme = 1;
		}
#if MD_PRINT
#endif

#if ENABLE_BFRAME
		get_pred_y_16(w, h, qpel_gmv_x_of_refp_cu_16, qpel_gmv_y_of_refp_cu_16, dx, dy, fme2mdrefbuf, lidx, pred_y);
#else
		get_pred_y_16(w, h, qpel_gmv_x_of_refp_cu_16, qpel_gmv_y_of_refp_cu_16, dx, dy, fme2mdrefbuf, pred_y);
#endif
	}

	return 1;
}

static BOOL com_mc_y_16(u8 mode_type, CU_POS* cu, U13 pic_w, U13 pic_h, S3 refi[2], s16 mv[2][2], U10 stride_luma,
	pel pred_y[16][16], U4 bit_depth, U2 channel,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS], pel fme2mdrefbuf[2560][8][2][16]
#if ENABLE_BFRAME
	, U1 lidx
#endif
#if SUB_TMVP
	, u8 skip_idx, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	int scup = cu->scup;
	int x = cu->x_pos;
	int y = cu->y_pos;
	int w = cu->cu_width;
	int h = cu->cu_height;
	s16 mv_t[2][2];
#pragma HLS array_partition variable=mv_t complete dim=0
	int mc_flag = 1;
	int qpel_gmv_x_of_refp_cu = 0;
	int qpel_gmv_y_of_refp_cu = 0;

	mv_clip_1(x, y, pic_w, pic_h, w, h, refi, mv, mv_t);

	if ((mode_type == 0 || mode_type == 1) && ((refi[0]) >= 0)) {
		if (!rdo_mc_y_16(mode_type,
			CtrPosSKIP, fme2mdrefbuf,
			x, y, w, h, mv, mv_t, stride_luma, bit_depth, channel,
#if ENABLE_BFRAME
			lidx,
#endif // ENABLE_BFRAME
			pred_y
#if SUB_TMVP
			, pic_w, pic_h, skip_idx, core_sbtmvp
#endif
		))
			return FALSE;
	}
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
	return 1;
}

static BOOL mc_skip_y_16(MD_COM_MODE* mod_info_curr, U13 pic_width, U13 pic_height, pel pred_cache[16][16], U4 bit_depth,
	strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	pel fme2mdrefbuf[2560][8][2][16]
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int mode_idx
#endif
)
{
	{
		CU_POS cu = { (int)mod_info_curr->scup, mod_info_curr->x_pos, mod_info_curr->y_pos, mod_info_curr->cu_width, mod_info_curr->cu_height };
		if (!com_mc_cu_y_16(&cu, pic_width, pic_height, mod_info_curr->refi, mod_info_curr->mv,
			SWW, pred_cache, bit_depth, Fetch_Ref_window_ptr,
			CtrPosSKIP,
#if ENABLE_BFRAME
			CtrPosSKIP_ref1,
#endif // ENABLE_BFRAME
			fme2mdrefbuf
			, MODE_SKIP
#if SUB_TMVP
			, core_sbtmvp, mode_idx, mod_info_curr->umve_flag
#endif	
		))
		{
			return 0;
		}
	}
	return 1;
}


static BOOL make_skip_resi_8_16(int idx, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo, MD_KERNEL_MODE* mod_info_curr,
	int pic_width, int pic_height, int cu_width_log2, int cu_height_log2, pel* org_y,
	int stride_org_l, int cu_width, int cu_height, U4 bit_depth)
{
	if (!derive_mode_info(idx, skip_rdo, skip_rdo_mode, merge_rdo, mod_info_curr)) {
		return 0;
	}
	return 1;
}
static BOOL make_skip_resi_16_8(int idx, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo, MD_KERNEL_MODE* mod_info_curr,
	int pic_width, int pic_height, int cu_width_log2, int cu_height_log2, pel* org_y,
	int stride_org_l, int cu_width, int cu_height, U4 bit_depth)
{
	if (!derive_mode_info(idx, skip_rdo, skip_rdo_mode, merge_rdo, mod_info_curr)) {
		return 0;
	}
	return 1;
}
static BOOL make_skip_resi_16_16(int idx, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo, MD_KERNEL_MODE* mod_info_curr,
	int pic_width, int pic_height, int cu_width_log2, int cu_height_log2, pel* org_y,
	int stride_org_l, int cu_width, int cu_height, U4 bit_depth)
{
	if (!derive_mode_info(idx, skip_rdo, skip_rdo_mode, merge_rdo, mod_info_curr)) {
		return 0;
	}
	return 1;
}

static int com_affine_mc_fetch_pred_y_16(pel RefWindowLCU[SWW * SWH], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS], MD_COM_MODE* mod_info_curr, U4 bit_depth,
	U13 pic_w, U13 pic_h, pel pred_cache[SIZE_16])
{
	S3* refi = mod_info_curr->refi;
	U4 sub_w = 4;
	U4 sub_h = 4;
	if (refi[0] >= 0 && refi[1] >= 0) {
		sub_w = 8;
		sub_h = 8;
	}
	if (refi[0] >= 0) {
		//return com_affine_mc_pred_y_16(Fetch_Refwin_ptr, mod_info_curr, pred_cache, sub_w, sub_h, 0, bit_depth, pic_w, pic_h);
	}
	return 0;
}

static s64 pinter_me_pred_16(RDOQ_MODEL* model_cnt, MD_FW* md_fw_ptr, pel RefWindowLCU[SWW * SWH], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS], MD_COM_MODE* mod_info_curr_ptr, /*COM_PART_INFO* mod_info_curr_pb_info,*/
	s64 lambdaY, s64 dist_pred[1], pel* org_y, U7 stride_org, s64* cost_best,
	int bit_cnt, u8 curr_mvr, s16 resi_t[16][16], U2 tree_status, U2 cons_pred_mode, pel pred_cache[16][16], U1 is_intra,
	pel refwin_md[88][88], S14 CtrPosFME[RANGE_NUM][DIR_DIM][MAP_DIMS], pel RefWindowLCU_t[512 * 512])
{
#pragma HLS array_partition variable=mod_info_curr_ptr->num_nz complete dim=0
	MD_COM_MODE* mod_info_curr = mod_info_curr_ptr;

	com_mc_fetch_16(RefWindowLCU, mod_info_curr, tree_status, md_fw_ptr->bit_depth_internal,
		md_fw_ptr->pic_width, md_fw_ptr->pic_height, curr_mvr, CtrPos, pred_cache,
		refwin_md, CtrPosFME, RefWindowLCU_t);

	return *cost_best;
}

static BOOL analyze_me_uni_pred_8_16(MD_FW* md_fw_ptr, MD_KERNEL_MODE* mod_info_curr,
	u8 num_refp_cnt, u8 curr_mvr, U7 cu_width, U7 cu_height, s16 mvp_all[2][5][2], s16 mv_all[2][5][2],
	int best_mv_uni_inner[2][4][2],
	U7 stride_org,
	int refi_cur, U2 tree_status, U2 ctx_cons_pred_mode,
	S14 sub_pel_mv[MV_D],
	MD_KERNEL_INPUT* md_kernel_input
#if ENABLE_BFRAME
	, MV_DIR* mv_dir
#endif
)
{
#pragma HLS array_partition variable=sub_pel_mv complete dim=0
#pragma HLS array_partition variable=mvp_all complete dim=0
#pragma HLS array_partition variable=mod_info_curr->mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr->mvd complete dim=0
#pragma HLS array_partition variable=best_mv_uni_inner complete dim=0

	int bit_cnt = 0;
#if ENABLE_BFRAME
	int lidx = mv_dir->lidx;
	int best_refi = mv_dir->cur_refi;
#else
	int lidx = 0;
	int best_refi = 0;
#endif
	int me_level = 3;
	int is_intra = 0;
	mod_info_curr->cu_mode = 1;
	mod_info_curr->affine_flag = 0;
	s16* mv;
	s16* mvd;
	mv = mod_info_curr->mv[lidx];
	mvd = mod_info_curr->mvd[lidx];

	init_inter_data_8_16(mod_info_curr, md_fw_ptr->pic_width_in_scu);
#if ENABLE_BFRAME
	if (best_refi != 0 || lidx != 0)
	{
		best_refi = pinter_fme_all_cu_pred_8_16(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, num_refp_cnt, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv);
		if (best_refi < 0) { return FALSE; }
		best_refi = mv_dir->cur_refi;
	}
	else
#endif
	{
		best_refi = pinter_fme_all_cu_pred_8_16(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, num_refp_cnt, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv);
		if (best_refi < 0) { return FALSE; }
	}


	fme_set_mv_refi_8_16(mv, mvd, mv_all, mvp_all, mod_info_curr, best_refi, curr_mvr, lidx);

	/* prediction */
#if MD_PRINT && !ENABLE_BFRAME
	((int)mod_info_curr->refi[0]) >= 0
		&& !(((int)mod_info_curr->refi[1]) >= 0) ? ((void)0) :
		__assert_HLS("((mod_info_curr->refi[0]) >= 0) && !((mod_info_curr->refi[1]) >= 0)", "../separate/enc_pinter.c",
			(unsigned int)1053, __FUNCTION__);
#endif

	return TRUE;
}
static BOOL analyze_me_uni_pred_16_8(MD_FW* md_fw_ptr, MD_KERNEL_MODE* mod_info_curr,
	u8 num_refp_cnt, u8 curr_mvr, U7 cu_width, U7 cu_height, s16 mvp_all[2][5][2], s16 mv_all[2][5][2],
	int best_mv_uni_inner[2][4][2],
	U7 stride_org,
	int refi_cur, U2 tree_status, U2 ctx_cons_pred_mode,
	S14 sub_pel_mv[MV_D],
	MD_KERNEL_INPUT* md_kernel_input
#if ENABLE_BFRAME
	, MV_DIR* mv_dir
#endif
)
{
#pragma HLS array_partition variable=sub_pel_mv complete dim=0
#pragma HLS array_partition variable=mvp_all complete dim=0
#pragma HLS array_partition variable=mod_info_curr->mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr->mvd complete dim=0
#pragma HLS array_partition variable=best_mv_uni_inner complete dim=0

	int bit_cnt = 0;
#if ENABLE_BFRAME
	int lidx = mv_dir->lidx;
	int best_refi = mv_dir->cur_refi;
#else
	int lidx = 0;
	int best_refi = 0;
#endif
	int me_level = 3;
	int is_intra = 0;
	mod_info_curr->cu_mode = 1;
	mod_info_curr->affine_flag = 0;
	s16* mv;
	s16* mvd;
	mv = mod_info_curr->mv[lidx];
	mvd = mod_info_curr->mvd[lidx];

	init_inter_data_16_8(mod_info_curr, md_fw_ptr->pic_width_in_scu);
#if ENABLE_BFRAME
	if (best_refi != 0 || lidx != 0)
	{
		best_refi = pinter_fme_all_cu_pred_16_8(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, num_refp_cnt, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv);
		if (best_refi < 0) { return FALSE; }
		best_refi = mv_dir->cur_refi;
	}
	else
#endif
	{
		best_refi = pinter_fme_all_cu_pred_16_8(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, num_refp_cnt, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv);
		if (best_refi < 0) { return FALSE; }
	}


	fme_set_mv_refi_16_8(mv, mvd, mv_all, mvp_all, mod_info_curr, best_refi, curr_mvr, lidx);

	/* prediction */
#if MD_PRINT && !ENABLE_BFRAME
	((int)mod_info_curr->refi[0]) >= 0
		&& !(((int)mod_info_curr->refi[1]) >= 0) ? ((void)0) :
		__assert_HLS("((mod_info_curr->refi[0]) >= 0) && !((mod_info_curr->refi[1]) >= 0)", "../separate/enc_pinter.c",
		(unsigned int)1053, __FUNCTION__);
#endif

	return TRUE;
}
static BOOL analyze_me_uni_pred_16_16(MD_FW* md_fw_ptr, MD_KERNEL_MODE* mod_info_curr,
	u8 num_refp_cnt, u8 curr_mvr, U7 cu_width, U7 cu_height, s16 mvp_all[2][5][2], s16 mv_all[2][5][2],
	int best_mv_uni_inner[2][4][2],
	U7 stride_org,
	int refi_cur, U2 tree_status, U2 ctx_cons_pred_mode,
	S14 sub_pel_mv[MV_D],
	MD_KERNEL_INPUT* md_kernel_input
#if ENABLE_BFRAME
	, MV_DIR* mv_dir
#endif
)
{
	int bit_cnt = 0;
#if ENABLE_BFRAME
	int lidx = mv_dir->lidx;
	int best_refi = mv_dir->cur_refi;
#else
	int lidx = 0;
	int best_refi = 0;
#endif
	int me_level = 3;
	int is_intra = 0;
	mod_info_curr->cu_mode = 1;
	mod_info_curr->affine_flag = 0;
	s16* mv;
	s16* mvd;
	mv = mod_info_curr->mv[lidx];
	mvd = mod_info_curr->mvd[lidx];

	init_inter_data_16_16(mod_info_curr, md_fw_ptr->pic_width_in_scu);
#if ENABLE_BFRAME
	if (best_refi != 0 || lidx != 0)
	{
		best_refi = pinter_fme_all_cu_pred_16_16(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, num_refp_cnt, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv);
		if (best_refi < 0) { return FALSE; }
		best_refi = mv_dir->cur_refi;
	}
	else
#endif
	{
		best_refi = pinter_fme_all_cu_pred_16_16(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, num_refp_cnt, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv);
		if (best_refi < 0) { return FALSE; }
	}


	fme_set_mv_refi_16_16(mv, mvd, mv_all, mvp_all, mod_info_curr, best_refi, curr_mvr, lidx);

	/* prediction */
#if MD_PRINT && !ENABLE_BFRAME
	((int)mod_info_curr->refi[0]) >= 0
		&& !(((int)mod_info_curr->refi[1]) >= 0) ? ((void)0) :
		__assert_HLS("((mod_info_curr->refi[0]) >= 0) && !((mod_info_curr->refi[1]) >= 0)", "../separate/enc_pinter.c",
		(unsigned int)1053, __FUNCTION__);
#endif

	return TRUE;
}

//void inter_pred_16(RDOQ_MODEL* model_cnt, MD_FW* md_fw_ptr,
//	s64* cost_best_temp, MD_INPUT* md_input_ptr, U7 cu_width, U7 cu_height,
//	U8 RefWindowLCU[SWW * SWH], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS], s64* dist_pred,
//	MD_COM_MODE* mod_info_curr_ptr, /*COM_PART_INFO* mod_info_curr_pb_info, */pel org_y[256], int stride_org,
//	int mode_idx, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo,
//	U3 cu_width_log2, U3 cu_height_log2, s16 resi_t[16][16], U2 tree_status, u8 ctx_cons_pred_mode,
//	U1 valid_flag[1], U1 valid_mode[17], S14 sub_pel_mv[MV_D], pel pred_cache[16][16], s16 mvp_all[2][5][2],
//	U8 refwin_md[88][88], S14 sw_offset_x_md, S14 sw_offset_y_md, U8 RefWindowLCU_t[512 * 512])
//{
//	if (mode_idx < 0)
//		return;
//
//	*cost_best_temp = (s64)MAX_S64;
//	s16 mv_all[2][5][2];
//	int best_mv_uni_inner[2][4][2];
//	u8 num_refp_cnt = md_fw_ptr->num_refp;
//	int refi_cur = 0;
//	dist_pred[0] = (s64)MAX_S64;
//	valid_flag[0] = valid_mode[mode_idx];
//	U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
//	u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
//	u8 curr_mvr = 0;
//	U2 mode_type = 0;
//	if (valid_flag[0] == 1) {
//		mode_type = mode_type_table[mode_idx];
//		curr_mvr = curr_mvr_table[mode_idx];
//
//		int pic_height = md_fw_ptr->pic_height_in_scu << 2;
//		int pic_width = md_fw_ptr->pic_width_in_scu << 2;
//		if (mode_type == 0 || mode_type == 1)
//		{
//			if (mode_type == 1) {
//				BOOL res = analyze_me_uni_pred_16(model_cnt, md_fw_ptr, mod_info_curr_ptr,/* mod_info_curr_pb_info,*/ md_input_ptr, num_refp_cnt, curr_mvr, cu_width, cu_height,
//					mvp_all, mv_all, best_mv_uni_inner, cost_best_temp, RefWindowLCU, CtrPos, dist_pred,
//					org_y, stride_org, refi_cur, resi_t, tree_status, ctx_cons_pred_mode, sub_pel_mv, pred_cache,
//					refwin_md, sw_offset_x_md, sw_offset_y_md, RefWindowLCU_t);
//				valid_flag[0] = res;
//			}
//			else if (mode_type == 2)
//			{
//				//for (int i = 0; i < NEB_NUMS; ++i){
//				//	me_line_map_ptr->mv_nebs[i][0] = me_line_map_ptr->mv_nebs[i][1] = 0;
//				//}
//				//analyze_affine_uni_pred_16(model_cnt, md_fw_ptr, me_line_map_ptr, inner_nebs, above_nebs_line, mod_info_curr_ptr, mod_info_curr_pb_info, mod_info_curr_tb_info, md_input_ptr, Orig_Lcu_ptr,
//				//	Fetch_Refwin_ptr, curr_mvr, best_mv_uni_inner, cost_best_temp,
//				//	dist_pred, allowed, resi_t, tree_status, ctx_cons_pred_mode, pred_cache);
//				//valid_flag[0] = allowed[0];
//#if MD_PRINT
//				__assert_HLS("affine is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4550, __FUNCTION__);
//#endif
//			}
//			else if (mode_type == 0)
//			{
//#ifdef MD_CMOD
//#if MD_PRINT
//				__assert_HLS("skip is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4672, __FUNCTION__);
//#endif
//#else
//				if (!make_skip_resi_16(mode_idx, skip_rdo, skip_rdo_mode, &merge_rdo, mod_info_curr_ptr, /*mod_info_curr_pb_info,*/ RefWindowLCU, CtrPos, pic_width, pic_height,
//					cu_width_log2, cu_height_log2, org_y, 64, dist_pred, cu_width, cu_height, resi_t, pred_cache, RefWindowLCU_t)) {
//					valid_flag[0] = 0;
//				}
//#endif 
//			}
//
//			CU_POS cu = { (int)mod_info_curr_ptr->scup, mod_info_curr_ptr->x_pos, mod_info_curr_ptr->y_pos, mod_info_curr_ptr->cu_width, mod_info_curr_ptr->cu_height };
//			if (!com_mc_y_16(mode_type, &cu, pic_width, pic_height, mod_info_curr_ptr->refi, mod_info_curr_ptr->mv,
//				SWW, RefWindowLCU, pred_cache, 8, tree_status, CtrPos, RefWindowLCU_t)) {
//				valid_flag[0] = 0;
//			}
//
//		}
//	}
//}

void diff_ssd_bitcnt_8_16(MD_FW* md_fw_ptr, MD_INPUT* md_input_ptr, u8 num_refp_for_diff,
	u8 mode_type_nz, MD_KERNEL_MODE* mod_info_nz, pel pred_cache_nz[16][16], pel pred_cache_update[16][16], S3 mod_info_refi_for_diff[2],
	pel orgY_nz[16][16], s64* dist_pred, s64* cost_best_temp, s16 mod_info_mvd_for_diff[2][2], s16 mod_info_mvd_for_rate[2][2], s16 mod_info_mvd_for_up[2][2],
	U2 tree_status, U2 curr_cons_pred_mode, s8 inter_mode_idx, U1 valid_mode[17], U7 cu_width, MD_KERNEL_INPUT* md_kernel_input, int refp_ptr0, int refp_ptr1)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=md_input_ptr->lambda core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_nz
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY_nz core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=dist_pred
#pragma HLS INTERFACE axis port=cost_best_temp
#pragma HLS RESOURCE variable=valid_mode core=RAM_1P_BRAM
#endif

	// STREAM BUFFER
	u8 mode_type_read = mode_type_nz;
	s8 mode_idx_read = inter_mode_idx;
	s64 dist_pred_write = MAX_S64;
	s64 cost_best_write = MAX_S64;
#pragma HLS ARRAY_PARTITION variable=pred_cache_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_nz complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_nz complete dim=1
#pragma HLS ARRAY_PARTITION variable=orgY_nz complete dim=2
#pragma HLS ARRAY_PARTITION variable=orgY_nz complete dim=1
	for (int i = 0; i < 2; i++) {
#pragma HLS UNROLL
		for (int j = 0; j < 2; j++) {
#pragma HLS UNROLL
			mod_info_mvd_for_diff[i][j] = mod_info_nz->mvd[i][j];
			mod_info_mvd_for_rate[i][j] = mod_info_nz->mvd[i][j];
			mod_info_mvd_for_up[i][j] = mod_info_nz->mvd[i][j];
		}
	}
	if (mode_idx_read >= 0)
	{
		u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
		int curr_mvr = curr_mvr_table[mode_idx_read];
		int cu_width_log2 = md_kernel_input->cu_width_log2;
		int cu_height_log2 = md_kernel_input->cu_height_log2;
		s64 lambdaY = md_input_ptr->lambda_y;
		int is_intra = 0;
		U1 valid_flag = valid_mode[mode_idx_read];
		if (valid_flag == 1)
		{
			if (mode_type_read == 1 || mode_type_read == 0)
			{
				dist_pred_write = enc_ssd_16b_1_8_16_lxy(cu_width_log2, cu_height_log2, pred_cache_nz, orgY_nz, 1 << cu_width_log2, 16, md_fw_ptr->bit_depth_internal);
				int num_nz[MAX_NUM_TB][N_C];
				cu_nz_cln(num_nz);
				if (mode_type_read != 0)
				{
					cost_best_write = dist_pred_write;
					int bit_cnt = get_bitcnt_est_16_8_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode, mod_info_nz->cu_mode,
						mod_info_nz->umve_flag, mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx, mod_info_refi_for_diff,
						0, mod_info_nz->smvd_flag, num_refp_for_diff, mod_info_nz->affine_mvd, mod_info_nz->mvd,
						md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part,
						num_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
#/*if ENABLE_BFRAME
					int bit_cnt = get_bitcnt_est_8_16_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode,
					mod_info_nz->cu_mode, mod_info_nz->umve_flag, mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx,
					mod_info_nz->refi, 0, mod_info_nz->smvd_flag, md_fw_ptr->num_refp[0], mod_info_nz->affine_mvd, mod_info_nz->mvd, 
					md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part, n
					um_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
#else
					int bit_cnt = get_bitcnt_est_16_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode, mod_info_nz->cu_mode, mod_info_nz->umve_flag, mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx, mod_info_nz->refi, 0, mod_info_nz->smvd_flag, md_fw_ptr->num_refp, mod_info_nz->affine_mvd, mod_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part, num_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
#endif*/

					cost_best_write += (bit_cnt * lambdaY + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
				}
			}
		}
	}

	// WRITE STREAMS
	*dist_pred = dist_pred_write;
	*cost_best_temp = cost_best_write;

	for (int i = 0; i < 16; ++i)
	{
#pragma HLS PIPELINE
		for (int j = 0; j < 16; ++j)
		{
			pred_cache_update[i][j] = pred_cache_nz[i][j];
		}
	}
}

void diff_ssd_bitcnt_16_8(MD_FW* md_fw_ptr, MD_INPUT* md_input_ptr, u8 num_refp_for_diff,
	u8 mode_type_nz, MD_KERNEL_MODE* mod_info_nz, pel pred_cache_nz[16][16], pel pred_cache_update[16][16], S3 mod_info_refi_for_diff[2],
	pel orgY_nz[16][16], s64* dist_pred, s64* cost_best_temp, s16 mod_info_mvd_for_diff[2][2], s16 mod_info_mvd_for_rate[2][2], s16 mod_info_mvd_for_up[2][2],
	U2 tree_status, U2 curr_cons_pred_mode, s8 inter_mode_idx, U1 valid_mode[17], U7 cu_width, MD_KERNEL_INPUT* md_kernel_input, int refp_ptr0, int refp_ptr1)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=md_input_ptr->lambda core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_nz
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY_nz core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=dist_pred
#pragma HLS INTERFACE axis port=cost_best_temp
#pragma HLS RESOURCE variable=valid_mode core=RAM_1P_BRAM
#endif

	// STREAM BUFFER
	u8 mode_type_read = mode_type_nz;
	s8 mode_idx_read = inter_mode_idx;
	s64 dist_pred_write = MAX_S64;
	s64 cost_best_write = MAX_S64;
#pragma HLS ARRAY_PARTITION variable=pred_cache_update complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_nz complete dim=2
//#pragma HLS ARRAY_PARTITION variable=pred_cache_nz complete dim=1
#pragma HLS ARRAY_PARTITION variable=orgY_nz complete dim=2
//#pragma HLS ARRAY_PARTITION variable=orgY_nz complete dim=1
	for (int i = 0; i < 2; i++) {
#pragma HLS UNROLL
		for (int j = 0; j < 2; j++) {
#pragma HLS UNROLL
			mod_info_mvd_for_diff[i][j] = mod_info_nz->mvd[i][j];
			mod_info_mvd_for_rate[i][j] = mod_info_nz->mvd[i][j];
			mod_info_mvd_for_up[i][j] = mod_info_nz->mvd[i][j];
		}
	}
	if (mode_idx_read >= 0)
	{
		u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
		int curr_mvr = curr_mvr_table[mode_idx_read];
		int cu_width_log2 = md_kernel_input->cu_width_log2;
		int cu_height_log2 = md_kernel_input->cu_height_log2;
		s64 lambdaY = md_input_ptr->lambda_y;
		int is_intra = 0;
		U1 valid_flag = valid_mode[mode_idx_read];
		if (valid_flag == 1)
		{
			if (mode_type_read == 1 || mode_type_read == 0)
			{
				dist_pred_write = enc_ssd_16b_1_16_8_lxy(cu_width_log2, cu_height_log2, pred_cache_nz, orgY_nz, 1 << cu_width_log2, 16, md_fw_ptr->bit_depth_internal);
				int num_nz[MAX_NUM_TB][N_C];
				cu_nz_cln(num_nz);
				if (mode_type_read != 0)
				{
					cost_best_write = dist_pred_write;
					int bit_cnt = get_bitcnt_est_16_8_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode, mod_info_nz->cu_mode,
						mod_info_nz->umve_flag, mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx, mod_info_refi_for_diff,
						0, mod_info_nz->smvd_flag, num_refp_for_diff, mod_info_nz->affine_mvd, mod_info_nz->mvd,
						md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part,
						num_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
//#if ENABLE_BFRAME
//					int bit_cnt = get_bitcnt_est_16_8_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode, mod_info_nz->cu_mode, mod_info_nz->umve_flag, mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx, mod_info_nz->refi, 0, mod_info_nz->smvd_flag, md_fw_ptr->num_refp[0], mod_info_nz->affine_mvd, mod_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part, num_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
//#else
//					int bit_cnt = get_bitcnt_est_16_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode, mod_info_nz->cu_mode, mod_info_nz->umve_flag, mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx, mod_info_nz->refi, 0, mod_info_nz->smvd_flag, md_fw_ptr->num_refp, mod_info_nz->affine_mvd, mod_info_nz->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part, num_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
//#endif

					cost_best_write += (bit_cnt * lambdaY + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
				}
			}
		}
	}

	// WRITE STREAMS
	*dist_pred = dist_pred_write;
	*cost_best_temp = cost_best_write;

	for (int i = 0; i < 16; ++i)
	{
#pragma HLS PIPELINE
		for (int j = 0; j < 16; ++j)
		{
			pred_cache_update[i][j] = pred_cache_nz[i][j];
		}
	}
}

void diff_ssd_bitcnt_16_16(MD_FW* md_fw_ptr, u8 num_refp_for_diff, MD_INPUT* md_input_ptr,
	u8 mode_type_nz, MD_KERNEL_MODE* mod_info_nz, pel pred_cache_nz[16][16], pel pred_cache_update[16][16], S3 mod_info_refi_for_diff[2],
	pel orgY_nz[16][16], s64* dist_pred, s64* cost_best_temp, s16 mod_info_mvd_for_diff[2][2], s16 mod_info_mvd_for_rate[2][2], s16 mod_info_mvd_for_up[2][2],
	U2 tree_status, U2 curr_cons_pred_mode, s8 inter_mode_idx, U1 valid_mode[17], U7 cu_width, MD_KERNEL_INPUT* md_kernel_input, int refp_ptr0, int refp_ptr1)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS RESOURCE variable=md_input_ptr->lambda core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_nz
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_update core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY_nz core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=dist_pred
#pragma HLS INTERFACE axis port=cost_best_temp
#pragma HLS RESOURCE variable=valid_mode core=RAM_1P_BRAM
#endif

	// STREAM BUFFER
	u8 mode_type_read = mode_type_nz;
	s8 mode_idx_read = inter_mode_idx;
	s64 dist_pred_write = MAX_S64;
	s64 cost_best_write = MAX_S64;
	for (int i = 0; i < 2; i++) {
#pragma HLS UNROLL
		for (int j = 0; j < 2; j++) {
#pragma HLS UNROLL
			mod_info_mvd_for_diff[i][j] = mod_info_nz->mvd[i][j];
			mod_info_mvd_for_rate[i][j] = mod_info_nz->mvd[i][j];
			mod_info_mvd_for_up[i][j] = mod_info_nz->mvd[i][j];
		}
	}
	if (mode_idx_read >= 0)
	{
		u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
		int curr_mvr = curr_mvr_table[mode_idx_read];
		int cu_width_log2 = md_kernel_input->cu_width_log2;
		int cu_height_log2 = md_kernel_input->cu_height_log2;
		s64 lambdaY = md_input_ptr->lambda_y;
		int is_intra = 0;
		U1 valid_flag = valid_mode[mode_idx_read];
		if (valid_flag == 1)
		{
			if (mode_type_read == 1 || mode_type_read == 0)
			{
				dist_pred_write = enc_ssd_16b_1_16_16_lxy(cu_width_log2, cu_height_log2, pred_cache_nz, orgY_nz, 1 << cu_width_log2, 16, md_fw_ptr->bit_depth_internal);
				int num_nz[MAX_NUM_TB][N_C];
				cu_nz_cln(num_nz);
				if (mode_type_read != 0)
				{
					cost_best_write = dist_pred_write;
#if ENABLE_BFRAME
					int bit_cnt = get_bitcnt_est_16_16_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode, mod_info_nz->cu_mode, mod_info_nz->umve_flag,
						mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx, mod_info_refi_for_diff, 0, mod_info_nz->smvd_flag, num_refp_for_diff,
						mod_info_nz->affine_mvd, mod_info_mvd_for_diff, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part,
						num_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
#else
					int bit_cnt = get_bitcnt_est_16_coef_0(md_fw_ptr->f_scu, curr_mvr, tree_status, 0, 2, curr_cons_pred_mode, mod_info_nz->cu_mode, mod_info_nz->umve_flag, 
						mod_info_nz->umve_idx, mod_info_nz->affine_flag, 1, mod_info_nz->skip_idx, mod_info_refi_for_diff, 0, mod_info_nz->smvd_flag, num_refp_for_diff,
						mod_info_nz->affine_mvd, mod_info_mvd_for_diff, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2, mod_info_nz->tb_part, mod_info_nz->pb_part,
						num_nz, mod_info_nz->ipm, md_fw_ptr->slice_type, md_fw_ptr->cur_ptr, refp_ptr0, refp_ptr1, mod_info_nz->mpm, is_intra);
#endif

					cost_best_write += (bit_cnt * lambdaY + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
				}
			}
		}
	}

	// WRITE STREAMS
	*dist_pred = dist_pred_write;
	*cost_best_temp = cost_best_write;

	for (int i = 0; i < 16; ++i)
	{
#pragma HLS PIPELINE
		for (int j = 0; j < 16; ++j)
		{
			pred_cache_update[i][j] = pred_cache_nz[i][j];
		}
	}
}


//
//static void limit_inter_rdo_num_16(RDOQ_MODEL* model_cnt, U3 max_rdo_num, U5 all_inter_mode_num, MD_FW* md_fw_ptr, ENC_ME_LINE_MAP* me_line_map_ptr,
//	ENC_ME_NEB_INFO inner_nebs[2][SCU_IN_LCU_NUMS_LEN][SCU_IN_LCU_NUMS_LEN],ENC_ME_NEB_INFO above_nebs_line[ABOVE_LINE_LEN],
//	s64* cost_best_temp,
//	MD_INPUT* md_input_ptr, u8 num_refp_cnt, u8& curr_mvr, U7 cu_width, U7 cu_height, s16 mvp_all[2][5][2],
//	s16 mv_all[2][5][2], u32 mecost_all[2][5], U8 RefWindowLCU[SWW*SWH], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS],
//	MD_COM_MODE mod_info_curr_ptr[5 + 1], COM_PART_INFO mod_info_curr_pb_info[5 + 1], COM_PART_INFO mod_info_curr_tb_info[5 + 1], s64 dist_pred[5 + 1], pel* org_y, U7 stride_org, int bit_cnt, s8 refi_cur, pel p_fenc_LCU_Y[MAX_CU_SIZE_FETCH*MAX_CU_SIZE_FETCH],
//	u8& mode_type, SKIP_RDO skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo,
//	U3 cu_width_log2, U3 cu_height_log2, s16 resi_t[5 + 1][16][16], U2 tree_status, U2 ctx_cons_pred_mode, U1 valid_flag[1], U1 valid_mode[17], S14 sub_pel_mv[MV_D], pel pred_cache[5 + 1][16][16])
//{
//	int best_mv_uni_inner[2][4][2];
//
//	s64 dist_pred_all[30] = { 0 };
//	for (U5 mode_idx = 9; mode_idx < 14/*all_inter_mode_num*/; mode_idx++) {
//#pragma HLS LOOP_TRIPCOUNT max=17
//		analyze_uni_pred_16(model_cnt, md_fw_ptr, me_line_map_ptr, inner_nebs, above_nebs_line, &cost_best_temp[1 + mode_idx - 9], md_input_ptr, num_refp_cnt, curr_mvr,
//			cu_width, cu_height, mvp_all, mv_all, mecost_all, best_mv_uni_inner, RefWindowLCU, CtrPos, &mod_info_curr_ptr[0], &mod_info_curr_pb_info[0], &mod_info_curr_tb_info[0],
//			&dist_pred[1 + mode_idx - 9], org_y, stride_org, bit_cnt, (int)refi_cur,
//			mode_type, mode_idx, skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2, resi_t[1 + mode_idx - 9], tree_status, ctx_cons_pred_mode, valid_flag, valid_mode, sub_pel_mv, pred_cache[1 + mode_idx - 9]);
//
//		if (valid_flag[0] == 1)
//		{
//			dist_pred_all[mode_idx] = dist_pred[1 + mode_idx - 9];
//			valid_mode[mode_idx] = 1;
//
//			copy_md_com_mode_info(&mod_info_curr_ptr[0], &mod_info_curr_ptr[1 + mode_idx - 9]);
//			copy_md_com_part_info(&mod_info_curr_pb_info[0], &mod_info_curr_pb_info[1 + mode_idx - 9]);
//			copy_md_com_part_info(&mod_info_curr_tb_info[0], &mod_info_curr_tb_info[1 + mode_idx - 9]);
//		}
//		else
//		{
//			dist_pred_all[mode_idx] = MAX_S64;
//			valid_mode[mode_idx] = 0;
//		}
//	}
//
//	choose_inter_rdo_mode(max_rdo_num, all_inter_mode_num, dist_pred_all, valid_mode);
//}

void com_get_mpm_16x16(int x_scu, int y_scu, u8 mpm[2], MPM_ARRAY_SIZE<16, 16>* MPM_buffer_ptr_16x16, IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16)
{
//#pragma HLS INLINE off
#pragma HLS INLINE 
	u8 ipm_l = 0;
	u8 ipm_u = 0;
	int valid_l = 0;
	int valid_u = 0;
	int mpm_x = x_scu % 16;
	int mpm_y = y_scu % 16;
	int pic_x_scu = mpm_x;
	int pic_y_scu = mpm_y;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x16->map_scu_left_line_new[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_16x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_16x16->left;
			valid_l = 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_16x16->left;
			valid_l = 1;
		}
	}
	if (pic_y_scu == 0) {
		if (y_scu > 0
			&& ((IP_map_scu_ptr_16x16->map_scu_up_line[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_16x16->map_scu_up_line[0] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_16x16->up;
			valid_u = 1;
		}
	}
	else {
		if (y_scu > 0
			&& ((IP_map_scu_ptr_16x16->map_scu_up_line[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_16x16->map_scu_up_line[0] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_16x16->up;
			valid_u = 1;
		}
	}
	/*mpm[0] = (ipm_l < ipm_u ? ipm_l : ipm_u);
	mpm[1] = (ipm_l > ipm_u ? ipm_l : ipm_u);
	if (mpm[0] == mpm[1]) {
		mpm[0] = 0;
		mpm[1] = ((u8)(((mpm[1]) == 0 ? 2 : (mpm[1]))));
	}*/
	u8 mpm0_tmp = (ipm_l < ipm_u ? ipm_l : ipm_u);
	u8	mpm1_tmp = (ipm_l > ipm_u ? ipm_l : ipm_u);
	if (mpm0_tmp == mpm1_tmp) {
		mpm[0] = 0;
		mpm[1] = ((u8)(((mpm1_tmp) == 0 ? 2 : (mpm1_tmp))));
	}
	else {
		mpm[0] = mpm0_tmp;
		mpm[1] = mpm1_tmp;
	}
}
void com_get_mpm_16x8(int x_scu, int y_scu, u8 mpm[2], MPM_ARRAY_SIZE<16, 8>* MPM_buffer_ptr_16x8, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8)
{
#pragma HLS INLINE off
	u8 ipm_l = 0;
	u8 ipm_u = 0;
	int valid_l = 0;
	int valid_u = 0;
	int mpm_x = x_scu % 16;
	int mpm_y = y_scu % 16;
	int pic_x_scu = mpm_x;
	int pic_y_scu = mpm_y;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x8->map_scu_left_line_new[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_16x8->map_scu_left_line_new[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_16x8->left;
			valid_l = 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x8->map_scu_left_line_new[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_16x8->left;
			valid_l = 1;
		}
	}
	if (pic_y_scu == 0) {
		if (y_scu > 0
			&& ((IP_map_scu_ptr_16x8->map_scu_up_line[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_16x8->map_scu_up_line[0] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_16x8->up;
			valid_u = 1;
		}
	}
	else {
		if (y_scu > 0
			&& ((IP_map_scu_ptr_16x8->map_scu_up_line[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_16x8->map_scu_up_line[0] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_16x8->up;
			valid_u = 1;
		}
	}
	mpm[0] = (ipm_l < ipm_u ? ipm_l : ipm_u);
	mpm[1] = (ipm_l > ipm_u ? ipm_l : ipm_u);
	if (mpm[0] == mpm[1]) {
		mpm[0] = 0;
		mpm[1] = ((u8)(((mpm[1]) == 0 ? 2 : (mpm[1]))));
	}
}
void com_get_mpm_8x16(int x_scu, int y_scu, u8 mpm[2], MPM_ARRAY_SIZE<8, 16>* MPM_buffer_ptr_8x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16)
{
#pragma HLS INLINE off
	u8 ipm_l = 0;
	u8 ipm_u = 0;
	int valid_l = 0;
	int valid_u = 0;
	int mpm_x = x_scu % 16;
	int mpm_y = y_scu % 16;
	int pic_x_scu = mpm_x;
	int pic_y_scu = mpm_y;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_8x16->map_scu_left_line_new[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_8x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_8x16->left;
			valid_l = 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_8x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_8x16->left;
			valid_l = 1;
		}
	}
	if (pic_y_scu == 0) {
		if (y_scu > 0
			&& ((IP_map_scu_ptr_8x16->map_scu_up_line[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_8x16->map_scu_up_line[0] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_8x16->up;
			valid_u = 1;
		}
	}
	else {
		if (y_scu > 0
			&& ((IP_map_scu_ptr_8x16->map_scu_up_line[0] >> 15 & (1)))
			&& ((IP_map_scu_ptr_8x16->map_scu_up_line[0] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_8x16->up;
			valid_u = 1;
		}
	}
	mpm[0] = (ipm_l < ipm_u ? ipm_l : ipm_u);
	mpm[1] = (ipm_l > ipm_u ? ipm_l : ipm_u);
	if (mpm[0] == mpm[1]) {
		mpm[0] = 0;
		mpm[1] = ((u8)(((mpm[1]) == 0 ? 2 : (mpm[1]))));
	}
}

static int get_rmd_result_8_16(U3 cu_width_log2, U3 cu_heght_log2, U13 x, U13 y, u8 ipred_list[],
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE],
#else
	u8 rmd_mode[IPD_RDO_CNT],
#endif
#if EIPM
	int eipm_enable_flag
#endif
#if USE_SPEED_LEVEL
	, U8 speed_level
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=ipred_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=rmd_mode complete dim=0
	int i;
	int w = cu_width_log2 - 2;
	int h = cu_heght_log2 - 2;
	int x0 = x >> 2;
	int y0 = y >> 2;
	int idx = get_g_map_idx(w, h, x0, y0);
	//int cnt = ((((cu_width_log2 - cu_heght_log2) >= 2) || ((cu_heght_log2 - cu_width_log2) >= 2)) ? (IPD_RDO_CNT - 1) : IPD_RDO_CNT);
#if USE_SPEED_LEVEL
	int cnt = IPD_RDO_CNT;
	if (speed_level == 1)
		cnt = IPD_RDO_CNT; //5
	else if (speed_level == 2)
		cnt = EXTRA_RDO_MODE;//10
	else
		cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
	int cnt = IPD_RDO_CNT;
#endif

#if EIPM && !USE_EIPM_RMD
	if (eipm_enable_flag)
	{

		for (int i = 0; i < IPD_RDO_CNT; i++)
		{
			if (rmd_mode[i] >= 3 && rmd_mode[i] <= 31)
			{
				if (rmd_mode[i] == 3)
				{
					ipred_list[5] = 34;
				}
				else if (rmd_mode[i] > 3 && rmd_mode[i] <= 11)
				{
					ipred_list[5] = rmd_mode[i] + 30;
					ipred_list[6] = rmd_mode[i] + 31;
				}
				else if (rmd_mode[i] == 12)
				{
					ipred_list[5] = 43;
					ipred_list[6] = 44;
				}
				else if (rmd_mode[i] > 12 && rmd_mode[i] <= 23)
				{
					ipred_list[5] = rmd_mode[i] + 32;
					ipred_list[6] = rmd_mode[i] + 33;
				}
				else if (rmd_mode[i] == 24)
				{
					ipred_list[5] = 57;
					ipred_list[6] = 58;
				}
				else if (rmd_mode[i] > 24 && rmd_mode[i] <= 30)
				{
					ipred_list[5] = rmd_mode[i] + 34;
					ipred_list[6] = rmd_mode[i] + 35;
				}
				else
				{
					ipred_list[5] = 65;
				}
				break;
			}
		}
	}
#endif
	for (i = 0; i < cnt; i++) {
#pragma HLS UNROLL
		ipred_list[i] = rmd_mode[i];
	}

	return cnt;
}
static int get_rmd_result_16_8(U3 cu_width_log2, U3 cu_heght_log2, U13 x, U13 y, u8 ipred_list[],
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE],
#else
	u8 rmd_mode[IPD_RDO_CNT],
#endif
#if EIPM
	int eipm_enable_flag
#endif
#if USE_SPEED_LEVEL
	, U8 speed_level
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=ipred_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=rmd_mode complete dim=0
	int i;
	int w = cu_width_log2 - 2;
	int h = cu_heght_log2 - 2;
	int x0 = x >> 2;
	int y0 = y >> 2;
	int idx = get_g_map_idx(w, h, x0, y0);
	//int cnt = ((((cu_width_log2 - cu_heght_log2) >= 2) || ((cu_heght_log2 - cu_width_log2) >= 2)) ? (IPD_RDO_CNT - 1) : IPD_RDO_CNT);
#if USE_SPEED_LEVEL
	int cnt = IPD_RDO_CNT;
	if (speed_level == 1)
		cnt = IPD_RDO_CNT; //5
	else if (speed_level == 2)
		cnt = EXTRA_RDO_MODE;//10
	else
		cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
	int cnt = IPD_RDO_CNT;
#endif

#if EIPM && !USE_EIPM_RMD
	if (eipm_enable_flag)
	{

		for (int i = 0; i < IPD_RDO_CNT; i++)
		{
			if (rmd_mode[i] >= 3 && rmd_mode[i] <= 31)
			{
				if (rmd_mode[i] == 3)
				{
					ipred_list[5] = 34;
				}
				else if (rmd_mode[i] > 3 && rmd_mode[i] <= 11)
				{
					ipred_list[5] = rmd_mode[i] + 30;
					ipred_list[6] = rmd_mode[i] + 31;
				}
				else if (rmd_mode[i] == 12)
				{
					ipred_list[5] = 43;
					ipred_list[6] = 44;
				}
				else if (rmd_mode[i] > 12 && rmd_mode[i] <= 23)
				{
					ipred_list[5] = rmd_mode[i] + 32;
					ipred_list[6] = rmd_mode[i] + 33;
				}
				else if (rmd_mode[i] == 24)
				{
					ipred_list[5] = 57;
					ipred_list[6] = 58;
				}
				else if (rmd_mode[i] > 24 && rmd_mode[i] <= 30)
				{
					ipred_list[5] = rmd_mode[i] + 34;
					ipred_list[6] = rmd_mode[i] + 35;
				}
				else
				{
					ipred_list[5] = 65;
				}
				break;
			}
		}
	}
#endif
	for (i = 0; i < cnt; i++) {
#pragma HLS UNROLL
		ipred_list[i] = rmd_mode[i];
	}

	return cnt;
}
static int get_rmd_result_16_16(U3 cu_width_log2, U3 cu_heght_log2, U13 x, U13 y, u8 ipred_list[],
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE],
#else
	u8 rmd_mode[IPD_RDO_CNT],
#endif
#if EIPM
	int eipm_enable_flag
#endif
#if USE_SPEED_LEVEL
	, U8 speed_level
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=ipred_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=rmd_mode complete dim=0
	int i;
	int w = cu_width_log2 - 2;
	int h = cu_heght_log2 - 2;
	int x0 = x >> 2;
	int y0 = y >> 2;
	int idx = get_g_map_idx(w, h, x0, y0);
	//int cnt = ((((cu_width_log2 - cu_heght_log2) >= 2) || ((cu_heght_log2 - cu_width_log2) >= 2)) ? (IPD_RDO_CNT - 1) : IPD_RDO_CNT);
#if USE_SPEED_LEVEL
	int cnt = IPD_RDO_CNT;
	if (speed_level == 1)
		cnt = IPD_RDO_CNT; //5
	else if (speed_level == 2)
		cnt = EXTRA_RDO_MODE;//10
	else
		cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
#if SIMPLE_MD
	int cnt = 1;
#else
	int cnt = IPD_RDO_CNT;
#endif // 0
#endif

#if EIPM && !USE_EIPM_RMD
	if (eipm_enable_flag)
	{

		for (int i = 0; i < IPD_RDO_CNT; i++)
		{
#pragma HLS UNROLL
			if (rmd_mode[i] >= 3 && rmd_mode[i] <= 31)
			{
				if (rmd_mode[i] == 3)
				{
					ipred_list[5] = 34;
				}
				else if (rmd_mode[i] > 3 && rmd_mode[i] <= 11)
				{
					ipred_list[5] = rmd_mode[i] + 30;
					ipred_list[6] = rmd_mode[i] + 31;
				}
				else if (rmd_mode[i] == 12)
				{
					ipred_list[5] = 43;
					ipred_list[6] = 44;
				}
				else if (rmd_mode[i] > 12 && rmd_mode[i] <= 23)
				{
					ipred_list[5] = rmd_mode[i] + 32;
					ipred_list[6] = rmd_mode[i] + 33;
				}
				else if (rmd_mode[i] == 24)
				{
					ipred_list[5] = 57;
					ipred_list[6] = 58;
				}
				else if (rmd_mode[i] > 24 && rmd_mode[i] <= 30)
				{
					ipred_list[5] = rmd_mode[i] + 34;
					ipred_list[6] = rmd_mode[i] + 35;
				}
				else
				{
					ipred_list[5] = 65;
				}
				break;
			}
		}
	}
#endif
	for (i = 0; i < cnt; i++) {
#pragma HLS UNROLL
		ipred_list[i] = rmd_mode[i];
	}

	return cnt;
}

u16 com_get_avail_intra_ip_16x16(IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16,
	U11 x_scu, U11 y_scu, U8 cu_width, U8 cu_height)
{
//#pragma HLS INLINE off
#pragma HLS INLINE
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0 && ((IP_map_scu_ptr_16x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_16x16->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_16x16->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0) {
			if (x_scu > 0 && ((IP_map_scu_ptr_16x16->map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
		}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0 && ((IP_map_scu_ptr_16x16->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x16->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}
u16 com_get_avail_intra_ip_16x8(IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8,
	U11 x_scu, U11 y_scu, U8 cu_width, U8 cu_height)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x8->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0 && ((IP_map_scu_ptr_16x8->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_16x8->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_16x8->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0) {
			if (x_scu > 0 && ((IP_map_scu_ptr_16x8->map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
		}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0 && ((IP_map_scu_ptr_16x8->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x8->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}
u16 com_get_avail_intra_ip_8x16(IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16,
	U11 x_scu, U11 y_scu, U8 cu_width, U8 cu_height)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0 && ((IP_map_scu_ptr_8x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0 && ((IP_map_scu_ptr_8x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_8x16->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_8x16->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0) {
			if (x_scu > 0 && ((IP_map_scu_ptr_8x16->map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
		}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0 && ((IP_map_scu_ptr_8x16->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_8x16->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

void prepare_intra_info_8_16(MD_FW* md_fw_ptr, MD_COM_MODE* mod_info_curr_ptr,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>* MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>* MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>* MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8,
	U3 cu_width_log2, U3 cu_height_log2, U13 pix_x, U13 pix_y, U14 sub_x,
	U14 sub_y, u8 ipred_list[33], int pred_cnt[1], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16* avail_tb,
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE]
	, U8 speed_level
#else
	u8 rmd_mode[IPD_RDO_CNT]
#endif
)
{
#pragma HLS inline off
#pragma HLS ARRAY_PARTITION variable=src_le_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up_temp complete dim=0
	int pb_x_scu = mod_info_curr_ptr->x_pos >> 2;
	int pb_y_scu = mod_info_curr_ptr->y_pos >> 2;
	int tb_x_scu;
	int tb_y_scu;
	int i;
	int bit_depth;
	
		com_get_mpm_8x16(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr_8x16, IP_map_scu_ptr_8x16);

	//com_get_mpm(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr, me_line_map_ptr);
	pred_cnt[0] = get_rmd_result_8_16(cu_width_log2, cu_height_log2, pix_x, pix_y, ipred_list, rmd_mode
#if EIPM
		, md_fw_ptr->eipm_enable_flag
#endif
#if USE_SPEED_LEVEL
		, speed_level
#endif
	);

	bit_depth = md_fw_ptr->bit_depth_internal;
	tb_x_scu = sub_x >> 2;
	tb_y_scu = sub_y >> 2;
	
		*avail_tb = com_get_avail_intra_ip_8x16(IP_map_scu_ptr_8x16, tb_x_scu, tb_y_scu, 1 << cu_width_log2, 1 << cu_height_log2);

	for (i = 0; i < 35; i++) {
#pragma HLS UNROLL
		src_le_temp[i] = (1 << (bit_depth - 1));
	}
	for (i = 0; i < 35; i++) {
#pragma HLS UNROLL
		src_up_temp[i] = (1 << (bit_depth - 1));
	}

	get_IP_pixel_8_16(1 << cu_width_log2, 1 << cu_height_log2, *avail_tb, md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu, bit_depth, 0, src_le_temp, src_up_temp, sub_x, sub_y,
		IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
		IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8);
}
void prepare_intra_info_16_8(MD_FW* md_fw_ptr, MD_COM_MODE* mod_info_curr_ptr,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>* MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>* MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>* MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8,
	U3 cu_width_log2, U3 cu_height_log2, U13 pix_x, U13 pix_y, U14 sub_x,
	U14 sub_y, u8 ipred_list[33], int pred_cnt[1], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16* avail_tb,
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE]
	, U8 speed_level
#else
	u8 rmd_mode[IPD_RDO_CNT]
#endif
)
{
#pragma HLS inline off
#pragma HLS ARRAY_PARTITION variable=src_le_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up_temp complete dim=0
	int pb_x_scu = mod_info_curr_ptr->x_pos >> 2;
	int pb_y_scu = mod_info_curr_ptr->y_pos >> 2;
	int tb_x_scu;
	int tb_y_scu;
	int i;
	int bit_depth;

		com_get_mpm_16x8(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr_16x8, IP_map_scu_ptr_16x8);
	//com_get_mpm(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr, me_line_map_ptr);
	pred_cnt[0] = get_rmd_result_16_8(cu_width_log2, cu_height_log2, pix_x, pix_y, ipred_list, rmd_mode
#if EIPM
		, md_fw_ptr->eipm_enable_flag
#endif
#if USE_SPEED_LEVEL
		, speed_level
#endif
	);

	bit_depth = md_fw_ptr->bit_depth_internal;
	tb_x_scu = sub_x >> 2;
	tb_y_scu = sub_y >> 2;
		*avail_tb = com_get_avail_intra_ip_16x8(IP_map_scu_ptr_16x8, tb_x_scu, tb_y_scu, 1 << cu_width_log2, 1 << cu_height_log2);

	for (i = 0; i < 35; i++) {
#pragma HLS UNROLL
		src_le_temp[i] = (1 << (bit_depth - 1));
	}
	for (i = 0; i < 35; i++) {
#pragma HLS UNROLL
		src_up_temp[i] = (1 << (bit_depth - 1));
	}

	get_IP_pixel_16_8(1 << cu_width_log2, 1 << cu_height_log2, *avail_tb, md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu, bit_depth, 0, src_le_temp, src_up_temp, sub_x, sub_y,
		IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
		IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8);
}
void prepare_intra_info_16_16(MD_FW* md_fw_ptr, MD_COM_MODE* mod_info_curr_ptr,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>* MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>* MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>* MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8,
	U3 cu_width_log2, U3 cu_height_log2, U13 pix_x, U13 pix_y, U14 sub_x,
	U14 sub_y, u8 ipred_list[33], int pred_cnt[1], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16* avail_tb,
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE]
	, U8 speed_level
#else
	u8 rmd_mode[IPD_RDO_CNT]
#endif
)
{
#pragma HLS INLINE
//#pragma HLS inline off
#pragma HLS ARRAY_PARTITION variable=src_le_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=ipred_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=rmd_mode complete dim=0
	int pb_x_scu = mod_info_curr_ptr->x_pos >> 2;
	int pb_y_scu = mod_info_curr_ptr->y_pos >> 2;
	int tb_x_scu;
	int tb_y_scu;
	int i;
	int bit_depth;
		com_get_mpm_16x16(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr_16x16, IP_map_scu_ptr_16x16);

	
	//com_get_mpm(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr, me_line_map_ptr);
	pred_cnt[0] = get_rmd_result_16_16(cu_width_log2, cu_height_log2, pix_x, pix_y, ipred_list, rmd_mode
#if EIPM
		, md_fw_ptr->eipm_enable_flag
#endif
#if USE_SPEED_LEVEL
		, speed_level
#endif
	);

	bit_depth = md_fw_ptr->bit_depth_internal;
	tb_x_scu = sub_x >> 2;
	tb_y_scu = sub_y >> 2;
		*avail_tb = com_get_avail_intra_ip_16x16(IP_map_scu_ptr_16x16, tb_x_scu, tb_y_scu, 1 << cu_width_log2, 1 << cu_height_log2);
	

	for (i = 0; i < 35; i++) {
#pragma HLS UNROLL
		src_le_temp[i] = (1 << (bit_depth - 1));
	}
	for (i = 0; i < 35; i++) {
#pragma HLS UNROLL
		src_up_temp[i] = (1 << (bit_depth - 1));
	}

	get_IP_pixel_16_16(1 << cu_width_log2, 1 << cu_height_log2, *avail_tb, md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu, bit_depth, 0, src_le_temp, src_up_temp, sub_x, sub_y,
		IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
		IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8);
}

void rdo_prepare_8_16(MD_FW* md_fw_ptr,
	ENC_ME_LINE_MAP_SIZE<16>* me_line_map_ptr_16,
	ENC_ME_NEB_INFO up_nebs[1 + (16 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(16 >> 2)],
	SKIP_MERGE_INPUT_16* skip_in_16,
	MD_COM_MODE* mod_info_curr_ptr,
	MERGE_RDO* merge_rdo, MD_INPUT* md_input_ptr,
	U1 valid_mode[17], U1 amvr_enable_flag,
	ENC_FME_INFO_ALL_16* fme_mv_info,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>* MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>* MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>* MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8,
	U3 cu_width_log2, U3 cu_height_log2,
	u8 ipred_list[IPRED_LIST_NUM], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16* avail_tb, u8 rmd_mode[IPRED_LIST_NUM],
	U3 qt_depth, U5 all_inter_mode_num,
	U7 cu_width, U7 cu_height,
#if ENABLE_BFRAME
	ME_MV_DIR_16* me_mv_dir, MV_DIR* mv_dir,
#endif
	/*COM_PART_INFO* mod_info_curr_pb_info, */pel* org_y,
	U2 tree_status, u8 curr_cons_pred_mode,
	u8 inter_num[1], u8 intra_num[1], u8 rdo_list[MAX_RDO_NUM_SIZE(8, 16)], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], SKIP_RDO* skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2], strFetch_ref_window_16* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, SKIP_MERGE_INPUT* skip_in
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0
	s8 refi_cur = 0;
	U3 max_rdo_num = MAX_RDO_NUM_SIZE(8, 16);
	U3 max_inter = 0;
	U14 sub_x = mod_info_curr_ptr[0].x_pos;
	U14 sub_y = mod_info_curr_ptr[0].y_pos;
	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;
	int num_amvr;
	int pred_cnt[1] = { 5 };
#if ENABLE_BFRAME
	s8 num_refp_cnt[REFP_NUM] = { md_fw_ptr->num_refp[0], md_fw_ptr->num_refp[1] };
#else
	u8 num_refp_cnt = md_fw_ptr->num_refp;
#endif

	/*
		if (amvr_enable_flag) {
			num_amvr = 5;
		}
		else */
	{
		num_amvr = 1;
	}

	inter_num[0] = 0;
	intra_num[0] = 0;

	//printf("pos=(%d %d) size=(%d %d) slice=%d cons_pred_mode=%d\n", mod_info_curr_ptr->x_pos, mod_info_curr_ptr->y_pos, cu_width, cu_height, md_fw_ptr->slice_type, curr_cons_pred_mode);
	if (!(md_fw_ptr->slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA)) {
		max_inter = (curr_cons_pred_mode == ONLY_INTER) ? MAX_RDO_NUM_SIZE(8, 16) : MAX_RDO_NUM_INTER_SIZE(8, 16);
		prepare_luma_inter_8_16(md_fw_ptr,
			me_line_map_ptr_16,
			up_nebs, left_nebs, skip_in_16,
			mod_info_curr_ptr,
			skip_rdo, skip_rdo_mode, merge_rdo, md_input_ptr,
			num_amvr, md_input_ptr->lambda_mv, refi_cur, num_refp_cnt, md_fw_ptr->cur_ptr, md_fw_ptr->refp_ptr, mvp_all, valid_mode, amvr_enable_flag,
			fme_mv_info,
#if ENABLE_BFRAME
			me_mv_dir, mv_dir,
#endif
			sub_pel_mv, skip_mode, Fetch_Ref_window_ptr
#if SUB_TMVP
			, core_sbtmvp, skip_in
#endif
		);

		if (valid_mode[9])
		{
			rdo_list[inter_num[0]] = 9;
			inter_num[0]++;
		}

		//if (valid_mode[4])
		//{
		//	rdo_list[inter_num[0]] = 4;
		//	inter_num[0]++;
		//}

#ifdef MD_CMOD
#else
		for (int mode_index = 0; mode_index < 4; mode_index++)
		{
			if (inter_num[0] >= max_inter)
				break;
			if (valid_mode[mode_index] == 1)
			{
				rdo_list[inter_num[0]] = mode_index;
				inter_num[0]++;
			}
		}
#endif
	}

	if (!(IS_INTER_SLICE(md_fw_ptr->slice_type) && curr_cons_pred_mode == ONLY_INTER))
	{
		prepare_intra_info_8_16(md_fw_ptr, &mod_info_curr_ptr[0],
			IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
			MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
			IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
			cu_width_log2, cu_height_log2, pix_x, pix_y, sub_x, sub_y, ipred_list, pred_cnt, src_le_temp, src_up_temp, avail_tb, rmd_mode
#if USE_SPEED_LEVEL
			, md_input_ptr->speed_level
#endif
		);
#if USE_SPEED_LEVEL
		if (md_input_ptr->speed_level == 1)
			max_rdo_num = IPD_RDO_CNT;
		else if (md_input_ptr->speed_level == 2)
			max_rdo_num = EXTRA_RDO_MODE;
		else
			max_rdo_num = IPD_RDO_CNT + EXTRA_RDO_MODE;

#endif
		intra_num[0] = avs3_min(pred_cnt[0], (int)(max_rdo_num - inter_num[0]));
		for (int intra_index = 0; intra_index < 5; intra_index++)
		{
#pragma HLS UNROLL
			if (intra_index < intra_num[0])
				rdo_list[inter_num[0] + intra_index] = all_inter_mode_num + intra_index;
		}
	}
}
void rdo_prepare_16_8(MD_FW* md_fw_ptr,
	ENC_ME_LINE_MAP_SIZE<16>* me_line_map_ptr_16,
	ENC_ME_NEB_INFO up_nebs[1 + (16 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(16 >> 2)],
	SKIP_MERGE_INPUT_16* skip_in_16,
	MD_COM_MODE* mod_info_curr_ptr,
	MERGE_RDO* merge_rdo, MD_INPUT* md_input_ptr,
	U1 valid_mode[17], U1 amvr_enable_flag,
	ENC_FME_INFO_ALL_16* fme_mv_info,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>* MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>* MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>* MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8,
	U3 cu_width_log2, U3 cu_height_log2,
	u8 ipred_list[IPRED_LIST_NUM], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16* avail_tb, u8 rmd_mode[IPRED_LIST_NUM],
	U3 qt_depth, U5 all_inter_mode_num,
	U7 cu_width, U7 cu_height,
#if ENABLE_BFRAME
	ME_MV_DIR_16* me_mv_dir, MV_DIR* mv_dir,
#endif
	/*COM_PART_INFO* mod_info_curr_pb_info, */pel* org_y,
	U2 tree_status, u8 curr_cons_pred_mode,
	u8 inter_num[1], u8 intra_num[1], u8 rdo_list[MAX_RDO_NUM_SIZE(16, 8)], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], SKIP_RDO* skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2], strFetch_ref_window_16* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, SKIP_MERGE_INPUT* skip_in
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0
	s8 refi_cur = 0;
	U3 max_rdo_num = MAX_RDO_NUM_SIZE(16, 8);
	U3 max_inter = 0;
	U14 sub_x = mod_info_curr_ptr[0].x_pos;
	U14 sub_y = mod_info_curr_ptr[0].y_pos;
	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;
	int num_amvr;
	int pred_cnt[1] = { 5 };
#if ENABLE_BFRAME
	s8 num_refp_cnt[REFP_NUM] = { md_fw_ptr->num_refp[0], md_fw_ptr->num_refp[1] };
#else
	u8 num_refp_cnt = md_fw_ptr->num_refp;
#endif

	/*
		if (amvr_enable_flag) {
			num_amvr = 5;
		}
		else */
	{
		num_amvr = 1;
	}

	inter_num[0] = 0;
	intra_num[0] = 0;

	//printf("pos=(%d %d) size=(%d %d) slice=%d cons_pred_mode=%d\n", mod_info_curr_ptr->x_pos, mod_info_curr_ptr->y_pos, cu_width, cu_height, md_fw_ptr->slice_type, curr_cons_pred_mode);
	if (!(md_fw_ptr->slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA)) {
		max_inter = (curr_cons_pred_mode == ONLY_INTER) ? MAX_RDO_NUM_SIZE(16, 8) : MAX_RDO_NUM_INTER_SIZE(16, 8);
		prepare_luma_inter_16_8(md_fw_ptr,
			me_line_map_ptr_16,
			up_nebs, left_nebs, skip_in_16,
			mod_info_curr_ptr,
			skip_rdo, skip_rdo_mode, merge_rdo, md_input_ptr,
			num_amvr, md_input_ptr->lambda_mv, refi_cur, num_refp_cnt, md_fw_ptr->cur_ptr, md_fw_ptr->refp_ptr, mvp_all, valid_mode, amvr_enable_flag,
			fme_mv_info,
#if ENABLE_BFRAME
			me_mv_dir, mv_dir,
#endif
			sub_pel_mv, skip_mode, Fetch_Ref_window_ptr
#if SUB_TMVP
			, core_sbtmvp, skip_in
#endif
		);

		if (valid_mode[9])
		{
			rdo_list[inter_num[0]] = 9;
			inter_num[0]++;
		}

		//if (valid_mode[4])
		//{
		//	rdo_list[inter_num[0]] = 4;
		//	inter_num[0]++;
		//}

#ifdef MD_CMOD
#else
		for (int mode_index = 0; mode_index < 4; mode_index++)
		{
			if (inter_num[0] >= max_inter)
				break;
			if (valid_mode[mode_index] == 1)
			{
				rdo_list[inter_num[0]] = mode_index;
				inter_num[0]++;
			}
		}
#endif
	}

	if (!(IS_INTER_SLICE(md_fw_ptr->slice_type) && curr_cons_pred_mode == ONLY_INTER))
	{
		prepare_intra_info_16_8(md_fw_ptr, &mod_info_curr_ptr[0],
			IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
			MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
			IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
			cu_width_log2, cu_height_log2, pix_x, pix_y, sub_x, sub_y, ipred_list, pred_cnt, src_le_temp, src_up_temp, avail_tb, rmd_mode
#if USE_SPEED_LEVEL
			, md_input_ptr->speed_level
#endif
		);
#if USE_SPEED_LEVEL
		if (md_input_ptr->speed_level == 1)
			max_rdo_num = IPD_RDO_CNT;
		else if (md_input_ptr->speed_level == 2)
			max_rdo_num = EXTRA_RDO_MODE;
		else
			max_rdo_num = IPD_RDO_CNT + EXTRA_RDO_MODE;

#endif
		intra_num[0] = avs3_min(pred_cnt[0], (int)(max_rdo_num - inter_num[0]));
		for (int intra_index = 0; intra_index < 5; intra_index++)
		{
#pragma HLS UNROLL
			if (intra_index < intra_num[0])
				rdo_list[inter_num[0] + intra_index] = all_inter_mode_num + intra_index;
		}
	}
}
void rdo_prepare_16_16(MD_FW* md_fw_ptr,
	ENC_ME_LINE_MAP_SIZE<16>* me_line_map_ptr_16,
	ENC_ME_NEB_INFO up_nebs[1 + (16 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(16 >> 2)],
	SKIP_MERGE_INPUT_16* skip_in_16,
	MD_COM_MODE* mod_info_curr_ptr,
	MERGE_RDO* merge_rdo, MD_INPUT* md_input_ptr,
	U1 valid_mode[17], U1 amvr_enable_flag,
	ENC_FME_INFO_ALL_16* fme_mv_info,
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>* MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>* MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>* MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>* IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>* IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>* IP_map_scu_ptr_16x8,
	U3 cu_width_log2, U3 cu_height_log2,
	u8 ipred_list[IPRED_LIST_NUM], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16* avail_tb, u8 rmd_mode[IPRED_LIST_NUM],
	U3 qt_depth, U5 all_inter_mode_num,
	U7 cu_width, U7 cu_height,
#if ENABLE_BFRAME
	ME_MV_DIR_16* me_mv_dir, MV_DIR* mv_dir,
#endif
	/*COM_PART_INFO* mod_info_curr_pb_info, */pel* org_y,
	U2 tree_status, u8 curr_cons_pred_mode,
	u8 inter_num[1], u8 intra_num[1], u8 rdo_list[IPRED_LIST_NUM], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], SKIP_RDO* skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2], strFetch_ref_window_16* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, SKIP_MERGE_INPUT* skip_in
#endif
)
{
#pragma HLS   ARRAY_PARTITION variable=	valid_mode complete dim=0

#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0
	s8 refi_cur = 0;
	U3 max_rdo_num = MD_MAX_RDO_NUM;
	U3 max_inter = 0;
	U14 sub_x = mod_info_curr_ptr[0].x_pos;
	U14 sub_y = mod_info_curr_ptr[0].y_pos;
	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;
	int num_amvr;
	int pred_cnt[1] = { 5 };
#if ENABLE_BFRAME
	s8 num_refp_cnt[REFP_NUM] = { md_fw_ptr->num_refp[0], md_fw_ptr->num_refp[1] };
#else
	u8 num_refp_cnt = md_fw_ptr->num_refp;
#endif

	/*
		if (amvr_enable_flag) {
			num_amvr = 5;
		}
		else */
	{
		num_amvr = 1;
	}

	//	inter_num[0] = 0;
	//	intra_num[0] = 0;
	int inter_num_tmp = 0;
#if !SIMPLE_MD
	//printf("pos=(%d %d) size=(%d %d) slice=%d cons_pred_mode=%d\n", mod_info_curr_ptr->x_pos, mod_info_curr_ptr->y_pos, cu_width, cu_height, md_fw_ptr->slice_type, curr_cons_pred_mode);
	if (!(md_fw_ptr->slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA)) {
		max_inter = (curr_cons_pred_mode == ONLY_INTER) ? MD_MAX_RDO_NUM : MD_MAX_RDO_NUM_INTER;
		prepare_luma_inter_16_16(md_fw_ptr,
			me_line_map_ptr_16,
			up_nebs, left_nebs, skip_in_16,
			mod_info_curr_ptr,
			skip_rdo, skip_rdo_mode, merge_rdo, md_input_ptr,
			num_amvr, md_input_ptr->lambda_mv, refi_cur, num_refp_cnt, md_fw_ptr->cur_ptr, md_fw_ptr->refp_ptr, mvp_all, valid_mode, amvr_enable_flag,
			fme_mv_info,
#if ENABLE_BFRAME
			me_mv_dir, mv_dir,
#endif
			sub_pel_mv, skip_mode, Fetch_Ref_window_ptr
#if SUB_TMVP
			, core_sbtmvp, skip_in
#endif
		);

	/*	if (valid_mode[9])
		{
			rdo_list[inter_num[0]] = 9;
			inter_num[0]++;
		}

		//if (valid_mode[4])
		//{
		//	rdo_list[inter_num[0]] = 4;
		//	inter_num[0]++;
		//}

#ifdef MD_CMOD
#else
		for (int mode_index = 0; mode_index < 4; mode_index++)
		{
			if (inter_num[0] >= max_inter)
				break;
			if (valid_mode[mode_index] == 1)
			{
				rdo_list[inter_num[0]] = mode_index;
				inter_num[0]++;
			}
		}
#endif*/
		int valid_num = valid_mode[9] + valid_mode[0] + valid_mode[1] + valid_mode[2] + valid_mode[3];
		inter_num_tmp = valid_num >= max_inter ? max_inter : valid_num;
		inter_num[0] = inter_num_tmp;
		//			int rdo_list[5];

		int k = 0;
		if (valid_mode[9])
		{
			rdo_list[k] = 9;
			k++;
		}
#ifdef MD_CMOD
#else
		for (int mode_index = 0; mode_index < 4; mode_index++)
		{
#pragma HLS UNROLL
			if (valid_mode[mode_index])
			{
				rdo_list[k] = mode_index;
				k++;
			}
		}
#endif
	}
#endif
	if (!(IS_INTER_SLICE(md_fw_ptr->slice_type) && curr_cons_pred_mode == ONLY_INTER))
	{
		prepare_intra_info_16_16(md_fw_ptr, &mod_info_curr_ptr[0],
			IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
			MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
			IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
			cu_width_log2, cu_height_log2, pix_x, pix_y, sub_x, sub_y, ipred_list, pred_cnt, src_le_temp, src_up_temp, avail_tb, rmd_mode
#if USE_SPEED_LEVEL
			, md_input_ptr->speed_level
#endif
		);
#if USE_SPEED_LEVEL
		if (md_input_ptr->speed_level == 1)
			max_rdo_num = IPD_RDO_CNT;
		else if (md_input_ptr->speed_level == 2)
			max_rdo_num = EXTRA_RDO_MODE;
		else
			max_rdo_num = IPD_RDO_CNT + EXTRA_RDO_MODE;

#endif
		intra_num[0] = avs3_min(pred_cnt[0], (int)(max_rdo_num - inter_num_tmp));
		for (int intra_index = 0; intra_index < 5; intra_index++)
		{
#pragma HLS UNROLL
			if (intra_index < intra_num[0])
				rdo_list[inter_num_tmp + intra_index] = all_inter_mode_num + intra_index;
		}
	}
}

static void intra_inter_pred_8_16(U7 w, U7 h, u8* curr_mvr_rate,
	MD_KERNEL_MODE* mod_info_nz, s16* orgY,
	u8* mode_type_nz, u8* mode_type_rate, s8* inter_mode_idx,
	s16 coef_tmp[16][16], U1* valid_flag, U1 valid_mode[17], 
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[16][16], pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(8, 16) - 1][16][16], pel pred_y_intra[MAX_RDO_NUM_SIZE(8, 16)][16][16],
	pel pred_cache_ith[16][16],  pel pred_cache_for_diff[16][16],
	/*u8 num_refp_cnt,*/ u8* num_refp_for_diff, u8* num_refp_for_rate,
	U1* is_intra_quant, u8 intra_mode_list[IPRED_LIST_NUM], pel src_le_temp[16 * 2 + 3], pel src_up_temp[16 * 2 + 3], u16 avail_tb, u8 rdo_list[MAX_RDO_NUM_SIZE(8, 16)],
	u8 rdo_idx, u8 inter_rdo_num,
	MD_FW* md_fw_ptr,
	SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo,
	U3 cu_width_log2, U3 cu_height_log2, U2 tree_status, U2 curr_cons_pred_mode,
	S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2],
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
	S8 mod_info_ipm_for_rate[4][2], u8 mod_info_mpm_for_rate[4][2], S8 mod_info_ipm_for_up[4][2], u8 mod_info_mpm_for_up[4][2],
	S3 mod_info_refi_for_diff[2], S3 mod_info_refi_for_rate[2], S3 mod_info_refi_for_up[2],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR* mv_dir, strFetch_ref_window_16* Fetch_Ref_window_ptr,
#endif // ENABLE_BFRAME
	//pel fme2mdrefbuf[2560][8][2][16],
	MD_KERNEL_INPUT* md_kernel_input, u8 mpm[MAX_NUM_PB][2], u8* iQuant
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_SPEED_LEVEL
	, U8 speed_level
#endif

)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mv core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_nz
#pragma HLS INTERFACE axis port=mode_type_rate
#pragma HLS INTERFACE axis port=inter_mode_idx
#pragma HLS RESOURCE variable=coef_tmp core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=valid_flag
#pragma HLS RESOURCE variable=valid_mode core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=is_intra_quant
#pragma HLS RESOURCE variable=src_le_temp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=src_up_temp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdo_list core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=RefWindowLCU core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=CtrPos core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=CtrPosFME core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->pmv_cands core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->refi_cands core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->mode_list core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->valid core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->skip_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->skip_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->affine_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->mvp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->refi core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_refi core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_cp_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_cp_num core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->valid core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=sub_pel_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mvp_all core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=refwin_md core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=iQuant
#endif

#pragma HLS ARRAY_PARTITION variable=orgY  complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_le_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_nz complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_for_diff complete dim=2

	// STRAM BUFFER
	s8 inter_mode_idx_write;
	u8 curr_mvr_write = 0;
	u8 mode_type_write = 0;
	U1 valid_flag_write = 0;
	U1 is_intra_write;
	MD_KERNEL_MODE mode_info_write;

	// CORE LOGIC
	inter_mode_idx_write = rdo_list[rdo_idx];
	static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
	static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
	s8 intra_mode_idx;
#if USE_SPEED_LEVEL
	int extra_intra = 0;
	if (speed_level == 1)
		extra_intra = 0;
	else if (speed_level == 2)
		extra_intra = 5;
	else
		extra_intra = 10;
#else
	int extra_intra = 0;
#endif

	if (inter_mode_idx_write >= 17)
	{
		is_intra_write = 1;
		intra_mode_idx = intra_mode_list[inter_mode_idx_write - 17];
		inter_mode_idx_write = -1;
	}
	else
	{
		is_intra_write = 0;
		intra_mode_idx = 0;
	}

	if (is_intra_write == 0) {

		//valid_flag_write = valid_mode[inter_mode_idx_write];

		/*if (valid_flag_write == 1) */{
			mode_type_write = mode_type_table[inter_mode_idx_write];
			curr_mvr_write = curr_mvr_table[inter_mode_idx_write];
			//inter_mode_idx -= 9;
		}

		if (inter_mode_idx_write >= 0)
		{
			static s16 mv_all[2][5][2];
			static int best_mv_uni_inner[2][4][2];
			
#if ENABLE_BFRAME
			//num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
			*num_refp_for_diff = md_fw_ptr->num_refp[mv_dir->lidx];
			*num_refp_for_rate = md_fw_ptr->num_refp[mv_dir->lidx];
#else
			//num_refp_cnt = md_fw_ptr->num_refp;
			*num_refp_for_diff = md_fw_ptr->num_refp;
			*num_refp_for_rate = md_fw_ptr->num_refp;
#endif
			int refi_cur = 0;
			//if (valid_flag_write == 1)
			{
				int pic_height = md_fw_ptr->pic_height_in_scu << 2;
				int pic_width = md_fw_ptr->pic_width_in_scu << 2;
				if (mode_type_write == 1)
				{
					mode_info_write.cu_mode = 1;
					mode_info_write.affine_flag = 0;
					init_inter_data_8_16(&mode_info_write, md_fw_ptr->pic_width_in_scu);
					//for (int i = 0; i < 2; i++) {
					//	for (int j = 0; j < 2; j++) {
					//		mode_info_write.mv[i][j] = 0;
					//		mode_info_write.mvd[i][j] = 0;
					//	}
					//}
#if ENABLE_BFRAME
					U1 lidx = mv_dir->lidx;
#else
					U1 lidx = 0;
#endif
					mode_info_write.mv[lidx][0] = mv_copy[lidx][0];
					mode_info_write.mv[lidx][1] = mv_copy[lidx][1];
					mode_info_write.mvd[lidx][0] = mvd_copy[lidx][0];
					mode_info_write.mvd[lidx][1] = mvd_copy[lidx][1];
					mode_info_write.refi[0] = refi_copy[0];
					mode_info_write.refi[1] = refi_copy[1];
				}
				else if (mode_type_write == 2)
				{
#if MD_PRINT
					__assert_HLS("affine is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4550, __FUNCTION__);
#endif
				}
				else if (mode_type_write == 0)
				{
#ifdef MD_CMOD
#if MD_PRINT
					__assert_HLS("skip is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4672, __FUNCTION__);
#endif
#else
					//make_skip_resi_8_16(inter_mode_idx_write, skip_rdo, skip_rdo_mode, merge_rdo, &mode_info_write, pic_width, pic_height,
					//	cu_width_log2, cu_height_log2, orgY, 64, w, h, md_fw_ptr->bit_depth_internal);
					derive_mode_info(inter_mode_idx_write, skip_rdo, skip_rdo_mode, merge_rdo, &mode_info_write);
#endif 
				}
				//				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };
				//#if ENABLE_BFRAME
				//				if (!REFI_IS_VALID(mode_info_write.refi[REFP_0]) && !REFI_IS_VALID(mode_info_write.refi[REFP_1]))
				//				{
				//					//valid_flag = 0;
				//				}
				//				if (!com_mc_cu_y_16(&cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
				//					SWW, pred_cache_nz, md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr, 
				//					CtrPosSKIP,
				//					CtrPosSKIP_ref1,
				//					fme2mdrefbuf
				//					, mode_type_write == 1 ? MODE_INTER : MODE_DIR
				//#if SUB_TMVP
				//					, core_sbtmvp, mode_info_write.skip_idx, mode_info_write.umve_flag
				//#endif
				//				))
				//				{
				//					//valid_flag_write = 0;
				//				}
				//#else
				//				if (!com_mc_y_16(mode_type_write, &cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
				//					SWW, pred_cache_nz, md_fw_ptr->bit_depth_internal, tree_status,
				//					CtrPosSKIP, fme2mdrefbuf
				//					))
				//				{
				//					valid_flag_write = 0;
				//				}
				//#endif

				if (mode_type_write == 1 || mode_type_write == 0)
				{
					if (mode_type_write == 1) {
						enc_diff_16b_8_16(cu_width_log2, cu_height_log2, orgY, pred_y_inter1, 16, w, h, coef_tmp);
					}
					else {
						enc_diff_16b_8_16(cu_width_log2, cu_height_log2, orgY, pred_y_inter2[rdo_idx - 1], 16, w, h, coef_tmp);
					}
					mode_info_write.tb_part = ((int)SIZE_2Nx2N);
				}
			}
		}
	}
	else
	{

		//		if (intra_mode_idx == 12)
		//			Ipred_vert_16(w, h, src_up_temp + 3, orgY, pred_cache_nz, coef_tmp);
		//		else if (intra_mode_idx == 24)
		//			Ipred_hor_16(w, h, src_le_temp + 3, orgY, pred_cache_nz, coef_tmp);
		//		else if (intra_mode_idx == 0)
		//			Ipred_dc_16(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, avail_tb, orgY, pred_cache_nz, coef_tmp);
		//		else if (intra_mode_idx == 1)
		//			Ipred_plane_16(w, h, src_le_temp + 2, src_up_temp + 2, md_fw_ptr->bit_depth_internal, orgY, pred_cache_nz, coef_tmp);
		//		else if (intra_mode_idx == 2)
		//			Ipred_bi_16(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, orgY, pred_cache_nz, coef_tmp);
		//		else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
		//			ipred_ang1_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
		//#if MIPF
		//				, 1, md_fw_ptr->mipf_enable_flag
		//#endif
		//			);
		//		else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
		//			ipred_ang2_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
		//#if MIPF
		//				, 1, md_fw_ptr->mipf_enable_flag
		//#endif
		//			);
		//		else
		//
		//		{
		//#if EIPM
		//			if (intra_mode_idx > 33)
		//			{
		//				ipred_ang_eipm_16(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
		//#if MIPF
		//					, 1, md_fw_ptr->mipf_enable_flag, md_fw_ptr->bit_depth_internal, coef_tmp, pred_cache_nz, orgY
		//#endif
		//				);
		//			/*static pel pred_1d[256] = { 0 };
		//			memset(pred_1d, 0, sizeof(pel) * 256);
		//
		//			if (intra_mode_idx > 33)
		//			{
		//				ipred_ang_eipm(src_le_temp + 3, src_up_temp + 3, pred_1d, w, h, intra_mode_idx
		//#if MIPF
		//					, 1, md_fw_ptr->mipf_enable_flag
		//#endif
		//				);
		//
		//				clip_pred(pred_1d, w, h, md_fw_ptr->bit_depth_internal);
		//
		//				for (int i = 0; i < 16; i++)
		//				{
		//					if (i < h)
		//					{
		//						for (int j = 0; j < 16; j++)
		//						{
		//							if (j < w)
		//							{
		//								coef_tmp[i][j] = orgY[(i * 16) + j] - pred_1d[(i * w) + j];
		//								pred_cache_nz[i][j] = pred_1d[(i * w) + j];
		//							}
		//						}
		//					}
		//				}*/
		//			}
		//			else
		//#endif
		//				ipred_ang3_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
		//#if MIPF
		//					, 1, md_fw_ptr->mipf_enable_flag
		//#endif
		//				);
		//		}

		Ipred_8_16_diff(w, h, orgY, pred_y_intra[rdo_idx], coef_tmp);

			mode_info_write.cu_mode = 0;
			mode_info_write.ipm[0][0] = intra_mode_idx;
			mode_info_write.ipm[0][1] = -1;
#if USE_ROI_MODE_CONFIG
		}
#endif
		//valid_flag_write = 1;
	}

	// WRITE STREAMS
	*inter_mode_idx = inter_mode_idx_write;
	*curr_mvr_rate = curr_mvr_write;
	*mode_type_nz = mode_type_write;
	*mode_type_rate = mode_type_write;
	*valid_flag = valid_flag_write;
	*is_intra_quant = is_intra_write;
#pragma HLS ARRAY_PARTITION variable=mod_info_ipm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mpm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.ipm complete dim=0
#pragma HLS ARRAY_PARTITION variable=mpm complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.affine_mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.affine_mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->affine_mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->affine_mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_diff complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_up complete dim=0
	if (is_intra_write == 1) {
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS PIPELINE
			for (int j = 0; j < 16; ++j)
			{
				pred_cache_ith[i][j] = pred_y_intra[rdo_idx][i][j];
				pred_cache_for_diff[i][j] = pred_y_intra[rdo_idx][i][j];
				
			}
		}
	}
	else if (mode_type_write == 1)
	{
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS PIPELINE
			for (int j = 0; j < 16; ++j)
			{
				pred_cache_ith[i][j] = pred_y_inter1[i][j];
				pred_cache_for_diff[i][j] = pred_y_inter1[i][j];
				
			}
		}
	}
	else if (mode_type_write == 0)
	{
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS PIPELINE
			for (int j = 0; j < 16; ++j)
			{
				pred_cache_ith[i][j] = pred_y_inter2[rdo_idx - 1][i][j];
				pred_cache_for_diff[i][j] = pred_y_inter2[rdo_idx - 1][i][j];
			}
			//pred_cache_for_diff[i][j] = pred_cache_ith[i][j];
		}
	}
	mod_info_nz->cu_mode = mode_info_write.cu_mode;
	mod_info_nz->affine_flag = mode_info_write.affine_flag;
	for (int i = 0; i < REFP_NUM; ++i)
	{
#pragma HLS UNROLL
		for (int j = 0; j < MV_D; ++j)
		{
#pragma HLS UNROLL
			mod_info_nz->mvd[i][j] = mode_info_write.mvd[i][j];
			mod_info_nz->mv[i][j] = mode_info_write.mv[i][j];
			for (int k = 0; k < VER_NUM; ++k)
			{
				mod_info_nz->affine_mv[i][k][j] = mode_info_write.affine_mv[i][k][j];
				mod_info_nz->affine_mvd[i][k][j] = mode_info_write.affine_mvd[i][k][j];
			}
		}
		mod_info_nz->refi[i] = mode_info_write.refi[i];
		mod_info_refi_for_diff[i] = mode_info_write.refi[i];
		mod_info_refi_for_rate[i] = mode_info_write.refi[i];
		mod_info_refi_for_up[i] = mode_info_write.refi[i];
	}
	mod_info_nz->skip_idx = mode_info_write.skip_idx;
	mod_info_nz->smvd_flag = mode_info_write.smvd_flag;
	mod_info_nz->umve_flag = mode_info_write.umve_flag;
	mod_info_nz->umve_idx = mode_info_write.umve_idx;
	for (int i = 0; i < MAX_NUM_PB; ++i)
	{
#pragma HLS UNROLL
		for (int j = 0; j < 2; ++j)
		{
#pragma HLS UNROLL
			mod_info_ipm_for_rate[i][j] = mode_info_write.ipm[i][j];
			mod_info_mpm_for_rate[i][j] = mpm[i][j];
			mod_info_ipm_for_up[i][j] = mode_info_write.ipm[i][j];
			mod_info_mpm_for_up[i][j] = mpm[i][j];
			mod_info_nz->ipm[i][j] = mode_info_write.ipm[i][j];
			mod_info_nz->mpm[i][j] = mpm[i][j];
		}
	}
	mod_info_nz->tb_part = mode_info_write.tb_part;
	mod_info_nz->pb_part = 0;
	*iQuant = rdo_idx;
}
static void intra_inter_pred_16_8(U7 w, U7 h, u8* curr_mvr_rate,
	MD_KERNEL_MODE* mod_info_nz, s16* orgY,
	u8* mode_type_nz, u8* mode_type_rate, s8* inter_mode_idx,
	s16 coef_tmp[16][16], U1* valid_flag, U1 valid_mode[17], 
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[16][16], pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(16, 8) - 1][16][16], pel pred_y_intra[MAX_RDO_NUM_SIZE(16, 8)][16][16],
	pel pred_cache_ith[16][16], pel pred_cache_for_diff[16][16],
	/*u8 num_refp_cnt,*/ u8* num_refp_for_diff, u8* num_refp_for_rate,
	U1* is_intra_quant, u8 intra_mode_list[IPRED_LIST_NUM], pel src_le_temp[16 * 2 + 3], pel src_up_temp[16 * 2 + 3], u16 avail_tb, u8 rdo_list[MAX_RDO_NUM_SIZE(16, 8)],
	u8 rdo_idx, u8 inter_rdo_num,
	MD_FW* md_fw_ptr,
	SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo,
	U3 cu_width_log2, U3 cu_height_log2, U2 tree_status, U2 curr_cons_pred_mode,
	S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2],
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
	S8 mod_info_ipm_for_rate[4][2], u8 mod_info_mpm_for_rate[4][2], S8 mod_info_ipm_for_up[4][2], u8 mod_info_mpm_for_up[4][2],
	S3 mod_info_refi_for_diff[2], S3 mod_info_refi_for_rate[2], S3 mod_info_refi_for_up[2],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR* mv_dir, strFetch_ref_window_16* Fetch_Ref_window_ptr,
#endif // ENABLE_BFRAME
	//pel fme2mdrefbuf[2560][8][2][16],
	MD_KERNEL_INPUT* md_kernel_input, u8 mpm[MAX_NUM_PB][2], u8* iQuant
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_SPEED_LEVEL
	, U8 speed_level
#endif

)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mv core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_nz
#pragma HLS INTERFACE axis port=mode_type_rate
#pragma HLS INTERFACE axis port=inter_mode_idx
#pragma HLS RESOURCE variable=coef_tmp core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=valid_flag
#pragma HLS RESOURCE variable=valid_mode core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=is_intra_quant
#pragma HLS RESOURCE variable=src_le_temp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=src_up_temp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdo_list core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=RefWindowLCU core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=CtrPos core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=CtrPosFME core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->pmv_cands core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->refi_cands core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->mode_list core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->valid core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->skip_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->skip_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->affine_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->mvp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->refi core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_refi core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_cp_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_cp_num core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->valid core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=sub_pel_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mvp_all core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=refwin_md core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=iQuant
#endif

#pragma HLS ARRAY_PARTITION variable=orgY  complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_le_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_nz complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_for_diff complete dim=2

	// STRAM BUFFER
	s8 inter_mode_idx_write;
	u8 curr_mvr_write = 0;
	u8 mode_type_write = 0;
	U1 valid_flag_write = 0;
	U1 is_intra_write;
	MD_KERNEL_MODE mode_info_write;

	// CORE LOGIC
	inter_mode_idx_write = rdo_list[rdo_idx];
	static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
	static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
	s8 intra_mode_idx;
#if USE_SPEED_LEVEL
	int extra_intra = 0;
	if (speed_level == 1)
		extra_intra = 0;
	else if (speed_level == 2)
		extra_intra = 5;
	else
		extra_intra = 10;
#else
	int extra_intra = 0;
#endif

	if (inter_mode_idx_write >= 17)
	{
		is_intra_write = 1;
		intra_mode_idx = intra_mode_list[inter_mode_idx_write - 17];
		inter_mode_idx_write = -1;
	}
	else
	{
		is_intra_write = 0;
		intra_mode_idx = 0;
	}

	if (is_intra_write == 0) {

		//valid_flag_write = valid_mode[inter_mode_idx_write];

		/*if (valid_flag_write == 1) */ {
			mode_type_write = mode_type_table[inter_mode_idx_write];
			curr_mvr_write = curr_mvr_table[inter_mode_idx_write];
			//inter_mode_idx -= 9;
		}

		if (inter_mode_idx_write >= 0)
		{
			static s16 mv_all[2][5][2];
			static int best_mv_uni_inner[2][4][2];

#if ENABLE_BFRAME
			//num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
			*num_refp_for_diff = md_fw_ptr->num_refp[mv_dir->lidx];
			*num_refp_for_rate = md_fw_ptr->num_refp[mv_dir->lidx];
#else
			//num_refp_cnt = md_fw_ptr->num_refp;
			*num_refp_for_diff = md_fw_ptr->num_refp;
			*num_refp_for_rate = md_fw_ptr->num_refp;
#endif
			int refi_cur = 0;
			//if (valid_flag_write == 1)
			{
				int pic_height = md_fw_ptr->pic_height_in_scu << 2;
				int pic_width = md_fw_ptr->pic_width_in_scu << 2;
				if (mode_type_write == 1)
				{

					mode_info_write.cu_mode = 1;
					mode_info_write.affine_flag = 0;
					init_inter_data_16_8(&mode_info_write, md_fw_ptr->pic_width_in_scu);
					//for (int i = 0; i < 2; i++) {
					//	for (int j = 0; j < 2; j++) {
					//		mode_info_write.mv[i][j] = 0;
					//		mode_info_write.mvd[i][j] = 0;
					//	}
					//}
#if ENABLE_BFRAME
					U1 lidx = mv_dir->lidx;
#else
					U1 lidx = 0;
#endif
					mode_info_write.mv[lidx][0] = mv_copy[lidx][0];
					mode_info_write.mv[lidx][1] = mv_copy[lidx][1];
					mode_info_write.mvd[lidx][0] = mvd_copy[lidx][0];
					mode_info_write.mvd[lidx][1] = mvd_copy[lidx][1];
					mode_info_write.refi[0] = refi_copy[0];
					mode_info_write.refi[1] = refi_copy[1];
				}
				else if (mode_type_write == 2)
				{
#if MD_PRINT
					__assert_HLS("affine is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4550, __FUNCTION__);
#endif
				}
				else if (mode_type_write == 0)
				{
#ifdef MD_CMOD
#if MD_PRINT
					__assert_HLS("skip is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4672, __FUNCTION__);
#endif
#else
					//make_skip_resi_16_8(inter_mode_idx_write, skip_rdo, skip_rdo_mode, merge_rdo, &mode_info_write, pic_width, pic_height,
					//	cu_width_log2, cu_height_log2, orgY, 64, w, h, md_fw_ptr->bit_depth_internal);
					derive_mode_info(inter_mode_idx_write, skip_rdo, skip_rdo_mode, merge_rdo, &mode_info_write);
#endif 
				}
				//				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };
				//#if ENABLE_BFRAME
				//				if (!REFI_IS_VALID(mode_info_write.refi[REFP_0]) && !REFI_IS_VALID(mode_info_write.refi[REFP_1]))
				//				{
				//					//valid_flag = 0;
				//				}
				//				if (!com_mc_cu_y_16(&cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
				//					SWW, pred_cache_nz, md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr, 
				//					CtrPosSKIP,
				//					CtrPosSKIP_ref1,
				//					fme2mdrefbuf
				//					, mode_type_write == 1 ? MODE_INTER : MODE_DIR
				//#if SUB_TMVP
				//					, core_sbtmvp, mode_info_write.skip_idx, mode_info_write.umve_flag
				//#endif
				//				))
				//				{
				//					//valid_flag_write = 0;
				//				}
				//#else
				//				if (!com_mc_y_16(mode_type_write, &cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
				//					SWW, pred_cache_nz, md_fw_ptr->bit_depth_internal, tree_status,
				//					CtrPosSKIP, fme2mdrefbuf
				//					))
				//				{
				//					valid_flag_write = 0;
				//				}
				//#endif

				if (mode_type_write == 1 || mode_type_write == 0)
				{
					/*if (mode_type_write == 1) {
						enc_diff_16b_16_8(cu_width_log2, cu_height_log2, orgY, pred_y_inter1, 16, w, h, coef_tmp);
					}
					else {
						enc_diff_16b_16_8(cu_width_log2, cu_height_log2, orgY, pred_y_inter2[rdo_idx - 1], 16, w, h, coef_tmp);
					}*/
					mode_info_write.tb_part = ((int)SIZE_2Nx2N);
				}
			}
		}
	}
	else
	{

			//		if (intra_mode_idx == 12)
			//			Ipred_vert_16(w, h, src_up_temp + 3, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 24)
			//			Ipred_hor_16(w, h, src_le_temp + 3, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 0)
			//			Ipred_dc_16(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, avail_tb, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 1)
			//			Ipred_plane_16(w, h, src_le_temp + 2, src_up_temp + 2, md_fw_ptr->bit_depth_internal, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 2)
			//			Ipred_bi_16(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
			//			ipred_ang1_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
			//#if MIPF
			//				, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//			);
			//		else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
			//			ipred_ang2_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
			//#if MIPF
			//				, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//			);
			//		else
			//
			//		{
			//#if EIPM
			//			if (intra_mode_idx > 33)
			//			{
			//				ipred_ang_eipm_16(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
			//#if MIPF
			//					, 1, md_fw_ptr->mipf_enable_flag, md_fw_ptr->bit_depth_internal, coef_tmp, pred_cache_nz, orgY
			//#endif
			//				);
			//			/*static pel pred_1d[256] = { 0 };
			//			memset(pred_1d, 0, sizeof(pel) * 256);
			//
			//			if (intra_mode_idx > 33)
			//			{
			//				ipred_ang_eipm(src_le_temp + 3, src_up_temp + 3, pred_1d, w, h, intra_mode_idx
			//#if MIPF
			//					, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//				);
			//
			//				clip_pred(pred_1d, w, h, md_fw_ptr->bit_depth_internal);
			//
			//				for (int i = 0; i < 16; i++)
			//				{
			//					if (i < h)
			//					{
			//						for (int j = 0; j < 16; j++)
			//						{
			//							if (j < w)
			//							{
			//								coef_tmp[i][j] = orgY[(i * 16) + j] - pred_1d[(i * w) + j];
			//								pred_cache_nz[i][j] = pred_1d[(i * w) + j];
			//							}
			//						}
			//					}
			//				}*/
			//			}
			//			else
			//#endif
			//				ipred_ang3_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
			//#if MIPF
			//					, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//				);
			//		}

			//Ipred_16_8_diff(w, h, orgY, pred_y_intra[rdo_idx], coef_tmp);

			mode_info_write.cu_mode = 0;
			mode_info_write.ipm[0][0] = intra_mode_idx;
			mode_info_write.ipm[0][1] = -1;
#if USE_ROI_MODE_CONFIG
		}
#endif
		//valid_flag_write = 1;
	}

	// WRITE STREAMS
	*inter_mode_idx = inter_mode_idx_write;
	*curr_mvr_rate = curr_mvr_write;
	*mode_type_nz = mode_type_write;
	*mode_type_rate = mode_type_write;
	*valid_flag = valid_flag_write;
	*is_intra_quant = is_intra_write;
#pragma HLS ARRAY_PARTITION variable=mod_info_ipm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mpm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.ipm complete dim=0
#pragma HLS ARRAY_PARTITION variable=mpm complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_y_intra complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred_y_inter1 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_inter2 complete dim=3
	if (is_intra_write == 1) {
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS PIPELINE
			for (int j = 0; j < 16; ++j)
			{
				pred_cache_ith[i][j] = pred_y_intra[rdo_idx][i][j];
				pred_cache_for_diff[i][j] = pred_y_intra[rdo_idx][i][j];
				coef_tmp[i][j] = ((s16)(((int)orgY[j + i * 16]) - ((int)pred_y_intra[rdo_idx][i][j])));
			}
		}
	}
	else if (mode_type_write == 1)
	{
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS PIPELINE
			for (int j = 0; j < 16; ++j)
			{
				pred_cache_ith[i][j] = pred_y_inter1[i][j];
				pred_cache_for_diff[i][j] = pred_y_inter1[i][j];
				coef_tmp[i][j] = ((s16)(((int)orgY[j + i * 16]) - ((int)pred_y_inter1[i][j])));
			}
		}
	}
	else if (mode_type_write == 0)
	{
		for (int i = 0; i < 16; ++i)
		{
#pragma HLS PIPELINE
			for (int j = 0; j < 16; ++j)
			{
				pred_cache_ith[i][j] = pred_y_inter2[rdo_idx - 1][i][j];
				pred_cache_for_diff[i][j] = pred_y_inter2[rdo_idx - 1][i][j];
				coef_tmp[i][j] = ((s16)(((int)orgY[j + i * 16]) - ((int)pred_y_inter2[rdo_idx - 1][i][j])));
			}
			//pred_cache_for_diff[i][j] = pred_cache_ith[i][j];
		}
	}
#pragma HLS ARRAY_PARTITION variable=mode_info_write.mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.affine_mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.affine_mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->affine_mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->affine_mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_diff complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_up complete dim=0

	mod_info_nz->cu_mode = mode_info_write.cu_mode;
	mod_info_nz->affine_flag = mode_info_write.affine_flag;
	for (int i = 0; i < REFP_NUM; ++i)
	{
#pragma HLS UNROLL
		for (int j = 0; j < MV_D; ++j)
		{
#pragma HLS UNROLL
			mod_info_nz->mvd[i][j] = mode_info_write.mvd[i][j];
			mod_info_nz->mv[i][j] = mode_info_write.mv[i][j];
			for (int k = 0; k < VER_NUM; ++k)
			{
#pragma HLS UNROLL
				mod_info_nz->affine_mv[i][k][j] = mode_info_write.affine_mv[i][k][j];
				mod_info_nz->affine_mvd[i][k][j] = mode_info_write.affine_mvd[i][k][j];
			}
		}
		mod_info_nz->refi[i] = mode_info_write.refi[i];
		mod_info_refi_for_diff[i] = mode_info_write.refi[i];
		mod_info_refi_for_rate[i] = mode_info_write.refi[i];
		mod_info_refi_for_up[i] = mode_info_write.refi[i];
	}
	mod_info_nz->skip_idx = mode_info_write.skip_idx;
	mod_info_nz->smvd_flag = mode_info_write.smvd_flag;
	mod_info_nz->umve_flag = mode_info_write.umve_flag;
	mod_info_nz->umve_idx = mode_info_write.umve_idx;
	for (int i = 0; i < MAX_NUM_PB; ++i)
	{
#pragma HLS UNROLL
		for (int j = 0; j < 2; ++j)
		{
#pragma HLS UNROLL
			mod_info_ipm_for_rate[i][j] = mode_info_write.ipm[i][j];
			mod_info_mpm_for_rate[i][j] = mpm[i][j];
			mod_info_ipm_for_up[i][j] = mode_info_write.ipm[i][j];
			mod_info_mpm_for_up[i][j] = mpm[i][j];
			mod_info_nz->ipm[i][j] = mode_info_write.ipm[i][j];
			mod_info_nz->mpm[i][j] = mpm[i][j];
		}
	}
	mod_info_nz->tb_part = mode_info_write.tb_part;
	mod_info_nz->pb_part = 0;
	*iQuant = rdo_idx;
}
static void intra_inter_pred_16_16(U7 w, U7 h, u8* curr_mvr_rate,
	MD_KERNEL_MODE* mod_info_nz, s16* orgY,
	u8* mode_type_nz, u8* mode_type_rate, s8* inter_mode_idx,
	s16 coef_tmp[16][16], U1* valid_flag, U1 valid_mode[17], 
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[16][16], pel pred_y_inter2[2][16][16], pel pred_y_intra[5][16][16],
	pel pred_cache_ith[16][16], pel pred_cache_for_diff[16][16], s16 coef_tmp_for_th[16][16],
	u8 num_refp_cnt, u8* num_refp_for_diff, u8* num_refp_for_rate,
	U1* is_intra_quant, u8 intra_mode_list[IPRED_LIST_NUM], pel src_le_temp[16 * 2 + 3], pel src_up_temp[16 * 2 + 3], u16 avail_tb, u8 rdo_list[5],
	u8 rdo_idx, u8 inter_rdo_num,
	MD_FW* md_fw_ptr,
	SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo,
	U3 cu_width_log2, U3 cu_height_log2, U2 tree_status, U2 curr_cons_pred_mode,
	S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2],
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
	S8 mod_info_ipm_for_rate[4][2], u8 mod_info_mpm_for_rate[4][2], S8 mod_info_ipm_for_up[4][2], u8 mod_info_mpm_for_up[4][2],
	S3 mod_info_refi_for_diff[2], S3 mod_info_refi_for_rate[2], S3 mod_info_refi_for_up[2],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR* mv_dir, strFetch_ref_window_16* Fetch_Ref_window_ptr,
#endif // ENABLE_BFRAME
	//pel fme2mdrefbuf[2560][8][2][16],
	MD_KERNEL_INPUT* md_kernel_input, u8 mpm[MAX_NUM_PB][2], u8* iQuant
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_SPEED_LEVEL
	, U8 speed_level
#endif

)
{
#if MD_KERNEL_16_INTERFACE
#pragma HLS INTERFACE axis port=mod_info_nz->cu_mode
#pragma HLS INTERFACE axis port=mod_info_nz->affine_flag
#pragma HLS RESOURCE variable=mod_info_nz->mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->mv core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->skip_idx
#pragma HLS INTERFACE axis port=mod_info_nz->smvd_flag
#pragma HLS RESOURCE variable=mod_info_nz->affine_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->affine_mvd core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mod_info_nz->refi core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->umve_flag
#pragma HLS INTERFACE axis port=mod_info_nz->umve_idx
#pragma HLS RESOURCE variable=mod_info_nz->ipm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mod_info_nz->tb_part
#pragma HLS INTERFACE axis port=mod_info_nz->pb_part
#pragma HLS RESOURCE variable=mod_info_nz->mpm core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=orgY core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=mode_type_nz
#pragma HLS INTERFACE axis port=mode_type_rate
#pragma HLS INTERFACE axis port=inter_mode_idx
#pragma HLS RESOURCE variable=coef_tmp core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=valid_flag
#pragma HLS RESOURCE variable=valid_mode core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_nz core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=is_intra_quant
#pragma HLS RESOURCE variable=src_le_temp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=src_up_temp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=rdo_list core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=RefWindowLCU core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=CtrPos core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=CtrPosFME core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->pmv_cands core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->refi_cands core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo->mode_list core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->valid core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->skip_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->skip_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->affine_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->mvp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->refi core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_refi core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_cp_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->mrg_list_cp_num core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=merge_rdo->valid core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=sub_pel_mv core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mvp_all core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=refwin_md core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=mpm core=RAM_1P_BRAM
#pragma HLS INTERFACE axis port=iQuant
#endif

//#pragma HLS ARRAY_PARTITION variable=orgY  complete dim=0
#pragma HLS ARRAY_PARTITION variable=orgY dim=1 cyclic factor=16
#pragma HLS ARRAY_PARTITION variable=src_le_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_nz complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_cache_for_diff complete dim=2

	// STRAM BUFFER
	s8 inter_mode_idx_write;
	u8 curr_mvr_write = 0;
	u8 mode_type_write = 0;
	U1 valid_flag_write = 0;
	U1 is_intra_write;
	MD_KERNEL_MODE mode_info_write;

	// CORE LOGIC
	inter_mode_idx_write = rdo_list[rdo_idx];
	static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
	static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
	s8 intra_mode_idx;
#if USE_SPEED_LEVEL
	int extra_intra = 0;
	if (speed_level == 1)
		extra_intra = 0;
	else if (speed_level == 2)
		extra_intra = 5;
	else
		extra_intra = 10;
#else
	int extra_intra = 0;
#endif

	if (inter_mode_idx_write >= 17)
	{
		is_intra_write = 1;
		intra_mode_idx = intra_mode_list[inter_mode_idx_write - 17];
		inter_mode_idx_write = -1;
	}
	else
	{
		is_intra_write = 0;
		intra_mode_idx = 0;
	}

#if !SIMPLE_MD
	if (is_intra_write == 0) {

		//valid_flag_write = valid_mode[inter_mode_idx_write];

		/*if (valid_flag_write == 1) */ {
			mode_type_write = mode_type_table[inter_mode_idx_write];
			curr_mvr_write = curr_mvr_table[inter_mode_idx_write];
			//inter_mode_idx -= 9;
		}

		if (inter_mode_idx_write >= 0)
		{
			static s16 mv_all[2][5][2];
			static int best_mv_uni_inner[2][4][2];

#if ENABLE_BFRAME
			num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
			*num_refp_for_diff = md_fw_ptr->num_refp[mv_dir->lidx];
			*num_refp_for_rate = md_fw_ptr->num_refp[mv_dir->lidx];
#else
			num_refp_cnt = md_fw_ptr->num_refp;
			*num_refp_for_diff = md_fw_ptr->num_refp;
			*num_refp_for_rate = md_fw_ptr->num_refp;
#endif
			int refi_cur = 0;
			//if (valid_flag_write == 1)
			{
				int pic_height = md_fw_ptr->pic_height_in_scu << 2;
				int pic_width = md_fw_ptr->pic_width_in_scu << 2;
				if (mode_type_write == 1)
				{
					mode_info_write.cu_mode = 1;
					mode_info_write.affine_flag = 0;
					init_inter_data_16_16(&mode_info_write, md_fw_ptr->pic_width_in_scu);
					//for (int i = 0; i < 2; i++) {
					//	for (int j = 0; j < 2; j++) {
					//		mode_info_write.mv[i][j] = 0;
					//		mode_info_write.mvd[i][j] = 0;
					//	}
					//}
#if ENABLE_BFRAME
					U1 lidx = mv_dir->lidx;
#else
					U1 lidx = 0;
#endif
					mode_info_write.mv[lidx][0] = mv_copy[lidx][0];
					mode_info_write.mv[lidx][1] = mv_copy[lidx][1];
					mode_info_write.mvd[lidx][0] = mvd_copy[lidx][0];
					mode_info_write.mvd[lidx][1] = mvd_copy[lidx][1];
					mode_info_write.refi[0] = refi_copy[0];
					mode_info_write.refi[1] = refi_copy[1];
				}
				else if (mode_type_write == 2)
				{
#if MD_PRINT
					__assert_HLS("affine is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4550, __FUNCTION__);
#endif
				}
				else if (mode_type_write == 0)
				{
#ifdef MD_CMOD
#if MD_PRINT
					__assert_HLS("skip is not support in md kernel 16.", "analyze_uni_pred_16", (unsigned int)4672, __FUNCTION__);
#endif
#else
					//make_skip_resi_16_16(inter_mode_idx_write, skip_rdo, skip_rdo_mode, merge_rdo, &mode_info_write, pic_width, pic_height,
					//	cu_width_log2, cu_height_log2, orgY, 64, w, h, md_fw_ptr->bit_depth_internal);
					derive_mode_info(inter_mode_idx_write, skip_rdo, skip_rdo_mode, merge_rdo, &mode_info_write);
#endif 
				}
				//				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };
				//#if ENABLE_BFRAME
				//				if (!REFI_IS_VALID(mode_info_write.refi[REFP_0]) && !REFI_IS_VALID(mode_info_write.refi[REFP_1]))
				//				{
				//					//valid_flag = 0;
				//				}
				//				if (!com_mc_cu_y_16(&cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
				//					SWW, pred_cache_nz, md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr, 
				//					CtrPosSKIP,
				//					CtrPosSKIP_ref1,
				//					fme2mdrefbuf
				//					, mode_type_write == 1 ? MODE_INTER : MODE_DIR
				//#if SUB_TMVP
				//					, core_sbtmvp, mode_info_write.skip_idx, mode_info_write.umve_flag
				//#endif
				//				))
				//				{
				//					//valid_flag_write = 0;
				//				}
				//#else
				//				if (!com_mc_y_16(mode_type_write, &cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
				//					SWW, pred_cache_nz, md_fw_ptr->bit_depth_internal, tree_status,
				//					CtrPosSKIP, fme2mdrefbuf
				//					))
				//				{
				//					valid_flag_write = 0;
				//				}
				//#endif

				if (mode_type_write == 1 || mode_type_write == 0)
				{
					if (mode_type_write == 1) {
						enc_diff_16b_16_16(cu_width_log2, cu_height_log2, orgY, pred_y_inter1, 16, w, h, coef_tmp);
					}
					else {
						enc_diff_16b_16_16(cu_width_log2, cu_height_log2, orgY, pred_y_inter2[rdo_idx-1], 16, w, h, coef_tmp);
					}
					//enc_diff_16b_16_16(cu_width_log2, cu_height_log2, orgY, pred_cache_nz, 16, w, h, coef_tmp);
					mode_info_write.tb_part = ((int)SIZE_2Nx2N);
				}
			}
		}
	}
	else
#endif
	{

			//		if (intra_mode_idx == 12)
			//			Ipred_vert_16(w, h, src_up_temp + 3, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 24)
			//			Ipred_hor_16(w, h, src_le_temp + 3, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 0)
			//			Ipred_dc_16(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, avail_tb, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 1)
			//			Ipred_plane_16(w, h, src_le_temp + 2, src_up_temp + 2, md_fw_ptr->bit_depth_internal, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx == 2)
			//			Ipred_bi_16(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, orgY, pred_cache_nz, coef_tmp);
			//		else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
			//			ipred_ang1_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
			//#if MIPF
			//				, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//			);
			//		else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
			//			ipred_ang2_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
			//#if MIPF
			//				, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//			);
			//		else
			//
			//		{
			//#if EIPM
			//			if (intra_mode_idx > 33)
			//			{
			//				ipred_ang_eipm_16(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
			//#if MIPF
			//					, 1, md_fw_ptr->mipf_enable_flag, md_fw_ptr->bit_depth_internal, coef_tmp, pred_cache_nz, orgY
			//#endif
			//				);
			//			/*static pel pred_1d[256] = { 0 };
			//			memset(pred_1d, 0, sizeof(pel) * 256);
			//
			//			if (intra_mode_idx > 33)
			//			{
			//				ipred_ang_eipm(src_le_temp + 3, src_up_temp + 3, pred_1d, w, h, intra_mode_idx
			//#if MIPF
			//					, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//				);
			//
			//				clip_pred(pred_1d, w, h, md_fw_ptr->bit_depth_internal);
			//
			//				for (int i = 0; i < 16; i++)
			//				{
			//					if (i < h)
			//					{
			//						for (int j = 0; j < 16; j++)
			//						{
			//							if (j < w)
			//							{
			//								coef_tmp[i][j] = orgY[(i * 16) + j] - pred_1d[(i * w) + j];
			//								pred_cache_nz[i][j] = pred_1d[(i * w) + j];
			//							}
			//						}
			//					}
			//				}*/
			//			}
			//			else
			//#endif
			//				ipred_ang3_16(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, orgY, pred_cache_nz, coef_tmp
			//#if MIPF
			//					, 1, md_fw_ptr->mipf_enable_flag
			//#endif
			//				);
			//		}

		Ipred_16_16_diff(w, h, orgY, pred_y_intra[rdo_idx], coef_tmp);

			mode_info_write.cu_mode = 0;
			mode_info_write.ipm[0][0] = intra_mode_idx;
			mode_info_write.ipm[0][1] = -1;
#if USE_ROI_MODE_CONFIG
		}
#endif
		//valid_flag_write = 1;
	}

	// WRITE STREAMS
	*inter_mode_idx = inter_mode_idx_write;
	*curr_mvr_rate = curr_mvr_write;
	*mode_type_nz = mode_type_write;
	*mode_type_rate = mode_type_write;
	*valid_flag = valid_flag_write;
	*is_intra_quant = is_intra_write;
#pragma HLS ARRAY_PARTITION variable=mod_info_ipm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mpm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.ipm complete dim=0
#pragma HLS ARRAY_PARTITION variable=mpm complete dim=0
	for (int i = 0; i < 16; ++i)
	{
#pragma HLS PIPELINE
		for (int j = 0; j < 16; ++j)
		{
			if (is_intra_write == 1) {
				pred_cache_ith[i][j] = pred_y_intra[rdo_idx][i][j];
				pred_cache_for_diff[i][j] = pred_y_intra[rdo_idx][i][j];
			}
#if	!SIMPLE_MD
			else if (mode_type_write == 1){
				pred_cache_ith[i][j] = pred_y_inter1[i][j];
				pred_cache_for_diff[i][j] = pred_y_inter1[i][j];
			}
			else if (mode_type_write == 0) {
				pred_cache_ith[i][j] = pred_y_inter2[rdo_idx-1][i][j];
				pred_cache_for_diff[i][j] = pred_y_inter2[rdo_idx - 1][i][j];
			}
#endif
			//pred_cache_for_diff[i][j] = pred_cache_ith[i][j];
			coef_tmp_for_th[i][j] = coef_tmp[i][j];
		}
	}
	mod_info_nz->cu_mode = mode_info_write.cu_mode;
	mod_info_nz->affine_flag = mode_info_write.affine_flag;
#pragma HLS ARRAY_PARTITION variable=mode_info_write.mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.affine_mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.affine_mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->affine_mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->affine_mvd complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_nz->refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_diff complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_refi_for_up complete dim=0
#if	!SIMPLE_MD
	for (int i = 0; i < REFP_NUM; ++i)
	{
#pragma HLS UNROLL
		for (int j = 0; j < MV_D; ++j)
		{
#pragma HLS UNROLL
			mod_info_nz->mvd[i][j] = mode_info_write.mvd[i][j];
			mod_info_nz->mv[i][j] = mode_info_write.mv[i][j];
			for (int k = 0; k < VER_NUM; ++k)
			{
#pragma HLS UNROLL
				mod_info_nz->affine_mv[i][k][j] = mode_info_write.affine_mv[i][k][j];
				mod_info_nz->affine_mvd[i][k][j] = mode_info_write.affine_mvd[i][k][j];
			}
		}
		mod_info_nz->refi[i] = mode_info_write.refi[i];
		mod_info_refi_for_diff[i] = mode_info_write.refi[i];
		mod_info_refi_for_rate[i] = mode_info_write.refi[i];
		mod_info_refi_for_up[i] = mode_info_write.refi[i];
	}
	mod_info_nz->skip_idx = mode_info_write.skip_idx;
	mod_info_nz->smvd_flag = mode_info_write.smvd_flag;
	mod_info_nz->umve_flag = mode_info_write.umve_flag;
	mod_info_nz->umve_idx = mode_info_write.umve_idx;
#endif
#pragma HLS ARRAY_PARTITION variable=mod_info_ipm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mpm_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_ipm_for_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mpm_for_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode_info_write.ipm complete dim=0
#pragma HLS ARRAY_PARTITION variable=mpm complete dim=0
	for (int i = 0; i < MAX_NUM_PB; ++i)
	{
#pragma HLS UNROLL
		for (int j = 0; j < 2; ++j)
		{
#pragma HLS UNROLL
			mod_info_nz->ipm[i][j] = mode_info_write.ipm[i][j];
			mod_info_nz->mpm[i][j] = mpm[i][j];
			mod_info_ipm_for_rate[i][j] = mode_info_write.ipm[i][j];
			mod_info_mpm_for_rate[i][j] = mpm[i][j];
			mod_info_ipm_for_up[i][j] = mode_info_write.ipm[i][j];
			mod_info_mpm_for_up[i][j] = mpm[i][j];
		}
	}
	mod_info_nz->tb_part = mode_info_write.tb_part;
	mod_info_nz->pb_part = 0;
	*iQuant = rdo_idx;
}


void rdo_skip_8_16(s64* cost_best, MD_COM_MODE_BEST_16* best_info_ptr_16,
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16,
	MD_COM_MODE* mod_info_curr,
	pel org_y[16][16], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO* merge,
	U13 pic_width, U13 pic_height, U2 slice_type, U2 tree_status, s64 lambda_y, U2 curr_cons_pred_mode, U4 bit_depth,
	strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS], 
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	//pel fme2mdrefbuf[2560][8][2][16]
	pel pred_y_skip[13][16][16]
#if SUB_TMVP
	, int cu_width, int cu_height, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	U3 cu_width_log2 = mod_info_curr->cu_width_log2;

	if (slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA) { return; }

	int valid_skip_num = 0;
	for (int idx = 0; idx < SKIP_MODE_NUM; ++idx) {//
#pragma HLS PIPELINE II=4
#pragma HLS LOOP_TRIPCOUNT max=12
		// derive mode info
		if (valid_skip_num < SKIP_MODE_NUM_SIZE(8, 16))
		{
			SKIP_ELEMENT* mode = skip_mode + idx;
			if (mode->valid == 0) { continue; }

			mod_info_curr->cu_mode = MODE_SKIP;
			mod_info_curr->umve_flag = mode->umve_flag;
			mod_info_curr->umve_idx = mode->umve_idx;
			mod_info_curr->affine_flag = mode->affine_flag;
			mod_info_curr->skip_idx = mode->skip_idx;
			mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
			mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
			mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
			mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
			mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
			mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
			mod_info_curr->mv[1][0] = 0;
			mod_info_curr->mv[1][1] = 0;
			mod_info_curr->refi[1] = -1;
#endif
			// skip index 1 and 2 for P slice

#if ENABLE_BFRAME
			if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
			if (mod_info_curr->refi[0] == -1) { continue; }
#endif

			valid_skip_num++;
        pel pred_y_skip_cp[16][16];
#pragma HLS ARRAY_PARTITION variable=pred_y_skip_cp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=3
		for(int i=0;i<16;i++)
			for(int j=0;j<16;j++)
				pred_y_skip_cp[i][j] = pred_y_skip[idx][i][j];

			s64 cost = enc_ssd_16b_1_8_16_wsc(mod_info_curr->cu_width_log2, mod_info_curr->cu_height_log2, pred_y_skip[idx], org_y, mod_info_curr->cu_width, 16, bit_depth);
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->num_nz complete dim=0
   for(int i=0;i<4;i++){
#pragma HLS UNROLL
#pragma HLS pipeline
     for(int j=0;j<3;j++)
     {
       mod_info_curr->num_nz[i][j] = 0;
     }
   }
			mod_info_curr->tb_part = ((int)SIZE_2Nx2N);

			// calc bit est
			U16 bit_est = enc_bit_est_flag_skip_8_16(slice_type, tree_status, mod_info_curr->umve_flag, mod_info_curr->umve_idx, mod_info_curr->affine_flag, mod_info_curr->skip_idx, mod_info_curr->cu_width_log2, mod_info_curr->cu_height_log2, mod_info_curr->num_nz, mod_info_curr->ipm, 8);
			cost += ((bit_est * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE);
#if SUB_TMVP
			// if skip tmvp mode
			if (idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE) {
				core_sbtmvp->sbTmvp_flag = 1;
				if (!core_sbtmvp->isValid)
					continue;
			}
			else {
				core_sbtmvp->sbTmvp_flag = 0;
			}
#endif
			// compare cost
			if (cost < *cost_best) {
#if SUB_TMVP

				core_sbtmvp->best_sbTmvp_flag = core_sbtmvp->sbTmvp_flag;
				if (core_sbtmvp->best_sbTmvp_flag) {
					for (int i = 0; i < SBTMVP_NUM; i++)
					{
#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT max=4
						core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_X];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_Y];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_X];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_Y];
						core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_0] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_0];
						core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_1] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_1];

					}
					for (int lidx = 0; lidx < 2; lidx++)
					{
						best_info_ptr_16->mvd[lidx][0] = 0;
						best_info_ptr_16->mvd[lidx][1] = 0;
					}
				}
				//}
#endif
				best_info_ptr_16->cu_mode = mod_info_curr->cu_mode;
				best_info_ptr_16->pb_part = mod_info_curr->pb_part;
				best_info_ptr_16->tb_part = mod_info_curr->tb_part;
				best_info_ptr_16->umve_flag = mod_info_curr->umve_flag;

				*cost_best = cost;

				best_info_ptr_16->mvr_idx = ((u8)0);
				best_info_ptr_16->refi[0] = mod_info_curr->refi[0];
				best_info_ptr_16->refi[1] = mod_info_curr->refi[1];
				for (int lidx = 0; lidx < 2; lidx++) {
					best_info_ptr_16->mv[lidx][0] = mod_info_curr->mv[lidx][0];
					best_info_ptr_16->mv[lidx][1] = mod_info_curr->mv[lidx][1];
					best_info_ptr_16->mvd[lidx][0] = mod_info_curr->mvd[lidx][0];
					best_info_ptr_16->mvd[lidx][1] = mod_info_curr->mvd[lidx][1];
				}

#if SUB_TMVP
				if (core_sbtmvp->best_sbTmvp_flag) {
					for (int lidx = 0; lidx < 2; lidx++)
					{
#pragma HLS pipeline
						best_info_ptr_16->mvd[lidx][MV_X] = 0;
						best_info_ptr_16->mvd[lidx][MV_Y] = 0;
					}
				}
				//core_sbtmvp->sbTmvp_flag = 0;
#endif

				best_info_ptr_16->smvd_flag = mod_info_curr->smvd_flag;
				best_info_ptr_16->affine_flag = mod_info_curr->affine_flag;

				if (best_info_ptr_16->umve_flag != 0) {
					best_info_ptr_16->umve_idx = mod_info_curr->umve_idx;
				}
				else {
					best_info_ptr_16->skip_idx = mod_info_curr->skip_idx;
				}

#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->num_nz_y complete dim=0
				for (U3 i_numnz = 0; i_numnz < 4; i_numnz++) {
#pragma HLS pipeline
#pragma HLS UNROLL
					best_info_ptr_16->num_nz_y[i_numnz] = 0;
				}

//#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->coef_y complete dim=0
//#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->reco_y complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=3
			for (int i = 0; i < 16; ++i) {
#pragma HLS pipeline
				for (int j = 0; j < 8; ++j) {
					if (i < mod_info_curr->cu_height && j < mod_info_curr->cu_width) {
						cu_data_temp_ptr_16->coef_y[i][j] = 0;
						s16 pred = ((1 << bit_depth) - 1) < pred_y_skip[idx][i][j] ? ((1 << bit_depth) - 1) : pred_y_skip[idx][i][j];
						cu_data_temp_ptr_16->reco_y[i][j] = 0 > pred ? 0 : pred;
					}
				}
			}
        }
		}
	}
}

void rdo_skip_16_8(s64* cost_best, MD_COM_MODE_BEST_16* best_info_ptr_16,
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16,
	MD_COM_MODE* mod_info_curr,
	pel org_y[16][16], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO* merge,
	U13 pic_width, U13 pic_height, U2 slice_type, U2 tree_status, s64 lambda_y, U2 curr_cons_pred_mode, U4 bit_depth,
	strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	//pel fme2mdrefbuf[2560][8][2][16]
	pel pred_y_skip[13][16][16]
#if SUB_TMVP
	, int cu_width, int cu_height, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	U3 cu_width_log2 = mod_info_curr->cu_width_log2;

	if (slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA) { return; }

	int valid_skip_num = 0;

	for (int idx = 0; idx < SKIP_MODE_NUM; ++idx) {//
#pragma HLS PIPELINE II=4
#pragma HLS LOOP_TRIPCOUNT max=12
		// derive mode info
		if (valid_skip_num < SKIP_MODE_NUM_SIZE(16, 8))
		{
			SKIP_ELEMENT* mode = skip_mode + idx;
			if (mode->valid == 0) { continue; }

			mod_info_curr->cu_mode = MODE_SKIP;
			mod_info_curr->umve_flag = mode->umve_flag;
			mod_info_curr->umve_idx = mode->umve_idx;
			mod_info_curr->affine_flag = mode->affine_flag;
			mod_info_curr->skip_idx = mode->skip_idx;
			mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
			mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
			mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
			mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
			mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
			mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
			mod_info_curr->mv[1][0] = 0;
			mod_info_curr->mv[1][1] = 0;
			mod_info_curr->refi[1] = -1;
#endif
			// skip index 1 and 2 for P slice

#if ENABLE_BFRAME
			if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
			if (mod_info_curr->refi[0] == -1) { continue; }
#endif
			valid_skip_num++;
		pel pred_y_skip_cp[16][16];
#pragma HLS ARRAY_PARTITION variable=pred_y_skip_cp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=3
		for(int i=0;i<16;i++)
			for(int j=0;j<16;j++)
				pred_y_skip_cp[i][j] = pred_y_skip[idx][i][j];

			s64 cost = enc_ssd_16b_1_16_8_wsc(mod_info_curr->cu_width_log2, mod_info_curr->cu_height_log2, pred_y_skip[idx], org_y, mod_info_curr->cu_width, 16, bit_depth);
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->num_nz complete dim=0
   for(int i=0;i<4;i++){
#pragma HLS UNROLL
#pragma HLS pipeline
     for(int j=0;j<3;j++)
     {
       mod_info_curr->num_nz[i][j] = 0;
     }
   }
			mod_info_curr->tb_part = ((int)SIZE_2Nx2N);

			// calc bit est
			U16 bit_est = enc_bit_est_flag_skip_16_8(slice_type, tree_status, mod_info_curr->umve_flag, mod_info_curr->umve_idx, mod_info_curr->affine_flag, mod_info_curr->skip_idx, mod_info_curr->cu_width_log2, mod_info_curr->cu_height_log2, mod_info_curr->num_nz, mod_info_curr->ipm, 8);
			cost += ((bit_est * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE);
#if SUB_TMVP
			// if skip tmvp mode
			if (idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE) {
				core_sbtmvp->sbTmvp_flag = 1;
				if (!core_sbtmvp->isValid)
					continue;
			}
			else {
				core_sbtmvp->sbTmvp_flag = 0;
			}
#endif
			// compare cost
			if (cost < *cost_best) {
#if SUB_TMVP

				core_sbtmvp->best_sbTmvp_flag = core_sbtmvp->sbTmvp_flag;
				if (core_sbtmvp->best_sbTmvp_flag) {
					for (int i = 0; i < SBTMVP_NUM; i++)
					{
#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT max=4
						core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_X];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_Y];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_X];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_Y];
						core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_0] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_0];
						core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_1] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_1];

					}
					for (int lidx = 0; lidx < 2; lidx++)
					{
						best_info_ptr_16->mvd[lidx][0] = 0;
						best_info_ptr_16->mvd[lidx][1] = 0;
					}
				}
				//}
#endif
				best_info_ptr_16->cu_mode = mod_info_curr->cu_mode;
				best_info_ptr_16->pb_part = mod_info_curr->pb_part;
				best_info_ptr_16->tb_part = mod_info_curr->tb_part;
				best_info_ptr_16->umve_flag = mod_info_curr->umve_flag;

				*cost_best = cost;

				best_info_ptr_16->mvr_idx = ((u8)0);
				best_info_ptr_16->refi[0] = mod_info_curr->refi[0];
				best_info_ptr_16->refi[1] = mod_info_curr->refi[1];
				for (int lidx = 0; lidx < 2; lidx++) {
					best_info_ptr_16->mv[lidx][0] = mod_info_curr->mv[lidx][0];
					best_info_ptr_16->mv[lidx][1] = mod_info_curr->mv[lidx][1];
					best_info_ptr_16->mvd[lidx][0] = mod_info_curr->mvd[lidx][0];
					best_info_ptr_16->mvd[lidx][1] = mod_info_curr->mvd[lidx][1];
				}

#if SUB_TMVP
				if (core_sbtmvp->best_sbTmvp_flag) {
					for (int lidx = 0; lidx < 2; lidx++)
					{
#pragma HLS pipeline
						best_info_ptr_16->mvd[lidx][MV_X] = 0;
						best_info_ptr_16->mvd[lidx][MV_Y] = 0;
					}
				}
				//core_sbtmvp->sbTmvp_flag = 0;
#endif

				best_info_ptr_16->smvd_flag = mod_info_curr->smvd_flag;
				best_info_ptr_16->affine_flag = mod_info_curr->affine_flag;

				if (best_info_ptr_16->umve_flag != 0) {
					best_info_ptr_16->umve_idx = mod_info_curr->umve_idx;
				}
				else {
					best_info_ptr_16->skip_idx = mod_info_curr->skip_idx;
				}

#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->num_nz_y complete dim=0
				for (U3 i_numnz = 0; i_numnz < 4; i_numnz++) {
#pragma HLS pipeline
#pragma HLS UNROLL
					best_info_ptr_16->num_nz_y[i_numnz] = 0;
				}

//#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->coef_y complete dim=0
//#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->reco_y complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=3
			for (int i = 0; i < 8; ++i) {
#pragma HLS pipeline
				for (int j = 0; j < 16; ++j) {
					if (i < mod_info_curr->cu_height && j < mod_info_curr->cu_width) {
						cu_data_temp_ptr_16->coef_y[i][j] = 0;
						s16 pred = ((1 << bit_depth) - 1) < pred_y_skip[idx][i][j] ? ((1 << bit_depth) - 1) : pred_y_skip[idx][i][j];
						cu_data_temp_ptr_16->reco_y[i][j] = 0 > pred ? 0 : pred;
					}
				}
			}
        }
		}
	}
}
void rdo_skip_16_16(s64* cost_best, MD_COM_MODE_BEST_16* best_info_ptr_16,
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16,
	MD_COM_MODE* mod_info_curr,
	pel org_y[16][16], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO* merge,
	U13 pic_width, U13 pic_height, U2 slice_type, U2 tree_status, s64 lambda_y, U2 curr_cons_pred_mode, U4 bit_depth,
	strFetch_ref_window_16* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	//pel fme2mdrefbuf[2560][8][2][16]
	pel pred_y_skip[13][16][16]
#if SUB_TMVP
	, int cu_width, int cu_height, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	U3 cu_width_log2 = mod_info_curr->cu_width_log2;

	if (slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA) { return; }

	for (int idx = 0; idx < SKIP_MODE_NUM; ++idx) {//
 #pragma HLS PIPELINE II=4
		// derive mode info
#pragma HLS LOOP_TRIPCOUNT max=12
			SKIP_ELEMENT* mode = skip_mode + idx;
			if (mode->valid == 0) { continue; }

			mod_info_curr->cu_mode = MODE_SKIP;
			mod_info_curr->umve_flag = mode->umve_flag;
			mod_info_curr->umve_idx = mode->umve_idx;
			mod_info_curr->affine_flag = mode->affine_flag;
			mod_info_curr->skip_idx = mode->skip_idx;
			mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
			mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
			mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
			mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
			mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
			mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
			mod_info_curr->mv[1][0] = 0;
			mod_info_curr->mv[1][1] = 0;
			mod_info_curr->refi[1] = -1;
#endif
			// skip index 1 and 2 for P slice

#if ENABLE_BFRAME
		if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
		if (mod_info_curr->refi[0] == -1) { continue; }
#endif

		pel pred_y_skip_cp[16][16];
#pragma HLS ARRAY_PARTITION variable=pred_y_skip_cp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=3
		for(int i=0;i<16;i++)
			for(int j=0;j<16;j++)
				pred_y_skip_cp[i][j] = pred_y_skip[idx][i][j];

		s64 cost = enc_ssd_16b_1_16_16_wsc(mod_info_curr->cu_width_log2, mod_info_curr->cu_height_log2, pred_y_skip_cp, org_y, mod_info_curr->cu_width, 16, bit_depth);
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->num_nz complete dim=0
   for(int i=0;i<4;i++){
#pragma HLS UNROLL
#pragma HLS pipeline
     for(int j=0;j<3;j++)
     {
       mod_info_curr->num_nz[i][j] = 0;
     }
   }
		mod_info_curr->tb_part = ((int)SIZE_2Nx2N);

		// calc bit est
		U16 bit_est = enc_bit_est_flag_skip_16_16(slice_type, tree_status, mod_info_curr->umve_flag, mod_info_curr->umve_idx, mod_info_curr->affine_flag, mod_info_curr->skip_idx, mod_info_curr->cu_width_log2, mod_info_curr->cu_height_log2, mod_info_curr->num_nz, mod_info_curr->ipm, 8);
		cost += ((bit_est * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE);
#if SUB_TMVP
		// if skip tmvp mode
		if (idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE) {
			core_sbtmvp->sbTmvp_flag = 1;
			if (!core_sbtmvp->isValid)
				continue;
		}
		else {
			core_sbtmvp->sbTmvp_flag = 0;
		}
#endif
		// compare cost
		if (cost < *cost_best) {
#if SUB_TMVP
			
			core_sbtmvp->best_sbTmvp_flag = core_sbtmvp->sbTmvp_flag;
			if (core_sbtmvp->best_sbTmvp_flag) {
				for (int i = 0; i < SBTMVP_NUM; i++)
				{
#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT max=4
					core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_X];
					core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_Y];
					core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_X];
					core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_Y];
					core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_0] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_0];
					core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_1] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_1];

				}
				for (int lidx = 0; lidx < 2; lidx++)
				{
					best_info_ptr_16->mvd[lidx][0] = 0;
					best_info_ptr_16->mvd[lidx][1] = 0;
				}
			}
			//}
#endif
			best_info_ptr_16->cu_mode = mod_info_curr->cu_mode;
			best_info_ptr_16->pb_part = mod_info_curr->pb_part;
			best_info_ptr_16->tb_part = mod_info_curr->tb_part;
			best_info_ptr_16->umve_flag = mod_info_curr->umve_flag;

			*cost_best = cost;

			best_info_ptr_16->mvr_idx = ((u8)0);
			best_info_ptr_16->refi[0] = mod_info_curr->refi[0];
			best_info_ptr_16->refi[1] = mod_info_curr->refi[1];
			for (int lidx = 0; lidx < 2; lidx++) {
				best_info_ptr_16->mv[lidx][0] = mod_info_curr->mv[lidx][0];
				best_info_ptr_16->mv[lidx][1] = mod_info_curr->mv[lidx][1];
				best_info_ptr_16->mvd[lidx][0] = mod_info_curr->mvd[lidx][0];
				best_info_ptr_16->mvd[lidx][1] = mod_info_curr->mvd[lidx][1];
			}

#if SUB_TMVP
			if (core_sbtmvp->best_sbTmvp_flag) {
				for (int lidx = 0; lidx < 2; lidx++)
				{
#pragma HLS pipeline
					best_info_ptr_16->mvd[lidx][MV_X] = 0;
					best_info_ptr_16->mvd[lidx][MV_Y] = 0;
				}
			}
			//core_sbtmvp->sbTmvp_flag = 0;
#endif

			best_info_ptr_16->smvd_flag = mod_info_curr->smvd_flag;
			best_info_ptr_16->affine_flag = mod_info_curr->affine_flag;

			if (best_info_ptr_16->umve_flag != 0) {
				best_info_ptr_16->umve_idx = mod_info_curr->umve_idx;
			}
			else {
				best_info_ptr_16->skip_idx = mod_info_curr->skip_idx;
			}

#pragma HLS ARRAY_PARTITION variable=best_info_ptr_16->num_nz_y complete dim=0
			for (U3 i_numnz = 0; i_numnz < 4; i_numnz++) {
#pragma HLS pipeline
#pragma HLS UNROLL
				best_info_ptr_16->num_nz_y[i_numnz] = 0;
			}

//#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->coef_y complete dim=0
//#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->reco_y complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip complete dim=3
			for (int i = 0; i < 16; ++i) {
#pragma HLS pipeline
				for (int j = 0; j < 16; ++j) {
					if (i < mod_info_curr->cu_height && j < mod_info_curr->cu_width) {
						cu_data_temp_ptr_16->coef_y[i][j] = 0;
						s16 pred = ((1 << bit_depth) - 1) < pred_y_skip[idx][i][j] ? ((1 << bit_depth) - 1) : pred_y_skip[idx][i][j];
						cu_data_temp_ptr_16->reco_y[i][j] = 0 > pred ? 0 : pred;
					}
				}
			}

		}
	}
}

#if !LUMA_8x16_PIPELINE_DUMMY
void rdo_luma_8_16_pipeline(u8 all_rdo_num, U8 w, U8 h, pel orgY[16 * 16], pel orgY_nz[16][16], pel org_diff[16][16], U1 valid_mode[17], u8 ipred_list[5], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16 avail_tb, u8 rdo_list[MAX_RDO_NUM_SIZE(8, 16)], u8 inter_rdo_num, 
	RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, U2 tree_status, MD_COM_MODE_BEST_16* best_info_ptr_16, MD_INPUT* md_input_ptr,
	#if ENABLE_BFRAME
	MV_DIR* mv_dir, strFetch_ref_window_16* Fetch_Ref_window_ptr,
#endif
	SKIP_ELEMENT skip_mode[MAX_SKIP_NUM], MERGE_RDO* merge_rdo, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2], U3 cu_width_log2, U3 cu_height_log2, 
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16,
	U2 curr_cons_pred_mode,
	//pel fme2mdrefbuf[2560][8][2][16],
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[16][16], pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(8, 16) - 1][16][16], pel pred_y_intra[MAX_RDO_NUM_SIZE(8, 16)][16][16],
	MD_KERNEL_INPUT* md_kernel_input, u8 mpm[MAX_NUM_PB][2], U7 cu_width, int refp_ptr0, int refp_ptr1, U2 ch_type, s64 lambda, s64 cost_skip, s64* cost_best, U6 qp
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	w = 8;
	h = 16;
	cu_width = 8;

	cu_width_log2 = 3;
	cu_height_log2 = 4;
#ifdef MD_CMOD
	for (rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
	{
#pragma HLS LOOP_TRIPCOUNT max=2
#elif USE_ENH
#if USE_EIPM_RMD
#if USE_SPEED_LEVEL
	int rdo_cnt = 5;
	if (md_input_ptr->speed_level == 1)
		rdo_cnt = IPD_RDO_CNT; //5
	else if (md_input_ptr->speed_level == 2)
		rdo_cnt = EXTRA_RDO_MODE;//10
	else
		rdo_cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
	int rdo_cnt = MAX_RDO_NUM_SIZE(8, 16);
#endif
	for (u8 rdo_idx = 0; rdo_idx < rdo_cnt; rdo_idx++)
#else
	for (u8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
#endif
	{
#pragma HLS LOOP_TRIPCOUNT max=5
#pragma HLS DATAFLOW
#else
	for (u8 rdo_idx = 0; rdo_idx < 5; rdo_idx++)
	{
#pragma HLS LOOP_TRIPCOUNT max=5
#endif
		U1 is_intra_quant, is_intra_rate, is_intra_update;
		s8 inter_mode_idx;
		u8 mode_type_nz, mode_type_rate, mode_type_update;
		u8 curr_mvr_rate, curr_mvr_update;
		U1 valid_flag;
		s32 dist_value;
		s64 flag_cost[2];
		s64 cost_best_temp;
		s64 dist_pred;
		 s16 coef_tmp[16][16];
		 s16 coef_tmp_h[16][16], coef_tmp_ith[16][16];
		 s16 coef_tmp_v[16][16], coef_tmp_itv[16][16];
		 pel pred_cache_nz[16][16], pred_cache_ith[16][16], pred_cache_update[16][16];
		 int num_nz_rate[MAX_NUM_TB][N_C], num_nz_itv, num_nz_ith, num_nz_update[MAX_NUM_TB][N_C];
		 s16 coef_pb_part[16][16], coef_update[16][16];
		 pel rec[16][16];
		 MD_KERNEL_MODE md_info_nz;
		u8 iUpdate, iQuant;
		 pel pred_cache_for_diff[16][16];
		 pel rec_for_update[16][16];
		s16  dst_for_itv[16][16];
		u8 /*num_refp_for_ip,*/ num_refp_for_diff, num_refp_for_rate;
		S8 mod_info_ipm_for_rate[4][2];
		u8 mod_info_mpm_for_rate[4][2];
		S8 mod_info_ipm_for_up[4][2];
		u8 mod_info_mpm_for_up[4][2];
		s16 mod_info_mvd_for_diff[2][2];
		s16 mod_info_mvd_for_rate[2][2];
		s16 mod_info_mvd_for_up[2][2];
		S3 mod_info_refi_for_diff[2];
		S3 mod_info_refi_for_rate[2];
		S3 mod_info_refi_for_up[2];
		static s16 coef_tmp_h_for_ver[16][16];
		static int num_nz_for_update[MAX_NUM_TB][N_C];
		static s16 coef_tmp_for_ith[16][16];
		//num_refp_for_ip = 0;
		//num_refp_for_diff = 0;
		//num_refp_for_rate = 0;
#pragma HLS ARRAY_PARTITION variable=mod_info_mvd_for_diff complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mvd_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mvd_for_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz.mvd complete dim=0
#if !AZB_ENABLE
		intra_inter_pred_8_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag,
			valid_mode, 
			mv_copy, mvd_copy, refi_copy, pred_y_inter1, pred_y_inter2, pred_y_intra,
			pred_cache_ith, pred_cache_for_diff, /*num_refp_for_ip,*/ &num_refp_for_diff, &num_refp_for_rate,
			&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
			md_fw_ptr,
			skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
			tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
			md_input_ptr->CtrPos2MD,
			mod_info_ipm_for_rate, mod_info_mpm_for_rate, mod_info_ipm_for_up, mod_info_mpm_for_up,
			mod_info_refi_for_diff, mod_info_refi_for_rate, mod_info_refi_for_up,
#if ENABLE_BFRAME
			md_input_ptr->CtrPos2MD_ref1, mv_dir, Fetch_Ref_window_ptr,
#endif // ENABLE_BFRAME
			//fme2mdrefbuf,
			md_kernel_input, mpm, &iQuant
#if SUB_TMVP
			, core_sbtmvp
#endif
#if USE_SPEED_LEVEL
			, md_input_ptr->speed_level
#endif

		);

		diff_ssd_bitcnt_8_16(md_fw_ptr, md_input_ptr, num_refp_for_diff,
			mode_type_nz, &md_info_nz, pred_cache_for_diff, pred_cache_update, mod_info_refi_for_diff,
			orgY_nz, &dist_pred, &cost_best_temp, mod_info_mvd_for_diff, mod_info_mvd_for_rate, mod_info_mvd_for_up,
			tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);

		transform_hor_8_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp, coef_tmp_h_for_ver, coef_tmp_h);
		transform_ver_8_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp_h_for_ver,/* coef_tmp_h,*/ coef_tmp_v);

		quant_nnz_8_16_luma(num_nz_rate, &num_nz_itv, w, h, rdoq_array, md_fw_ptr->bit_depth_internal, qp, lambda,
			is_intra_quant, &is_intra_rate, coef_tmp_v, coef_tmp_itv, dst_for_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr->slice_type, coef_pb_part, coef_update, iQuant, &iUpdate);

		rate_est_8_16(w, h, md_fw_ptr, mod_info_refi_for_rate, mod_info_mvd_for_rate, num_refp_for_rate, mod_info_ipm_for_rate, mod_info_mpm_for_rate, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
			flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);

		inv_transform_ver_8_16(w, h, md_fw_ptr->bit_depth_internal, qp, num_nz_itv, &num_nz_ith, num_nz_update, /* coef_tmp_itv, */dst_for_itv, coef_tmp_ith, coef_tmp_for_ith, cu_width_log2, cu_height_log2);
		inv_transform_hor_8_16(w, h, md_fw_ptr->bit_depth_internal, num_nz_ith, md_info_nz.tb_part, cu_width_log2, cu_height_log2, pred_cache_ith, &dist_value,
			rec, rec_for_update,/* coef_tmp_for_ith,*/coef_tmp_ith, ch_type, org_diff);

		update_rdo_luma_8_16(valid_flag, w, h, mod_info_mvd_for_up,
			cu_data_temp_ptr_16, mod_info_ipm_for_up, mod_info_mpm_for_up,
			&md_info_nz, best_info_ptr_16, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
			mode_type_update, is_intra_update, curr_mvr_update,
			//rec_for_update,/*rec,*/ pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate
			/*rec_for_update,*/rec,pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate
#if SUB_TMVP
			, core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
			, md_input_ptr->valid_mode_config
#endif
		);

#if SET_MD_16_MAX_COST
		* cost_best = 1 << 25;
#endif
#else
		if (md_fw_ptr->slice_type == 1)  // I_slice
		{
			intra_inter_pred_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, valid_mode, pred_cache_nz, pred_cache_ith,
				&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
				md_fw_ptr,
				RefWindowLCU, CtrPos,
#if ENABLE_BFRAME
				RefWindowLCU_ref1, CtrPos_ref1, mv_dir, refwin_md_ref1, CtrPosFME_ref1, Fetch_Ref_window_ptr,
#endif
				skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
				tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
				refwin_md, CtrPosFME, md_kernel_input, mpm, &iQuant);

			diff_ssd_bitcnt_16(model_cnt, md_fw_ptr, md_input_ptr,
				mode_type_nz, &md_info_nz, pred_cache_nz, pred_cache_update,
				orgY_nz, &dist_pred, &cost_best_temp,
				tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);

			transform_hor_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp, coef_tmp_h);
			transform_ver_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp_h, coef_tmp_v);

			quant_nnz_16(num_nz_rate, num_nz_update, &num_nz_itv, w, h, model_cnt, rdoq_array, md_fw_ptr->bit_depth_internal, qp, lambda,
				is_intra_quant, &is_intra_rate, coef_tmp_v, coef_tmp_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr->slice_type, coef_pb_part, coef_update, iQuant, &iUpdate);

			rate_est_16(w, h, model_cnt, md_fw_ptr, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
				flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);

			inv_transform_ver_16(w, h, md_fw_ptr->bit_depth_internal, qp, num_nz_itv, &num_nz_ith, coef_tmp_itv, coef_tmp_ith, cu_width_log2, cu_height_log2);
			inv_transform_hor_16(w, h, md_fw_ptr->bit_depth_internal, num_nz_ith, md_info_nz.tb_part, cu_width_log2, cu_height_log2, pred_cache_ith, &dist_value, rec, coef_tmp_ith, ch_type, org_diff);

			update_rdo_luma_16(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz, best_info_ptr, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
				mode_type_update, is_intra_update, curr_mvr_update,
				rec, pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate);
		}
		else // p/b slice.
		{
			intra_inter_pred_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, valid_mode, pred_cache_nz, pred_cache_ith,
				&is_intra_rate, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
				md_fw_ptr,
				RefWindowLCU, CtrPos,
				skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
				tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
				refwin_md, CtrPosFME, md_kernel_input, mpm, &iUpdate);
			diff_ssd_bitcnt_16(model_cnt, md_fw_ptr, md_input_ptr,
				mode_type_nz, &md_info_nz, pred_cache_nz, pred_cache_update,
				orgY_nz, &dist_pred, &cost_best_temp,
				tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);
			for (int i = 0; i < 256; ++i)
			{
				coef_pb_part[i] = 0;
			}
			num_nz_rate[0][0] = 0;
			rate_est_azb_16(w, h, model_cnt, md_fw_ptr, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
				flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);
			dist_value = dist_pred;
			if (valid_flag == 1)
			{
				if (mode_type_nz == 1 || mode_type_nz == 0)
				{
					dist_pred = MAX_S64;
				}
			}
			update_rdo_luma_16(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz, best_info_ptr, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
				mode_type_update, is_intra_update, curr_mvr_update,
				pred_cache_update, pred_cache_update, coef_pb_part, num_nz_rate, md_kernel_input, cost_skip, iUpdate);
		}
#endif

#if DEBUG_LUMA_16_PIPELINE
		printf("luma cost=%lld\n", cost_best);
#endif
	}
}
#endif // !LUMA_8x16_PIPELINE_DUMMY

#if !LUMA_16x8_PIPELINE_DUMMY
void rdo_luma_16_8_pipeline(u8 all_rdo_num, U8 w, U8 h, pel orgY[16 * 16], pel orgY_nz[16][16], pel org_diff[16][16], U1 valid_mode[17], u8 ipred_list[5], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16 avail_tb, u8 rdo_list[MAX_RDO_NUM_SIZE(16, 8)], u8 inter_rdo_num,
	RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, U2 tree_status, MD_COM_MODE_BEST_16* best_info_ptr_16, MD_INPUT* md_input_ptr,
#if ENABLE_BFRAME
	MV_DIR* mv_dir, strFetch_ref_window_16* Fetch_Ref_window_ptr,
#endif
	SKIP_ELEMENT skip_mode[MAX_SKIP_NUM], MERGE_RDO* merge_rdo, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2], U3 cu_width_log2, U3 cu_height_log2,
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16,
	U2 curr_cons_pred_mode,
	//pel fme2mdrefbuf[2560][8][2][16],
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[16][16], pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(16, 8) - 1][16][16], pel pred_y_intra[MAX_RDO_NUM_SIZE(16, 8)][16][16],
	MD_KERNEL_INPUT* md_kernel_input, u8 mpm[MAX_NUM_PB][2], U7 cu_width, int refp_ptr0, int refp_ptr1, U2 ch_type, s64 lambda, s64 cost_skip, s64* cost_best, U6 qp
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{

	w=16;
	h=8;
	cu_width_log2=4;
	cu_height_log2=3;
	cu_width=16;
#ifdef MD_CMOD
	for (rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
	{
#pragma HLS LOOP_TRIPCOUNT max=2
#elif USE_ENH
#if USE_EIPM_RMD
#if USE_SPEED_LEVEL
	int rdo_cnt = 5;
	if (md_input_ptr->speed_level == 1)
		rdo_cnt = IPD_RDO_CNT; //5
	else if (md_input_ptr->speed_level == 2)
		rdo_cnt = EXTRA_RDO_MODE;//10
	else
		rdo_cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
	int rdo_cnt = MAX_RDO_NUM_SIZE(16, 8);
#endif
	for (u8 rdo_idx = 0; rdo_idx < rdo_cnt; rdo_idx++)
#else
	for (u8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
#endif
	{
#pragma HLS LOOP_TRIPCOUNT max=5
#pragma HLS DATAFLOW
#else
	for (u8 rdo_idx = 0; rdo_idx < 5; rdo_idx++)
	{
#pragma HLS LOOP_TRIPCOUNT max=5
#endif
		U1 is_intra_quant, is_intra_rate, is_intra_update;
		s8 inter_mode_idx;
		u8 mode_type_nz, mode_type_rate, mode_type_update;
		u8 curr_mvr_rate, curr_mvr_update;
		U1 valid_flag;
		s32 dist_value;
		s64 flag_cost[2];
		s64 cost_best_temp;
		s64 dist_pred;
			s16 coef_tmp[16][16];
			s16 coef_tmp_h[16][16], coef_tmp_ith[16][16];
			s16 coef_tmp_v[16][16], coef_tmp_itv[16][16];
			pel pred_cache_nz[16][16], pred_cache_ith[16][16], pred_cache_update[16][16];
			int num_nz_rate[MAX_NUM_TB][N_C], num_nz_itv, num_nz_ith, num_nz_update[MAX_NUM_TB][N_C];
			s16 coef_pb_part[16][16], coef_update[16][16];
			pel rec[16][16];
			MD_KERNEL_MODE md_info_nz;
		u8 iUpdate, iQuant;
			pel pred_cache_for_diff[16][16];
			pel rec_for_update[16][16];
		s16  dst_for_itv[16][16];
		u8 /*num_refp_for_ip,*/ num_refp_for_diff, num_refp_for_rate;
		S8 mod_info_ipm_for_rate[4][2];
		u8 mod_info_mpm_for_rate[4][2];
		S8 mod_info_ipm_for_up[4][2];
		u8 mod_info_mpm_for_up[4][2];
		s16 mod_info_mvd_for_diff[2][2];
		s16 mod_info_mvd_for_rate[2][2];
		s16 mod_info_mvd_for_up[2][2];
		S3 mod_info_refi_for_diff[2];
		S3 mod_info_refi_for_rate[2];
		S3 mod_info_refi_for_up[2];
			s16 coef_tmp_h_for_ver[16][16];
			int num_nz_for_update[MAX_NUM_TB][N_C];
			s16 coef_tmp_for_ith[16][16];
		/*num_refp_for_ip = 0;
		num_refp_for_diff = 0;
		num_refp_for_rate = 0;*/
#if !AZB_ENABLE
		intra_inter_pred_16_8(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, 
			valid_mode, 
			mv_copy, mvd_copy, refi_copy, pred_y_inter1, pred_y_inter2, pred_y_intra,
			pred_cache_ith,pred_cache_for_diff, /*num_refp_for_ip,*/ &num_refp_for_diff, &num_refp_for_rate,
			&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
			md_fw_ptr,
			skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
			tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
			md_input_ptr->CtrPos2MD,
			mod_info_ipm_for_rate, mod_info_mpm_for_rate, mod_info_ipm_for_up, mod_info_mpm_for_up,
			mod_info_refi_for_diff, mod_info_refi_for_rate, mod_info_refi_for_up,
#if ENABLE_BFRAME
			md_input_ptr->CtrPos2MD_ref1, mv_dir, Fetch_Ref_window_ptr,
#endif // ENABLE_BFRAME
			//fme2mdrefbuf,
			md_kernel_input, mpm, &iQuant
#if SUB_TMVP
			, core_sbtmvp
#endif
#if USE_SPEED_LEVEL
			, md_input_ptr->speed_level
#endif

		);

		diff_ssd_bitcnt_16_8(md_fw_ptr, md_input_ptr, num_refp_for_diff,
			mode_type_nz, &md_info_nz, pred_cache_for_diff, pred_cache_update, mod_info_refi_for_diff,
			orgY_nz, &dist_pred, &cost_best_temp, mod_info_mvd_for_diff, mod_info_mvd_for_rate, mod_info_mvd_for_up,
			tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);

		transform_hor_16_8(w, h, md_fw_ptr->bit_depth_internal, coef_tmp, coef_tmp_h_for_ver, coef_tmp_h);
		transform_ver_16_8(w, h, md_fw_ptr->bit_depth_internal, coef_tmp_h_for_ver,/* coef_tmp_h,*/ coef_tmp_v);

		quant_nnz_16_8_luma(num_nz_rate, &num_nz_itv, w, h, rdoq_array, md_fw_ptr->bit_depth_internal, qp, lambda,
			is_intra_quant, &is_intra_rate, coef_tmp_v, dst_for_itv, coef_tmp_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr->slice_type,
			coef_pb_part, coef_update, iQuant, &iUpdate);

		rate_est_16_8(w, h, md_fw_ptr, mod_info_refi_for_rate, mod_info_mvd_for_rate, num_refp_for_rate, mod_info_ipm_for_rate, mod_info_mpm_for_rate, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
			flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);

		inv_transform_ver_16_8(w, h, md_fw_ptr->bit_depth_internal, qp, num_nz_itv, &num_nz_ith, num_nz_update,/*coef_tmp_itv,*/ dst_for_itv, coef_tmp_ith, coef_tmp_for_ith,
			cu_width_log2, cu_height_log2);
		inv_transform_hor_16_8(w, h, md_fw_ptr->bit_depth_internal, num_nz_ith, md_info_nz.tb_part, cu_width_log2, cu_height_log2, pred_cache_ith, 
			&dist_value, rec, rec_for_update, /*coef_tmp_for_ith,*/coef_tmp_ith, ch_type, org_diff);

		update_rdo_luma_16_8(valid_flag, w, h, mod_info_mvd_for_up,
			cu_data_temp_ptr_16, mod_info_ipm_for_up, mod_info_mpm_for_up,
			&md_info_nz, best_info_ptr_16, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
			mode_type_update, is_intra_update, curr_mvr_update,
			rec,/*rec_for_update, */pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate
#if SUB_TMVP
			, core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
			, md_input_ptr->valid_mode_config
#endif
		);

#if SET_MD_16_MAX_COST
		* cost_best = 1 << 25;
#endif
#else
		if (md_fw_ptr->slice_type == 1)  // I_slice
		{
			intra_inter_pred_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, valid_mode, pred_cache_nz, pred_cache_ith,
				&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
				md_fw_ptr,
				RefWindowLCU, CtrPos,
#if ENABLE_BFRAME
				RefWindowLCU_ref1, CtrPos_ref1, mv_dir, refwin_md_ref1, CtrPosFME_ref1, Fetch_Ref_window_ptr,
#endif
				skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
				tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
				refwin_md, CtrPosFME, md_kernel_input, mpm, &iQuant);

			diff_ssd_bitcnt_16(model_cnt, md_fw_ptr, md_input_ptr,
				mode_type_nz, &md_info_nz, pred_cache_nz, pred_cache_update,
				orgY_nz, &dist_pred, &cost_best_temp,
				tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);

			transform_hor_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp, coef_tmp_h);
			transform_ver_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp_h, coef_tmp_v);

			quant_nnz_16(num_nz_rate, num_nz_update, &num_nz_itv, w, h, model_cnt, rdoq_array, md_fw_ptr->bit_depth_internal, qp, lambda,
				is_intra_quant, &is_intra_rate, coef_tmp_v, coef_tmp_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr->slice_type, coef_pb_part, coef_update, iQuant, &iUpdate);

			rate_est_16(w, h, model_cnt, md_fw_ptr, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
				flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);

			inv_transform_ver_16(w, h, md_fw_ptr->bit_depth_internal, qp, num_nz_itv, &num_nz_ith, coef_tmp_itv, coef_tmp_ith, cu_width_log2, cu_height_log2);
			inv_transform_hor_16(w, h, md_fw_ptr->bit_depth_internal, num_nz_ith, md_info_nz.tb_part, cu_width_log2, cu_height_log2, pred_cache_ith, &dist_value, rec, coef_tmp_ith, ch_type, org_diff);

			update_rdo_luma_16(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz, best_info_ptr, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
				mode_type_update, is_intra_update, curr_mvr_update,
				rec, pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate);
		}
		else // p/b slice.
		{
			intra_inter_pred_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, valid_mode, pred_cache_nz, pred_cache_ith,
				&is_intra_rate, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
				md_fw_ptr,
				RefWindowLCU, CtrPos,
				skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
				tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
				refwin_md, CtrPosFME, md_kernel_input, mpm, &iUpdate);
			diff_ssd_bitcnt_16(model_cnt, md_fw_ptr, md_input_ptr,
				mode_type_nz, &md_info_nz, pred_cache_nz, pred_cache_update,
				orgY_nz, &dist_pred, &cost_best_temp,
				tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);
			for (int i = 0; i < 256; ++i)
			{
				coef_pb_part[i] = 0;
			}
			num_nz_rate[0][0] = 0;
			rate_est_azb_16(w, h, model_cnt, md_fw_ptr, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
				flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);
			dist_value = dist_pred;
			if (valid_flag == 1)
			{
				if (mode_type_nz == 1 || mode_type_nz == 0)
				{
					dist_pred = MAX_S64;
				}
			}
			update_rdo_luma_16(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz, best_info_ptr, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
				mode_type_update, is_intra_update, curr_mvr_update,
				pred_cache_update, pred_cache_update, coef_pb_part, num_nz_rate, md_kernel_input, cost_skip, iUpdate);
		}
#endif

#if DEBUG_LUMA_16_PIPELINE
		printf("luma cost=%lld\n", cost_best);
#endif
	}
}
#endif // !LUMA_16x8_PIPELINE_DUMMY

#if !LUMA_16x16_PIPELINE_DUMMY
void rdo_luma_16_16_pipeline(u8 all_rdo_num, U8 w, U8 h, pel orgY[16 * 16], pel orgY_nz[16][16], pel org_diff[16][16], U1 valid_mode[17], u8 ipred_list[5], pel src_le_temp[2 * 16 + 3], pel src_up_temp[2 * 16 + 3], u16 avail_tb, u8 rdo_list[5], u8 inter_rdo_num,
	RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, U2 tree_status, MD_COM_MODE_BEST_16* best_info_ptr_16, MD_INPUT* md_input_ptr,
#if ENABLE_BFRAME
	MV_DIR* mv_dir, strFetch_ref_window_16* Fetch_Ref_window_ptr,
#endif
	SKIP_ELEMENT skip_mode[MAX_SKIP_NUM], MERGE_RDO* merge_rdo, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2], U3 cu_width_log2, U3 cu_height_log2,
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_temp_ptr_16,
	U2 curr_cons_pred_mode,
	//pel fme2mdrefbuf[2560][8][2][16],
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[16][16], pel pred_y_inter2[2][16][16], pel pred_y_intra[5][16][16],
	MD_KERNEL_INPUT* md_kernel_input, u8 mpm[MAX_NUM_PB][2], U7 cu_width, int refp_ptr0, int refp_ptr1, U2 ch_type, s64 lambda, s64 cost_skip, s64 cost_best[1], U6 qp
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{
#pragma HLS resource variable=cost_best core=RAM_1P_BRAM 

#pragma HLS resource variable=mv_copy core=RAM_1P_BRAM 
#pragma HLS resource variable=mvd_copy core=RAM_1P_BRAM 
#pragma HLS resource variable=orgY core=RAM_1P_BRAM 
#pragma HLS resource variable=orgY_nz core=RAM_1P_BRAM 
#pragma HLS resource variable=org_diff core=RAM_1P_BRAM 
#pragma HLS resource variable=pred_y_intra core=RAM_1P_BRAM  
#pragma HLS resource variable=rdo_list core=RAM_1P_BRAM 
#pragma HLS resource variable=refi_copy core=RAM_1P_BRAM 
#pragma HLS resource variable=valid_mode core=RAM_1P_BRAM 

#pragma HLS RESOURCE variable=skip_rdo_mode->skip_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->skip_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->affine_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->mvp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->refi core=RAM_1P_BRAM



#ifdef MD_CMOD
	for (rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
	{
#pragma HLS LOOP_TRIPCOUNT max=2
#elif USE_ENH
#if USE_EIPM_RMD
#if USE_SPEED_LEVEL
	int rdo_cnt = 5;
	if (md_input_ptr->speed_level == 1)
		rdo_cnt = IPD_RDO_CNT; //5
	else if (md_input_ptr->speed_level == 2)
		rdo_cnt = EXTRA_RDO_MODE;//10
	else
		rdo_cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
#if SIMPLE_MD
	int rdo_cnt = 1;
#else
	int rdo_cnt = 5;
#endif

#endif
	for (u8 rdo_idx = 0; rdo_idx < rdo_cnt; rdo_idx++)
#else
	for (u8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
#endif
	{
#pragma HLS LOOP_TRIPCOUNT max=5
#pragma HLS DATAFLOW
#else
	for (u8 rdo_idx = 0; rdo_idx < 5; rdo_idx++)
	{
#pragma HLS LOOP_TRIPCOUNT max=5
#pragma HLS DATAFLOW
#endif
		U1 is_intra_quant, is_intra_rate, is_intra_update;
		s8 inter_mode_idx;
		u8 mode_type_nz, mode_type_rate, mode_type_update;
		u8 curr_mvr_rate, curr_mvr_update;
		U1 valid_flag;
		s32 dist_value;
		s64 flag_cost[2];
		s64 cost_best_temp;
		s64 dist_pred;
		static s16 coef_tmp[16][16];
		static s16 coef_tmp_h[16][16];
		s16  coef_tmp_ith[16][16];
		static s16 coef_tmp_v[16][16], coef_tmp_itv[16][16];
		static pel pred_cache_nz[16][16], pred_cache_ith[16][16], pred_cache_update[16][16];
		static int num_nz_rate[MAX_NUM_TB][N_C], num_nz_itv, num_nz_ith, num_nz_update[MAX_NUM_TB][N_C];
		static s16 coef_pb_part[16][16], coef_update[16][16];
		static pel rec[16][16];
		static MD_KERNEL_MODE md_info_nz;
		u8 iUpdate, iQuant;
		static pel pred_cache_for_diff[16][16];
		static pel rec_for_update[16][16];
		s16  dst_for_itv[16][16];
		u8 num_refp_for_ip, num_refp_for_diff, num_refp_for_rate;
		S8 mod_info_ipm_for_rate[4][2];
		u8 mod_info_mpm_for_rate[4][2];
		S8 mod_info_ipm_for_up[4][2];
		u8 mod_info_mpm_for_up[4][2];
		s16 mod_info_mvd_for_diff[2][2];
		s16 mod_info_mvd_for_rate[2][2];
		s16 mod_info_mvd_for_up[2][2];
		S3 mod_info_refi_for_diff[2];
		S3 mod_info_refi_for_rate[2];
		S3 mod_info_refi_for_up[2];
		static s16 coef_tmp_h_for_ver[16][16];
		static int num_nz_for_update[MAX_NUM_TB][N_C];
		static s16 coef_tmp_for_ith[16][16];
		static s16 coef_tmp_for_th[16][16];
		w = 16;
		h = 16;
		cu_width_log2 = 4;
		cu_height_log2 = 4;
		num_refp_for_ip = 0;
		num_refp_for_diff = 0;
		num_refp_for_rate = 0;
#pragma HLS ARRAY_PARTITION variable=mod_info_mvd_for_diff complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mvd_for_rate complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_mvd_for_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_info_nz.mvd complete dim=0
#if !AZB_ENABLE
		intra_inter_pred_16_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, valid_mode, 
			mv_copy, mvd_copy, refi_copy, pred_y_inter1, pred_y_inter2, pred_y_intra,
			pred_cache_ith,
			pred_cache_for_diff, coef_tmp_for_th, num_refp_for_ip, &num_refp_for_diff, &num_refp_for_rate,
			&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
			md_fw_ptr,
			skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
			tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
			md_input_ptr->CtrPos2MD,
			mod_info_ipm_for_rate, mod_info_mpm_for_rate, mod_info_ipm_for_up, mod_info_mpm_for_up,
			mod_info_refi_for_diff, mod_info_refi_for_rate, mod_info_refi_for_up,
#if ENABLE_BFRAME
			md_input_ptr->CtrPos2MD_ref1, mv_dir, Fetch_Ref_window_ptr,
#endif // ENABLE_BFRAME
			//fme2mdrefbuf,
			md_kernel_input, mpm, &iQuant
#if SUB_TMVP
			, core_sbtmvp
#endif
#if USE_SPEED_LEVEL
			, md_input_ptr->speed_level
#endif

		);
#if	!SIMPLE_MD
		diff_ssd_bitcnt_16_16(md_fw_ptr, num_refp_for_diff, md_input_ptr,
			mode_type_nz, &md_info_nz, pred_cache_for_diff, pred_cache_update, mod_info_refi_for_diff,
			orgY_nz, &dist_pred, &cost_best_temp, mod_info_mvd_for_diff, mod_info_mvd_for_rate, mod_info_mvd_for_up,
			tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);
#else
		cost_best_temp = 0;
		dist_pred = 0;
#endif
		transform_hor_16_16(w, h, md_fw_ptr->bit_depth_internal, /*coef_tmp,*/ coef_tmp_for_th, coef_tmp_h_for_ver, coef_tmp_h);
		transform_ver_16_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp_h_for_ver, coef_tmp_v);

		quant_nnz_16_16_luma(num_nz_rate, &num_nz_itv, w, h, rdoq_array, md_fw_ptr->bit_depth_internal, qp, lambda,
			is_intra_quant, &is_intra_rate, coef_tmp_v, coef_tmp_itv, dst_for_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr->slice_type, coef_pb_part, coef_update, iQuant, &iUpdate);
#if	!SIMPLE_MD
		rate_est_16_16(w, h, md_fw_ptr, mod_info_refi_for_rate, mod_info_mvd_for_rate, num_refp_for_rate, mod_info_ipm_for_rate, mod_info_mpm_for_rate, 
			&md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
			flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);
#else
		curr_mvr_update = curr_mvr_rate;
		is_intra_update = is_intra_rate;
		mode_type_update = mode_type_rate;
#endif
		inv_transform_ver_16_16(w, h, md_fw_ptr->bit_depth_internal, qp, num_nz_itv, &num_nz_ith, num_nz_update, /*coef_tmp_itv, */dst_for_itv, coef_tmp_ith, coef_tmp_for_ith,cu_width_log2, cu_height_log2);
		//inv_transform_ver_16_16(w, h, md_fw_ptr->bit_depth_internal, qp, num_nz_itv, &num_nz_ith, num_nz_update, coef_tmp_itv, coef_tmp_ith, cu_width_log2, cu_height_log2);
		inv_transform_hor_16_16(w, h, md_fw_ptr->bit_depth_internal, num_nz_ith, md_info_nz.tb_part, cu_width_log2, cu_height_log2, pred_cache_ith, &dist_value, 
			rec, rec_for_update,/* coef_tmp_for_ith,*/coef_tmp_ith, ch_type, org_diff);

		update_rdo_luma_16_16(valid_flag, w, h, mod_info_mvd_for_up,
			cu_data_temp_ptr_16, mod_info_ipm_for_up, mod_info_mpm_for_up,
			&md_info_nz, best_info_ptr_16, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
			mode_type_update, is_intra_update, curr_mvr_update,
			///*rec,*/ rec_for_update, pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate
			rec, pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate
#if SUB_TMVP
			, core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
			, md_input_ptr->valid_mode_config
#endif
		);

#if SET_MD_16_MAX_COST
		cost_best[0] = 1 << 25;
#endif
#else
		if (md_fw_ptr->slice_type == 1)  // I_slice
		{
			intra_inter_pred_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, valid_mode, pred_cache_nz, pred_cache_ith,
				&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
				md_fw_ptr,
				RefWindowLCU, CtrPos,
#if ENABLE_BFRAME
				RefWindowLCU_ref1, CtrPos_ref1, mv_dir, refwin_md_ref1, CtrPosFME_ref1, Fetch_Ref_window_ptr,
#endif
				skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
				tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
				refwin_md, CtrPosFME, md_kernel_input, mpm, &iQuant);

			diff_ssd_bitcnt_16(model_cnt, md_fw_ptr, md_input_ptr,
				mode_type_nz, &md_info_nz, pred_cache_nz, pred_cache_update,
				orgY_nz, &dist_pred, &cost_best_temp,
				tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);

			transform_hor_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp, coef_tmp_h);
			transform_ver_16(w, h, md_fw_ptr->bit_depth_internal, coef_tmp_h, coef_tmp_v);

			quant_nnz_16(num_nz_rate, num_nz_update, &num_nz_itv, w, h, model_cnt, rdoq_array, md_fw_ptr->bit_depth_internal, qp, lambda,
				is_intra_quant, &is_intra_rate, coef_tmp_v, coef_tmp_itv, cu_width_log2, cu_height_log2, ch_type, md_fw_ptr->slice_type, coef_pb_part, coef_update, iQuant, &iUpdate);

			rate_est_16(w, h, model_cnt, md_fw_ptr, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
				flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);

			inv_transform_ver_16(w, h, md_fw_ptr->bit_depth_internal, qp, num_nz_itv, &num_nz_ith, coef_tmp_itv, coef_tmp_ith, cu_width_log2, cu_height_log2);
			inv_transform_hor_16(w, h, md_fw_ptr->bit_depth_internal, num_nz_ith, md_info_nz.tb_part, cu_width_log2, cu_height_log2, pred_cache_ith, &dist_value, rec, coef_tmp_ith, ch_type, org_diff);

			update_rdo_luma_16(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz, best_info_ptr, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
				mode_type_update, is_intra_update, curr_mvr_update,
				rec, pred_cache_update, coef_update, num_nz_update, md_kernel_input, cost_skip, iUpdate);
		}
		else // p/b slice.
		{
			intra_inter_pred_16(w, h, &curr_mvr_rate, &md_info_nz, orgY, &mode_type_nz, &mode_type_rate, &inter_mode_idx, coef_tmp, &valid_flag, valid_mode, pred_cache_nz, pred_cache_ith,
				&is_intra_rate, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
				md_fw_ptr,
				RefWindowLCU, CtrPos,
				skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
				tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all,
				refwin_md, CtrPosFME, md_kernel_input, mpm, &iUpdate);
			diff_ssd_bitcnt_16(model_cnt, md_fw_ptr, md_input_ptr,
				mode_type_nz, &md_info_nz, pred_cache_nz, pred_cache_update,
				orgY_nz, &dist_pred, &cost_best_temp,
				tree_status, curr_cons_pred_mode, inter_mode_idx, valid_mode, cu_width, md_kernel_input, refp_ptr0, refp_ptr1);
			for (int i = 0; i < 256; ++i)
			{
				coef_pb_part[i] = 0;
			}
			num_nz_rate[0][0] = 0;
			rate_est_azb_16(w, h, model_cnt, md_fw_ptr, &md_info_nz, mode_type_rate, &mode_type_update, curr_mvr_rate, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_pb_part, lambda, is_intra_rate, &is_intra_update,
				flag_cost, num_nz_rate, md_kernel_input, refp_ptr0, refp_ptr1);
			dist_value = dist_pred;
			if (valid_flag == 1)
			{
				if (mode_type_nz == 1 || mode_type_nz == 0)
				{
					dist_pred = MAX_S64;
				}
			}
			update_rdo_luma_16(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz, best_info_ptr, dist_pred, dist_value, cost_best_temp, cost_best, flag_cost,
				mode_type_update, is_intra_update, curr_mvr_update,
				pred_cache_update, pred_cache_update, coef_pb_part, num_nz_rate, md_kernel_input, cost_skip, iUpdate);
		}
#endif

#if DEBUG_LUMA_16_PIPELINE
		printf("luma cost=%lld\n", cost_best);
#endif
	}
}
#endif //!LUMA_16x16_PIPELINE_DUMMY

void get_ref_pel_2_8_16(U8 w, U8 h, u8 all_rdo_num, u8 rdo_list[MAX_RDO_NUM_SIZE(8, 16)], u8 intra_mode_list[IPRED_LIST_NUM], MD_COM_MODE * mod_info_curr,
	SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO * merge, strFetch_ref_window_16 * Fetch_Ref_window_ptr,
	S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], MD_FW * md_fw_ptr, MD_INPUT * md_input_ptr, s16 mvp_all[2][5][2], SKIP_RDO * skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo, int stride_org, MD_KERNEL_INPUT * md_kernel_input,
	U2 tree_status, u8 curr_cons_pred_mode,
	S14 sub_pel_mv[MV_D],
	pel src_le_temp[16 * 2 + 3], pel src_up_temp[16 * 2 + 3], u16 avail_tb
#if ENABLE_BFRAME
	, S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR * mv_dir
#endif
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp
#endif
	, S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_skip_inter[13][16][16], pel pred_y_intra[MAX_RDO_NUM_SIZE(8, 16)][16][16], pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(8, 16) - 1][16][16], Arbitor& ref)
{
	int pic_height = md_fw_ptr->pic_height_in_scu << 2;
	int pic_width = md_fw_ptr->pic_width_in_scu << 2;
	static MD_KERNEL_MODE mode_info_write;

	int valid_skip_num = 0;
	//get skip pred
	if (md_fw_ptr->slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA) {

	}
	else
	{
		for (int idx = 0; idx < SKIP_MODE_NUM + 1; ++idx)
		{
			if (idx < SKIP_MODE_NUM)
			{
				if (valid_skip_num < SKIP_MODE_NUM_SIZE(8, 16)) {
					SKIP_ELEMENT* mode = skip_mode + idx;

					if (mode->valid == 0) { continue; }

					mod_info_curr->cu_mode = MODE_SKIP;
					mod_info_curr->umve_flag = mode->umve_flag;
					mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
					mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
					mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
					mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
					mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
					mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
					mod_info_curr->mv[1][0] = 0;
					mod_info_curr->mv[1][1] = 0;
					mod_info_curr->refi[1] = -1;
#endif
					// skip index 1 and 2 for P slice
#if ENABLE_BFRAME
					if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
					if (mod_info_curr->refi[0] == -1) { continue; }
#endif
				}
			}
			else {
				mod_info_curr->cu_mode = MODE_INTER;
				s8 inter_mode_idx = rdo_list[0];
				static s16 mv_all[2][5][2];
				static int best_mv_uni_inner[2][4][2];
				u8 mode_type_write = 0;
				U2 curr_mvr_write = 0;
				int refi_cur = 0;
#if ENABLE_BFRAME
				u8 num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
#else
				u8 num_refp_cnt = md_fw_ptr->num_refp;

#endif
				if (inter_mode_idx < 17) {
					static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
					static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
					mode_type_write = mode_type_table[inter_mode_idx];
					curr_mvr_write = curr_mvr_table[inter_mode_idx];
					if (mode_type_write == 1) {
						BOOL res = analyze_me_uni_pred_8_16(md_fw_ptr, &mode_info_write, num_refp_cnt, curr_mvr_write, w, h,
							mvp_all, mv_all, best_mv_uni_inner,
							64, refi_cur, tree_status, curr_cons_pred_mode, sub_pel_mv,
							md_kernel_input
#if ENABLE_BFRAME
							, mv_dir
#endif
						);
#if ENABLE_BFRAME
						U1 lidx = mv_dir->lidx;
#else 
						U1 lidx = 0;
#endif					
						mv_copy[lidx][0] = mode_info_write.mv[lidx][0];
						mv_copy[lidx][1] = mode_info_write.mv[lidx][1];
						mvd_copy[lidx][0] = mode_info_write.mvd[lidx][0];
						mvd_copy[lidx][1] = mode_info_write.mvd[lidx][1];
						refi_copy[0] = mode_info_write.refi[0];
						refi_copy[1] = mode_info_write.refi[1];
					}
				}
			}
			// calc pred info
			if (idx < SKIP_MODE_NUM) {
				if (valid_skip_num < SKIP_MODE_NUM_SIZE(8, 16))
				{
					CU_POS cu = { (int)mod_info_curr->scup, mod_info_curr->x_pos, mod_info_curr->y_pos, mod_info_curr->cu_width, mod_info_curr->cu_height };
					BOOL res = com_mc_cu_y_8_16(&cu, pic_width, pic_height, mod_info_curr->refi, mod_info_curr->mv,
						SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
						CtrPos2MD
#if ENABLE_BFRAME
						, CtrPosSKIP_ref1
#endif // ENABLE_BFRAME
						, ref
						, MODE_SKIP
#if SUB_TMVP
						, core_sbtmvp, idx, mod_info_curr->umve_flag
#endif	
					);

					if (res != FALSE)
						valid_skip_num++;
				}
			}
			else {
				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };
				BOOL res = com_mc_cu_y_8_16(&cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
					SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
					CtrPos2MD
#if ENABLE_BFRAME
					, CtrPosSKIP_ref1
#endif // ENABLE_BFRAME
					, ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
					, core_sbtmvp, idx, mod_info_curr->umve_flag
#endif	
				);
			}

		}
	}

	//get inter_pred
	U8 mode_list[MAX_INTER_SKIP_RDO] = { 0 };
	for (int i = 0, j = 0; i < 12 && j < 4; ++i) {
		if (skip_mode[i].valid && (skip_mode[i].refi[REFP_0] >= 0 || REFI_IS_VALID(skip_mode[i].refi[REFP_1])))
		{
			mode_list[j++] = i;
		}
	}
	for (U8 rdo_idx = 1; rdo_idx < MAX_RDO_NUM_INTER_SIZE(8, 16); rdo_idx++) {

		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;
		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 1) {
			if (inter_mode_idx < skip_rdo->num_rdo) {
				int skip_idx = inter_mode_idx;
				if (rdo_idx == 1) {
					for (int j = 0; j < 16; j++) {
						for (int k = 0; k < 16; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
					continue;
				}
				if (rdo_idx == 2) {
					for (int j = 0; j < 16; j++) {
						for (int k = 0; k < 16; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
					continue;
				}
			}
		}
	}

	for (U8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {

		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;

		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 0) {
			if (intra_mode_idx == 12)
				Ipred_vert_8_16_pred(w, h, src_up_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 24)
				Ipred_hor_8_16_pred(w, h, src_le_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 0)
				Ipred_dc_8_16_pred(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, avail_tb, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 1)
				Ipred_plane_8_16_pred(w, h, src_le_temp + 2, src_up_temp + 2, md_fw_ptr->bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 2)
				Ipred_bi_8_16_pred(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
				ipred_ang1_8_16_pred(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, md_fw_ptr->mipf_enable_flag
#endif
				);
			else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
				ipred_ang2_8_16_pred(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, md_fw_ptr->mipf_enable_flag
#endif
				);
			else
			{
#if EIPM

				if (intra_mode_idx > 33)
				{
					ipred_ang_eipm_8_16_pred(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
#if MIPF
						, 1, md_fw_ptr->mipf_enable_flag, md_fw_ptr->bit_depth_internal, pred_y_intra[rdo_idx]
#endif
					);

				}
				else
#endif
					ipred_ang3_8_16_pred(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
						, 1, md_fw_ptr->mipf_enable_flag
#endif
					);
			}
		}
	}
}
void get_ref_pel_2_16_8(U8 w, U8 h, u8 all_rdo_num, u8 rdo_list[MAX_RDO_NUM_SIZE(16, 8)], u8 intra_mode_list[IPRED_LIST_NUM], MD_COM_MODE * mod_info_curr,
	SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO * merge, strFetch_ref_window_16 * Fetch_Ref_window_ptr,
	S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], MD_FW * md_fw_ptr, MD_INPUT * md_input_ptr, s16 mvp_all[2][5][2], SKIP_RDO * skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo, int stride_org, MD_KERNEL_INPUT * md_kernel_input,
	U2 tree_status, u8 curr_cons_pred_mode,
	S14 sub_pel_mv[MV_D],
	pel src_le_temp[16 * 2 + 3], pel src_up_temp[16 * 2 + 3], u16 avail_tb
#if ENABLE_BFRAME
	, S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR * mv_dir
#endif
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp
#endif
	, S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_skip_inter[13][16][16], pel pred_y_intra[MAX_RDO_NUM_SIZE(16, 8)][16][16], pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(16, 8) - 1][16][16], Arbitor& ref)
{
	int pic_height = md_fw_ptr->pic_height_in_scu << 2;
	int pic_width = md_fw_ptr->pic_width_in_scu << 2;
	static MD_KERNEL_MODE mode_info_write;

	int valid_skip_num = 0;
	//get skip pred
	if (md_fw_ptr->slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA) {

	}
	else
	{
		for (int idx = 0; idx < SKIP_MODE_NUM + 1; ++idx)
		{
			if (idx < SKIP_MODE_NUM)
			{
				if (valid_skip_num < SKIP_MODE_NUM_SIZE(16, 8))
				{
					SKIP_ELEMENT* mode = skip_mode + idx;

					if (mode->valid == 0) { continue; }

					mod_info_curr->cu_mode = MODE_SKIP;
					mod_info_curr->umve_flag = mode->umve_flag;
					mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
					mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
					mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
					mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
					mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
					mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
					mod_info_curr->mv[1][0] = 0;
					mod_info_curr->mv[1][1] = 0;
					mod_info_curr->refi[1] = -1;
#endif
					// skip index 1 and 2 for P slice
#if ENABLE_BFRAME
					if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
					if (mod_info_curr->refi[0] == -1) { continue; }
#endif
				}
			}
			else {
				mod_info_curr->cu_mode = MODE_INTER;
				s8 inter_mode_idx = rdo_list[0];
				static s16 mv_all[2][5][2];
				static int best_mv_uni_inner[2][4][2];
				u8 mode_type_write = 0;
				U2 curr_mvr_write = 0;
				int refi_cur = 0;
#if ENABLE_BFRAME
				u8 num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
#else
				u8 num_refp_cnt = md_fw_ptr->num_refp;

#endif
				if (inter_mode_idx < 17) {
					static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
					static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
					mode_type_write = mode_type_table[inter_mode_idx];
					curr_mvr_write = curr_mvr_table[inter_mode_idx];
					if (mode_type_write == 1) {
						BOOL res = analyze_me_uni_pred_16_8(md_fw_ptr, &mode_info_write, num_refp_cnt, curr_mvr_write, w, h,
							mvp_all, mv_all, best_mv_uni_inner,
							64, refi_cur, tree_status, curr_cons_pred_mode, sub_pel_mv,
							md_kernel_input
#if ENABLE_BFRAME
							, mv_dir
#endif
						);
#if ENABLE_BFRAME
						U1 lidx = mv_dir->lidx;
#else 
						U1 lidx = 0;
#endif					
						mv_copy[lidx][0] = mode_info_write.mv[lidx][0];
						mv_copy[lidx][1] = mode_info_write.mv[lidx][1];
						mvd_copy[lidx][0] = mode_info_write.mvd[lidx][0];
						mvd_copy[lidx][1] = mode_info_write.mvd[lidx][1];
						refi_copy[0] = mode_info_write.refi[0];
						refi_copy[1] = mode_info_write.refi[1];
					}
				}
			}
			// calc pred info
			if (idx < SKIP_MODE_NUM) {
				if (valid_skip_num < SKIP_MODE_NUM_SIZE(16, 8))
				{
					CU_POS cu = { (int)mod_info_curr->scup, mod_info_curr->x_pos, mod_info_curr->y_pos, mod_info_curr->cu_width, mod_info_curr->cu_height };
					BOOL res = com_mc_cu_y_16_8(&cu, pic_width, pic_height, mod_info_curr->refi, mod_info_curr->mv,
						SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
						CtrPos2MD
#if ENABLE_BFRAME
						, CtrPosSKIP_ref1
#endif // ENABLE_BFRAME
						, ref
						, mod_info_curr->cu_mode
#if SUB_TMVP
						, core_sbtmvp, idx, mod_info_curr->umve_flag
#endif	
					);

					if (res != FALSE)
						valid_skip_num++;
				}
			}
			else {
				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };
				BOOL res1 = com_mc_cu_y_16_8(&cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
					SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
					CtrPos2MD,
					CtrPosSKIP_ref1,
					ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
					, core_sbtmvp, mode_info_write.skip_idx, mode_info_write.umve_flag
#endif
				);
			}
		}
	}

//get inter_pred
	U8 mode_list[MAX_INTER_SKIP_RDO] = { 0 };
	for (int i = 0, j = 0; i < 12 && j < 4; ++i) {
		if (skip_mode[i].valid && (skip_mode[i].refi[REFP_0] >= 0 || REFI_IS_VALID(skip_mode[i].refi[REFP_1])))
		{
			mode_list[j++] = i;
		}
	}
	for (U8 rdo_idx = 1; rdo_idx < MAX_RDO_NUM_INTER_SIZE(16, 8); rdo_idx++) {

		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;
		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 1) {
			if (inter_mode_idx < skip_rdo->num_rdo) {
				int skip_idx = inter_mode_idx;
				if (rdo_idx == 1) {
					for (int j = 0; j < 16; j++) {
						for (int k = 0; k < 16; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
					continue;
				}
				if (rdo_idx == 2) {
					for (int j = 0; j < 16; j++) {
						for (int k = 0; k < 16; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
					continue;
				}
			}
		}
	}


	for (U8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {

		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;

		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 0) {
			if (intra_mode_idx == 12)
				Ipred_vert_16_8_pred(w, h, src_up_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 24)
				Ipred_hor_16_8_pred(w, h, src_le_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 0)
				Ipred_dc_16_8_pred(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, avail_tb, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 1)
				Ipred_plane_16_8_pred(w, h, src_le_temp + 2, src_up_temp + 2, md_fw_ptr->bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 2)
				Ipred_bi_16_8_pred(w, h, src_le_temp + 3, src_up_temp + 3, md_fw_ptr->bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
				ipred_ang1_16_8_pred(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, md_fw_ptr->mipf_enable_flag
#endif
				);
			else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
				ipred_ang2_16_8_pred(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, md_fw_ptr->mipf_enable_flag
#endif
				);
			else
			{
#if EIPM

				if (intra_mode_idx > 33)
				{
					ipred_ang_eipm_16_8_pred(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
#if MIPF
						, 1, md_fw_ptr->mipf_enable_flag, md_fw_ptr->bit_depth_internal, pred_y_intra[rdo_idx]
#endif
					);

				}
				else
#endif
					ipred_ang3_16_8_pred(w, h, src_le_temp, src_up_temp, md_fw_ptr->bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
						, 1, md_fw_ptr->mipf_enable_flag
#endif
					);
			}
		}
	}
}

void get_ref_inter_16_16(u8 w, u8 h,MD_FW * md_fw_ptr, u8 curr_cons_pred_mode, SKIP_ELEMENT skip_mode[SKIP_MODE_NUM],  MD_COM_MODE * mod_info_curr,
		u8 rdo_list[5], MV_DIR * mv_dir, s16 mvp_all[2][5][2], U2 tree_status, S14 sub_pel_mv[MV_D], MD_KERNEL_INPUT * md_kernel_input, SKIP_RDO * skip_rdo,
		S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_skip_inter[13][16][16], strFetch_ref_window_16 * Fetch_Ref_window_ptr,
		S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],  Arbitor& ref, pel pred_y_inter2[2][16][16], CORE_SBTMVP * core_sbtmvp)
{
	int pic_height = md_fw_ptr->pic_height_in_scu << 2;
	int pic_width = md_fw_ptr->pic_width_in_scu << 2;
	static MD_KERNEL_MODE mode_info_write;

#pragma HLS ARRAY_PARTITION variable=pred_y_inter2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_inter2 complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred_y_skip_inter complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip_inter complete dim=3
#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0

#pragma HLS ARRAY_PARTITION variable=skip_mode complete dim=0
#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP complete dim=0
#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP_ref1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->refi complete dim=0
//#pragma HLS ARRAY_PARTITION variable=mvd_copy complete dim=0
#pragma HLS ARRAY_PARTITION variable=refi_copy complete dim=0
	//get skip pred
	if (!(md_fw_ptr->slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA)) {
		for (int idx = 0; idx < SKIP_MODE_NUM + 1; ++idx)
		{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT max=13
			if (idx < SKIP_MODE_NUM)
			{
				SKIP_ELEMENT* mode = skip_mode + idx;

				if (mode->valid == 0) { continue; }
#pragma HLS ARRAY_PARTITION variable=mode->mvp complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode->refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->refi complete dim=0
				mod_info_curr->cu_mode = MODE_SKIP;
				mod_info_curr->umve_flag = mode->umve_flag;
				mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
				mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
				mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
				mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
				mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
				mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
				mod_info_curr->mv[1][0] = 0;
				mod_info_curr->mv[1][1] = 0;
				mod_info_curr->refi[1] = -1;
#endif
				// skip index 1 and 2 for P slice
#if ENABLE_BFRAME
				if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
				if (mod_info_curr->refi[0] == -1) { continue; }
#endif
			}
			else {
				mod_info_curr->cu_mode = MODE_INTER;
				s8 inter_mode_idx = rdo_list[0];
				static s16 mv_all[2][5][2];
				static int best_mv_uni_inner[2][4][2];
#pragma HLS ARRAY_PARTITION variable=mv_all complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_mv_uni_inner complete dim=0
				u8 mode_type_write = 0;
				U2 curr_mvr_write = 0;
				int refi_cur = 0;
#if ENABLE_BFRAME
				u8 num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
#else
				u8 num_refp_cnt = md_fw_ptr->num_refp;

#endif
				if (inter_mode_idx < 17) {
					static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
					static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
					mode_type_write = mode_type_table[inter_mode_idx];
					curr_mvr_write = curr_mvr_table[inter_mode_idx];
					if (mode_type_write == 1) {
						BOOL res = analyze_me_uni_pred_16_16(md_fw_ptr, &mode_info_write, num_refp_cnt, curr_mvr_write, w, h,
							mvp_all, mv_all, best_mv_uni_inner,
							64, refi_cur, tree_status, curr_cons_pred_mode, sub_pel_mv, 
							md_kernel_input
#if ENABLE_BFRAME
							, mv_dir
#endif
						);
#if ENABLE_BFRAME
						U1 lidx = mv_dir->lidx;
#else 
						U1 lidx = 0;
#endif					
						mv_copy[lidx][0] = mode_info_write.mv[lidx][0];
						mv_copy[lidx][1] = mode_info_write.mv[lidx][1];
						mvd_copy[lidx][0] = mode_info_write.mvd[lidx][0];
						mvd_copy[lidx][1] = mode_info_write.mvd[lidx][1];
						refi_copy[0] = mode_info_write.refi[0];
						refi_copy[1] = mode_info_write.refi[1];
					}
				}
			}

			// calc pred info
			if (idx < SKIP_MODE_NUM) {
				CU_POS cu = { (int)mod_info_curr->scup, mod_info_curr->x_pos, mod_info_curr->y_pos, mod_info_curr->cu_width, mod_info_curr->cu_height };
				BOOL res = com_mc_cu_y_16_16(&cu, pic_width, pic_height, mod_info_curr->refi, mod_info_curr->mv,
					SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
					CtrPos2MD
#if ENABLE_BFRAME
				, CtrPosSKIP_ref1
#endif // ENABLE_BFRAME
					, ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
				, core_sbtmvp, idx, mod_info_curr->umve_flag
#endif	
				);
			}
			else {
				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };
				BOOL res = com_mc_cu_y_16_16(&cu, pic_width, pic_height, mode_info_write.refi, mode_info_write.mv,
					SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
					CtrPos2MD
#if ENABLE_BFRAME
					, CtrPosSKIP_ref1
#endif // ENABLE_BFRAME
					, ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
					, core_sbtmvp, idx, mod_info_curr->umve_flag
#endif	
				);
			}
		}
	}

	//get inter pred
	U8 mode_list[MAX_INTER_SKIP_RDO];
#pragma HLS ARRAY_PARTITION variable=mode_list complete dim=0
	int j=0;
	for (int i = 0; i < 12; ++i) {
#pragma HLS PIPELINE
		if(j<4){
		if (skip_mode[i].valid && (skip_mode[i].refi[REFP_0] >= 0 || REFI_IS_VALID(skip_mode[i].refi[REFP_1])))
		{
			mode_list[j++] = i;
		}
		}
	}


	for (U8 rdo_idx = 1; rdo_idx < 3; rdo_idx++) {
#pragma HLS PIPELINE
		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
		}

		if (is_intra_write != 1) {
			if (inter_mode_idx < skip_rdo->num_rdo) {
				int skip_idx = inter_mode_idx;
				if (rdo_idx == 1 || rdo_idx == 2) {
					for (int j = 0; j < 16; j++) {
						for (int k = 0; k < 16; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
				}
			}
		}
	}
}

void get_ref_intra_16_16(u8 all_rdo_num, u8 rdo_list[5], u8 intra_mode_list[IPRED_LIST_NUM], pel src_le_temp[16 * 2 + 3], pel src_up_temp[16 * 2 + 3],
		pel pred_y_intra[5][16][16], U4 bit_depth_internal, int mipf_enable_flag, U8 w, U8 h, u16 avail_tb)
{

#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=intra_mode_list complete dim=0
#if SIMPLE_MD
	all_rdo_num = 1;
#endif // SIMPLE_MD
	for (U8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {

#pragma HLS LOOP_TRIPCOUNT max=5
		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;

		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}
#if SIMPLE_MD
		intra_mode_idx = 0;
		intra_mode_list[0] = intra_mode_list[1] = intra_mode_list[2] = intra_mode_list[3] = intra_mode_list[4] = 0;
#endif // SIMPLE_MD

		if (is_intra_write != 0) {
#if !SIMPLE_MD
			if (intra_mode_idx == 12)
				Ipred_vert_16_16_pred(w, h, src_up_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 24)
				Ipred_hor_16_16_pred(w, h, src_le_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 0)
				Ipred_dc_16_16_pred(w, h, src_le_temp + 3, src_up_temp + 3, bit_depth_internal, avail_tb, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 1)
				Ipred_plane_16_16_pred(w, h, src_le_temp + 2, src_up_temp + 2, bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 2)
				Ipred_bi_16_16_pred(w, h, src_le_temp + 3, src_up_temp + 3, bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
				ipred_ang1_16_16_pred(w, h, src_le_temp, src_up_temp, bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, mipf_enable_flag
#endif
				);
			else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
				ipred_ang2_16_16_pred(w, h, src_le_temp, src_up_temp, bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, mipf_enable_flag
#endif
				);
			else if (intra_mode_idx >= 13 && intra_mode_idx <= 23) {
				ipred_ang3_16_16_pred(w, h, src_le_temp, src_up_temp, bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
				#if MIPF
										, 1, mipf_enable_flag
				#endif
				);
			}
#if EIPM
			else
				ipred_ang_eipm_16_16_pred(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
#if MIPF
					, 1, mipf_enable_flag, bit_depth_internal, pred_y_intra[rdo_idx]
#endif
				);
#endif
#else
			Ipred_dc_16_16_pred(w, h, src_le_temp + 3, src_up_temp + 3, bit_depth_internal, avail_tb, pred_y_intra[rdo_idx]);
#endif
		}
	}
}

void get_ref_pel_2_16_16(U8 w, U8 h, u8 all_rdo_num, u8 rdo_list[5], u8 intra_mode_list[IPRED_LIST_NUM], MD_COM_MODE * mod_info_curr,
	SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO * merge, strFetch_ref_window_16 * Fetch_Ref_window_ptr,
	S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], MD_FW * md_fw_ptr, MD_INPUT * md_input_ptr, s16 mvp_all[2][5][2], SKIP_RDO * skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo, int stride_org, MD_KERNEL_INPUT * md_kernel_input,
	U2 tree_status, u8 curr_cons_pred_mode,
	S14 sub_pel_mv[MV_D],
	pel src_le_temp[16 * 2 + 3], pel src_up_temp[16 * 2 + 3], u16 avail_tb
#if ENABLE_BFRAME
	, S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR * mv_dir
#endif
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp
#endif
	, S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_skip_inter[13][16][16], pel pred_y_intra[5][16][16], pel pred_y_inter2[2][16][16], Arbitor& ref)
{
	U4 bit_depth_internal = md_fw_ptr->bit_depth_internal;
	int mipf_enable_flag = md_fw_ptr->mipf_enable_flag;
	u8 rdo_list_intra[5];
#pragma HLS ARRAY_PARTITION variable=rdo_list_intra complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0

	for(int i=0;i<5;i++)
#pragma HLS UNROLL
		rdo_list_intra[i] = rdo_list[i];

	u8 w_cp = w;
	u8 h_cp = h;
#if !SIMPLE_MD
	get_ref_inter_16_16(w,h,md_fw_ptr, curr_cons_pred_mode, skip_mode, mod_info_curr,
			rdo_list, mv_dir, mvp_all, tree_status, sub_pel_mv, md_kernel_input, skip_rdo,
			mv_copy, mvd_copy, refi_copy, pred_y_skip_inter, Fetch_Ref_window_ptr,
			CtrPos2MD, CtrPosSKIP_ref1,  ref, pred_y_inter2, core_sbtmvp);
#endif
	get_ref_intra_16_16(all_rdo_num, rdo_list_intra, intra_mode_list, src_le_temp, src_up_temp,
			pred_y_intra, bit_depth_internal, mipf_enable_flag, w_cp, h_cp, avail_tb);
}


s64 rdo_luma_8_16(U1 isNS_allow, U8 w, U8 h, RDOQ_ARRAY * rdoq_array, MD_FW * md_fw_ptr,
	ENC_ME_LINE_MAP_SIZE<16>*me_line_map_ptr_16,
	ENC_ME_NEB_INFO up_nebs[1 + (16 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(16 >> 2)],
	SKIP_MERGE_INPUT_16 * skip_in_16,
	U2 tree_status, MD_COM_MODE_BEST_16 * best_info_ptr_16, MD_INPUT * md_input_ptr, pel p_fenc_LCU_Y[16][16],
#if ENABLE_BFRAME
	ME_MV_DIR_16 * me_mv_dir,
#endif
	MD_COM_MODE * mod_info_curr_ptr,
	ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_temp_ptr_16,
	U2 curr_cons_pred_mode, U9 cup, U3 qt_depth,
	ENC_FME_INFO_ALL_16 * fme_mv_info,
	u8 rmd_mode[IPRED_LIST_NUM],
	IP_ARRAY_SIZE<16, 16>*IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>*IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>*IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>*MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>*MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>*MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>*IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>*IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>*IP_map_scu_ptr_16x8,
	Arbitor& ref,
	MD_KERNEL_INPUT * md_kernel_input, strFetch_ref_window_16 * Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp, SKIP_MERGE_INPUT * skip_in
#endif
)
{
	if (!isNS_allow)
		return 0;
	U4 bit_depth = md_fw_ptr->bit_depth_internal;
	s64 cost_skip = MAX_S64;
	U3 cu_width_log2 = mod_info_curr_ptr[0].cu_width_log2;
	U3 cu_height_log2 = mod_info_curr_ptr[0].cu_height_log2;
	U7 cu_width = (1 << cu_width_log2);
	U7 cu_height = (1 << cu_height_log2);
	U1 emvr_enable_flag = 1;
	U1 amvr_enable_flag = 1;

	U14 sub_x = mod_info_curr_ptr[0].x_pos;
	U14 sub_y = mod_info_curr_ptr[0].y_pos;

	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;

	//int i = 0;
	int j = 0;
	int k = 0;
	static U1 valid_mode[17]; //only mode1: 9,10,11,12,13 is valid  //{SKIP:0,1,2,3;Skip_Merge:4,5,6,7,8;Mode1:9,10,11,12,13;Mode2:14,15,16};    //{Mode 0:(skip mode:fix 4, skip_merger:0~5), Mode1:(ME:AMVR:FIX 1/5); Mode 2(AFF_ME::FIX 1/3)
	int bit_cnt = 0;

	static pel orgY[16 * 16], orgY_nz[16 * 16], orgY_diff[16][16], orgY_16[16][16];
	for (int i = 0; i < cu_height; i++)
#pragma HLS LOOP_TRIPCOUNT max=16
		for (int j = 0; j < cu_width; j++)
		{
#pragma HLS LOOP_TRIPCOUNT max=16
			pel org = p_fenc_LCU_Y[i][j];
			orgY[(i << 4) + j] = org;
			orgY_nz[(i << 4) + j] = org;
			orgY_diff[i][j] = org;
			orgY_16[i][j] = org;
		}
	int refp_ptr0 = md_fw_ptr->refp_ptr[0][0];
	int refp_ptr1 = md_fw_ptr->refp_ptr[0][1];

	s64 lambda = md_input_ptr->lambda_y;

	u8 ipred_list[IPRED_LIST_NUM];
	static pel src_le_temp[2 * 16 + 3];
	static pel src_up_temp[2 * 16 + 3];
	u16 avail_tb;

	u8 rdo_list[MAX_RDO_NUM_SIZE(8, 16)] = {}, inter_rdo_num = 0, intra_rdo_num[1] = { 0 };

	static SKIP_ELEMENT skip_mode[SKIP_MODE_NUM];
	static MERGE_RDO merge_rdo;
	static SKIP_RDO skip_rdo;
	static SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO];
	S14 sub_pel_mv[MV_D];
	static s16 mvp_all[2][5][2];

#if ENABLE_BFRAME
	MV_DIR mv_dir;
#endif
	rdo_prepare_8_16(md_fw_ptr,
		me_line_map_ptr_16,
		up_nebs, left_nebs,
		skip_in_16,
		mod_info_curr_ptr,
		&merge_rdo, md_input_ptr, valid_mode, amvr_enable_flag, fme_mv_info,
		IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
		MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
		IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
		cu_width_log2, cu_height_log2, ipred_list, src_le_temp, src_up_temp, &avail_tb, rmd_mode,
		qt_depth, 17,
		cu_width, cu_height,
#if ENABLE_BFRAME
		me_mv_dir, &mv_dir,
#endif
		orgY, tree_status, curr_cons_pred_mode,
		&inter_rdo_num, intra_rdo_num, rdo_list, skip_mode, &skip_rdo, skip_rdo_mode, sub_pel_mv, mvp_all, Fetch_Ref_window_ptr
#if SUB_TMVP
		, core_sbtmvp, skip_in
#endif
	);


	u8 all_rdo_num = inter_rdo_num + intra_rdo_num[0];

	static pel pred_y_skip_inter[13][16][16];
	static pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(8, 16) - 1][16][16];
	static pel pred_y_intra[MAX_RDO_NUM_SIZE(8, 16)][16][16];

	static S14 mv_copy[2][2];
	static s16 mvd_copy[2][2];
	static S3 refi_copy[2];
	get_ref_pel_2_16_16(w, h, all_rdo_num, rdo_list, ipred_list, mod_info_curr_ptr, skip_mode, &merge_rdo, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD, md_fw_ptr, md_input_ptr, mvp_all, &skip_rdo, skip_rdo_mode, merge_rdo, 64, md_kernel_input, tree_status,
		curr_cons_pred_mode, sub_pel_mv,
		src_le_temp, src_up_temp, avail_tb
#if ENABLE_BFRAME
		, md_input_ptr->CtrPos2MD_ref1, &mv_dir
#endif
#if SUB_TMVP
		, core_sbtmvp
#endif
		, mv_copy, mvd_copy, refi_copy, pred_y_skip_inter, pred_y_intra, pred_y_inter2, ref);


#ifdef MD_CMOD
#else
	rdo_skip_8_16(&cost_skip, best_info_ptr_16,
		cu_data_temp_ptr_16,
		mod_info_curr_ptr,
		orgY_16, skip_mode, &merge_rdo, md_fw_ptr->pic_width,
		md_fw_ptr->pic_height, md_fw_ptr->slice_type, tree_status, lambda, curr_cons_pred_mode, bit_depth, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD,
#if ENABLE_BFRAME
		md_input_ptr->CtrPos2MD_ref1,
#endif
		//fme2mdrefbuf
		pred_y_skip_inter
#if SUB_TMVP
		, cu_width, cu_height, core_sbtmvp
#endif
	);
#endif

	U2 ch_type = 0;
	s64 cost_best;
	U6 qp = md_input_ptr->qp_y;

	if (PATCH_MODE())
		cost_skip = MAX_S64;
#if USE_INTRA_REFRESH
	if (md_input_ptr->EncRefresh && md_fw_ptr->slice_type != SLICE_I)
	{
		if (md_input_ptr->RefreshMode == 0)
		{
			if (mod_info_curr_ptr->y_pos >= md_input_ptr->pirStartRow * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->y_pos < md_input_ptr->pirEndRow * 32 * md_input_ptr->RefreshSize)
				cost_best = MAX_S64;
		}
		else
		{
			if (mod_info_curr_ptr->x_pos >= md_input_ptr->pirStartCol * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->x_pos < md_input_ptr->pirEndCol * 32 * md_input_ptr->RefreshSize)
				cost_best = MAX_S64;
		}

	}
#endif
	rdo_luma_8_16_pipeline(all_rdo_num, w, h, orgY, orgY_16, orgY_diff, valid_mode, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, inter_rdo_num, rdoq_array, md_fw_ptr, tree_status,
		best_info_ptr_16, md_input_ptr,
#if ENABLE_BFRAME
		& mv_dir, Fetch_Ref_window_ptr,
#endif
		skip_mode, &merge_rdo, &skip_rdo, skip_rdo_mode, sub_pel_mv, mvp_all, cu_width_log2, cu_height_log2,
		cu_data_temp_ptr_16,
		curr_cons_pred_mode,
		//fme2mdrefbuf,
		mv_copy, mvd_copy, refi_copy, pred_y_skip_inter[12], pred_y_inter2, pred_y_intra,
		md_kernel_input, mod_info_curr_ptr->mpm, cu_width, refp_ptr0, refp_ptr1, ch_type, lambda, cost_skip, &cost_best, qp
#if SUB_TMVP
		, core_sbtmvp
#endif
	);

	return cost_best;
}
s64 rdo_luma_16_8(U1 isNS_allow, U8 w, U8 h, RDOQ_ARRAY * rdoq_array, MD_FW * md_fw_ptr,
	ENC_ME_LINE_MAP_SIZE<16>*me_line_map_ptr_16,
	ENC_ME_NEB_INFO up_nebs[1 + (16 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(16 >> 2)],
	SKIP_MERGE_INPUT_16 * skip_in_16,
	U2 tree_status, MD_COM_MODE_BEST_16 * best_info_ptr_16, MD_INPUT * md_input_ptr, pel p_fenc_LCU_Y[16][16],
#if ENABLE_BFRAME
	ME_MV_DIR_16 * me_mv_dir,
#endif
	MD_COM_MODE * mod_info_curr_ptr,
	ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_temp_ptr_16,
	U2 curr_cons_pred_mode, U9 cup, U3 qt_depth,
	ENC_FME_INFO_ALL_16 * fme_mv_info,
	u8 rmd_mode[IPRED_LIST_NUM],
	IP_ARRAY_SIZE<16, 16>*IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>*IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>*IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>*MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>*MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>*MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>*IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>*IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>*IP_map_scu_ptr_16x8,
	Arbitor& ref,
	MD_KERNEL_INPUT * md_kernel_input, strFetch_ref_window_16 * Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp, SKIP_MERGE_INPUT * skip_in
#endif
)
{
	if (!isNS_allow)
		return 0;
	U4 bit_depth = md_fw_ptr->bit_depth_internal;
	s64 cost_skip = MAX_S64;
	U3 cu_width_log2 = mod_info_curr_ptr[0].cu_width_log2;
	U3 cu_height_log2 = mod_info_curr_ptr[0].cu_height_log2;
	U7 cu_width = (1 << cu_width_log2);
	U7 cu_height = (1 << cu_height_log2);
	U1 emvr_enable_flag = 1;
	U1 amvr_enable_flag = 1;

	U14 sub_x = mod_info_curr_ptr[0].x_pos;
	U14 sub_y = mod_info_curr_ptr[0].y_pos;

	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;

	//int i = 0;
	int j = 0;
	int k = 0;
	static U1 valid_mode[17]; //only mode1: 9,10,11,12,13 is valid  //{SKIP:0,1,2,3;Skip_Merge:4,5,6,7,8;Mode1:9,10,11,12,13;Mode2:14,15,16};    //{Mode 0:(skip mode:fix 4, skip_merger:0~5), Mode1:(ME:AMVR:FIX 1/5); Mode 2(AFF_ME::FIX 1/3)
	int bit_cnt = 0;

	static pel orgY[16 * 16], orgY_nz[16 * 16], orgY_diff[16][16], orgY_16[16][16];
	for (int i = 0; i < cu_height; i++)
#pragma HLS LOOP_TRIPCOUNT max=16
		for (int j = 0; j < cu_width; j++)
		{
#pragma HLS LOOP_TRIPCOUNT max=16
			pel org = p_fenc_LCU_Y[i][j];
			orgY[(i << 4) + j] = org;
			orgY_nz[(i << 4) + j] = org;
			orgY_diff[i][j] = org;
			orgY_16[i][j] = org;
		}
	int refp_ptr0 = md_fw_ptr->refp_ptr[0][0];
	int refp_ptr1 = md_fw_ptr->refp_ptr[0][1];

	s64 lambda = md_input_ptr->lambda_y;

	u8 ipred_list[IPRED_LIST_NUM];
	static pel src_le_temp[2 * 16 + 3];
	static pel src_up_temp[2 * 16 + 3];
	u16 avail_tb;

	u8 rdo_list[MAX_RDO_NUM_SIZE(16, 8)] = {}, inter_rdo_num = 0, intra_rdo_num[1] = { 0 };

	static SKIP_ELEMENT skip_mode[SKIP_MODE_NUM];
	static MERGE_RDO merge_rdo;
	static SKIP_RDO skip_rdo;
	static SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO];
	S14 sub_pel_mv[MV_D];
	static s16 mvp_all[2][5][2];

#if ENABLE_BFRAME
	MV_DIR mv_dir;
#endif
	rdo_prepare_16_8(md_fw_ptr,
		me_line_map_ptr_16,
		up_nebs, left_nebs,
		skip_in_16,
		mod_info_curr_ptr,
		&merge_rdo, md_input_ptr, valid_mode, amvr_enable_flag, fme_mv_info,
		IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
		MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
		IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
		cu_width_log2, cu_height_log2, ipred_list, src_le_temp, src_up_temp, &avail_tb, rmd_mode,
		qt_depth, 17,
		cu_width, cu_height,
#if ENABLE_BFRAME
		me_mv_dir, &mv_dir,
#endif
		orgY, tree_status, curr_cons_pred_mode,
		&inter_rdo_num, intra_rdo_num, rdo_list, skip_mode, &skip_rdo, skip_rdo_mode, sub_pel_mv, mvp_all, Fetch_Ref_window_ptr
#if SUB_TMVP
		, core_sbtmvp, skip_in
#endif
	);


	u8 all_rdo_num = inter_rdo_num + intra_rdo_num[0];

	static pel pred_y_skip_inter[13][16][16];
	static pel pred_y_inter2[MAX_RDO_NUM_INTER_SIZE(16, 8) - 1][16][16];
	static pel pred_y_intra[MAX_RDO_NUM_SIZE(16, 8)][16][16];

	static S14 mv_copy[2][2];
	static s16 mvd_copy[2][2];
	static S3 refi_copy[2];
	get_ref_pel_2_16_16(w, h, all_rdo_num, rdo_list, ipred_list, mod_info_curr_ptr, skip_mode, &merge_rdo, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD, md_fw_ptr, md_input_ptr, mvp_all, &skip_rdo, skip_rdo_mode, merge_rdo, 64, md_kernel_input, tree_status,
		curr_cons_pred_mode, sub_pel_mv,
		src_le_temp, src_up_temp, avail_tb
#if ENABLE_BFRAME
		, md_input_ptr->CtrPos2MD_ref1, &mv_dir
#endif
#if SUB_TMVP
		, core_sbtmvp
#endif
		, mv_copy, mvd_copy, refi_copy, pred_y_skip_inter, pred_y_intra, pred_y_inter2, ref);


#ifdef MD_CMOD
#else
	rdo_skip_16_8(&cost_skip, best_info_ptr_16,
		cu_data_temp_ptr_16,
		mod_info_curr_ptr,
		orgY_16, skip_mode, &merge_rdo, md_fw_ptr->pic_width,
		md_fw_ptr->pic_height, md_fw_ptr->slice_type, tree_status, lambda, curr_cons_pred_mode, bit_depth, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD,
#if ENABLE_BFRAME
		md_input_ptr->CtrPos2MD_ref1,
#endif
		//fme2mdrefbuf
		pred_y_skip_inter
#if SUB_TMVP
		, cu_width, cu_height, core_sbtmvp
#endif
	);
#endif

	U2 ch_type = 0;
	s64 cost_best;
	U6 qp = md_input_ptr->qp_y;

	if (PATCH_MODE())
		cost_skip = MAX_S64;
#if USE_INTRA_REFRESH
	if (md_input_ptr->EncRefresh && md_fw_ptr->slice_type != SLICE_I)
	{
		if (md_input_ptr->RefreshMode == 0)
		{
			if (mod_info_curr_ptr->y_pos >= md_input_ptr->pirStartRow * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->y_pos < md_input_ptr->pirEndRow * 32 * md_input_ptr->RefreshSize)
				cost_best = MAX_S64;
		}
		else
		{
			if (mod_info_curr_ptr->x_pos >= md_input_ptr->pirStartCol * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->x_pos < md_input_ptr->pirEndCol * 32 * md_input_ptr->RefreshSize)
				cost_best = MAX_S64;
		}

	}
#endif
	rdo_luma_16_8_pipeline(all_rdo_num, w, h, orgY, orgY_16, orgY_diff, valid_mode, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, inter_rdo_num, rdoq_array, md_fw_ptr, tree_status,
		best_info_ptr_16, md_input_ptr,
#if ENABLE_BFRAME
		& mv_dir, Fetch_Ref_window_ptr,
#endif
		skip_mode, &merge_rdo, &skip_rdo, skip_rdo_mode, sub_pel_mv, mvp_all, cu_width_log2, cu_height_log2,
		cu_data_temp_ptr_16,
		curr_cons_pred_mode,
		//fme2mdrefbuf,
		mv_copy, mvd_copy, refi_copy, pred_y_skip_inter[12], pred_y_inter2, pred_y_intra,
		md_kernel_input, mod_info_curr_ptr->mpm, cu_width, refp_ptr0, refp_ptr1, ch_type, lambda, cost_skip, &cost_best, qp
#if SUB_TMVP
		, core_sbtmvp
#endif
	);

	return cost_best;
}
s64 rdo_luma_16_16(U1 isNS_allow, U8 w, U8 h, RDOQ_ARRAY * rdoq_array, MD_FW * md_fw_ptr,
	ENC_ME_LINE_MAP_SIZE<16>*me_line_map_ptr_16,
	ENC_ME_NEB_INFO up_nebs[1 + (16 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(16 >> 2)],
	SKIP_MERGE_INPUT_16 * skip_in_16,
	U2 tree_status, MD_COM_MODE_BEST_16 * best_info_ptr_16, MD_INPUT * md_input_ptr, pel p_fenc_LCU_Y[16][16],
#if ENABLE_BFRAME
	ME_MV_DIR_16 * me_mv_dir,
#endif
	MD_COM_MODE * mod_info_curr_ptr,
	ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_temp_ptr_16,
	U2 curr_cons_pred_mode, U9 cup, U3 qt_depth,
	ENC_FME_INFO_ALL_16 * fme_mv_info,
	u8 rmd_mode[IPRED_LIST_NUM],
	IP_ARRAY_SIZE<16, 16>*IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>*IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>*IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>*MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>*MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>*MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>*IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>*IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>*IP_map_scu_ptr_16x8,
	Arbitor& ref,
	MD_KERNEL_INPUT * md_kernel_input, strFetch_ref_window_16 * Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp, SKIP_MERGE_INPUT * skip_in
#endif
)
{
	if (!isNS_allow)
		return 0;
	U4 bit_depth = md_fw_ptr->bit_depth_internal;
	s64 cost_skip = MAX_S64;
	U3 cu_width_log2 = mod_info_curr_ptr[0].cu_width_log2;
	U3 cu_height_log2 = mod_info_curr_ptr[0].cu_height_log2;
	U7 cu_width = (1 << cu_width_log2);
	U7 cu_height = (1 << cu_height_log2);
	U1 emvr_enable_flag = 1;
	U1 amvr_enable_flag = 1;

	U14 sub_x = mod_info_curr_ptr[0].x_pos;
	U14 sub_y = mod_info_curr_ptr[0].y_pos;

	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;

	//int i = 0;
	int j = 0;
	int k = 0;
	static U1 valid_mode[17]; //only mode1: 9,10,11,12,13 is valid  //{SKIP:0,1,2,3;Skip_Merge:4,5,6,7,8;Mode1:9,10,11,12,13;Mode2:14,15,16};    //{Mode 0:(skip mode:fix 4, skip_merger:0~5), Mode1:(ME:AMVR:FIX 1/5); Mode 2(AFF_ME::FIX 1/3)
	int bit_cnt = 0;

	static pel orgY[16 * 16], orgY_nz[16 * 16], orgY_diff[16][16], orgY_16[16][16];
#pragma HLS ARRAY_PARTITION variable=p_fenc_LCU_Y complete dim=2
#pragma HLS ARRAY_PARTITION variable=org cyclic factor=16 dim=1
#pragma HLS ARRAY_PARTITION variable=orgY cyclic factor=16 dim=1 
#pragma HLS ARRAY_PARTITION variable=orgY_nz cyclic factor=16 dim=1
#pragma HLS ARRAY_PARTITION variable=orgY_diff cyclic factor=16 dim=2
#pragma HLS ARRAY_PARTITION variable=orgY_16 cyclic factor=16 dim=2
#pragma HLS ARRAY_PARTITION variable=orgY_16_0 cyclic factor=16 dim=2
	for (int i = 0; i < 16; i++)
	{
#pragma HLS LOOP_TRIPCOUNT max=16
 #pragma HLS PIPELINE
		for (int j = 0; j < 16; j++)
		{
#pragma HLS LOOP_TRIPCOUNT max=16
			pel org = p_fenc_LCU_Y[i][j];
			orgY[(i << 4) + j] = org;
			orgY_nz[(i << 4) + j] = org;
			orgY_diff[i][j] = org;
			orgY_16[i][j] = org;
		}
	}
	int refp_ptr0 = md_fw_ptr->refp_ptr[0][0];
	int refp_ptr1 = md_fw_ptr->refp_ptr[0][1];

	s64 lambda = md_input_ptr->lambda_y;

	u8 ipred_list[IPRED_LIST_NUM];
	static pel src_le_temp[2 * 16 + 3];
	static pel src_up_temp[2 * 16 + 3];
	u16 avail_tb;

	u8 rdo_list[MD_MAX_RDO_NUM] = {}, inter_rdo_num = 0, intra_rdo_num[1] = { 0 };

	static SKIP_ELEMENT skip_mode[SKIP_MODE_NUM];
	static MERGE_RDO merge_rdo;
	static SKIP_RDO skip_rdo;
	STATIC_C SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO];
	S14 sub_pel_mv[MV_D];
	static s16 mvp_all[2][5][2];

#pragma HLS RESOURCE variable=skip_rdo_mode->skip_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->umve_idx core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->affine_flag core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->mvp core=RAM_1P_BRAM
#pragma HLS RESOURCE variable=skip_rdo_mode->refi core=RAM_1P_BRAM


#if ENABLE_BFRAME
	MV_DIR mv_dir;
#endif
	rdo_prepare_16_16(md_fw_ptr,
		me_line_map_ptr_16,
		up_nebs, left_nebs,
		skip_in_16,
		mod_info_curr_ptr,
		&merge_rdo, md_input_ptr, valid_mode, amvr_enable_flag, fme_mv_info,
		IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
		MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
		IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
		cu_width_log2, cu_height_log2, ipred_list, src_le_temp, src_up_temp, &avail_tb, rmd_mode,
		qt_depth, 17,
		cu_width, cu_height,
#if ENABLE_BFRAME
		me_mv_dir, &mv_dir,
#endif
		orgY, tree_status, curr_cons_pred_mode,
		&inter_rdo_num, intra_rdo_num, rdo_list, skip_mode, &skip_rdo, skip_rdo_mode, sub_pel_mv, mvp_all, Fetch_Ref_window_ptr
#if SUB_TMVP
		, core_sbtmvp, skip_in
#endif
	);


	u8 all_rdo_num = inter_rdo_num + intra_rdo_num[0];

	STATIC_C pel pred_y_skip_inter[13][16][16];
	static pel pred_y_inter2[2][16][16];
	static pel pred_y_intra[5][16][16];

	static S14 mv_copy[2][2];
	static s16 mvd_copy[2][2];
	static S3 refi_copy[2];
#if 1
	get_ref_pel_2_16_16(w, h, all_rdo_num, rdo_list, ipred_list, mod_info_curr_ptr, skip_mode, &merge_rdo, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD, md_fw_ptr, md_input_ptr, mvp_all, &skip_rdo, skip_rdo_mode, merge_rdo, 64, md_kernel_input, tree_status,
		curr_cons_pred_mode, sub_pel_mv,
		src_le_temp, src_up_temp, avail_tb
#if ENABLE_BFRAME
		, md_input_ptr->CtrPos2MD_ref1, &mv_dir
#endif
#if SUB_TMVP
		, core_sbtmvp
#endif
		, mv_copy, mvd_copy, refi_copy, pred_y_skip_inter, pred_y_intra, pred_y_inter2, ref);
#endif

#if !SIMPLE_MD
#ifdef MD_CMOD
#else
	rdo_skip_16_16(&cost_skip, best_info_ptr_16,
		cu_data_temp_ptr_16,
		mod_info_curr_ptr,
		orgY_16, skip_mode, &merge_rdo, md_fw_ptr->pic_width,
		md_fw_ptr->pic_height, md_fw_ptr->slice_type, tree_status, lambda, curr_cons_pred_mode, bit_depth, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD,
#if ENABLE_BFRAME
		md_input_ptr->CtrPos2MD_ref1,
#endif
		//fme2mdrefbuf
		pred_y_skip_inter
#if SUB_TMVP
		, cu_width, cu_height, core_sbtmvp
#endif
	);
#endif
#endif

	U2 ch_type = 0;
	s64 cost_best[1];
	U6 qp = md_input_ptr->qp_y;
#pragma HLS resource variable=cost_best core=RAM_1P_BRAM

	if (PATCH_MODE())
		cost_skip = MAX_S64;
#if USE_INTRA_REFRESH
	if (md_input_ptr->EncRefresh && md_fw_ptr->slice_type != SLICE_I)
	{
		if (md_input_ptr->RefreshMode == 0)
		{
			if (mod_info_curr_ptr->y_pos >= md_input_ptr->pirStartRow * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->y_pos < md_input_ptr->pirEndRow * 32 * md_input_ptr->RefreshSize)
				cost_best[0] = MAX_S64;
		}
		else
		{
			if (mod_info_curr_ptr->x_pos >= md_input_ptr->pirStartCol * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->x_pos < md_input_ptr->pirEndCol * 32 * md_input_ptr->RefreshSize)
				cost_best[0] = MAX_S64;
		}

	}
#endif
//dummy Port alignment
#if 1
	U32 zero = (cu_width >= 4) ? (U32)0 : (U32)cu_width;
	U1 zero_1b = zero & 1;
// disappear
#define TOUCH_OUT(a) (a) = (a) + zero;
#define TOUCH(a) (a) = (a) + zero;
#define BIT_WIDTH(a, bit) (a) = (a) + (zero_1b << ((bit)-1))


	TOUCH(ch_type);
	TOUCH(lambda);
	TOUCH(cost_best[0]);
	TOUCH(mod_info_curr_ptr->mpm[1][0]);
	TOUCH(mod_info_curr_ptr->mpm[1][1]);
	TOUCH(mod_info_curr_ptr->mpm[2][0]);
	TOUCH(mod_info_curr_ptr->mpm[2][1]);
	TOUCH(mod_info_curr_ptr->mpm[3][0]);
	TOUCH(mod_info_curr_ptr->mpm[3][1]);
	TOUCH(mv_copy [0][0]);
	TOUCH(mvd_copy [0][0]);
	TOUCH(refi_copy[0]);
	TOUCH(refi_copy[1]);
		pel pred_y_inter_before[16][16];
#pragma HLS array_partition variable=pred_y_intra complete dim=3
#pragma HLS array_partition variable=pred_y_inter2 complete dim=1
#pragma HLS array_partition variable=pred_y_inter2 complete dim=2
#pragma HLS array_partition variable=pred_y_inter2 complete dim=3
#pragma HLS array_partition variable=pred_y_inter_before complete dim=1
#pragma HLS array_partition variable=pred_y_inter_before complete dim=2
#pragma HLS array_partition variable=pred_y_skip_inter complete dim=2
#pragma HLS array_partition variable=pred_y_skip_inter complete dim=3

#pragma HLS array_partition variable=rdoq_array->rdoq_est_run complete dim=1
#pragma HLS array_partition variable=rdoq_array->rdoq_est_run complete dim=2
#pragma HLS array_partition variable=rdoq_array->rdoq_est_level complete dim=1
#pragma HLS array_partition variable=rdoq_array->rdoq_est_level complete dim=2
#pragma HLS array_partition variable=rdoq_array->rdoq_est_last complete dim=1
#pragma HLS array_partition variable=rdoq_array->rdoq_est_last complete dim=2
#pragma HLS array_partition variable=rdoq_array->rdoq_est_last complete dim=3
#pragma HLS array_partition variable=rdoq_array->rdoq_est_last complete dim=4

	for(int n = 0; n < 2; n++ )
	{
#pragma HLS PIPELINE
		for (int i=0; i<16; i++) 
		{
			
			for (int j=0; j<16; j++) 
			{
			//TOUCH(pred_y_inter1[i][j]);
				TOUCH(pred_y_inter2[n][i][j]);
				pred_y_inter_before[i][j] = pred_y_skip_inter[12][i][j];
			}
			if (i < 2)
			{
				for (int j = 0; j < 24; j++)
				{
					BIT_WIDTH(rdoq_array->rdoq_est_run[j][i], 32);
					BIT_WIDTH(rdoq_array->rdoq_est_level[j][i], 32);
				}
				for (int j = 0; j < 6; j++)
				{
					for (int m = 0; m < 12; m++)
					{
						for (int q = 0; q < 2; q++)
						{
							BIT_WIDTH(rdoq_array->rdoq_est_last[i][j][m][q], 32);
						}
					}
				}
			}
		}
	}
	/*for (int i=0; i<16; i++) {
		for(int j=0;j<16;j++){
		TOUCH(pred_y_skip_inter[12][i][j]);
		}
	}*/
	// for (int i=0; i<16; i++) {
	// 	for (int j=0; j<16; j++) {
	// 		TOUCH(pred_y_inter2[1][i][j]);
	// 	}
	// }
	for (int i=0; i<16; i++) {
		#pragma HLS UNROLL
		TOUCH(pred_y_intra[0][0][i]);
	}
//	TOUCH_OUT(cost_best);

// bitwidth become small
	BIT_WIDTH(md_kernel_input->cu_width_log2, 8);
	BIT_WIDTH(md_kernel_input->cu_height_log2, 8);
	BIT_WIDTH(skip_rdo.num_rdo,8);
	BIT_WIDTH(cost_best[0],64);

    
    
// 	for (int j = 0; j < 2; j++)
// 	{
// #pragma HLS PIPELINE
// 		for (int i = 0; i < 24; i++) {
// 			BIT_WIDTH(rdoq_array->rdoq_est_run[i][j], 32);
// 			BIT_WIDTH(rdoq_array->rdoq_est_level[i][j], 32);
// 		 }
// 	}
//     for(int i = 0; i < 2;i++)
// 	{
// #pragma HLS PIPELINE

//          for(int j = 0; j < 6;j++ ){
// 			for(int m = 0;m < 12;m++){
// 				for(int n = 0; n < 2;n++){
// 			       BIT_WIDTH(rdoq_array->rdoq_est_last[i][j][m][n], 32);
// 				}
// 			}
// 		 }
// 	}
    #pragma HLS array_partition variable=pred_y_inter_before complete dim=1
	#pragma HLS array_partition variable=pred_y_inter_before complete dim=2
#endif
	rdo_luma_16_16_pipeline(all_rdo_num, w, h, orgY, orgY_16, orgY_diff, valid_mode, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, inter_rdo_num, rdoq_array, md_fw_ptr, tree_status,
		best_info_ptr_16, md_input_ptr,
#if ENABLE_BFRAME
		& mv_dir, Fetch_Ref_window_ptr,
#endif
		skip_mode, &merge_rdo, &skip_rdo, skip_rdo_mode, sub_pel_mv, mvp_all, cu_width_log2, cu_height_log2,
		cu_data_temp_ptr_16,
		curr_cons_pred_mode,
		//fme2mdrefbuf,
		mv_copy, mvd_copy, refi_copy, pred_y_inter_before, pred_y_inter2, pred_y_intra,
		md_kernel_input, mod_info_curr_ptr->mpm, cu_width, refp_ptr0, refp_ptr1, ch_type, lambda, cost_skip, &cost_best[0], qp
#if SUB_TMVP
		, core_sbtmvp
#endif
	);

	return cost_best[0];
}

void get_ref_uv16(strFetch_ref_window* Fetch_Ref_window_ptr, s8 refi, int lidx, U2* U_ref0)
{
#pragma HLS INLINE 
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->lidx complete dim=0
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->cur_refi complete dim=0
	* U_ref0 = 0;
#if ENABLE_BFRAME
	if (Fetch_Ref_window_ptr->code_stru == RA)
	{
		if (lidx == Fetch_Ref_window_ptr->lidx[REFP_0] && refi == Fetch_Ref_window_ptr->cur_refi[REFP_0])
		{
			*U_ref0 = 1;
		}
		if (lidx == Fetch_Ref_window_ptr->lidx[REFP_1] && refi == Fetch_Ref_window_ptr->cur_refi[REFP_1])
		{
			*U_ref0 = 2;
		}
	}
	else
	{
		if (refi == Fetch_Ref_window_ptr->cur_refi[REFP_0])
		{
#endif
			* U_ref0 = 1;
#if ENABLE_BFRAME
		}
		else if (refi == Fetch_Ref_window_ptr->cur_refi[REFP_1])
		{
			*U_ref0 = 2;
		}
	}
#endif
}

void com_mc_c_00_uv16(int gmv_x, int gmv_y, s16 pred_u[16][16], s16 pred_v[16][16], int w, int h, int bit_depth, pel UP_tmp_mc[19][19], pel VP_tmp_mc[19][19])
{
	int i;
	int j;
	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
		for (j = 0; j < 16; j++) {
			pred_u[i][j] = UP_tmp_mc[i + 1][j + 1];// ref_u[j + offset_ref];
			pred_v[i][j] = VP_tmp_mc[i + 1][j + 1];// ref_v[j + offset_ref];
		}
	}
}
void com_mc_c_0n_uv16(int gmv_x, int gmv_y, s16 pred_u[16][16], s16 pred_v[16][16], int w, int h, int bit_depth, pel UP_tmp_mc[19][19], pel VP_tmp_mc[19][19], s16 tbl_mc_c_coeff_all_dy[4])
{
	int i;
	int j;
	s32 pt;
	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
		for (j = 0; j < 16; j++) {
			pt = (
				((int)tbl_mc_c_coeff_all_dy[0]) * ((int)UP_tmp_mc[i][j + 1]) +
				((int)tbl_mc_c_coeff_all_dy[1]) * ((int)UP_tmp_mc[i + 1][j + 1]) +
				((int)tbl_mc_c_coeff_all_dy[2]) * ((int)UP_tmp_mc[i + 2][j + 1]) +
				((int)tbl_mc_c_coeff_all_dy[3]) * ((int)UP_tmp_mc[i + 3][j + 1]) + (1 << 5)) >> 6;
			pred_u[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
				1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
			pt = (
				((int)tbl_mc_c_coeff_all_dy[0]) * ((int)VP_tmp_mc[i][j + 1]) +
				((int)tbl_mc_c_coeff_all_dy[1]) * ((int)VP_tmp_mc[i + 1][j + 1]) +
				((int)tbl_mc_c_coeff_all_dy[2]) * ((int)VP_tmp_mc[i + 2][j + 1]) +
				((int)tbl_mc_c_coeff_all_dy[3]) * ((int)VP_tmp_mc[i + 3][j + 1]) + (1 << 5)) >> 6;
			pred_v[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
				1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
		}
	}
}
void com_mc_c_n0_uv16(int gmv_x, int gmv_y, s16 pred_u[16][16], s16 pred_v[16][16], int w, int h, int bit_depth, pel UP_tmp_mc[19][19], pel VP_tmp_mc[19][19], s16 tbl_mc_c_coeff_all_dx[4])
{
	int i;
	int j;
	s32 pt;
	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
		for (j = 0; j < 16; j++) {
			pt = (
				((int)tbl_mc_c_coeff_all_dx[0]) * ((int)UP_tmp_mc[i + 1][j]) +
				((int)tbl_mc_c_coeff_all_dx[1]) * ((int)UP_tmp_mc[i + 1][j + 1]) +
				((int)tbl_mc_c_coeff_all_dx[2]) * ((int)UP_tmp_mc[i + 1][j + 2]) +
				((int)tbl_mc_c_coeff_all_dx[3]) * ((int)UP_tmp_mc[i + 1][j + 3]) + (1 << 5)) >> 6;
			pred_u[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
				1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
			pt = (
				((int)tbl_mc_c_coeff_all_dx[0]) * ((int)VP_tmp_mc[i + 1][j]) +
				((int)tbl_mc_c_coeff_all_dx[1]) * ((int)VP_tmp_mc[i + 1][j + 1]) +
				((int)tbl_mc_c_coeff_all_dx[2]) * ((int)VP_tmp_mc[i + 1][j + 2]) +
				((int)tbl_mc_c_coeff_all_dx[3]) * ((int)VP_tmp_mc[i + 1][j + 3]) + (1 << 5)) >> 6;
			pred_v[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
				1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
		}
	}
}
void com_mc_c_nn_uv16(int gmv_x, int gmv_y, s16 pred_u[16][16], s16 pred_v[16][16], int w, int h, int bit_depth,
	pel UP_tmp_mc[19][19], pel VP_tmp_mc[19][19], s16 tbl_mc_c_coeff_all_dx[4], s16 tbl_mc_c_coeff_all_dy[4])
{
	static  s16 buf_u[19][16];
	static  s16 buf_v[19][16];
	static  s16 buf_u1[19][16];
	static  s16 buf_v1[19][16];
#pragma HLS ARRAY_PARTITION variable=buf_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=buf_v complete dim=2
#pragma HLS ARRAY_PARTITION variable=buf_u1 complete dim=2
#pragma HLS ARRAY_PARTITION variable=buf_v1 complete dim=2
	const int shift1 = bit_depth - 8;
	const int shift2 = 20 - bit_depth;
	const int add1 = 1 << shift1 >> 1;
	const int add2 = 1 << (shift2 - 1);
	int i;
	int j;
	s32 pt_u[16];
	s32 pt_v[16];
#pragma HLS ARRAY_PARTITION variable=pt_u complete dim=0
#pragma HLS ARRAY_PARTITION variable=pt_v complete dim=0
	s16 buf_u_tmp;
	s16 buf_v_tmp;
	for (i = 0; i < h + 3; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=19 max=19 avg=19
		for (j = 0; j < 16; j++) {
			buf_u_tmp = ((s16)((
				((int)tbl_mc_c_coeff_all_dx[0]) * ((int)UP_tmp_mc[i][j]) +
				((int)tbl_mc_c_coeff_all_dx[1]) * ((int)UP_tmp_mc[i][j + 1]) +
				((int)tbl_mc_c_coeff_all_dx[2]) * ((int)UP_tmp_mc[i][j + 2]) +
				((int)tbl_mc_c_coeff_all_dx[3]) * ((int)UP_tmp_mc[i][j + 3]) + add1) >> shift1));
			buf_u[i][j] = buf_u_tmp;
			buf_u1[i][j] = buf_u_tmp;
			buf_v_tmp = ((s16)((
				((int)tbl_mc_c_coeff_all_dx[0]) * ((int)VP_tmp_mc[i][j]) +
				((int)tbl_mc_c_coeff_all_dx[1]) * ((int)VP_tmp_mc[i][j + 1]) +
				((int)tbl_mc_c_coeff_all_dx[2]) * ((int)VP_tmp_mc[i][j + 2]) +
				((int)tbl_mc_c_coeff_all_dx[3]) * ((int)VP_tmp_mc[i][j + 3]) + add1) >> shift1));
			buf_v[i][j] = buf_v_tmp;
			buf_v1[i][j] = buf_v_tmp;
		}
	}
	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
		for (j = 0; j < 16; j++) {
			pt_u[j] = (
				((int)tbl_mc_c_coeff_all_dy[0]) * ((int)buf_u[i][j]) +
				((int)tbl_mc_c_coeff_all_dy[1]) * ((int)buf_u[i + 1][j]) +
				((int)tbl_mc_c_coeff_all_dy[2]) * ((int)buf_u1[i + 2][j]) +
				((int)tbl_mc_c_coeff_all_dy[3]) * ((int)buf_u1[i + 3][j]) + add2) >> shift2;
			pt_v[j] = (
				((int)tbl_mc_c_coeff_all_dy[0]) * ((int)buf_v[i][j]) +
				((int)tbl_mc_c_coeff_all_dy[1]) * ((int)buf_v[i + 1][j]) +
				((int)tbl_mc_c_coeff_all_dy[2]) * ((int)buf_v1[i + 2][j]) +
				((int)tbl_mc_c_coeff_all_dy[3]) * ((int)buf_v1[i + 3][j]) + add2) >> shift2;
		}
		for (j = 0; j < 16; j++) {
			pred_u[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt_u[j] ? (1 << bit_depth) - 1 : pt_u[j])) ? 0 : (((
				1 << bit_depth) - 1 < pt_u[j] ? (1 << bit_depth) - 1 : pt_u[j])))));
			pred_v[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt_v[j] ? (1 << bit_depth) - 1 : pt_v[j])) ? 0 : (((
				1 << bit_depth) - 1 < pt_v[j] ? (1 << bit_depth) - 1 : pt_v[j])))));
		}
	}
}

void com_tbl_mc_c_1_uv(int ori_mv_x, int ori_mv_y, int gmv_x, int gmv_y, s16 pred_u[16][16], s16 pred_v[16][16], int w, int h, int bit_depth,
	strFetch_ref_window* Fetch_Ref_window_ptr, U2 UV_flag
)
{
#pragma HLS INLINE OFF
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_UP cyclic factor=128 dim=1
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_VP cyclic factor=128 dim=1
#if ENABLE_BFRAME
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_UP_ref1 cyclic factor=128 dim=1
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_VP_ref1 cyclic factor=128 dim=1
#endif
#pragma HLS ARRAY_PARTITION variable=pred_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v complete dim=2
	pel UP_tmp[128];
	pel VP_tmp[128];
	pel UP_tmp_mc[19][19];
	pel VP_tmp_mc[19][19];
#pragma HLS ARRAY_PARTITION variable=UP_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=VP_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=UP_tmp_mc complete dim=2
#pragma HLS ARRAY_PARTITION variable=VP_tmp_mc complete dim=2
	for (int i = 0; i < h + 3; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=19 max=19 avg=19
		for (int j = 0; j < 128; j++) {
			if (UV_flag == 1) {
				UP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_UP[j + (((gmv_y >> 3) - 1) + i) * 128];
				VP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_VP[j + (((gmv_y >> 3) - 1) + i) * 128];
			}
#if ENABLE_BFRAME
			else if (UV_flag == 2) {
				UP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_UP_ref1[j + (((gmv_y >> 3) - 1) + i) * 128];
				VP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_VP_ref1[j + (((gmv_y >> 3) - 1) + i) * 128];
			}
#endif
		}
		for (int j = 0; j < 16 + 3; j++) {
			UP_tmp_mc[i][j] = UP_tmp[j + (gmv_x >> 3) - 1];
			VP_tmp_mc[i][j] = VP_tmp[j + (gmv_x >> 3) - 1];
		}
	}

	int coeff_dx;
	int coeff_dy;
	coeff_dx = gmv_x & 0x7;
	coeff_dy = gmv_y & 0x7;

	const s16 tbl_mc_c_coeff_all_0[32][4] = {
	{ 0, (64), 0, 0 }, { ((s16)(-4)), (62), (6), 0 }, { ((s16)(-6)), (56), (15), ((s16)(-1)) }, { ((s16)(-5)), (47), (25), ((s16)(-3)) },
	{ ((s16)(-4)), (36), (36), ((s16)(-4)) }, { ((s16)(-3)), (25), (47), ((s16)(-5)) }, { ((s16)(-1)), (15), (56), ((s16)(-6)) }, { 0, (6), (62), ((s16)(-4)) },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };

	s16 tbl_mc_c_coeff_all_dx[4];
	s16 tbl_mc_c_coeff_all_dy[4];
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_all_0 complete dim=2
#pragma HLS RESOURCE variable=tbl_mc_c_coeff_all_0 core=ROM_1P
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_all_dx complete dim=0
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_all_dy complete dim=0
	for (int i = 0; i < 4; i++) {
#pragma HLS UNROLL
		tbl_mc_c_coeff_all_dx[i] = tbl_mc_c_coeff_all_0[coeff_dx][i];
	}
	for (int i = 0; i < 4; i++) {
#pragma HLS UNROLL
		tbl_mc_c_coeff_all_dy[i] = tbl_mc_c_coeff_all_0[coeff_dy][i];
	}

	int dx;
	int dy;
	dx = ori_mv_x & 0x7;
	dy = ori_mv_y & 0x7;
	if (dx == 0) {
		if (dy == 0) {
			com_mc_c_00_uv16(gmv_x, gmv_y, pred_u, pred_v, w, h, bit_depth, UP_tmp_mc, VP_tmp_mc);
		}
		else {
			com_mc_c_0n_uv16(gmv_x, gmv_y, pred_u, pred_v, w, h, bit_depth, UP_tmp_mc, VP_tmp_mc, tbl_mc_c_coeff_all_dy);
		}
	}
	else {
		if (dy == 0) {
			com_mc_c_n0_uv16(gmv_x, gmv_y, pred_u, pred_v, w, h, bit_depth, UP_tmp_mc, VP_tmp_mc, tbl_mc_c_coeff_all_dx);
		}
		else {
			com_mc_c_nn_uv16(gmv_x, gmv_y, pred_u, pred_v, w, h, bit_depth, UP_tmp_mc, VP_tmp_mc, tbl_mc_c_coeff_all_dx, tbl_mc_c_coeff_all_dy);
		}
	}
}

static BOOL com_mc_cu_uv_16(MD_COM_MODE_BEST* mod_info_curr, int pic_w, int pic_h, S3 refi[REFP_NUM], s16 mv[REFP_NUM][2], int stride_chroma,
	pel pred_u[16][16], pel pred_v[16][16], pel pred1_u[16][16], pel pred1_v[16][16], int bit_depth, strFetch_ref_window* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int skip_idx, int cu_mode
#endif
)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->refp_pic_ptr complete dim=0
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->refp_is_library_picture complete dim=0
#pragma HLS ARRAY_PARTITION variable=refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred1_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred1_v complete dim=2
	int scup = mod_info_curr->scup;
	int x = mod_info_curr->x_pos;
	int y = mod_info_curr->y_pos;
	int w = mod_info_curr->cu_width;
	int h = mod_info_curr->cu_height;
	int	w1 = w >> 1;
	int	h1 = h >> 1;
	s16 mv_t[2];
	int min_clip[2];
	int max_clip[2];
#pragma HLS ARRAY_PARTITION variable=mv_t complete dim=0
#pragma HLS ARRAY_PARTITION variable=min_clip complete dim=0
#pragma HLS ARRAY_PARTITION variable=max_clip complete dim=0
	int x_ext = mod_info_curr->x_pos << 2;
	int y_ext = mod_info_curr->y_pos << 2;
	int w_ext = mod_info_curr->cu_width << 2;
	int h_ext = mod_info_curr->cu_height << 2;
	int x_ext_of_ctu;
	int y_ext_of_ctu;
	int qpel_gmv_x_of_ctu;
	int qpel_gmv_y_of_ctu;
	int qpel_gmv_x_of_refp_cu;
	int qpel_gmv_y_of_refp_cu;
	int dx;
	int dy;

	int bidx = 0;
	static pel pred_u0[16][16];
	static pel pred_u1[16][16];
	static pel pred_v0[16][16];
	static pel pred_v1[16][16];
#pragma HLS ARRAY_PARTITION variable=pred_u0 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v0 complete dim=2
#pragma HLS DEPENDENCE variable=pred_u0 inter false
#pragma HLS DEPENDENCE variable=pred_v0 inter false
#pragma HLS ARRAY_PARTITION variable=pred_u1 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v1 complete dim=2
#pragma HLS RESOURCE variable=pred_u0 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred_v0 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred_u1 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred_v1 core=RAM_S2P_BRAM
	U1 flag_u0 = 0;
	U1 flag_u1 = 0;

	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];
	if (refi[REFP_0] >= 0)
	{
		if (x_ext + mv[REFP_0][0] < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + mv[REFP_0][1] < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + mv[REFP_0][0] + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + mv[REFP_0][1] + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
		y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);
		qpel_gmv_x_of_ctu = x_ext_of_ctu + ((int)mv_t[0]);
		qpel_gmv_y_of_ctu = y_ext_of_ctu + ((int)mv_t[1]);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
		qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);
		//		assert((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < REFP_CU_SIZE && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < REFP_CU_SIZE);
		dx = qpel_gmv_x_of_refp_cu & 3;
		dy = qpel_gmv_y_of_refp_cu & 3;
		//assert((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + (dx ? 4 : 0) < SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + (dy ? 4 : 0) < SWH);
		if (!((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + mod_info_curr->cu_width + (dx ? 4 : 0) <= SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + mod_info_curr->cu_height + (dy ? 4 : 0) <= SWH)) { return FALSE; }

		w >= 8 && h >= 8 ? ((void)0) : __assert_HLS("w >= 8 && h >= 8", "../separate/com_mc.c", (unsigned int)3258,
			__FUNCTION__);
		//add by luke
		//pel ref_u0[SWH / 2 * SWW / 2];
		//pel ref_v0[SWH / 2 * SWW / 2];
		//get_ref_u(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0, ref_u0);
		//get_ref_v(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0, ref_v0);
		U2 UV_flag;
		get_ref_uv16(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0, &UV_flag);

#if SUB_TMVP
#pragma HLS ARRAY_PARTITION variable=core_sbtmvp->sbTmvp complete dim=0
		if (core_sbtmvp->sbTmvp_flag == 1 && cu_mode >= MODE_SKIP && skip_idx == 0 && mod_info_curr->cu_width >= SBTMVP_MIN_SIZE && mod_info_curr->cu_height >= SBTMVP_MIN_SIZE)
		{
			int cu_width = mod_info_curr->cu_width;
			int cu_height = mod_info_curr->cu_height;
			int sub_w = cu_width >> 2;
			int sub_h = cu_height >> 2;

			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_u_tmp[16][16];
			pel pred_v_tmp[16][16];
#pragma HLS ARRAY_PARTITION variable=pred_u_tmp complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v_tmp complete dim=2
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + (w << 1);
					y = tmp_y + (h << 1);

					/*x_ext = cu->x_pos << 2;
					y_ext = cu->y_pos << 2;
					w_ext = cu->cu_width << 2;
					h_ext = cu->cu_height << 2;*/
					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
#pragma HLS ARRAY_PARTITION variable=mv_sbtmvp complete dim=0
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + ((int)mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + ((int)mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}

					x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
					y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);
					qpel_gmv_x_of_ctu = x_ext_of_ctu + (mv_sbtmvp[0]);
					qpel_gmv_y_of_ctu = y_ext_of_ctu + (mv_sbtmvp[1]);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
					qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);

					dx = qpel_gmv_x_of_refp_cu & 3;
					dy = qpel_gmv_y_of_refp_cu & 3;
					if (!((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + (mod_info_curr->cu_width >> 1) + (dx ? 4 : 0) <= SWW &&
						(qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + (mod_info_curr->cu_height >> 1) + (dy ? 4 : 0) <= SWH))
					{
						return FALSE;
					}

					com_tbl_mc_c_1_uv(mv_sbtmvp[0], mv_sbtmvp[1], qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, pred_u_tmp, pred_v_tmp,
						mod_info_curr->cu_width >> 2, mod_info_curr->cu_height >> 2, bit_depth, Fetch_Ref_window_ptr, UV_flag);

					//com_tbl_mc_c_1(mv_sbtmvp[0], mv_sbtmvp[1],  ref_u0 , qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, stride_chroma,
					//	16, *pred_u_tmp, mod_info_curr->cu_width >> 2, mod_info_curr->cu_height >> 2, bit_depth);
					//com_tbl_mc_c_1(mv_sbtmvp[0], mv_sbtmvp[1],  ref_v0, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, stride_chroma,
					//	16, *pred_v_tmp, mod_info_curr->cu_width >> 2, mod_info_curr->cu_height >> 2, bit_depth);

					pel pred_u0_tmp[16];
					pel pred_v0_tmp[16];
					pel pred_tmp_u_tmp[16];
					pel pred_tmp_v_tmp[16];
#pragma HLS ARRAY_PARTITION variable=pred_u0_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_v0_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_tmp_u_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_tmp_v_tmp complete dim=0
					for (int i = 0; i < sub_h; i++)
					{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=8 max=8 avg=8
						for (int j = 0; j < 16; j++)
						{
							//pred_u0[h + i][w + j] = pred_u_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							//pred_v0[h + i][w + j] = pred_v_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							pred_u0_tmp[j] = pred_u0[h + i][j];
							pred_v0_tmp[j] = pred_v0[h + i][j];
					}
						for (int j = 0; j < 16; j++) {
							pred_tmp_u_tmp[j] = pred_u_tmp[i][j];
							pred_tmp_v_tmp[j] = pred_v_tmp[i][j];
						}
						for (int j = 0; j < 16; j++)
						{
							if (j < sub_w) {
								pred_u0_tmp[w + j] = pred_tmp_u_tmp[j];
								pred_v0_tmp[w + j] = pred_tmp_v_tmp[j];
							}
						}
						for (int j = 0; j < 16; j++)

						{
							pred_u0[h + i][j] = pred_u0_tmp[j];
							pred_v0[h + i][j] = pred_v0_tmp[j];
						}
					}
				}
				else {
#if MD_PRINT
					printf("%s:%d: sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
						}

				}



			}
		else {
#endif

			//com_tbl_mc_c_1(mv[REFP_0][0], mv[REFP_0][1],  ref_u0 , qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, stride_chroma,
			//	16, *pred_u0, mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth);
			//com_tbl_mc_c_1(mv[REFP_0][0], mv[REFP_0][1],  ref_v0, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, stride_chroma,
			//	16, *pred_v0, mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth);
			com_tbl_mc_c_1_uv(mv[REFP_0][0], mv[REFP_0][1], qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, pred_u0, pred_v0,
				mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth, Fetch_Ref_window_ptr, UV_flag);
#if SUB_TMVP
		}
#endif
		++bidx;
		flag_u0 = 1;
	}
#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3267);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			if (flag_u0 == 1) {
				for (int j = 0; j < h1; j++)
				{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
					for (int i = 0; i < 16; i++)
					{
						pred_u[j][i] = pred_u0[j][i];
						pred_v[j][i] = pred_v0[j][i];
						pred1_u[j][i] = pred_u0[j][i];
						pred1_v[j][i] = pred_v0[j][i];

					}
				}
			}
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	//static pel pred_snd[16][16];
	if (REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred_buf)[16] = bidx ? pred_snd : pred;
		if (x_ext + mv[REFP_1][0] < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + mv[REFP_1][1] < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + mv[REFP_1][0] + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + mv[REFP_1][1] + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
		y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);
		qpel_gmv_x_of_ctu = x_ext_of_ctu + ((int)mv_t[0]);
		qpel_gmv_y_of_ctu = y_ext_of_ctu + ((int)mv_t[1]);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
		qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);
		//		assert((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < REFP_CU_SIZE && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < REFP_CU_SIZE);
		dx = qpel_gmv_x_of_refp_cu & 3;
		dy = qpel_gmv_y_of_refp_cu & 3;
		//assert((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + (dx ? 4 : 0) < SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + (dy ? 4 : 0) < SWH);
		if (!((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + mod_info_curr->cu_width + (dx ? 4 : 0) < SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + mod_info_curr->cu_height + (dy ? 4 : 0) < SWH)) { return FALSE; }

		w >= 8 && h >= 8 ? ((void)0) : __assert_HLS("w >= 8 && h >= 8", "../separate/com_mc.c", (unsigned int)3258,
			__FUNCTION__);

		//pel ref_u0[SWH / 2 * SWW / 2];
		//pel ref_v0[SWH / 2 * SWW / 2];
		//get_ref_u(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1, ref_u0);
		//get_ref_v(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1, ref_v0);
		//com_tbl_mc_c_1(mv[REFP_1][0], mv[REFP_1][1],  ref_u0 , qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, stride_chroma,
		//	16, * pred_u1, mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth);
		//com_tbl_mc_c_1(mv[REFP_1][0], mv[REFP_1][1],  ref_v0, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, stride_chroma,
		//	16, * pred_v1, mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth);

		U2 UV_flag;
		get_ref_uv16(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1, &UV_flag);
		com_tbl_mc_c_1_uv(mv[REFP_1][0], mv[REFP_1][1], qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, pred_u1, pred_v1,
			mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth, Fetch_Ref_window_ptr, UV_flag);

		bidx++;
		flag_u1 = 1;
	}

	if ((flag_u0 == 1) && (flag_u1 == 1)) {
		for (int j = 0; j < h1; j++)
		{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
			for (int i = 0; i < 16; i++)
			{
				pred_u[j][i] = (pred_u0[j][i] + pred_u1[j][i] + 1) >> 1;
				pred_v[j][i] = (pred_v0[j][i] + pred_v1[j][i] + 1) >> 1;
				pred1_u[j][i] = (pred_u0[j][i] + pred_u1[j][i] + 1) >> 1;
				pred1_v[j][i] = (pred_v0[j][i] + pred_v1[j][i] + 1) >> 1;

			}
		}
	}
	else if ((flag_u0 == 1) && (flag_u1 == 0)) {
		for (int j = 0; j < h1; j++)
		{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
			for (int i = 0; i < 16; i++)
			{
				pred_u[j][i] = pred_u0[j][i];
				pred_v[j][i] = pred_v0[j][i];
				pred1_u[j][i] = pred_u0[j][i];
				pred1_v[j][i] = pred_v0[j][i];

			}
		}
	}
	else if ((flag_u0 == 0) && (flag_u1 == 1)) {
		for (int j = 0; j < h1; j++)
		{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
			for (int i = 0; i < 16; i++)
			{
				pred_u[j][i] = pred_u1[j][i];
				pred_v[j][i] = pred_v1[j][i];
				pred1_u[j][i] = pred_u1[j][i];
				pred1_v[j][i] = pred_v1[j][i];

			}
		}
	}
#endif
	return 1;
}

static void com_ipred_uv_16(U3 cu_width_log2, U3 cu_height_log2, pel src_le[35], pel src_up[35], pel pred[16][16], pel pred1[16][16], S8 ipm_c, S8 ipm, U7 w, U7 h, U4 bit_depth,
	u16 avail_cu,  pel piRecoY[32][32], pel nb_y[2][2 * 32 + 3]
#if MIPF
	, int mipf_enable_flag
#endif
)
{
#pragma HLS INLINE
#if USE_TSCPM
	int bAbove = IS_AVAIL(avail_cu, AVAIL_UP);
	int bLeft = IS_AVAIL(avail_cu, AVAIL_LE);
#endif

	if (ipm_c == 0 && (ipm == 12 || ipm == 24 || ipm == 0 || ipm == 2)) {
		ipm_c = (ipm == 12 ? 3 : ((ipm == 24 ? 2 : ((ipm == 0 ? 1 : 4)))));
	}


		if ((ipm_c == 0) && (ipm == 1)) {
			Ipred_plane_Chroma16( cu_width_log2,  cu_height_log2, w, h, src_le + 2, src_up + 2, bit_depth,  pred, pred1);
			//clip_pred(dst, w, h, bit_depth);
		}
#if EIPM
		else if ((ipm_c == 0) && (ipm > 33)) 
			{
				ipred_ang_eipm_Chroma16(src_le + 3, src_up + 3, w, h, ipm
#if MIPF
					, 0, mipf_enable_flag, bit_depth, pred, pred1
#endif
				);
			}

		else if ((ipm_c == 0) && (ipm < 34) && (ipm != 1)) {
#endif
				ipred_ang_Chroma16(src_le, src_up, pred, pred1, bit_depth, w, h, ipm
#if MIPF
					, 0, mipf_enable_flag
#endif
				);
				//clip_pred(dst, w, h, bit_depth);
			}
			
		// Clip
		//clip_pred(dst, w, h, bit_depth);
		else if (ipm_c == 1) {
		Ipred_dc_Chroma16( cu_width_log2,  cu_height_log2, w, h, src_le + 3, src_up + 3, bit_depth, avail_cu,  pred, pred1);
		}
		else if (ipm_c == 2) {
		Ipred_hor_Chroma16(w, h, src_le + 3,  pred, pred1);
		}
		else if (ipm_c == 3) {
		Ipred_vert_Chroma16(w, h, src_up + 3,  pred, pred1);
		}
		else if (ipm_c == 4) {
		Ipred_bi_Chroma16( cu_width_log2,  cu_height_log2, w, h, src_le + 3, src_up + 3, bit_depth,  pred, pred1);
		// Clip
		//clip_pred(dst, w, h, bit_depth);
		}
#if USE_TSCPM
		else if (ipm_c == 5) {
		ipred_tscpm_Chroma16(pred, pred1, piRecoY, 64, w, h, bAbove, bLeft, bit_depth, src_le + 3, src_up + 3, nb_y[0], nb_y[1]);
		}
#endif
	
	
}

template <size_t W, size_t H>
void IP_buffer_const_up(pel* up, pel IP_buffer_ptr_up_line[2 * W], U32 IP_map_scu_ptr_map_scu_up_line[(W >> 2) << 1],
	int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < W; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_up_line[i];
		}
		for (int i = 0; i < (W >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (W >> 2) + i < pic_width_in_scu : pic_x_scu + (W >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_map_scu_up_line[(W >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (W >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = IP_buffer_ptr_up_line[W + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = up[W + (i << 2) + 2];
				}
			}
		}
	}
}

template <size_t W, size_t H>
void IP_buffer_const_left(pel* left, pel IP_buffer_ptr_32x32_left_line[2 * H], U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(H >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < H; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_32x32_left_line[i];
		}
		for (int i = 0; i < (H >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (H >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_16x32_map_scu_left_line_new[(H >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (H >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = IP_buffer_ptr_32x32_left_line[H + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = left[H + (i << 2) + 2];
				}
			}
		}
	}
}

void IP_buffer_const_top_left(pel* up, pel* left, pel IP_buffer_ptr_top_left, int avail_cu)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}

#if USE_TSCPM
static void get_IP_pixel_32_for_chroma(U8 w, U8 h, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, U2 ch_type, pel left[2 * 32 + 3], pel up[2 * 32 + 3], U14 x, U14 y, 
	pel	IP_buffer_ptr_16x32_up_line[2 * 16], pel IP_buffer_ptr_16x32_left_line[2 * 32], pel IP_buffer_ptr_16x32_top_left,
	pel	IP_buffer_ptr_32x16_up_line[2 * 32], pel IP_buffer_ptr_32x16_left_line[2 * 16], pel IP_buffer_ptr_32x16_top_left,
	pel	IP_buffer_ptr_32x32_up_line[2 * 32], pel IP_buffer_ptr_32x32_left_line[2 * 32], pel IP_buffer_ptr_32x32_top_left,
	U32 IP_map_scu_ptr_16x32_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_left_line_new[(32 >> 2) << 1])
{
#pragma HLS INLINE OFF
#pragma HLS ARRAY_PARTITION variable=left complete dim=0
#pragma HLS ARRAY_PARTITION variable=up complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_32x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_32x32_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_16x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_16x32_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_32x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_32x16_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x32_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x32_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x32_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x32_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x16_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x16_map_scu_left_line_new complete dim=0
	int i;
	int j;
	int width_in_scu = ch_type == 0 ? w >> 2 : w >> (2 - 1);
	int height_in_scu = ch_type == 0 ? h >> 2 : h >> (2 - 1);
	//4
	U4 unit_size = ch_type == 0 ? 1 << 2 : 1 << 2 >> 1;
	U2 unit_size_bit = ch_type == 0 ? 2 : 1;
	//x/4
	int x_scu = ((ch_type == 0 ? x : x << 1)) >> 2;
	//y/4
	int y_scu = ((ch_type == 0 ? y : y << 1)) >> 2;
	//number of padding pixel in the left column   64
	int pad_le = h;
	//number of padding pixel in the upper row     64
	int pad_up = w;
	//16
	int pad_le_in_scu = height_in_scu;
	//16
	int pad_up_in_scu = width_in_scu;
	int pic_x = x % 64;
	int pic_y = y % 64;
	s16 pic_x_scu = (pic_x >> 2);
	s16 pic_y_scu = (pic_y >> 2);
	int flag;

	S7 ip_array_size_idx = get_ip_array_size_idx(w, h);
#if MD_PRINT
	assert(ip_array_size_idx != -1);
#endif

	if (w == 32 && h == 32)
	{
		IP_buffer_const_up<32, 32>(up, IP_buffer_ptr_32x32_up_line, IP_map_scu_ptr_32x32_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_const_left<32, 32>(left, IP_buffer_ptr_32x32_left_line, IP_map_scu_ptr_32x32_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_const_top_left(up, left, IP_buffer_ptr_32x32_top_left, avail_cu);
	}
	else if (w == 32 && h == 16)
	{
		IP_buffer_const_up<32, 16>(up, IP_buffer_ptr_32x16_up_line, IP_map_scu_ptr_32x16_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_const_left<32, 16>(left, IP_buffer_ptr_32x16_left_line, IP_map_scu_ptr_32x16_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_const_top_left(up, left, IP_buffer_ptr_32x16_top_left, avail_cu);
	}
	else if (w == 16 && h == 32)
	{
		IP_buffer_const_up<16, 32>(up, IP_buffer_ptr_16x32_up_line, IP_map_scu_ptr_16x32_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_const_left<16, 32>(left, IP_buffer_ptr_16x32_left_line, IP_map_scu_ptr_16x32_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_const_top_left(up, left, IP_buffer_ptr_16x32_top_left, avail_cu);
	}

	up[1] = left[3];
	left[1] = up[3];
	up[0] = left[4];
	left[0] = up[4];
}

#endif // USE_TSCPM

static __inline void com_mset_8b(pel* dst, pel v, int cnt)
{
#pragma HLS INLINE off
	int i;
	for (i = 0; i < cnt; i++)
	{
#pragma HLS LOOP_TRIPCOUNT max=67 
		dst[i] = v;
	}
}
void get_IP_pixel_16x16_chroma(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth,  pel left_u[35], pel up_u[35], pel left_v[35], pel up_v[35], U12 x, U12 y,
	pel	IP_buffer_ptr_U_16x16_up_line[2 * 16], pel IP_buffer_ptr_U_16x16_left_line[2 * 16], pel IP_buffer_ptr_U_16x16_top_left,
	pel	IP_buffer_ptr_V_16x16_up_line[2 * 16], pel IP_buffer_ptr_V_16x16_left_line[2 * 16], pel IP_buffer_ptr_V_16x16_top_left,
	U32 IP_map_scu_ptr_32x32_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_left_line_new[(32 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu =  width >> (2 - 1);
	U6 height_in_scu =  height >> (2 - 1);
	//4
	U3 unit_size =  1 << 2 >> 1;
	U2 unit_size_bit =  1;
	//x/4
	U11 x_scu = (( x << 1)) >> 2;
	//y/4
	U11 y_scu = (( y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u , (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_u, (1 << (bit_depth - 1)), width + pad_up + 3);
	//com_mset_8b(left_v, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 35; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] =  (IP_buffer_ptr_U_16x16_up_line[i]) ;
			up_v[i + 3] =  (IP_buffer_ptr_V_16x16_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				//flag = pic_y == 0 ?
				//	1 :
				//	((int)(me_line_ptr->map_scu_inner[me_line_ptr->curr_ctu_idx][pic_x_scu + width_in_scu + i][pic_y_scu - 1] >> 31 & (1)));
				flag = pic_y == 0 ?1 :((int)(IP_map_scu_ptr_32x32_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else
				flag = 0;

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x16_up_line[width + (i << unit_size_bit) + j]) ;
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x16_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {
		if (pic_x == 0)
		{
			for (i = 0; i < height; i++)
			{
#pragma HLS UNROLL
					//flag = ((int)(me_line_ptr->map_scu_inner[1 - me_line_ptr->curr_ctu_idx][15][pic_y_scu + height_in_scu + i] >> 31 & (1)));
				left_u[i + 3] =  (IP_buffer_ptr_U_16x16_left_line[i]) ;
				left_v[i + 3] =  (IP_buffer_ptr_V_16x16_left_line[i]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{
#pragma HLS UNROLL
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(IP_map_scu_ptr_32x32_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x16_left_line[height + (i << unit_size_bit) + j]) ;
						left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x16_left_line[height + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
						left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];
					}
				}
			}
		}
		else {
			for (i = 0; i < height; i++)
			{
#pragma HLS UNROLL
				left_u[i + 3] =  (IP_buffer_ptr_U_16x16_left_line[i]) ;
				left_v[i + 3] =  (IP_buffer_ptr_V_16x16_left_line[i]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{
#pragma HLS UNROLL
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(IP_map_scu_ptr_32x32_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x16_left_line[height + (i << unit_size_bit) + j]) ;
						left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x16_left_line[height + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
						left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];
					}
				}
			}
		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] =  (IP_buffer_ptr_U_16x16_top_left) ;
		up_v[2] = left_v[2] =  (IP_buffer_ptr_V_16x16_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}


	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];
	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}
void get_IP_pixel_8x16_chroma(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth,  pel left_u[35], pel up_u[35], pel left_v[35], pel up_v[35], U12 x, U12 y,
	pel	IP_buffer_ptr_U_8x16_up_line[2 * 8], pel IP_buffer_ptr_U_8x16_left_line[2 * 16], pel IP_buffer_ptr_U_8x16_top_left,
	pel	IP_buffer_ptr_V_8x16_up_line[2 * 8], pel IP_buffer_ptr_V_8x16_left_line[2 * 16], pel IP_buffer_ptr_V_8x16_top_left,
	U32 IP_map_scu_ptr_16x32_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(32 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu =  width >> (2 - 1);
	U6 height_in_scu =  height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit =  1;
	//x/4
	U11 x_scu = (( x << 1)) >> 2;
	//y/4
	U11 y_scu = (( y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u , (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_u, (1 << (bit_depth - 1)), width + pad_up + 3);
	//com_mset_8b(left_v, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 35; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_8x16_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_8x16_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ?1 :((int)(IP_map_scu_ptr_16x32_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else
				flag = 0;

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_8x16_up_line[width + (i << unit_size_bit) + j]) ;
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_8x16_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {
		if (pic_x == 0)
		{
			for (i = 0; i < height; i++)
			{
#pragma HLS UNROLL
				left_u[i + 3] =  (IP_buffer_ptr_U_8x16_left_line[i]) ;
				left_v[i + 3] =  (IP_buffer_ptr_V_8x16_left_line[i]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{
#pragma HLS UNROLL
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(IP_map_scu_ptr_16x32_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_8x16_left_line[height + (i << unit_size_bit) + j]);
						left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_8x16_left_line[height + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
						left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];
					}
				}
			}
		}
		else {
			for (i = 0; i < height; i++)
			{
#pragma HLS UNROLL
				left_u[i + 3] = (IP_buffer_ptr_U_8x16_left_line[i]) ;
				left_v[i + 3] = (IP_buffer_ptr_V_8x16_left_line[i]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{
#pragma HLS UNROLL
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(IP_map_scu_ptr_16x32_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_8x16_left_line[height + (i << unit_size_bit) + j]) ;
						left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_8x16_left_line[height + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
						left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];
					}
				}
			}
		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_8x16_top_left) ;
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_8x16_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}
void get_IP_pixel_16x8_chroma(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth,  pel left_u[35], pel up_u[35], pel left_v[35], pel up_v[35], U12 x, U12 y,
	pel	IP_buffer_ptr_U_16x8_up_line[2 * 16], pel IP_buffer_ptr_U_16x8_left_line[2 * 8], pel IP_buffer_ptr_U_16x8_top_left,
	pel	IP_buffer_ptr_V_16x8_up_line[2 * 16], pel IP_buffer_ptr_V_16x8_left_line[2 * 8], pel IP_buffer_ptr_V_16x8_top_left,
	U32 IP_map_scu_ptr_32x16_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_left_line_new[(16 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu =  width >> (2 - 1);
	U6 height_in_scu =  height >> (2 - 1);
	//4
	U3 unit_size =  1 << 2 >> 1;
	U2 unit_size_bit =  1;
	//x/4
	U11 x_scu = (( x << 1)) >> 2;
	//y/4
	U11 y_scu = (( y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u , (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_u, (1 << (bit_depth - 1)), width + pad_up + 3);
	//com_mset_8b(left_v, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 35; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_16x8_up_line[i]) ;
			up_v[i + 3] = (IP_buffer_ptr_V_16x8_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ?1 :((int)(IP_map_scu_ptr_32x16_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else
				flag = 0;

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x8_up_line[width + (i << unit_size_bit) + j]) ;
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x8_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {
		if (pic_x == 0)
		{
			for (i = 0; i < height; i++)
			{
#pragma HLS UNROLL
				left_u[i + 3] =  (IP_buffer_ptr_U_16x8_left_line[i]) ;
				left_v[i + 3] =  (IP_buffer_ptr_V_16x8_left_line[i]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{
#pragma HLS UNROLL
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(IP_map_scu_ptr_32x16_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x8_left_line[height + (i << unit_size_bit) + j]) ;
						left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x8_left_line[height + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
						left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];
					}
				}
			}
		}
		else {
			for (i = 0; i < height; i++)
			{
#pragma HLS UNROLL
				left_u[i + 3] =  (IP_buffer_ptr_U_16x8_left_line[i]);
				left_v[i + 3] =  (IP_buffer_ptr_V_16x8_left_line[i]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{
#pragma HLS UNROLL
				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(IP_map_scu_ptr_32x16_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x8_left_line[height + (i << unit_size_bit) + j]) ;
						left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x8_left_line[height + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{
#pragma HLS UNROLL
						left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
						left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];
					}
				}
			}
		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] =  (IP_buffer_ptr_U_16x8_top_left) ;
		up_v[2] = left_v[2] =  (IP_buffer_ptr_V_16x8_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];
	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

u16 com_get_avail_intra_ip_chroma_16x16(U11 x_scu, U11 y_scu, 
	U32 IP_map_scu_ptr_32x32_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_top_left_new
)
{

#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_32x32_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_32x32_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_32x32_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}

	return avail;
}

u16 com_get_avail_intra_ip_chroma_8x16(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_16x32_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_top_left_new
)
{

#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_16x32_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_16x32_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_16x32_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}

	return avail;
}

u16 com_get_avail_intra_ip_chroma_16x8(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_32x16_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_top_left_new
)
{

#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_32x16_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_32x16_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_32x16_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}

	return avail;
}

 void ipred_c_16_prepare(MD_FW* md_fw_ptr,
	U3 cu_width_log2, U3 cu_height_log2,
	 U13 pb_x, U13 pb_y,  MD_COM_MODE_BEST* mod_info_curr_ptr,
	pel nb_y[2][2 * 32 + 3], pel piRecoY[32][32],
	pel nb_u[2][2 * 16 + 3], pel nb_v[2][2 * 16 + 3],
	u16* avail_cu_output,
	pel	IP_buffer_ptr_U_16x16_up_line[2 * 16], pel IP_buffer_ptr_U_16x16_left_line[2 * 16], pel IP_buffer_ptr_U_16x16_top_left,
	pel	IP_buffer_ptr_V_16x16_up_line[2 * 16], pel IP_buffer_ptr_V_16x16_left_line[2 * 16], pel IP_buffer_ptr_V_16x16_top_left,
	pel	IP_buffer_ptr_U_8x16_up_line[2 * 8], pel IP_buffer_ptr_U_8x16_left_line[2 * 16], pel IP_buffer_ptr_U_8x16_top_left,
	pel	IP_buffer_ptr_V_8x16_up_line[2 * 8], pel IP_buffer_ptr_V_8x16_left_line[2 * 16], pel IP_buffer_ptr_V_8x16_top_left,
	pel	IP_buffer_ptr_U_16x8_up_line[2 * 16], pel IP_buffer_ptr_U_16x8_left_line[2 * 8], pel IP_buffer_ptr_U_16x8_top_left,
	pel	IP_buffer_ptr_V_16x8_up_line[2 * 16], pel IP_buffer_ptr_V_16x8_left_line[2 * 8], pel IP_buffer_ptr_V_16x8_top_left,
	pel	IP_buffer_ptr_16x32_up_line[2 * 16], pel IP_buffer_ptr_16x32_left_line[2 * 32], pel IP_buffer_ptr_16x32_top_left,
	pel	IP_buffer_ptr_32x16_up_line[2 * 32], pel IP_buffer_ptr_32x16_left_line[2 * 16], pel IP_buffer_ptr_32x16_top_left,
	pel	IP_buffer_ptr_32x32_up_line[2 * 32], pel IP_buffer_ptr_32x32_left_line[2 * 32], pel IP_buffer_ptr_32x32_top_left,
	U32 IP_map_scu_ptr_16x32_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x16_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x32_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_top_left_new
)
{
#pragma HLS INLINE OFF
#pragma HLS ARRAY_PARTITION variable=nb_y complete dim=0
#pragma HLS ARRAY_PARTITION variable=nb_u complete dim=0
#pragma HLS ARRAY_PARTITION variable=nb_v complete dim=0
	//u16 avail_cu = com_get_avail_intra_ip(MAP_SCU_IP_ptr, mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu);
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x32_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x32_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_16x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_16x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_16x16_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_16x16_left_line complete dim=0
	//get_IP_pixel_chroma(1 << cu_width_log2, 1 << cu_height_log2, avail_cu, md_fw_ptr->pic_width_in_scu,
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x16_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x16_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_16x8_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_16x8_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_16x8_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_16x8_left_line complete dim=0
	//	md_fw_ptr->pic_height_in_scu, md_fw_ptr->bit_depth_internal, uv + 1, nb[0], nb[1], pb_x >> 1, pb_y >> 1, me_line_map_ptr, IP_buffer_ptr);
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x32_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x32_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_8x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_8x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_8x16_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_8x16_left_line complete dim=0

	u16 avail_cu;
	if (cu_width_log2 == 4 && cu_height_log2 == 4)
	{
		avail_cu = com_get_avail_intra_ip_chroma_16x16(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_32x32_map_scu_up_line, IP_map_scu_ptr_32x32_map_scu_left_line_new, IP_map_scu_ptr_32x32_map_scu_top_left_new);
	}
	else if (cu_width_log2 == 3 && cu_height_log2 == 4)
	{
		avail_cu = com_get_avail_intra_ip_chroma_8x16(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_16x32_map_scu_up_line, IP_map_scu_ptr_16x32_map_scu_left_line_new, IP_map_scu_ptr_16x32_map_scu_top_left_new);
	}
	else if (cu_width_log2 == 4 && cu_height_log2 == 3)
	{
		avail_cu = com_get_avail_intra_ip_chroma_16x8(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_32x16_map_scu_up_line, IP_map_scu_ptr_32x16_map_scu_left_line_new, IP_map_scu_ptr_32x16_map_scu_top_left_new);
	}
	if (cu_width_log2 == 4 && cu_height_log2 == 4)
	{
		get_IP_pixel_16x16_chroma(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal, 
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_16x16_up_line, IP_buffer_ptr_U_16x16_left_line, IP_buffer_ptr_U_16x16_top_left,
			IP_buffer_ptr_V_16x16_up_line, IP_buffer_ptr_V_16x16_left_line, IP_buffer_ptr_V_16x16_top_left,
			IP_map_scu_ptr_32x32_map_scu_up_line, IP_map_scu_ptr_32x32_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 3 && cu_height_log2 == 4)
	{
		get_IP_pixel_8x16_chroma(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal, 
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_8x16_up_line, IP_buffer_ptr_U_8x16_left_line, IP_buffer_ptr_U_8x16_top_left,
			IP_buffer_ptr_V_8x16_up_line, IP_buffer_ptr_V_8x16_left_line, IP_buffer_ptr_V_8x16_top_left,
			IP_map_scu_ptr_16x32_map_scu_up_line, IP_map_scu_ptr_16x32_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 4 && cu_height_log2 == 3)
	{
		get_IP_pixel_16x8_chroma(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal, 
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_16x8_up_line, IP_buffer_ptr_U_16x8_left_line, IP_buffer_ptr_U_16x8_top_left,
			IP_buffer_ptr_V_16x8_up_line, IP_buffer_ptr_V_16x8_left_line, IP_buffer_ptr_V_16x8_top_left,
			IP_map_scu_ptr_32x16_map_scu_up_line, IP_map_scu_ptr_32x16_map_scu_left_line_new);
	}

	get_IP_pixel_32_for_chroma(1 << (cu_width_log2 + 1), 1 << (cu_height_log2 + 1), avail_cu, md_fw_ptr->pic_width_in_scu,
		md_fw_ptr->pic_height_in_scu, md_fw_ptr->bit_depth_internal, 0, nb_y[0], nb_y[1], pb_x, pb_y,
		IP_buffer_ptr_16x32_up_line, IP_buffer_ptr_16x32_left_line, IP_buffer_ptr_16x32_top_left,
		IP_buffer_ptr_32x16_up_line, IP_buffer_ptr_32x16_left_line, IP_buffer_ptr_32x16_top_left,
		IP_buffer_ptr_32x32_up_line, IP_buffer_ptr_32x32_left_line, IP_buffer_ptr_32x32_top_left,
		IP_map_scu_ptr_16x32_map_scu_up_line, IP_map_scu_ptr_16x32_map_scu_left_line_new,
		IP_map_scu_ptr_32x16_map_scu_up_line, IP_map_scu_ptr_32x16_map_scu_left_line_new,
		IP_map_scu_ptr_32x32_map_scu_up_line, IP_map_scu_ptr_32x32_map_scu_left_line_new);

	*avail_cu_output = avail_cu;
}

 void ipred_c_16(U3 cu_width_log2, U3 cu_height_log2, U7 cu_width, U7 cu_height,MD_FW* md_fw_ptr,
	pel pred[16][16], pel pred1[16][16],  pel nb_y[2][2 * 32 + 3], pel piRecoY[32][32],
	pel nb[2][2 * 16 + 3],u8 rdo_idx, S8 ipm, u16 avail_cu_output
)
{


	com_ipred_uv_16( cu_width_log2,  cu_height_log2, nb[0], nb[1], pred, pred1,rdo_idx >> 1, ipm,
		cu_width, cu_height, md_fw_ptr->bit_depth_internal, avail_cu_output,  piRecoY, nb_y
#if MIPF
		, md_fw_ptr->mipf_enable_flag
#endif
	);

}

static s64 get_bit_est_intra_chroma_16(int cu_width_log2, int cu_height_log2, int est_bit_intra)
{


	int cu_width = 1 << cu_width_log2;
	int cu_height = 1 << cu_height_log2;
	int bit_cnt = 0;

	if (cu_height == 16 && cu_width == 16) {
		//bit_cnt = ((int)(0.7556 * ((double)est_bit_intra) + 4.167));
		return (8613 * est_bit_intra + 13426) >> 14;
	}
	if (cu_height == 16 && cu_width == 8) {
		
		//bit_cnt = ((int)(0.8139 * ((double)est_bit_intra) + 4.952));
		return (8917 * est_bit_intra + 1816) >> 14;
	}
	if (cu_height == 16 && cu_width == 4) {
		
		//bit_cnt = ((int)(0.8026 * ((double)est_bit_intra) + 2.162));
		return (9499 * est_bit_intra - 5644) >> 14;
	}
	if (cu_height == 8 && cu_width == 16) {
		
		//bit_cnt = ((int)(0.8052 * ((double)est_bit_intra) + 2.103));
		return (9318 * est_bit_intra - 3581) >> 14;
	}
	if (cu_height == 4 && cu_width == 16) {
		
		//bit_cnt = ((int)(0.8245 * ((double)est_bit_intra) + 1.911));
		return (9587 * est_bit_intra - 6453) >> 14;
	}

	return bit_cnt;
}

s64 enc_ssd_16b_chroma_16(U7 w, U7 h, s16 src1[16][16], s16 src2[16][16], U4 bit_depth)
{
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2

	const U2 shift = (bit_depth - 8) << 1;
	s64 ssd = 0;

	U7 i, j;
	int diff[16];
#pragma HLS ARRAY_PARTITION variable=diff complete dim=0

	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16

		for (j = 0; j < 16; j++) {
			if (j < w) {
				diff[j] = src1[i][j] - src2[i][j];
			}
			else {
				diff[j] = 0;
			}
		}
		for (j = 0; j < 16; j++) {
			ssd += ((diff[j] * diff[j] >> shift));
		}
	}
	return ssd;

}

void rate_est_chroma_intra_16(s64 cost[6], u8 uv, S64 md_input_ptr_dist_chroma_weight[2], U2 mod_info_best_cu_mode, U3 mod_info_best_cu_width_log2,
	U3 mod_info_best_cu_height_log2, s16 coef_pb_part[12][16][16], s64 lambda_y, int num_nz[12], U4 rdo_idx
	, MD_COM_MODE_BEST* mod_info_best, int cu_width, int cu_height, s16 rec_tmp[16][16], u8 tscpm_enable_flag, U4 bit_depth, s16 orgU[16][16])
{
#pragma HLS ARRAY_PARTITION variable=cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_input_ptr_dist_chroma_weight complete dim=0
#pragma HLS ARRAY_PARTITION variable=num_nz complete dim=0
	//#pragma HLS ARRAY_PARTITION variable=dist_value complete dim=0
#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete dim=2	
//#pragma HLS ARRAY_PARTITION variable=coef_pb_part cyclic factor = 2 dim=1	
	// STREAM BUFFER

	int bin_cnt_chroma;
	s64 ssd_uv;
	static s64 ssd_u;
	static s64 ssd_v;
	int est_bit_intra_uv_tmp;
	static int est_bit_intra_u;
	static int est_bit_intra_v;

	if (mod_info_best_cu_mode == MODE_INTRA)
	{
		ssd_uv = (md_input_ptr_dist_chroma_weight[uv] * enc_ssd_16b_chroma_16(cu_width, cu_height, rec_tmp, orgU,
			bit_depth) + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		est_bit_intra_uv_tmp = enc_eco_xcoef_est_16(coef_pb_part[rdo_idx], mod_info_best_cu_width_log2, mod_info_best_cu_height_log2, num_nz[rdo_idx]);


		if (uv == 0)
		{
			ssd_u = ssd_uv;
			est_bit_intra_u = est_bit_intra_uv_tmp;
		}

		if (uv == 1)
		{
			ssd_v = ssd_uv;
			est_bit_intra_v = est_bit_intra_uv_tmp;
			int est_bit_intra = 2 + encode_intra_dir_c_est(rdo_idx / 2, mod_info_best->ipm[PB0][0], 0);
			int est_bit_intra_tmp = est_bit_intra + est_bit_intra_u + est_bit_intra_v;
			int bin_cnt_chroma = get_bit_est_intra_chroma_16(mod_info_best_cu_width_log2, mod_info_best_cu_height_log2, est_bit_intra_tmp);
			cost[rdo_idx / 2] = ssd_u + ssd_v + ((bin_cnt_chroma * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE);
		}
	}

	//WRITE STREAMS
}

#if 0
void update_chroma_intra(u8 rdo_idx, s64 cost, MD_COM_MODE_BEST * mod_info_best, pel rec_tmp[16][16], s16 coef_uv_pb_part[SIZE_16], int num_nz[MAX_NUM_TB][N_C])
{
	u8 uv = rdo_idx & 1;

	static s64 cost_best1;
	static s16 coef_u[SIZE_16];
	static pel rec_u[16][16];
	if (rdo_idx == 0)
	{
		cost_best1 = MAX_S64;
	}
	if (uv == 0)
	{
		for (int i = 0; i < SIZE_16; ++i)
		{
			coef_u[i] = coef_uv_pb_part[i];
		}
		for (int i = 0; i < 16; ++i)
		{
			for (int j = 0; j < 16; ++j)
			{
				rec_u[i][j] = rec_tmp[i][j];
			}
		}
	}

	if (uv == 1)
	{
		if (cost < cost_best1)
		{
			cost_best1 = cost;
			mod_info_best->ipm[0][1] = rdo_idx >> 1;
			for (int m = 0; m < mod_info_best->cu_height >> 1; ++m)
			{
				for (int n = 0; n < mod_info_best->cu_width >> 1; ++n)
				{
					mod_info_best->rec_u[m * (mod_info_best->cu_width >> 1) + n] = rec_u[m][n];
					mod_info_best->rec_v[m * (mod_info_best->cu_width >> 1) + n] = rec_tmp[m][n];

					mod_info_best->coef_u[m * (mod_info_best->cu_width >> 1) + n] = coef_u[m * (mod_info_best->cu_width >> 1) + n];
					mod_info_best->coef_v[m * (mod_info_best->cu_width >> 1) + n] = coef_uv_pb_part[m * (mod_info_best->cu_width >> 1) + n];
				}
			}
			mod_info_best->num_nz[0][1] = num_nz[0][1];
			mod_info_best->num_nz[0][2] = num_nz[0][2];
		}
	}
}
#endif

void ip_chroma_16_inter(MD_COM_MODE_BEST * mod_info_best, MD_FW * md_fw_ptr, 
	pel pred_cache_ith_u[16][16],  pel pred_cache_ith_v[16][16], 
	
	U4 bit_depth, strFetch_ref_window * Fetch_Ref_window_ptr,
	pel pred_cache_ith1_u[16][16], pel pred_cache_ith1_v[16][16]
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp
#endif
)
{
	// STREAM BUFFER
	com_mc_cu_uv_16(mod_info_best, md_fw_ptr->pic_width, md_fw_ptr->pic_height, mod_info_best->refi, mod_info_best->mv,
		SWW >> 1, pred_cache_ith_u, pred_cache_ith_v, pred_cache_ith1_u, pred_cache_ith1_v ,bit_depth, Fetch_Ref_window_ptr
#if SUB_TMVP
		, core_sbtmvp, mod_info_best->skip_idx, mod_info_best->cu_mode
#endif
	);

		
}

void updateModeChroma16_coefu_mux(int i, s16 mod_info_best_coef_uv[16][16], s16 coef_update[16][16])
{
#pragma HLS INLINE 
	//if ((i >= 0) & (i < 16)) {

	//	for (U8 j = 0; j < 16; j++) {
	//		ap_uint<4> sel = (i + j);    ////////////////// impact clk number
	//		mod_info_best_coef_uv[i][j] = coef_update[sel][j];
	//	}
	//}

	if (i== 0) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 1) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 2) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 3) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 4) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 5) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 6) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 7) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 8) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 9) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 10) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 11) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 12) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 13) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 14) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
	else if (i == 15) {
		for (U8 j = 0; j < 16; j++) { mod_info_best_coef_uv[i][j] = coef_update[(i + j) & 15][j]; }
	}
}
void update_chroma_16(MD_COM_MODE_BEST * mod_info_best, s16 coef_update[12][16][16], pel pred_update[12][16][16], pel rec_tmp[12][16][16], s64 cost[6], int num_nz[12], U4 bit_depth, pel mod_info_best_rec_u[16][16], pel mod_info_best_rec_v[16][16], pel mod_info_best_coef_u[16][16], pel mod_info_best_coef_v[16][16])
{
#pragma HLS ARRAY_PARTITION variable=cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=num_nz complete dim=0
#pragma HLS ARRAY_PARTITION variable=rec_tmp complete dim=3	
//#pragma HLS ARRAY_PARTITION variable=rec_tmp cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=coef_update complete dim=2		
//#pragma HLS ARRAY_PARTITION variable=coef_update cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=pred_update complete dim=3	
//#pragma HLS ARRAY_PARTITION variable=pred_update cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=mod_info_best_rec_u complete  dim=2
#pragma HLS ARRAY_PARTITION variable=mod_info_best_rec_v complete  dim=2
#pragma HLS ARRAY_PARTITION variable=mod_info_best_coef_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=mod_info_best_coef_v complete dim=2
	U3 cu_width_log2 = mod_info_best->cu_width_log2;
	U3 cu_height_log2 = mod_info_best->cu_height_log2;
	U7 cu_width = mod_info_best->cu_width;
	U7 cu_height = mod_info_best->cu_height;
	U12 size_tmp = cu_width * cu_height >> 2;
	int w = 16;// cu_width >> 1;
	int h = 16;// cu_height >> 1;
	int j, k;
	int inter_mode = mod_info_best->cu_mode;

	static s64 cost_best1;




	if (inter_mode != MODE_INTRA)
	{
		if (inter_mode == 2) {
			num_nz[0] = 0;
			num_nz[1] = 0;
		}

			for (k = 0; k < h; ++k) {
#pragma HLS PIPELINE ii=1
pel bit_depth_mov = (1 << bit_depth) - 1;

				if (num_nz[0] == 0) {
				for (j = 0; j < w; j++) {
          pel comp = bit_depth_mov < (pred_update[0][k][j]) ? bit_depth_mov : (pred_update[0][k][j]);
          
						mod_info_best_coef_u[k][j] = 0;
						mod_info_best_rec_u[k][j]= (((0 > comp ? 0 : comp)));
				}
			}
		else {
					updateModeChroma16_coefu_mux(k, mod_info_best_coef_u, coef_update[0]);
				for (j = 0; j < w; j++) {
						//mod_info_best_coef_u[k][j] = coef_update[0][(k + j) & 15][j];
             pel comp = bit_depth_mov < (rec_tmp[0][k][j]) ? bit_depth_mov : (rec_tmp[0][k][j]);
						mod_info_best_rec_u[k][j] = ((pel)((0 > comp ? 0 : comp)));
				}
			}

		if (num_nz[1] == 0) {
				for (j = 0; j < w; j++) {
          pel comp = bit_depth_mov < (pred_update[1][k][j]) ? bit_depth_mov : (pred_update[1][k][j]);
						mod_info_best_coef_v[k][j] = 0;
						mod_info_best_rec_v[k][j] = (((0 > comp ? 0 : comp)));
				}
			}
		else {
					updateModeChroma16_coefu_mux(k, mod_info_best_coef_v, coef_update[1]);
				for (j = 0; j < w; j++) {
          pel comp =bit_depth_mov < (rec_tmp[1][k][j]) ? bit_depth_mov : (rec_tmp[1][k][j]);
						//mod_info_best_coef_v[k][j] = coef_update[1][(k + j) & 15][j];
						mod_info_best_rec_v[k][j] = ((pel)((0 > comp ? 0 : comp)));
				}
			}
		}
		mod_info_best->num_nz[0][1] = num_nz[0];
		mod_info_best->num_nz[0][2] = num_nz[1];
	}
	else
	{
		static int best_ipd1 = 0;
			cost_best1 = MAX_S64;
			for (int i = 0; i < 6; i++)
			{
#pragma HLS UNROLL
				if (cost[i] < cost_best1) {
					cost_best1 = cost[i];
					best_ipd1 = i;
				}
			}
		
				mod_info_best->ipm[0][1] = best_ipd1;
				for (int m = 0; m < h; ++m)
				{
#pragma HLS PIPELINE ii=1
					for (int n = 0; n < w; ++n)
					{

						mod_info_best_rec_u[m][n] = rec_tmp[best_ipd1 * 2][m][n];
						mod_info_best_rec_v[m][n] = rec_tmp[best_ipd1 * 2 + 1][m][n];

					}
					updateModeChroma16_coefu_mux(m, mod_info_best_coef_u, coef_update[best_ipd1 * 2]);
					updateModeChroma16_coefu_mux(m, mod_info_best_coef_v, coef_update[best_ipd1 * 2 + 1]);
				}
				mod_info_best->num_nz[0][1] = num_nz[best_ipd1 * 2];
				mod_info_best->num_nz[0][2] = num_nz[best_ipd1 * 2 + 1];
			}

	
}

 void dct_row_Chroma16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
#pragma HLS ARRAY_PARTITION variable=src complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst complete dim=2
	U7 size = 16;
	U8 size_b = size - 1;

	int j, k;
	static int E[8], O[8];
	static int EE[4], EO[4];
	static int EEE[2], EEO[2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);
	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE ii=1
		if (j < cu_height) {

		for (k = 0; k < 8; k++)
		{
			E[k] = src[j][k] + src[j][15 - k];
			O[k] = src[j][k] - src[j][15 - k];
		}
		if (cu_width == 16) {
			for (k = 0; k < 4; k++)
			{
				EE[k] = E[k] + E[7 - k];
				EO[k] = E[k] - E[7 - k];
			}
		}
		else if (cu_width == 8) {
			for (k = 0; k < 4; k++)
			{
				EE[k] = src[j][k] + src[j][7 - k];
				EO[k] = src[j][k] - src[j][7 - k];
			}
		}
		if (cu_width == 16 || cu_width == 8) {
			EEE[0] = EE[0] + EE[3];
			EEO[0] = EE[0] - EE[3];
			EEE[1] = EE[1] + EE[2];
			EEO[1] = EE[1] - EE[2];
		}
		else if (cu_width == 4) {
			EEE[0] = src[j][0] + src[j][3];
			EEO[0] = src[j][0] - src[j][3];
			EEE[1] = src[j][1] + src[j][2];
			EEO[1] = src[j][1] - src[j][2];
		}
		tmp[0] = ((32 * EEE[0] + 32 * EEE[1] + add) >> shift);
		tmp[1] = ((32 * EEE[0] - 32 * EEE[1] + add) >> shift);
		tmp[2] = ((42 * EEO[0] + 17 * EEO[1] + add) >> shift);
		tmp[3] = ((17 * EEO[0] - 42 * EEO[1] + add) >> shift);
		tmp[4] = ((44 * EO[0] + 38 * EO[1] + 25 * EO[2] + 9 * EO[3] + add) >> shift);
		tmp[5] = ((38 * EO[0] - 9 * EO[1] - 44 * EO[2] - 25 * EO[3] + add) >> shift);
		tmp[6] = ((25 * EO[0] - 44 * EO[1] + 9 * EO[2] + 38 * EO[3] + add) >> shift);
		tmp[7] = ((9 * EO[0] - 25 * EO[1] + 38 * EO[2] - 44 * EO[3] + add) >> shift);
		tmp[8] = (((45) * O[0] + (43) * O[1] + (40) * O[2] + (35) * O[3] + (29) * O[4] + (21) * O[5] + (13) * O[6] + (4) * O[7] + add) >> shift);
		tmp[9] = (((43) * O[0] + (29) * O[1] + (4) * O[2] + (-21) * O[3] + (-40) * O[4] + (-45) * O[5] + (-35) * O[6] + (-13) * O[7] + add) >> shift);
		tmp[10] = (((40) * O[0] + (4) * O[1] + (-35) * O[2] + (-43) * O[3] + (-13) * O[4] + (29) * O[5] + (45) * O[6] + (21) * O[7] + add) >> shift);
		tmp[11] = (((35) * O[0] + (-21) * O[1] + (-43) * O[2] + (4) * O[3] + (45) * O[4] + (13) * O[5] + (-40) * O[6] + (-29) * O[7] + add) >> shift);
		tmp[12] = (((29) * O[0] + (-40) * O[1] + (-13) * O[2] + (45) * O[3] + (-4) * O[4] + (-43) * O[5] + (21) * O[6] + (35) * O[7] + add) >> shift);
		tmp[13] = (((21) * O[0] + (-45) * O[1] + (29) * O[2] + (13) * O[3] + (-43) * O[4] + (35) * O[5] + (4) * O[6] + (-40) * O[7] + add) >> shift);
		tmp[14] = (((13) * O[0] + (-35) * O[1] + (45) * O[2] + (-40) * O[3] + (21) * O[4] + (4) * O[5] + (-29) * O[6] + (43) * O[7] + add) >> shift);
		tmp[15] = (((4) * O[0] + (-13) * O[1] + (21) * O[2] + (-29) * O[3] + (35) * O[4] + (-40) * O[5] + (43) * O[6] + (-45) * O[7] + add) >> shift);
		if (cu_width == 4) {
				if (j == 0) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 1) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 2) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 3) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 4) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 5) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 6) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 7) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 8) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 9) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 10) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 11) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 12) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 13) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 14) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 15) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }


		}
		else if (cu_width == 8) {
				if (j == 0) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 1) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 2) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
		}
				else if (j == 3) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 4) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 5) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 6) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 7) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 8) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 9) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 10) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 11) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 12) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 13) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 14) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 15) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
			}
		else if (cu_width == 16) {

				if (j == 0) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 1) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 2) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 3) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 4) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 5) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 6) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 7) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 8) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 9) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 10) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 11) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 12) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 13) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 14) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 15) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}

			}
		}
	}
}
void transform_hor_Chroma16(U3 cu_width_log2,U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp[16][16], s16 coef_tmp_h[16][16], U8 rdo_idx, U8 all_rdo_num)
{
	if (rdo_idx < all_rdo_num) {
	U3 tb_width_log2 = cu_width_log2;// com_tbl_log2[w];
	U4 shift1;
	shift1 = com_get_forward_trans_shift(tb_width_log2, 0, md_fw_ptr_bit_depth_internal);
	dct_row_Chroma16(w, h, coef_tmp, coef_tmp_h, shift1);
	}
}
static void dct_col_Chroma16(U8 cu_width, U8 cu_height, s16 src[16][16], s16 dst[16][16], U4 shift)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst complete dim=1
	U7 size = 16;
	U8 size_b = size - 1;
	int j, k;
	int E[8], O[8];
	int EE[4], EO[4];
	int EEE[2], EEO[2];
	int tmp[16];
	int add;
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
	if (cu_height == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);
	for (j = 0; j < 16; j++)
	{
#pragma HLS PIPELINE
		if (j < cu_width) {

		for (k = 0; k < 8; k++)
		{
			E[k] = src[j][(k + j) & size_b] + src[j][(15 - k + j) & size_b];
			O[k] = src[j][(k + j) & size_b] - src[j][(15 - k + j) & size_b];
		}
		if (cu_height == 16) {
			for (k = 0; k < 4; k++)
			{
				EE[k] = E[k] + E[7 - k];
				EO[k] = E[k] - E[7 - k];
			}
		}
		else if (cu_height == 8) {
			for (k = 0; k < 4; k++)
			{
				EE[k] = src[j][(k + j) & size_b] + src[j][(7 - k + j) & size_b];
				EO[k] = src[j][(k + j) & size_b] - src[j][(7 - k + j) & size_b];
			}
		}
		if (cu_height == 16 || cu_height == 8) {
			EEE[0] = EE[0] + EE[3];
			EEO[0] = EE[0] - EE[3];
			EEE[1] = EE[1] + EE[2];
			EEO[1] = EE[1] - EE[2];
		}
		else if (cu_height == 4) {
			EEE[0] = src[j][(0 + j) & size_b] + src[j][(3 + j) & size_b];
			EEO[0] = src[j][(0 + j) & size_b] - src[j][(3 + j) & size_b];
			EEE[1] = src[j][(1 + j) & size_b] + src[j][(2 + j) & size_b];
			EEO[1] = src[j][(1 + j) & size_b] - src[j][(2 + j) & size_b];
		}
		tmp[0] = ((32 * EEE[0] + 32 * EEE[1] + add) >> shift);
		tmp[1] = ((32 * EEE[0] - 32 * EEE[1] + add) >> shift);
		tmp[2] = ((42 * EEO[0] + 17 * EEO[1] + add) >> shift);
		tmp[3] = ((17 * EEO[0] - 42 * EEO[1] + add) >> shift);
		tmp[4] = ((44 * EO[0] + 38 * EO[1] + 25 * EO[2] + 9 * EO[3] + add) >> shift);
		tmp[5] = ((38 * EO[0] - 9 * EO[1] - 44 * EO[2] - 25 * EO[3] + add) >> shift);
		tmp[6] = ((25 * EO[0] - 44 * EO[1] + 9 * EO[2] + 38 * EO[3] + add) >> shift);
		tmp[7] = ((9 * EO[0] - 25 * EO[1] + 38 * EO[2] - 44 * EO[3] + add) >> shift);
		tmp[8] = (((45) * O[0] + (43) * O[1] + (40) * O[2] + (35) * O[3] + (29) * O[4] + (21) * O[5] + (13) * O[6] + (4) * O[7] + add) >> shift);
		tmp[9] = (((43) * O[0] + (29) * O[1] + (4) * O[2] + (-21) * O[3] + (-40) * O[4] + (-45) * O[5] + (-35) * O[6] + (-13) * O[7] + add) >> shift);
		tmp[10] = (((40) * O[0] + (4) * O[1] + (-35) * O[2] + (-43) * O[3] + (-13) * O[4] + (29) * O[5] + (45) * O[6] + (21) * O[7] + add) >> shift);
		tmp[11] = (((35) * O[0] + (-21) * O[1] + (-43) * O[2] + (4) * O[3] + (45) * O[4] + (13) * O[5] + (-40) * O[6] + (-29) * O[7] + add) >> shift);
		tmp[12] = (((29) * O[0] + (-40) * O[1] + (-13) * O[2] + (45) * O[3] + (-4) * O[4] + (-43) * O[5] + (21) * O[6] + (35) * O[7] + add) >> shift);
		tmp[13] = (((21) * O[0] + (-45) * O[1] + (29) * O[2] + (13) * O[3] + (-43) * O[4] + (35) * O[5] + (4) * O[6] + (-40) * O[7] + add) >> shift);
		tmp[14] = (((13) * O[0] + (-35) * O[1] + (45) * O[2] + (-40) * O[3] + (21) * O[4] + (4) * O[5] + (-29) * O[6] + (43) * O[7] + add) >> shift);
		tmp[15] = (((4) * O[0] + (-13) * O[1] + (21) * O[2] + (-29) * O[3] + (35) * O[4] + (-40) * O[5] + (43) * O[6] + (-45) * O[7] + add) >> shift);
		if (cu_height == 4) {
				if (j == 0) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 1) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 2) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 3) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 4) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 5) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 6) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 7) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 8) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 9) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 10) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 11) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 12) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 13) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 14) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
				else if (j == 15) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }

		}
		else if (cu_height == 8) {
				if (j == 0) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 1) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 2) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 3) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 4) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 5) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 6) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 7) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 8) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 9) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 10) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 11) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 12) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 13) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 14) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
				else if (j == 15) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }

		}
		else if (cu_height == 16) {
				if (j == 0) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 1) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 2) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 3) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 4) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 5) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 6) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 7) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 8) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 9) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 10) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 11) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 12) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 13) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 14) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
				else if (j == 15) {
					dst[0][j] = tmp[0]; dst[8][j] = tmp[1]; dst[4][j] = tmp[2]; dst[12][j] = tmp[3]; dst[2][j] = tmp[4]; dst[6][j] = tmp[5]; dst[10][j] = tmp[6]; dst[14][j] = tmp[7]; dst[1][j] = tmp[8]; dst[3][j] = tmp[9]; dst[5][j] = tmp[10]; dst[7][j] = tmp[11]; dst[9][j] = tmp[12]; dst[11][j] = tmp[13]; dst[13][j] = tmp[14]; dst[15][j] = tmp[15];
				}
			}
		}
	}
}
void transform_ver_Chroma16(U3 cu_height_log2, U8 w, U8 h, U4 md_fw_ptr_bit_depth_internal, s16 coef_tmp_h[16][16], s16 coef_tmp_v[16][16], U8 rdo_idx, U8 all_rdo_num)
{
	if (rdo_idx < all_rdo_num) {
	U3 tb_height_log2 = cu_height_log2;// com_tbl_log2[h];
	U4 shift2;
	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, md_fw_ptr_bit_depth_internal);
	dct_col_Chroma16(w, h, coef_tmp_h, coef_tmp_v, shift2);
	}
}

void calcDiffChroma16(U3 cu_width_c, U3 cu_height_c, s16 orgU[16][16], s16 pred[16][16], s16 coef_tmp[16][16],U8 rdo_idx,U8 all_rdo_num)
{
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=2
	if (rdo_idx < all_rdo_num) {
	//if (cu_mode != 0) {
	s16 coef_tmp_buf[16];
#pragma HLS ARRAY_PARTITION variable=coef_tmp_buf complete dim=0
	for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < 16; j++) {
			if ((j < cu_width_c) && (i < cu_height_c)) {
				coef_tmp_buf[j] = ((s16)(((int)orgU[i][j]) - ((int)pred[i][j])));
			}
			else {
				coef_tmp_buf[j] = 0;
			}
		}
		for (int j = 0; j < 16; j++) {
			coef_tmp[i][j] = coef_tmp_buf[j];
		}
	}
}
}

void rdo_chroma_16_dataflow(u8 all_rdo_num, U7 cu_width, U7 cu_height, U4 bit_depth, MD_COM_MODE_BEST* mod_info_best,
	U3 cu_width_log2, U3 cu_height_log2, RDOQ_ARRAY* rdoq_array, int num_nz_rate[12], s16 coef_pb_part[12][16][16],
	pel pred_cache_ith[12][16][16], pel pred_cache_ith1[12][16][16], pel rec_tmp[12][16][16], pel orgU[2][16][16], MD_INPUT* md_input_ptr, MD_FW* md_fw_ptr)
{
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=1
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith1 complete dim=3
#pragma HLS ARRAY_PARTITION variable=rec_tmp complete dim=3	
#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete dim=2	
#pragma HLS ARRAY_PARTITION variable=num_nz_rate complete dim=0
#pragma HLS RESOURCE variable=orgU core=RAM_1P
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P
#pragma HLS RESOURCE variable=pred_cache_ith1 core=RAM_1P
#pragma HLS RESOURCE variable=rec_tmp core=RAM_1P
#pragma HLS RESOURCE variable=coef_pb_part core=RAM_1P


		s16 diff[2][16][16];
		s16 coef_tmp_h[2][16][16];
		s16 coef_tmp_v[2][16][16];
		s16 tmp_dst_coef[2][16][16];

		s16 coef_tmp_itv[2][16][16];
		s16 coef_dq[2][16][16];
		s16 coef_tmp_ith[2][16][16];
		s16 resi[2][16][16];
#pragma HLS RESOURCE variable=diff core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_dq core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=resi core=RAM_S2P_BRAM
		int final_x[2], final_y[2];
		int num_nz_ith[2], num_nz_itv[2];
		int num_nz_ith0[2], num_nz_ith1[2];


		calcDiffChroma16(cu_width, cu_height, orgU[0], pred_cache_ith[0], diff[0], 0, all_rdo_num);

		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[0], coef_tmp_h[0], 0, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[1], pred_cache_ith[1], diff[1], 1, all_rdo_num);

		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[0], coef_tmp_v[0], 0, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[1], coef_tmp_h[1], 1, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[0], pred_cache_ith[2], diff[0], 2, all_rdo_num);

		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[0], cu_width_log2, cu_height_log2, 0 + 1, bit_depth, rdoq_array, tmp_dst_coef[0], &final_x[0], &final_y[0], 0, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[1], coef_tmp_v[1], 1, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[0], coef_tmp_h[0], 2, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[1], pred_cache_ith[3], diff[1], 3, all_rdo_num);

		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[0], tmp_dst_coef[0], final_x[0], final_y[0], &num_nz_itv[0], coef_pb_part[0], 0, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[1], cu_width_log2, cu_height_log2, 1 + 1, bit_depth, rdoq_array, tmp_dst_coef[1], &final_x[1], &final_y[1], 1, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[0], coef_tmp_v[0], 2, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[1], coef_tmp_h[1], 3, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[0], pred_cache_ith[4], diff[0], 4, all_rdo_num);

		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[0], &num_nz_ith[0], &num_nz_rate[0], coef_tmp_itv[0], coef_dq[0], cu_width_log2, cu_height_log2, 0, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[1], tmp_dst_coef[1], final_x[1], final_y[1], &num_nz_itv[1], coef_pb_part[1], 1, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[0], cu_width_log2, cu_height_log2, 0 + 1, bit_depth, rdoq_array, tmp_dst_coef[0], &final_x[0], &final_y[0], 2, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[1], coef_tmp_v[1], 3, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[0], coef_tmp_h[0], 4, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[1], pred_cache_ith[5], diff[1], 5, all_rdo_num);

		itrans_v_Chroma16(cu_width, cu_height, coef_dq[0], coef_tmp_ith[0], cu_width_log2, bit_depth, num_nz_ith[0], &num_nz_ith0[0], 0, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[1], &num_nz_ith[1], &num_nz_rate[1], coef_tmp_itv[1], coef_dq[1], cu_width_log2, cu_height_log2, 1, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[0], tmp_dst_coef[0], final_x[0], final_y[0], &num_nz_itv[0], coef_pb_part[2], 2, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[1], cu_width_log2, cu_height_log2, 1 + 1, bit_depth, rdoq_array, tmp_dst_coef[1], &final_x[1], &final_y[1], 3, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[0], coef_tmp_v[0], 4, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[1], coef_tmp_h[1], 5, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[0], pred_cache_ith[6], diff[0], 6, all_rdo_num);

		itrans_h_Chroma16(cu_width, cu_height, resi[0], coef_tmp_ith[0], cu_height_log2, bit_depth, num_nz_ith0[0], &num_nz_ith1[0], 0, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[1], coef_tmp_ith[1], cu_width_log2, bit_depth, num_nz_ith[1], &num_nz_ith0[1], 1, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[0], &num_nz_ith[0], &num_nz_rate[2], coef_tmp_itv[0], coef_dq[0], cu_width_log2, cu_height_log2, 2, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[1], tmp_dst_coef[1], final_x[1], final_y[1], &num_nz_itv[1], coef_pb_part[3], 3, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[0], cu_width_log2, cu_height_log2, 0 + 1, bit_depth, rdoq_array, tmp_dst_coef[0], &final_x[0], &final_y[0], 4, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[1], coef_tmp_v[1], 5, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[0], coef_tmp_h[0], 6, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[1], pred_cache_ith[7], diff[1], 7, all_rdo_num);

		recon_Chroma16(resi[0], pred_cache_ith1[0], num_nz_ith1[0], cu_width, cu_height, rec_tmp[0], bit_depth, 0, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[1], coef_tmp_ith[1], cu_height_log2, bit_depth, num_nz_ith0[1], &num_nz_ith1[1], 1, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[0], coef_tmp_ith[0], cu_width_log2, bit_depth, num_nz_ith[0], &num_nz_ith0[0], 2, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[1], &num_nz_ith[1], &num_nz_rate[3], coef_tmp_itv[1], coef_dq[1], cu_width_log2, cu_height_log2, 3, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[0], tmp_dst_coef[0], final_x[0], final_y[0], &num_nz_itv[0], coef_pb_part[4], 4, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[1], cu_width_log2, cu_height_log2, 1 + 1, bit_depth, rdoq_array, tmp_dst_coef[1], &final_x[1], &final_y[1], 5, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[0], coef_tmp_v[0], 6, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[1], coef_tmp_h[1], 7, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[0], pred_cache_ith[8], diff[0], 8, all_rdo_num);

		recon_Chroma16(resi[1], pred_cache_ith1[1], num_nz_ith1[1], cu_width, cu_height, rec_tmp[1], bit_depth, 1, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[0], coef_tmp_ith[0], cu_height_log2, bit_depth, num_nz_ith0[0], &num_nz_ith1[0], 2, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[1], coef_tmp_ith[1], cu_width_log2, bit_depth, num_nz_ith[1], &num_nz_ith0[1], 3, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[0], &num_nz_ith[0], &num_nz_rate[4], coef_tmp_itv[0], coef_dq[0], cu_width_log2, cu_height_log2, 4, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[1], tmp_dst_coef[1], final_x[1], final_y[1], &num_nz_itv[1], coef_pb_part[5], 5, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[0], cu_width_log2, cu_height_log2, 0 + 1, bit_depth, rdoq_array, tmp_dst_coef[0], &final_x[0], &final_y[0], 6, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[1], coef_tmp_v[1], 7, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[0], coef_tmp_h[0], 8, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[1], pred_cache_ith[9], diff[1], 9, all_rdo_num);

		recon_Chroma16(resi[0], pred_cache_ith1[2], num_nz_ith1[0], cu_width, cu_height, rec_tmp[2], bit_depth, 2, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[1], coef_tmp_ith[1], cu_height_log2, bit_depth, num_nz_ith0[1], &num_nz_ith1[1], 3, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[0], coef_tmp_ith[0], cu_width_log2, bit_depth, num_nz_ith[0], &num_nz_ith0[0], 4, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[1], &num_nz_ith[1], &num_nz_rate[5], coef_tmp_itv[1], coef_dq[1], cu_width_log2, cu_height_log2, 5, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[0], tmp_dst_coef[0], final_x[0], final_y[0], &num_nz_itv[0], coef_pb_part[6], 6, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[1], cu_width_log2, cu_height_log2, 1 + 1, bit_depth, rdoq_array, tmp_dst_coef[1], &final_x[1], &final_y[1], 7, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[0], coef_tmp_v[0], 8, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[1], coef_tmp_h[1], 9, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[0], pred_cache_ith[10], diff[0], 10, all_rdo_num);

		recon_Chroma16(resi[1], pred_cache_ith1[3], num_nz_ith1[1], cu_width, cu_height, rec_tmp[3], bit_depth, 3, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[0], coef_tmp_ith[0], cu_height_log2, bit_depth, num_nz_ith0[0], &num_nz_ith1[0], 4, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[1], coef_tmp_ith[1], cu_width_log2, bit_depth, num_nz_ith[1], &num_nz_ith0[1], 5, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[0], &num_nz_ith[0], &num_nz_rate[6], coef_tmp_itv[0], coef_dq[0], cu_width_log2, cu_height_log2, 6, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[1], tmp_dst_coef[1], final_x[1], final_y[1], &num_nz_itv[1], coef_pb_part[7], 7, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[0], cu_width_log2, cu_height_log2, 0 + 1, bit_depth, rdoq_array, tmp_dst_coef[0], &final_x[0], &final_y[0], 8, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[1], coef_tmp_v[1], 9, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[0], coef_tmp_h[0], 10, all_rdo_num);
		calcDiffChroma16(cu_width, cu_height, orgU[1], pred_cache_ith[11], diff[1], 11, all_rdo_num);

		recon_Chroma16(resi[0], pred_cache_ith1[4], num_nz_ith1[0], cu_width, cu_height, rec_tmp[4], bit_depth, 4, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[1], coef_tmp_ith[1], cu_height_log2, bit_depth, num_nz_ith0[1], &num_nz_ith1[1], 5, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[0], coef_tmp_ith[0], cu_width_log2, bit_depth, num_nz_ith[0], &num_nz_ith0[0], 6, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[1], &num_nz_ith[1], &num_nz_rate[7], coef_tmp_itv[1], coef_dq[1], cu_width_log2, cu_height_log2, 7, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[0], tmp_dst_coef[0], final_x[0], final_y[0], &num_nz_itv[0], coef_pb_part[8], 8, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[1], cu_width_log2, cu_height_log2, 1 + 1, bit_depth, rdoq_array, tmp_dst_coef[1], &final_x[1], &final_y[1], 9, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[0], coef_tmp_v[0], 10, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff[1], coef_tmp_h[1], 11, all_rdo_num);

		recon_Chroma16(resi[1], pred_cache_ith1[5], num_nz_ith1[1], cu_width, cu_height, rec_tmp[5], bit_depth, 5, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[0], coef_tmp_ith[0], cu_height_log2, bit_depth, num_nz_ith0[0], &num_nz_ith1[0], 6, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[1], coef_tmp_ith[1], cu_width_log2, bit_depth, num_nz_ith[1], &num_nz_ith0[1], 7, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[0], &num_nz_ith[0], &num_nz_rate[8], coef_tmp_itv[0], coef_dq[0], cu_width_log2, cu_height_log2, 8, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[1], tmp_dst_coef[1], final_x[1], final_y[1], &num_nz_itv[1], coef_pb_part[9], 9, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[0], cu_width_log2, cu_height_log2, 0 + 1, bit_depth, rdoq_array, tmp_dst_coef[0], &final_x[0], &final_y[0], 10, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h[1], coef_tmp_v[1], 11, all_rdo_num);

		recon_Chroma16(resi[0], pred_cache_ith1[6], num_nz_ith1[0], cu_width, cu_height, rec_tmp[6], bit_depth, 6, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[1], coef_tmp_ith[1], cu_height_log2, bit_depth, num_nz_ith0[1], &num_nz_ith1[1], 7, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[0], coef_tmp_ith[0], cu_width_log2, bit_depth, num_nz_ith[0], &num_nz_ith0[0], 8, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[1], &num_nz_ith[1], &num_nz_rate[9], coef_tmp_itv[1], coef_dq[1], cu_width_log2, cu_height_log2, 9, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[0], tmp_dst_coef[0], final_x[0], final_y[0], &num_nz_itv[0], coef_pb_part[10], 10, all_rdo_num);
		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v[1], cu_width_log2, cu_height_log2, 1 + 1, bit_depth, rdoq_array, tmp_dst_coef[1], &final_x[1], &final_y[1], 11, all_rdo_num);

		recon_Chroma16(resi[1], pred_cache_ith1[7], num_nz_ith1[1], cu_width, cu_height, rec_tmp[7], bit_depth, 7, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[0], coef_tmp_ith[0], cu_height_log2, bit_depth, num_nz_ith0[0], &num_nz_ith1[0], 8, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[1], coef_tmp_ith[1], cu_width_log2, bit_depth, num_nz_ith[1], &num_nz_ith0[1], 9, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[0], &num_nz_ith[0], &num_nz_rate[10], coef_tmp_itv[0], coef_dq[0], cu_width_log2, cu_height_log2, 10, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv[1], tmp_dst_coef[1], final_x[1], final_y[1], &num_nz_itv[1], coef_pb_part[11], 11, all_rdo_num);

		recon_Chroma16(resi[0], pred_cache_ith1[8], num_nz_ith1[0], cu_width, cu_height, rec_tmp[8], bit_depth, 8, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[1], coef_tmp_ith[1], cu_height_log2, bit_depth, num_nz_ith0[1], &num_nz_ith1[1], 9, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[0], coef_tmp_ith[0], cu_width_log2, bit_depth, num_nz_ith[0], &num_nz_ith0[0], 10, all_rdo_num);
		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv[1], &num_nz_ith[1], &num_nz_rate[11], coef_tmp_itv[1], coef_dq[1], cu_width_log2, cu_height_log2, 11, all_rdo_num);

		recon_Chroma16(resi[1], pred_cache_ith1[9], num_nz_ith1[1], cu_width, cu_height, rec_tmp[9], bit_depth, 9, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[0], coef_tmp_ith[0], cu_height_log2, bit_depth, num_nz_ith0[0], &num_nz_ith1[0], 10, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq[1], coef_tmp_ith[1], cu_width_log2, bit_depth, num_nz_ith[1], &num_nz_ith0[1], 11, all_rdo_num);

		recon_Chroma16(resi[0], pred_cache_ith1[10], num_nz_ith1[0], cu_width, cu_height, rec_tmp[10], bit_depth, 10, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi[1], coef_tmp_ith[1], cu_height_log2, bit_depth, num_nz_ith0[1], &num_nz_ith1[1], 11, all_rdo_num);

		recon_Chroma16(resi[1], pred_cache_ith1[11], num_nz_ith1[1], cu_width, cu_height, rec_tmp[11], bit_depth, 11, all_rdo_num);



	
}

void rdo_chroma_16_dataflow_x(u8 all_rdo_num, U7 cu_width, U7 cu_height, U4 bit_depth, MD_COM_MODE_BEST* mod_info_best,
	U3 cu_width_log2, U3 cu_height_log2, RDOQ_ARRAY* rdoq_array, int num_nz_rate[12], s16 coef_pb_part[12][16][16],
	pel pred_cache_ith[12][16][16], pel pred_cache_ith1[12][16][16], pel rec_tmp[12][16][16], pel orgU[2][16][16], MD_INPUT* md_input_ptr, MD_FW* md_fw_ptr)
{
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=1
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith1 complete dim=3
#pragma HLS ARRAY_PARTITION variable=rec_tmp complete dim=3	
#pragma HLS ARRAY_PARTITION variable=coef_pb_part complete dim=2	
#pragma HLS ARRAY_PARTITION variable=num_nz_rate complete dim=0
#pragma HLS RESOURCE variable=orgU core=RAM_1P
#pragma HLS RESOURCE variable=pred_cache_ith core=RAM_1P
#pragma HLS RESOURCE variable=pred_cache_ith1 core=RAM_1P
#pragma HLS RESOURCE variable=rec_tmp core=RAM_1P
#pragma HLS RESOURCE variable=coef_pb_part core=RAM_1P


	for (u8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
	{
#pragma HLS DATAFLOW
#pragma HLS LOOP_TRIPCOUNT min=12 max=12 avg=12
		s16 diff[16][16];
		s16 coef_tmp_h[16][16];
		s16 coef_tmp_v[16][16];
		s16 tmp_dst_coef[16][16];

		s16 coef_tmp_itv[16][16];
		s16 coef_dq[16][16];
		s16 coef_tmp_ith[16][16];
		s16 resi[16][16];
#pragma HLS RESOURCE variable=diff core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_h core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_itv core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_dq core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_tmp_ith core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=resi core=RAM_S2P_BRAM
		int final_x, final_y;
		int num_nz_ith, num_nz_itv;
		int num_nz_ith0, num_nz_ith1;
		u8 uv = rdo_idx & 1;

		calcDiffChroma16(cu_width, cu_height, orgU[uv], pred_cache_ith[rdo_idx], diff, rdo_idx, all_rdo_num);
		transform_hor_Chroma16(cu_width_log2, cu_width, cu_height, bit_depth, diff, coef_tmp_h, rdo_idx, all_rdo_num);
		transform_ver_Chroma16(cu_height_log2, cu_width, cu_height, bit_depth, coef_tmp_h, coef_tmp_v, rdo_idx, all_rdo_num);


		rdoq_top_16_all_chroma(cu_width, cu_height, md_input_ptr->qp_u, md_input_ptr->lambda[1], 1, coef_tmp_v, cu_width_log2, cu_height_log2,
			uv + 1, bit_depth, rdoq_array, tmp_dst_coef, &final_x, &final_y, rdo_idx, all_rdo_num);
		CleanNz_16_all_chroma(cu_width, cu_height, coef_tmp_itv, tmp_dst_coef, final_x, final_y, &num_nz_itv,
			coef_pb_part[rdo_idx], rdo_idx, all_rdo_num);

		Dq_16_chroma(cu_width, cu_height, bit_depth, md_input_ptr->qp_u, num_nz_itv, &num_nz_ith, &num_nz_rate[rdo_idx], coef_tmp_itv, coef_dq, cu_width_log2, cu_height_log2, rdo_idx, all_rdo_num);
		itrans_v_Chroma16(cu_width, cu_height, coef_dq, coef_tmp_ith, cu_width_log2, bit_depth, num_nz_ith, &num_nz_ith0, rdo_idx, all_rdo_num);
		itrans_h_Chroma16(cu_width, cu_height, resi, coef_tmp_ith, cu_height_log2, bit_depth, num_nz_ith0, &num_nz_ith1, rdo_idx, all_rdo_num);
		recon_Chroma16(resi, pred_cache_ith1[rdo_idx], num_nz_ith1, cu_width, cu_height, rec_tmp[rdo_idx], bit_depth, rdo_idx, all_rdo_num);


	}
}
void rdo_chroma_16_pipeline_pred(U7 cu_width, U7 cu_height, U3 cu_width_log2, U3 cu_height_log2, u8 all_rdo_num, MD_COM_MODE_BEST* mod_info_best, U4 bit_depth, MD_FW* md_fw_ptr, pel orgU[2][16][16], S8 ipm,
	strFetch_ref_window* Fetch_Ref_window_ptr, pel piRecoY[32][32], pel pred_cache_ith[12][16][16], pel pred_cache_ith1[12][16][16],
	pel	IP_buffer_ptr_U_16x16_up_line[2 * 16], pel IP_buffer_ptr_U_16x16_left_line[2 * 16], pel IP_buffer_ptr_U_16x16_top_left,
	pel	IP_buffer_ptr_V_16x16_up_line[2 * 16], pel IP_buffer_ptr_V_16x16_left_line[2 * 16], pel IP_buffer_ptr_V_16x16_top_left,
	pel	IP_buffer_ptr_U_8x16_up_line[2 * 8], pel IP_buffer_ptr_U_8x16_left_line[2 * 16], pel IP_buffer_ptr_U_8x16_top_left,
	pel	IP_buffer_ptr_V_8x16_up_line[2 * 8], pel IP_buffer_ptr_V_8x16_left_line[2 * 16], pel IP_buffer_ptr_V_8x16_top_left,
	pel	IP_buffer_ptr_U_16x8_up_line[2 * 16], pel IP_buffer_ptr_U_16x8_left_line[2 * 8], pel IP_buffer_ptr_U_16x8_top_left,
	pel	IP_buffer_ptr_V_16x8_up_line[2 * 16], pel IP_buffer_ptr_V_16x8_left_line[2 * 8], pel IP_buffer_ptr_V_16x8_top_left,
	pel	IP_buffer_ptr_16x32_up_line[2 * 16], pel IP_buffer_ptr_16x32_left_line[2 * 32], pel IP_buffer_ptr_16x32_top_left,
	pel	IP_buffer_ptr_32x16_up_line[2 * 32], pel IP_buffer_ptr_32x16_left_line[2 * 16], pel IP_buffer_ptr_32x16_top_left,
	pel	IP_buffer_ptr_32x32_up_line[2 * 32], pel IP_buffer_ptr_32x32_left_line[2 * 32], pel IP_buffer_ptr_32x32_top_left,
	U32 IP_map_scu_ptr_16x32_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x16_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x32_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_top_left_new

#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif

)
			{
#pragma HLS INLINE OFF
//#pragma HLS ARRAY_PARTITION variable=pred_cache_ith cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=pred_cache_ith complete dim=3

#pragma HLS ARRAY_PARTITION variable=mod_info_best->ipm complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_best->num_nz complete dim=0
//#pragma HLS ARRAY_PARTITION variable=orgU complete dim=1
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=3
	static pel nb[2][2][2 * 16 + 3];
#pragma HLS ARRAY_PARTITION variable=nb complete dim=0
#if USE_TSCPM
	pel nb_y[2][32 * 2 + 3];
#pragma HLS ARRAY_PARTITION variable=nb_y complete dim=0
#endif
	for (int i = 0; i < 2 * 16 + 3; i++) {
#pragma HLS UNROLL
		nb[1][0][i] = (1 << bit_depth - 1);
		nb[1][1][i] = (1 << bit_depth - 1);
		nb[0][0][i] = (1 << bit_depth - 1);
		nb[0][1][i] = (1 << bit_depth - 1);
			}
	for (int i = 0; i < 2 * 8 + 3; i++) {
#pragma HLS UNROLL
		nb_y[0][i] = (1 << bit_depth - 1);
		nb_y[1][i] = (1 << bit_depth - 1);
		}

	u16 avail_cu_output = 0;

	if (mod_info_best->cu_mode != MODE_INTRA)
	{
		ip_chroma_16_inter(mod_info_best, md_fw_ptr,
			pred_cache_ith[0], pred_cache_ith[1], bit_depth, Fetch_Ref_window_ptr,
			pred_cache_ith1[0], pred_cache_ith1[1]
#if SUB_TMVP
			, core_sbtmvp
#endif
		);

	}
	else if (mod_info_best->cu_mode == MODE_INTRA)
	{
		ipred_c_16_prepare(md_fw_ptr, cu_width_log2, cu_height_log2,
			mod_info_best->x_pos, mod_info_best->y_pos,
			mod_info_best, nb_y, piRecoY, nb[0], nb[1],
			&avail_cu_output,
			IP_buffer_ptr_U_16x16_up_line, IP_buffer_ptr_U_16x16_left_line, IP_buffer_ptr_U_16x16_top_left,
			IP_buffer_ptr_V_16x16_up_line, IP_buffer_ptr_V_16x16_left_line, IP_buffer_ptr_V_16x16_top_left,
			IP_buffer_ptr_U_8x16_up_line, IP_buffer_ptr_U_8x16_left_line, IP_buffer_ptr_U_8x16_top_left,
			IP_buffer_ptr_V_8x16_up_line, IP_buffer_ptr_V_8x16_left_line, IP_buffer_ptr_V_8x16_top_left,
			IP_buffer_ptr_U_16x8_up_line, IP_buffer_ptr_U_16x8_left_line, IP_buffer_ptr_U_16x8_top_left,
			IP_buffer_ptr_V_16x8_up_line, IP_buffer_ptr_V_16x8_left_line, IP_buffer_ptr_V_16x8_top_left,
			IP_buffer_ptr_16x32_up_line, IP_buffer_ptr_16x32_left_line, IP_buffer_ptr_16x32_top_left,
			IP_buffer_ptr_32x16_up_line, IP_buffer_ptr_32x16_left_line, IP_buffer_ptr_32x16_top_left,
			IP_buffer_ptr_32x32_up_line, IP_buffer_ptr_32x32_left_line, IP_buffer_ptr_32x32_top_left,
			IP_map_scu_ptr_16x32_map_scu_up_line,
			IP_map_scu_ptr_16x32_map_scu_left_line_new,
			IP_map_scu_ptr_16x32_map_scu_top_left_new,
			IP_map_scu_ptr_32x16_map_scu_up_line,
			IP_map_scu_ptr_32x16_map_scu_left_line_new,
			IP_map_scu_ptr_32x16_map_scu_top_left_new,
			IP_map_scu_ptr_32x32_map_scu_up_line,
			IP_map_scu_ptr_32x32_map_scu_left_line_new,
			IP_map_scu_ptr_32x32_map_scu_top_left_new
		);
		for (u8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
		{
#pragma HLS LOOP_TRIPCOUNT min=12 max=12 avg=12
			u8 uv = rdo_idx & 1;
			ipred_c_16(cu_width_log2, cu_height_log2, cu_width, cu_height, md_fw_ptr, pred_cache_ith[rdo_idx], pred_cache_ith1[rdo_idx],
				nb_y, piRecoY, nb[uv], rdo_idx, ipm, avail_cu_output
			);
		}
	}
}
void rdo_chroma_16_pipeline_updata(u8 all_rdo_num, U7 cu_width, U7 cu_height, U3 cu_width_log2, U3 cu_height_log2,
	U4 bit_depth, MD_COM_MODE_BEST* mod_info_best,pel orgU[2][16][16], MD_INPUT* md_input_ptr,s16 coef_pb_part[12][16][16],
	pel rec_tmp[12][16][16],int num_nz_rate[12],pel pred_cache_ith[12][16][16], 
	pel mod_info_best_rec_u[16][16], pel mod_info_best_rec_v[16][16], 
	pel mod_info_best_coef_u[16][16], pel mod_info_best_coef_v[16][16]
)
{
#pragma HLS INLINE OFF
	s64 cost[6];
#pragma HLS ARRAY_PARTITION variable=cost complete dim=0
	for (int i = 0; i < 6; i++) {
#pragma HLS UNROLL
		cost[i] = 9223372036854775807;
	}
#pragma HLS ARRAY_PARTITION variable= md_input_ptr->dist_chroma_weight complete dim=0
#pragma HLS ARRAY_PARTITION variable= md_input_ptr->lambda complete dim=0
	for (u8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++)
	{
#pragma HLS LOOP_TRIPCOUNT min=12 max=12 avg=12
		u8 uv = rdo_idx & 1;
		rate_est_chroma_intra_16(cost, uv, md_input_ptr->dist_chroma_weight, mod_info_best->cu_mode, cu_width_log2, cu_height_log2,
			coef_pb_part, md_input_ptr->lambda[uv], num_nz_rate, rdo_idx, mod_info_best, cu_width, cu_height, rec_tmp[rdo_idx], 1, bit_depth, orgU[uv]);
	}
	update_chroma_16(mod_info_best, coef_pb_part, pred_cache_ith, rec_tmp, cost, num_nz_rate, bit_depth,
		mod_info_best_rec_u,
		mod_info_best_rec_v,
		mod_info_best_coef_u,
		mod_info_best_coef_v);
}

#if !CHROMA_16_PIPELINE_DUMMY
void rdo_chroma_16_pipeline(u8 all_rdo_num, MD_COM_MODE_BEST * mod_info_best, RDOQ_ARRAY * rdoq_array, MD_FW * md_fw_ptr,
	U2 tree_status,
	pel RefWindowLCU_UP[(SWH * SWW) >> 2], pel RefWindowLCU_VP[(SWH * SWW) >> 2], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	pel RefWindowLCU_UP_ref1[(SWH * SWW) >> 2], pel RefWindowLCU_VP_ref1[(SWH * SWW) >> 2], S14 CtrPos_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	MD_INPUT * md_input_ptr, pel orgU[2][16][16], 
	S8 ipm, U7 cu_width, U7 cu_height, U3 cu_width_log2, U3 cu_height_log2, U6 qp, s64 lambda, U1 is_intra_quant, int mod_info_nz_tb_part, s64 lambda_y, U4 bit_depth, strFetch_ref_window * Fetch_Ref_window_ptr,
	pel piRecoY[32][32], 
#if SUB_TMVP
	CORE_SBTMVP * core_sbtmvp,
#endif
	pel mod_info_best_rec_u[16][16], pel mod_info_best_rec_v[16][16], pel mod_info_best_coef_u[16][16], pel mod_info_best_coef_v[16][16],
	pel	IP_buffer_ptr_U_16x16_up_line[2 * 16], pel IP_buffer_ptr_U_16x16_left_line[2 * 16], pel IP_buffer_ptr_U_16x16_top_left,
	pel	IP_buffer_ptr_V_16x16_up_line[2 * 16], pel IP_buffer_ptr_V_16x16_left_line[2 * 16], pel IP_buffer_ptr_V_16x16_top_left,
	pel	IP_buffer_ptr_U_8x16_up_line[2 * 8], pel IP_buffer_ptr_U_8x16_left_line[2 * 16], pel IP_buffer_ptr_U_8x16_top_left,
	pel	IP_buffer_ptr_V_8x16_up_line[2 * 8], pel IP_buffer_ptr_V_8x16_left_line[2 * 16], pel IP_buffer_ptr_V_8x16_top_left,
	pel	IP_buffer_ptr_U_16x8_up_line[2 * 16], pel IP_buffer_ptr_U_16x8_left_line[2 * 8], pel IP_buffer_ptr_U_16x8_top_left,
	pel	IP_buffer_ptr_V_16x8_up_line[2 * 16], pel IP_buffer_ptr_V_16x8_left_line[2 * 8], pel IP_buffer_ptr_V_16x8_top_left,
	pel	IP_buffer_ptr_16x32_up_line[2 * 16], pel IP_buffer_ptr_16x32_left_line[2 * 32], pel IP_buffer_ptr_16x32_top_left,
	pel	IP_buffer_ptr_32x16_up_line[2 * 32], pel IP_buffer_ptr_32x16_left_line[2 * 16], pel IP_buffer_ptr_32x16_top_left,
	pel	IP_buffer_ptr_32x32_up_line[2 * 32], pel IP_buffer_ptr_32x32_left_line[2 * 32], pel IP_buffer_ptr_32x32_top_left,
	U32 IP_map_scu_ptr_16x32_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_16x32_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x16_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_32x16_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x32_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x32_map_scu_top_left_new
)
{


	pel pred_cache_ith[12][16][16];
	pel pred_cache_ith1[12][16][16];

	rdo_chroma_16_pipeline_pred(cu_width, cu_height, cu_width_log2, cu_height_log2, all_rdo_num, mod_info_best, bit_depth, md_fw_ptr, orgU, ipm,
		Fetch_Ref_window_ptr, piRecoY, pred_cache_ith, pred_cache_ith1,

			IP_buffer_ptr_U_16x16_up_line, IP_buffer_ptr_U_16x16_left_line, IP_buffer_ptr_U_16x16_top_left,
			IP_buffer_ptr_V_16x16_up_line, IP_buffer_ptr_V_16x16_left_line, IP_buffer_ptr_V_16x16_top_left,
			IP_buffer_ptr_U_8x16_up_line, IP_buffer_ptr_U_8x16_left_line, IP_buffer_ptr_U_8x16_top_left,
			IP_buffer_ptr_V_8x16_up_line, IP_buffer_ptr_V_8x16_left_line, IP_buffer_ptr_V_8x16_top_left,
			IP_buffer_ptr_U_16x8_up_line, IP_buffer_ptr_U_16x8_left_line, IP_buffer_ptr_U_16x8_top_left,
			IP_buffer_ptr_V_16x8_up_line, IP_buffer_ptr_V_16x8_left_line, IP_buffer_ptr_V_16x8_top_left,
			IP_buffer_ptr_16x32_up_line, IP_buffer_ptr_16x32_left_line, IP_buffer_ptr_16x32_top_left,
			IP_buffer_ptr_32x16_up_line, IP_buffer_ptr_32x16_left_line, IP_buffer_ptr_32x16_top_left,
			IP_buffer_ptr_32x32_up_line, IP_buffer_ptr_32x32_left_line, IP_buffer_ptr_32x32_top_left,

			IP_map_scu_ptr_16x32_map_scu_up_line,
			IP_map_scu_ptr_16x32_map_scu_left_line_new,
			IP_map_scu_ptr_16x32_map_scu_top_left_new,

			IP_map_scu_ptr_32x16_map_scu_up_line,
			IP_map_scu_ptr_32x16_map_scu_left_line_new,
			IP_map_scu_ptr_32x16_map_scu_top_left_new,
			IP_map_scu_ptr_32x32_map_scu_up_line,
			IP_map_scu_ptr_32x32_map_scu_left_line_new,
			IP_map_scu_ptr_32x32_map_scu_top_left_new

#if SUB_TMVP
		, core_sbtmvp
#endif

		
			);

		
	 s16 coef_pb_part[12][16][16];
	 pel rec_tmp[12][16][16];

	int num_nz_rate[12];
		

	rdo_chroma_16_dataflow(all_rdo_num, cu_width, cu_height, bit_depth, mod_info_best, cu_width_log2, cu_height_log2, rdoq_array, num_nz_rate,
		coef_pb_part, pred_cache_ith, pred_cache_ith1, rec_tmp, orgU, md_input_ptr, md_fw_ptr);


	rdo_chroma_16_pipeline_updata( all_rdo_num,  cu_width,  cu_height,  cu_width_log2,  cu_height_log2,
		 bit_depth,  mod_info_best,  orgU,   md_input_ptr,  coef_pb_part,rec_tmp,  num_nz_rate,  

		pred_cache_ith,mod_info_best_rec_u, mod_info_best_rec_v, mod_info_best_coef_u, mod_info_best_coef_v
	);

}
#endif

int rdo_chroma_16(RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, U2 tree_status, MD_COM_MODE_BEST* mod_info_best,
	MD_INPUT* md_input_ptr, pel orgU[2][16][16], 
	IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_U_16x16, IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_V_16x16,
	IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_U_8x16, IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_V_8x16,
	IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_U_16x8, IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_V_16x8,
	pel RefWindowLCU_UP[(SWH * SWW) >> 2], pel RefWindowLCU_VP[(SWH * SWW) >> 2], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	pel RefWindowLCU_UP_ref1[(SWH * SWW) >> 2], pel RefWindowLCU_VP_ref1[(SWH * SWW) >> 2], S14 CtrPos_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	U1 coef_rec_write_flag[1], strFetch_ref_window* Fetch_Ref_window_ptr,
	pel piRecoY[32][32],
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16,
	IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{

	U4 bit_depth = md_fw_ptr->bit_depth_internal;
	U3 cu_width_log2_chroma = mod_info_best->cu_width_log2 - 1;
	U3 cu_height_log2_chroma = mod_info_best->cu_height_log2 - 1;
	U7 cu_width = (1 << cu_width_log2_chroma);
	U7 cu_height = (1 << cu_height_log2_chroma);
	assert(cu_width == 16 || cu_height == 16 && cu_width <= 16 && cu_height <= 16);
	U13 pb_x = mod_info_best->x_pos;
	U13 pb_y = mod_info_best->y_pos;
	pel org[1] = { 0 };
	U7 cu_width_chroma = cu_width;
	U7 cu_height_chroma = cu_height;
	static  pel pred[3 - 1][16][16];
	s64 lambda_y = md_input_ptr->lambda_y;
	U12 size_tmp = (1 << (cu_width_log2_chroma)) * (1 << (cu_height_log2_chroma));
	s64 lambda = md_input_ptr->lambda[1];
	u8 all_rdo_num = 0;
	s64 cost_best1 = MAX_S64;
	int best_ipd1 = 0;
	int num_nz1 = 0;
	int num_nz2 = 0;
	S8 ipm = mod_info_best->ipm[0][0];
	U1 is_intra_quant = 1;
	U6 qp = md_input_ptr->qp_u;
	int mod_info_nz_tb_part = mod_info_best->tb_part;
	if (mod_info_best->cu_mode == MODE_INTRA) {
#if USE_TSCPM
		all_rdo_num = 12;
#else
		all_rdo_num = 10;
#endif
	}
	else {
		all_rdo_num = 2;
	}
	//k = 1;
	if (tree_status != TREE_LC && tree_status != TREE_C)
	{
		return 0;
	}

	pel mod_info_best_rec_u[16][16];
	pel mod_info_best_rec_v[16][16];
	pel mod_info_best_coef_u[16][16];
	pel mod_info_best_coef_v[16][16];

	pel	IP_buffer_ptr_U_16x16_up_line[2 * 16]; pel IP_buffer_ptr_U_16x16_left_line[2 * 16]; pel IP_buffer_ptr_U_16x16_top_left;	//IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_U_16x16;
	pel	IP_buffer_ptr_V_16x16_up_line[2 * 16]; pel IP_buffer_ptr_V_16x16_left_line[2 * 16]; pel IP_buffer_ptr_V_16x16_top_left;	//IP_ARRAY_SIZE<16, 16>* IP_buffer_ptr_V_16x16;
	pel	IP_buffer_ptr_U_8x16_up_line[2 * 8]; pel IP_buffer_ptr_U_8x16_left_line[2 * 16]; pel IP_buffer_ptr_U_8x16_top_left;	//IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_U_8x16;
	pel	IP_buffer_ptr_V_8x16_up_line[2 * 8]; pel IP_buffer_ptr_V_8x16_left_line[2 * 16]; pel IP_buffer_ptr_V_8x16_top_left;	//IP_ARRAY_SIZE<8, 16>* IP_buffer_ptr_V_8x16;
	pel	IP_buffer_ptr_U_16x8_up_line[2 * 16]; pel IP_buffer_ptr_U_16x8_left_line[2 * 8]; pel IP_buffer_ptr_U_16x8_top_left;	//IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_U_16x8;
	pel	IP_buffer_ptr_V_16x8_up_line[2 * 16]; pel IP_buffer_ptr_V_16x8_left_line[2 * 8]; pel IP_buffer_ptr_V_16x8_top_left;	//IP_ARRAY_SIZE<16, 8>* IP_buffer_ptr_V_16x8;
	pel	IP_buffer_ptr_16x32_up_line[2 * 16]; pel IP_buffer_ptr_16x32_left_line[2 * 32];	pel IP_buffer_ptr_16x32_top_left;	//IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32;
	pel	IP_buffer_ptr_32x16_up_line[2 * 32]; pel IP_buffer_ptr_32x16_left_line[2 * 16];	pel IP_buffer_ptr_32x16_top_left; //IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16;
	pel	IP_buffer_ptr_32x32_up_line[2 * 32]; pel IP_buffer_ptr_32x32_left_line[2 * 32]; pel IP_buffer_ptr_32x32_top_left;	//IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32;
	U32 IP_map_scu_ptr_16x32_map_scu_up_line[(16 >> 2) << 1];
	U32 IP_map_scu_ptr_16x32_map_scu_left_line_new[(32 >> 2) << 1];
	U32 IP_map_scu_ptr_16x32_map_scu_top_left_new;
	U32 IP_map_scu_ptr_32x16_map_scu_up_line[(32 >> 2) << 1];
	U32 IP_map_scu_ptr_32x16_map_scu_left_line_new[(16 >> 2) << 1];
	U32 IP_map_scu_ptr_32x16_map_scu_top_left_new;
	U32 IP_map_scu_ptr_32x32_map_scu_up_line[(32 >> 2) << 1];
	U32 IP_map_scu_ptr_32x32_map_scu_left_line_new[(32 >> 2) << 1];
	U32 IP_map_scu_ptr_32x32_map_scu_top_left_new;

	IP_buffer_ptr_U_16x16_top_left = 0;
	IP_buffer_ptr_V_16x16_top_left = 0;
	IP_buffer_ptr_32x32_top_left = 0;
	for (int i = 0; i < 32; i++) {
		IP_buffer_ptr_U_16x16_up_line[i] = 0;
		IP_buffer_ptr_V_16x16_up_line[i] = 0;
		IP_buffer_ptr_U_16x16_left_line[i] = 0;
		IP_buffer_ptr_V_16x16_left_line[i] = 0;
	}
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_32x32_up_line[i] = 0;
		IP_buffer_ptr_32x32_left_line[i] = 0;
	}
	IP_map_scu_ptr_32x32_map_scu_top_left_new = 0;
	for (int i = 0; i < 16; i++) {
		IP_map_scu_ptr_32x32_map_scu_up_line[i] = 0;
		IP_map_scu_ptr_32x32_map_scu_left_line_new[i] = 0;
	}

	IP_buffer_ptr_U_8x16_top_left = 0;
	IP_buffer_ptr_V_8x16_top_left = 0;
	IP_buffer_ptr_16x32_top_left = 0;
	for (int i = 0; i < 16; i++) {
		IP_buffer_ptr_U_8x16_up_line[i] = 0;
		IP_buffer_ptr_V_8x16_up_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_buffer_ptr_U_8x16_left_line[i] = 0;
		IP_buffer_ptr_V_8x16_left_line[i] = 0;
		IP_buffer_ptr_16x32_up_line[i] = 0;
	}
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_16x32_left_line[i] = 0;
	}
	IP_map_scu_ptr_16x32_map_scu_top_left_new = 0;
	for (int i = 0; i < 8; i++) {
		IP_map_scu_ptr_16x32_map_scu_up_line[i] = 0;
	}
	for (int i = 0; i < 16; i++) {
		IP_map_scu_ptr_16x32_map_scu_left_line_new[i] = 0;
	}

	IP_buffer_ptr_U_16x8_top_left = 0;
	IP_buffer_ptr_V_16x8_top_left = 0;
	IP_buffer_ptr_32x16_top_left = 0;
	for (int i = 0; i < 16; i++) {
		IP_buffer_ptr_U_16x8_left_line[i] = 0;
		IP_buffer_ptr_V_16x8_left_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_buffer_ptr_U_16x8_up_line[i] = 0;
		IP_buffer_ptr_V_16x8_up_line[i] = 0;
		IP_buffer_ptr_32x16_left_line[i] = 0;
	}
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_32x16_up_line[i] = 0;
	}
	IP_map_scu_ptr_32x16_map_scu_top_left_new = 0;
	for (int i = 0; i < 8; i++) {
		IP_map_scu_ptr_32x16_map_scu_left_line_new[i] = 0;
	}
	for (int i = 0; i < 16; i++) {
		IP_map_scu_ptr_32x16_map_scu_up_line[i] = 0;
	}

	if ((cu_width_log2_chroma == 4) && (cu_height_log2_chroma == 4))  //wxh == 16x16
	{
		IP_buffer_ptr_U_16x16_top_left = IP_buffer_ptr_U_16x16->top_left;
		IP_buffer_ptr_V_16x16_top_left = IP_buffer_ptr_V_16x16->top_left;
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_U_16x16_up_line[i] = IP_buffer_ptr_U_16x16->up_line[i];
			IP_buffer_ptr_V_16x16_up_line[i] = IP_buffer_ptr_V_16x16->up_line[i];
			IP_buffer_ptr_U_16x16_left_line[i] = IP_buffer_ptr_U_16x16->left_line[i];
			IP_buffer_ptr_V_16x16_left_line[i] = IP_buffer_ptr_V_16x16->left_line[i];
		}
		IP_buffer_ptr_32x32_top_left = IP_buffer_ptr_32x32->top_left;
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_32x32_up_line[i] = IP_buffer_ptr_32x32->up_line[i];
			IP_buffer_ptr_32x32_left_line[i] = IP_buffer_ptr_32x32->left_line[i];
		}
		IP_map_scu_ptr_32x32_map_scu_top_left_new = IP_map_scu_ptr_32x32->map_scu_top_left_new;
		for (int i = 0; i < 16; i++) {
			IP_map_scu_ptr_32x32_map_scu_up_line[i] = IP_map_scu_ptr_32x32->map_scu_up_line[i];
			IP_map_scu_ptr_32x32_map_scu_left_line_new[i] = IP_map_scu_ptr_32x32->map_scu_left_line_new[i];
		}
	}
	else if ((cu_width_log2_chroma == 3) && (cu_height_log2_chroma == 4)) //8x16
	{
		IP_buffer_ptr_U_8x16_top_left = IP_buffer_ptr_U_8x16->top_left;
		IP_buffer_ptr_V_8x16_top_left = IP_buffer_ptr_V_8x16->top_left;
		for (int i = 0; i < 16; i++) {
			IP_buffer_ptr_U_8x16_up_line[i] = IP_buffer_ptr_U_8x16->up_line[i];
			IP_buffer_ptr_V_8x16_up_line[i] = IP_buffer_ptr_V_8x16->up_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_U_8x16_left_line[i] = IP_buffer_ptr_U_8x16->left_line[i];
			IP_buffer_ptr_V_8x16_left_line[i] = IP_buffer_ptr_V_8x16->left_line[i];
		}
		IP_buffer_ptr_16x32_top_left = IP_buffer_ptr_16x32->top_left;
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_16x32_up_line[i] = IP_buffer_ptr_16x32->up_line[i];
		}
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_16x32_left_line[i] = IP_buffer_ptr_16x32->left_line[i];
		}
		IP_map_scu_ptr_16x32_map_scu_top_left_new = IP_map_scu_ptr_16x32->map_scu_top_left_new;
		for (int i = 0; i < 8; i++) {
			IP_map_scu_ptr_16x32_map_scu_up_line[i] = IP_map_scu_ptr_16x32->map_scu_up_line[i];
		}
		for (int i = 0; i < 16; i++) {
			IP_map_scu_ptr_16x32_map_scu_left_line_new[i] = IP_map_scu_ptr_16x32->map_scu_left_line_new[i];
		}
	}
	else if ((cu_width_log2_chroma == 4) && (cu_height_log2_chroma == 3)) // 16x8
	{
		IP_buffer_ptr_U_16x8_top_left = IP_buffer_ptr_U_16x8->top_left;
		IP_buffer_ptr_V_16x8_top_left = IP_buffer_ptr_V_16x8->top_left;
		for (int i = 0; i < 16; i++) {
			IP_buffer_ptr_U_16x8_left_line[i] = IP_buffer_ptr_U_16x8->left_line[i];
			IP_buffer_ptr_V_16x8_left_line[i] = IP_buffer_ptr_V_16x8->left_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_U_16x8_up_line[i] = IP_buffer_ptr_U_16x8->up_line[i];
			IP_buffer_ptr_V_16x8_up_line[i] = IP_buffer_ptr_V_16x8->up_line[i];
		}
		IP_buffer_ptr_32x16_top_left = IP_buffer_ptr_32x16->top_left;
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_32x16_left_line[i] = IP_buffer_ptr_32x16->left_line[i];
		}
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_32x16_up_line[i] = IP_buffer_ptr_32x16->up_line[i];
		}
		IP_map_scu_ptr_32x16_map_scu_top_left_new = IP_map_scu_ptr_32x16->map_scu_top_left_new;
		for (int i = 0; i < 8; i++) {
			IP_map_scu_ptr_32x16_map_scu_left_line_new[i] = IP_map_scu_ptr_32x16->map_scu_left_line_new[i];
		}
		for (int i = 0; i < 16; i++) {
			IP_map_scu_ptr_32x16_map_scu_up_line[i] = IP_map_scu_ptr_32x16->map_scu_up_line[i];
		}
	}

	rdo_chroma_16_pipeline(all_rdo_num, mod_info_best, rdoq_array, md_fw_ptr, tree_status,
		RefWindowLCU_UP, RefWindowLCU_VP, CtrPos,
#if ENABLE_BFRAME
		RefWindowLCU_UP_ref1, RefWindowLCU_VP_ref1, CtrPos_ref1,
#endif
		md_input_ptr, orgU, 
		ipm, cu_width_chroma, cu_height_chroma, cu_width_log2_chroma, cu_height_log2_chroma, qp, lambda, is_intra_quant, mod_info_nz_tb_part, lambda_y,
		bit_depth, Fetch_Ref_window_ptr,
		piRecoY,
#if SUB_TMVP
		core_sbtmvp,
#endif
		mod_info_best_rec_u, mod_info_best_rec_v, mod_info_best_coef_u, mod_info_best_coef_v,
		IP_buffer_ptr_U_16x16_up_line, IP_buffer_ptr_U_16x16_left_line, IP_buffer_ptr_U_16x16_top_left,
		IP_buffer_ptr_V_16x16_up_line, IP_buffer_ptr_V_16x16_left_line, IP_buffer_ptr_V_16x16_top_left,
		IP_buffer_ptr_U_8x16_up_line, IP_buffer_ptr_U_8x16_left_line, IP_buffer_ptr_U_8x16_top_left,
		IP_buffer_ptr_V_8x16_up_line, IP_buffer_ptr_V_8x16_left_line, IP_buffer_ptr_V_8x16_top_left,
		IP_buffer_ptr_U_16x8_up_line, IP_buffer_ptr_U_16x8_left_line, IP_buffer_ptr_U_16x8_top_left,
		IP_buffer_ptr_V_16x8_up_line, IP_buffer_ptr_V_16x8_left_line, IP_buffer_ptr_V_16x8_top_left,
		IP_buffer_ptr_16x32_up_line, IP_buffer_ptr_16x32_left_line, IP_buffer_ptr_16x32_top_left,
		IP_buffer_ptr_32x16_up_line, IP_buffer_ptr_32x16_left_line, IP_buffer_ptr_32x16_top_left,
		IP_buffer_ptr_32x32_up_line, IP_buffer_ptr_32x32_left_line, IP_buffer_ptr_32x32_top_left,
		IP_map_scu_ptr_16x32_map_scu_up_line,
		IP_map_scu_ptr_16x32_map_scu_left_line_new,
		IP_map_scu_ptr_16x32_map_scu_top_left_new,
		IP_map_scu_ptr_32x16_map_scu_up_line,
		IP_map_scu_ptr_32x16_map_scu_left_line_new,
		IP_map_scu_ptr_32x16_map_scu_top_left_new,
		IP_map_scu_ptr_32x32_map_scu_up_line,
		IP_map_scu_ptr_32x32_map_scu_left_line_new,
		IP_map_scu_ptr_32x32_map_scu_top_left_new
	);

	for (int k = 0; k < 16; ++k) {
		//#pragma HLS PIPELINE
		for (int j = 0; j < 16; j++) {
			//#pragma HLS UNROLL	
			if ((k < cu_height_chroma) && (j < cu_width_chroma)) {
				mod_info_best->rec_u[k * cu_width_chroma + j] = mod_info_best_rec_u[k][j];
				mod_info_best->rec_v[k * cu_width_chroma + j] = mod_info_best_rec_v[k][j];
				mod_info_best->coef_u[k * cu_width_chroma + j] = mod_info_best_coef_u[k][j];
				mod_info_best->coef_v[k * cu_width_chroma + j] = mod_info_best_coef_v[k][j];// coef_uv_pb_part[k][(j + k) & 31];
			}
		}
	}

	//print_chroma(mod_info_best, rdo_chroma_16_cnt, pred, coef_tmp);
	return 0;
}

void copy_to_cu_data_chroma16(U6 qp_y, ENC_CU_DATA_ARRAY * cu_data, MD_COM_MODE_BEST * mod_info_best, U2 tree_status, U1 coef_rec_write_flag[1])
{
	int i;
	int j;
	int k;
	int idx;
	int size;
	U3 cu_width_log2;
	U3 cu_height_log2;
	//int num_coef_y = 0;
	U12 num_coef_u = 0;
	U12 num_coef_v = 0;
	//int num_nnz_sum = 0;
	U1 cu_cbf_flag = 0;
	//int pb_idx_u = 0;
	U2 tb_idx_u = 0;
	U2 tb_idx_y;
	U14 num_coef_y = 0;

	cu_width_log2 = mod_info_best->cu_width_log2;
	cu_height_log2 = mod_info_best->cu_height_log2;

	if ((tree_status) != (TREE_L)) {
		/* copy coef */
		size = ((((mod_info_best->cu_width * mod_info_best->cu_height)) * sizeof(s16) >> 2));
		//if (coef_rec_write_flag[0] == 0) {////for Intra_CU
		for (i = 0; i < ((mod_info_best->cu_width * mod_info_best->cu_height) >> 2); i++) {
			cu_data->coef_u[i] = mod_info_best->coef_u[i];
			cu_data->coef_v[i] = mod_info_best->coef_v[i];
			cu_data->reco_u[i] = mod_info_best->rec_u[i];
			cu_data->reco_v[i] = mod_info_best->rec_v[i];  /* copy reco */

		}

		//}

		for (i = 0; i < mod_info_best->cu_width * mod_info_best->cu_height / 4; i++) {
			num_coef_u += ((cu_data->coef_u[i]) != 0 ? 1 : 0);
			num_coef_v += ((cu_data->coef_v[i]) != 0 ? 1 : 0);
		}
	}
	if (tree_status != TREE_C)
	{
		for (i = 0; i < mod_info_best->cu_width * mod_info_best->cu_height; i++) {
			num_coef_y += ((cu_data->coef_y[i]) != 0 ? 1 : 0);
		}
	}
	if (tree_status == TREE_LC) {
		cu_cbf_flag = ((num_coef_y == 0 ? 0 : 1)) | ((num_coef_u == 0 ? 0 : 1)) | ((num_coef_v == 0 ? 0 : 1));
	}
	else if ((tree_status) == (TREE_L)) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	/* copy mode info */
	if ((tree_status) == (TREE_C)) {
		idx = 0;
		for (j = 0; j < mod_info_best->cu_height >> 2; j++) {
			for (i = 0; i < mod_info_best->cu_width >> 2; i++) {
				//intra chroma mode
				if (mod_info_best->cu_mode == 0) {
					cu_data->ipm[1][idx + i] = mod_info_best->ipm[0][1];
				}
				// residual and partition
				for (k = 1; k < 3; k++) {
					cu_data->num_nz_coef[k][idx + i] = mod_info_best->num_nz[0][k];
				}
			}
			idx += mod_info_best->cu_width >> 2;
		}
	}
	else {
		idx = 0;
		for (j = 0; j < mod_info_best->cu_height >> 2; j++) {
			for (i = 0; i < mod_info_best->cu_width >> 2; i++) {

				//			tb_idx_y = get_part_idx((PART_SIZE)(mod_info_best->tb_part), i << 2, j << 2, mod_info_best->cu_width,mod_info_best->cu_height);
				tb_idx_y = get_part_idx(SIZE_2Nx2N, i << 2, j << 2, mod_info_best->cu_width,
					mod_info_best->cu_height);
				//pb_idx_u = 0;
				tb_idx_u = 0;

				for (k = 1; k < 3; k++) {
					cu_data->num_nz_coef[k][idx + i] = mod_info_best->num_nz[(k == 0 ? tb_idx_y : tb_idx_u)][k];
				}

				if (cu_cbf_flag) {
					cu_data->map_scu[idx + i] = cu_data->map_scu[idx + i] | ((1 << 24));
				}
				else {
					cu_data->map_scu[idx + i] = cu_data->map_scu[idx + i] & ((~(1 << 24)));
				}

				if (mod_info_best->cu_mode == 0)
				{
					cu_data->ipm[1][idx + i] = mod_info_best->ipm[0][1];
				}
			}
			idx += mod_info_best->cu_width >> 2;
		}

	}
}


void copy_to_cu_data_luma_16(U1 isNS_allow, U8 w, U8 h, U6 qp_y,
	ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_16,
	MD_COM_MODE_BEST_16 * mod_info_best_16, U2 tree_status,
	int slice_num, int affine_subblock_size_idx, s8 * coef_rec_write_flag, U2 NS_luma_pred_mode[1]
#if SUB_TMVP
	, CORE_SBTMVP * core_sbtmvp
#endif
#if CUDQP_QP_MAP
	, int cu_dqp_enable, int cu_qp_group_pred_qp
#endif
)
{
	if (!isNS_allow)
	{
		NS_luma_pred_mode[0] = ONLY_INTRA;
		return;
	}
	int i;
	int j;
	int k;
	int idx;
	U3 cu_width_log2;
	U3 cu_height_log2;
	int num_coef_y = 0;
	int num_coef_u = 0;
	int num_coef_v = 0;
	int num_nnz_sum = 0;
	int num_luma_tb;
	int cu_cbf_flag = 0;
	int pb_idx_u = 0;
	int tb_idx_u = 0;
	int pb_idx_y;
	int tb_idx_y;
	int pel_x = mod_info_best_16->x_scu * 4;
	int pel_y = mod_info_best_16->y_scu * 4;
	int pel_x_top = (mod_info_best_16->x_scu * 4 - (((mod_info_best_16->x_scu * 4) >> 6) << 6)) >> 2;
	int pel_y_top = (mod_info_best_16->y_scu * 4 - (((mod_info_best_16->y_scu * 4) >> 6) << 6)) >> 2;
	cu_width_log2 = mod_info_best_16->cu_width_log2;
	cu_height_log2 = mod_info_best_16->cu_height_log2;

	if (tree_status != TREE_C) {
		num_luma_tb = get_part_num((PART_SIZE)(mod_info_best_16->tb_part));
		for (i = 0; i < h; i++) {
#pragma HLS pipeline
			#pragma HLS LOOP_TRIPCOUNT max=16
			for (j = 0; j < w; j++)
			#pragma HLS LOOP_TRIPCOUNT max=16
				num_coef_y += (((int)cu_data_16->coef_y[i][j]) != 0 ? 1 : 0);
		}

		for (i = 0; i < num_luma_tb; i++) {
#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT max=4
			num_nnz_sum += mod_info_best_16->num_nz_y[i];
		}
	}
	if (tree_status == TREE_LC) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	else if (((int)tree_status) == ((int)TREE_L)) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	if (((int)tree_status) == ((int)TREE_C)) {
		idx = 0;
		for (j = 0; j < h >> 2; j++) {
#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT max=4
			for (i = 0; i < w >> 2; i++) {
#pragma HLS LOOP_TRIPCOUNT max=4
				if (mod_info_best_16->cu_mode == 0) {
					cu_data_16->ipm[1][idx + i] = mod_info_best_16->ipm[0][1];
				}
				cu_data_16->num_nz_coef[0][idx + i] = mod_info_best_16->num_nz_y[0];
			}
			idx += w >> 2;
		}
	}
	else {
		idx = 0;
		for (j = 0; j < h >> 2; j++) {
#pragma HLS pipeline
#pragma HLS LOOP_TRIPCOUNT max=4
			for (i = 0; i < w >> 2; i++) {
#pragma HLS LOOP_TRIPCOUNT max=4
				pb_idx_y = get_part_idx((PART_SIZE)(mod_info_best_16->pb_part), i << 2, j << 2, w, h);
				tb_idx_y = get_part_idx((PART_SIZE)(mod_info_best_16->tb_part), i << 2, j << 2, w, h);
				pb_idx_u = 0;
				tb_idx_u = 0;
				cu_data_16->pred_mode[idx + i] = ((u8)(mod_info_best_16->cu_mode));
				cu_data_16->umve_flag[idx + i] = mod_info_best_16->umve_flag;
				cu_data_16->umve_idx[idx + i] = mod_info_best_16->umve_idx;
				cu_data_16->pb_part[idx + i] = mod_info_best_16->pb_part;
				cu_data_16->tb_part[idx + i] = mod_info_best_16->tb_part;
#if CUDQP_QP_MAP
				cu_data_16->cu_luma_qp[idx + i] = cu_qp_group_pred_qp;
				//cu_data_16->luma_pred_qp[idx + i] = qp_y;
#endif
				cu_data_16->num_nz_coef[0][idx + i] = mod_info_best_16->num_nz_y[tb_idx_y];
				cu_data_16->map_scu[idx + i] = (cu_data_16->map_scu[idx + i] & 0xFF807F80) | ((unsigned int)(slice_num & 0x7F)) | (((
					unsigned int)qp_y << 16)) | ((unsigned int)((mod_info_best_16->cu_mode == 0) << 15)) | ((unsigned int)(1 << 31));
				if (mod_info_best_16->cu_mode == 2) {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] | ((unsigned int)(1 << 23));
				}
				else {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] & ((unsigned int)(~(1 << 23)));
				}
				cu_data_16->depth[idx + i] = ((s8)(mod_info_best_16->cud));
				cu_data_16->affine_flag[idx + i] = mod_info_best_16->affine_flag;
				if (mod_info_best_16->affine_flag) {
					cu_data_16->map_scu[idx + i] = (cu_data_16->map_scu[idx + i] & 0xFFFFFCFF) | ((unsigned int)((((int)(
						mod_info_best_16->affine_flag)) & 0x03) << 8));
				}
				else {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] & 0xFFFFFCFF;
				}
				if (cu_cbf_flag) {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] | ((unsigned int)(1 << 24));
				}
				else {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] & ((unsigned int)(~(1 << 24)));
				}
#if CUDQP_QP_MAP
				if (cu_dqp_enable && !cu_cbf_flag)
				{
					//change qp to pred_qp if no residual
					MCU_SET_QP(cu_data_16->map_scu[idx + i], cu_qp_group_pred_qp);
					//assert(ctx->cu_qp_group.pred_qp >= 0 && ctx->cu_qp_group.pred_qp <= MAX_QUANT_BASE + ctx->info.qp_offset_bit_depth);
				}
#endif
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFFFFFFF0) | ((unsigned int)((pel_x_top & 0xF) << 0));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFFFFFF0F) | ((unsigned int)((pel_y_top & 0xF) << 4));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFFFF00FF) | ((unsigned int)((i & 0xFF) << 8));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFF00FFFF) | ((unsigned int)((j & 0xFF) << 16));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xF0FFFFFF) | ((unsigned int)((
					cu_width_log2 & 0x0F) << 24));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0x0FFFFFFF) | ((unsigned int)((
					cu_height_log2 & 0x0F) << 28));
				cu_data_16->map_pb_tb_part[idx + i] = (cu_data_16->map_pb_tb_part[idx + i] & 0xFFFFFF00) | ((unsigned int)((
					mod_info_best_16->tb_part & 0xFF) << 0));
				if (mod_info_best_16->cu_mode == 0) {
					cu_data_16->mpm[0][idx + i] = mod_info_best_16->mpm[pb_idx_y][0];
					cu_data_16->mpm[1][idx + i] = mod_info_best_16->mpm[pb_idx_y][1];
					cu_data_16->ipm[0][idx + i] = mod_info_best_16->ipm[pb_idx_y][0];
					cu_data_16->ipm[1][idx + i] = mod_info_best_16->ipm[pb_idx_u][1];
					cu_data_16->ipf_flag[idx + i] = mod_info_best_16->ipf_flag;
					cu_data_16->mv[idx + i][0][0] = ((s16)0);
					cu_data_16->mv[idx + i][0][1] = ((s16)0);
					cu_data_16->mv[idx + i][1][0] = ((s16)0);
					cu_data_16->mv[idx + i][1][1] = ((s16)0);
					cu_data_16->mvd[idx + i][0][0] = ((s16)0);
					cu_data_16->mvd[idx + i][0][1] = ((s16)0);
					cu_data_16->mvd[idx + i][1][0] = ((s16)0);
					cu_data_16->mvd[idx + i][1][1] = ((s16)0);
					cu_data_16->refi[idx + i][0] = ((s8)(-1));
					cu_data_16->refi[idx + i][1] = ((s8)(-1));
					cu_data_16->skip_idx[idx + i] = 0;
					cu_data_16->smvd_flag[idx + i] = 0;
				}
				else {
					cu_data_16->mpm[0][idx + i] = 0;
					cu_data_16->mpm[1][idx + i] = 0;
					cu_data_16->ipm[0][idx + i] = 0;
					cu_data_16->ipm[1][idx + i] = 0;

					cu_data_16->refi[idx + i][0] = mod_info_best_16->refi[0];
					cu_data_16->refi[idx + i][1] = mod_info_best_16->refi[1];
					cu_data_16->mvr_idx[idx + i] = mod_info_best_16->mvr_idx;
					cu_data_16->mvp_from_hmvp_flag[idx + i] = mod_info_best_16->mvp_from_hmvp_flag;
					cu_data_16->smvd_flag[idx + i] = mod_info_best_16->smvd_flag;
					cu_data_16->skip_idx[idx + i] = mod_info_best_16->skip_idx;
					cu_data_16->mv[idx + i][0][0] = mod_info_best_16->mv[0][0];
					cu_data_16->mv[idx + i][0][1] = mod_info_best_16->mv[0][1];
					cu_data_16->mv[idx + i][1][0] = mod_info_best_16->mv[1][0];
					cu_data_16->mv[idx + i][1][1] = mod_info_best_16->mv[1][1];
					cu_data_16->mvd[idx + i][0][0] = mod_info_best_16->mvd[0][0];
					cu_data_16->mvd[idx + i][0][1] = mod_info_best_16->mvd[0][1];
					cu_data_16->mvd[idx + i][1][0] = mod_info_best_16->mvd[1][0];
					cu_data_16->mvd[idx + i][1][1] = mod_info_best_16->mvd[1][1];
#if SUB_TMVP
					if (core_sbtmvp != 0) {
						if (mod_info_best_16->umve_flag == 0 && mod_info_best_16->cu_mode >= MODE_SKIP && mod_info_best_16->skip_idx == 0 && mod_info_best_16->cu_width >= SBTMVP_MIN_SIZE && mod_info_best_16->cu_height >= SBTMVP_MIN_SIZE)
						{
							// sub block position
							int blk = ((i >= (mod_info_best_16->cu_width >> MIN_CU_LOG2) / SBTMVP_NUM_1D) ? 1 : 0) + ((j >= (mod_info_best_16->cu_height >> MIN_CU_LOG2) / SBTMVP_NUM_1D) ? SBTMVP_NUM_1D : 0);
							cu_data_16->refi[idx + i][0] = core_sbtmvp->best_sbTmvp[blk].ref_idx[0];
							cu_data_16->refi[idx + i][1] = core_sbtmvp->best_sbTmvp[blk].ref_idx[1];

							cu_data_16->mv[idx + i][0][0] = core_sbtmvp->best_sbTmvp[blk].mv[0][0];
							cu_data_16->mv[idx + i][0][1] = core_sbtmvp->best_sbTmvp[blk].mv[0][1];
							cu_data_16->mv[idx + i][1][0] = core_sbtmvp->best_sbTmvp[blk].mv[1][0];
							cu_data_16->mv[idx + i][1][1] = core_sbtmvp->best_sbTmvp[blk].mv[1][1];

							cu_data_16->mvd[idx + i][0][0] = 0;
							cu_data_16->mvd[idx + i][0][1] = 0;
							cu_data_16->mvd[idx + i][1][0] = 0;
							cu_data_16->mvd[idx + i][1][1] = 0;

						}
					}
#endif
				}
			}

			idx += w >> 2;
		}
		//if (mod_info_best->affine_flag) {
		//	enc_set_affine_mvf(affine_subblock_size_idx, cu_data, mod_info_best);
		//}
	}

	NS_luma_pred_mode[0] = cu_data_16->pred_mode[0];

}

void copy_to_cu_data_luma_16_16(U1 isNS_allow, U8 w, U8 h, U6 qp_y,
	ENC_CU_DATA_ARRAY_SIZE<16>* cu_data_16,
	MD_COM_MODE_BEST_16* mod_info_best_16, U2 tree_status,
	int slice_num, int affine_subblock_size_idx, s8* coef_rec_write_flag, U2 NS_luma_pred_mode[1]
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if CUDQP_QP_MAP
	, int cu_dqp_enable, int cu_qp_group_pred_qp
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=cu_data_16->map_scu complete dim=1
#pragma HLS ARRAY_PARTITION variable=cu_data_16->mv complete dim=1
#pragma HLS ARRAY_PARTITION variable=cu_data_16->mvd complete dim=1
#pragma HLS ARRAY_PARTITION variable=cu_data_16->refi complete dim=1

#pragma HLS ARRAY_PARTITION variable=cu_data_16->skip_idx complete dim=1
#pragma HLS ARRAY_PARTITION variable=cu_data_16->mvr_idx complete dim=1
#pragma HLS ARRAY_PARTITION variable=cu_data_16->mvp_from_hmvp_flag complete dim=1
#pragma HLS ARRAY_PARTITION variable=cu_data_16->smvd_flag complete dim=1
	if (!isNS_allow)
	{
		NS_luma_pred_mode[0] = ONLY_INTRA;
		return;
	}
	int i;
	int j;
	int k;
	int idx;
	U3 cu_width_log2;
	U3 cu_height_log2;
	int num_coef_y = 0;
	int num_coef_u = 0;
	int num_coef_v = 0;
	int num_nnz_sum = 0;
	int num_luma_tb;
	int cu_cbf_flag = 0;
	int pb_idx_u = 0;
	int tb_idx_u = 0;
	int pb_idx_y;
	int tb_idx_y;
	int pel_x = mod_info_best_16->x_scu * 4;
	int pel_y = mod_info_best_16->y_scu * 4;
	int pel_x_top = (mod_info_best_16->x_scu * 4 - (((mod_info_best_16->x_scu * 4) >> 6) << 6)) >> 2;
	int pel_y_top = (mod_info_best_16->y_scu * 4 - (((mod_info_best_16->y_scu * 4) >> 6) << 6)) >> 2;
	cu_width_log2 = mod_info_best_16->cu_width_log2;
	cu_height_log2 = mod_info_best_16->cu_height_log2;
	if (tree_status != TREE_C) {
		num_luma_tb = get_part_num((PART_SIZE)(mod_info_best_16->tb_part));
#if DISABLE_RDO_LUMA_16_16 && DISABLE_RDO_LUMA_8_16
		for (i = 0; i < 8; i++) {
#else
		for (i = 0; i < 16; i++) {
#endif // DISABLE_RDO_LUMA_16_16 && DISABLE_RDO_LUMA_8_16
#pragma HLS pipeline
#if DISABLE_RDO_LUMA_16_16 && DISABLE_RDO_LUMA_16_8
			for (j = 0; j < 8; j++) {
#else
			for (j = 0; j < 16; j++) {
#endif // DISABLE_RDO_LUMA_16_16 && DISABLE_RDO_LUMA_16_8
				num_coef_y += (((int)cu_data_16->coef_y[i][j]) != 0 ? 1 : 0);
			}
			}

		for (i = 0; i < 4; i++) {
#pragma HLS unroll
#pragma HLS LOOP_TRIPCOUNT max=4
			num_nnz_sum += mod_info_best_16->num_nz_y[i];
		}
		}
	if (tree_status == TREE_LC) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	else if (((int)tree_status) == ((int)TREE_L)) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	if (((int)tree_status) == ((int)TREE_C)) {
		idx = 0;
		for (j = 0; j < 4; j++) {
#pragma HLS pipeline
			for (i = 0; i < 4; i++) {
				if (mod_info_best_16->cu_mode == 0) {
					cu_data_16->ipm[1][idx + i] = mod_info_best_16->ipm[0][1];
				}
				cu_data_16->num_nz_coef[0][idx + i] = mod_info_best_16->num_nz_y[0];
			}
			idx += w >> 2;
			}
		}
	else {
		idx = 0;
		for (j = 0; j < 4; j++) {
#pragma HLS pipeline
			for (i = 0; i < 4; i++) {
				pb_idx_y = get_part_idx((PART_SIZE)(mod_info_best_16->pb_part), i << 2, j << 2, w, h);
				tb_idx_y = get_part_idx((PART_SIZE)(mod_info_best_16->tb_part), i << 2, j << 2, w, h);
				pb_idx_u = 0;
				tb_idx_u = 0;
				cu_data_16->pred_mode[idx + i] = ((u8)(mod_info_best_16->cu_mode));
				cu_data_16->umve_flag[idx + i] = mod_info_best_16->umve_flag;
				cu_data_16->umve_idx[idx + i] = mod_info_best_16->umve_idx;
				cu_data_16->pb_part[idx + i] = mod_info_best_16->pb_part;
				cu_data_16->tb_part[idx + i] = mod_info_best_16->tb_part;
#if CUDQP_QP_MAP
				cu_data_16->cu_luma_qp[idx + i] = cu_qp_group_pred_qp;
				//cu_data_16->luma_pred_qp[idx + i] = qp_y;
#endif
				cu_data_16->num_nz_coef[0][idx + i] = mod_info_best_16->num_nz_y[tb_idx_y];
				cu_data_16->map_scu[idx + i] = (cu_data_16->map_scu[idx + i] & 0xFF807F80) | ((unsigned int)(slice_num & 0x7F)) | (((
					unsigned int)qp_y << 16)) | ((unsigned int)((mod_info_best_16->cu_mode == 0) << 15)) | ((unsigned int)(1 << 31));
				if (mod_info_best_16->cu_mode == 2) {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] | ((unsigned int)(1 << 23));
				}
				else {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] & ((unsigned int)(~(1 << 23)));
				}
				cu_data_16->depth[idx + i] = ((s8)(mod_info_best_16->cud));
				cu_data_16->affine_flag[idx + i] = mod_info_best_16->affine_flag;
				if (mod_info_best_16->affine_flag) {
					cu_data_16->map_scu[idx + i] = (cu_data_16->map_scu[idx + i] & 0xFFFFFCFF) | ((unsigned int)((((int)(
						mod_info_best_16->affine_flag)) & 0x03) << 8));
				}
				else {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] & 0xFFFFFCFF;
				}
				if (cu_cbf_flag) {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] | ((unsigned int)(1 << 24));
				}
				else {
					cu_data_16->map_scu[idx + i] = cu_data_16->map_scu[idx + i] & ((unsigned int)(~(1 << 24)));
				}
#if CUDQP_QP_MAP
				if (cu_dqp_enable && !cu_cbf_flag)
				{
					//change qp to pred_qp if no residual
					MCU_SET_QP(cu_data_16->map_scu[idx + i], cu_qp_group_pred_qp);
					//assert(ctx->cu_qp_group.pred_qp >= 0 && ctx->cu_qp_group.pred_qp <= MAX_QUANT_BASE + ctx->info.qp_offset_bit_depth);
				}
#endif
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFFFFFFF0) | ((unsigned int)((pel_x_top & 0xF) << 0));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFFFFFF0F) | ((unsigned int)((pel_y_top & 0xF) << 4));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFFFF00FF) | ((unsigned int)((i & 0xFF) << 8));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xFF00FFFF) | ((unsigned int)((j & 0xFF) << 16));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0xF0FFFFFF) | ((unsigned int)((
					cu_width_log2 & 0x0F) << 24));
				cu_data_16->map_cu_mode[idx + i] = (cu_data_16->map_cu_mode[idx + i] & 0x0FFFFFFF) | ((unsigned int)((
					cu_height_log2 & 0x0F) << 28));
				cu_data_16->map_pb_tb_part[idx + i] = (cu_data_16->map_pb_tb_part[idx + i] & 0xFFFFFF00) | ((unsigned int)((
					mod_info_best_16->tb_part & 0xFF) << 0));
				if (mod_info_best_16->cu_mode == 0) {
					cu_data_16->mpm[0][idx + i] = mod_info_best_16->mpm[pb_idx_y][0];
					cu_data_16->mpm[1][idx + i] = mod_info_best_16->mpm[pb_idx_y][1];
					cu_data_16->ipm[0][idx + i] = mod_info_best_16->ipm[pb_idx_y][0];
					cu_data_16->ipm[1][idx + i] = mod_info_best_16->ipm[pb_idx_u][1];
					cu_data_16->ipf_flag[idx + i] = mod_info_best_16->ipf_flag;
					cu_data_16->mv[idx + i][0][0] = ((s16)0);
					cu_data_16->mv[idx + i][0][1] = ((s16)0);
					cu_data_16->mv[idx + i][1][0] = ((s16)0);
					cu_data_16->mv[idx + i][1][1] = ((s16)0);
					cu_data_16->mvd[idx + i][0][0] = ((s16)0);
					cu_data_16->mvd[idx + i][0][1] = ((s16)0);
					cu_data_16->mvd[idx + i][1][0] = ((s16)0);
					cu_data_16->mvd[idx + i][1][1] = ((s16)0);
					cu_data_16->refi[idx + i][0] = ((s8)(-1));
					cu_data_16->refi[idx + i][1] = ((s8)(-1));
					cu_data_16->skip_idx[idx + i] = 0;
					cu_data_16->smvd_flag[idx + i] = 0;
				}
				else {
					cu_data_16->mpm[0][idx + i] = 0;
					cu_data_16->mpm[1][idx + i] = 0;
					cu_data_16->ipm[0][idx + i] = 0;
					cu_data_16->ipm[1][idx + i] = 0;

					cu_data_16->refi[idx + i][0] = mod_info_best_16->refi[0];
					cu_data_16->refi[idx + i][1] = mod_info_best_16->refi[1];
					cu_data_16->mvr_idx[idx + i] = mod_info_best_16->mvr_idx;
					cu_data_16->mvp_from_hmvp_flag[idx + i] = mod_info_best_16->mvp_from_hmvp_flag;
					cu_data_16->smvd_flag[idx + i] = mod_info_best_16->smvd_flag;
					cu_data_16->skip_idx[idx + i] = mod_info_best_16->skip_idx;
					cu_data_16->mv[idx + i][0][0] = mod_info_best_16->mv[0][0];
					cu_data_16->mv[idx + i][0][1] = mod_info_best_16->mv[0][1];
					cu_data_16->mv[idx + i][1][0] = mod_info_best_16->mv[1][0];
					cu_data_16->mv[idx + i][1][1] = mod_info_best_16->mv[1][1];
					cu_data_16->mvd[idx + i][0][0] = mod_info_best_16->mvd[0][0];
					cu_data_16->mvd[idx + i][0][1] = mod_info_best_16->mvd[0][1];
					cu_data_16->mvd[idx + i][1][0] = mod_info_best_16->mvd[1][0];
					cu_data_16->mvd[idx + i][1][1] = mod_info_best_16->mvd[1][1];
#if SUB_TMVP
					if (core_sbtmvp != 0) {
						if (mod_info_best_16->umve_flag == 0 && mod_info_best_16->cu_mode >= MODE_SKIP && mod_info_best_16->skip_idx == 0 && mod_info_best_16->cu_width >= SBTMVP_MIN_SIZE && mod_info_best_16->cu_height >= SBTMVP_MIN_SIZE)
						{
							// sub block position
							int blk = ((i >= (mod_info_best_16->cu_width >> MIN_CU_LOG2) / SBTMVP_NUM_1D) ? 1 : 0) + ((j >= (mod_info_best_16->cu_height >> MIN_CU_LOG2) / SBTMVP_NUM_1D) ? SBTMVP_NUM_1D : 0);
							cu_data_16->refi[idx + i][0] = core_sbtmvp->best_sbTmvp[blk].ref_idx[0];
							cu_data_16->refi[idx + i][1] = core_sbtmvp->best_sbTmvp[blk].ref_idx[1];

							cu_data_16->mv[idx + i][0][0] = core_sbtmvp->best_sbTmvp[blk].mv[0][0];
							cu_data_16->mv[idx + i][0][1] = core_sbtmvp->best_sbTmvp[blk].mv[0][1];
							cu_data_16->mv[idx + i][1][0] = core_sbtmvp->best_sbTmvp[blk].mv[1][0];
							cu_data_16->mv[idx + i][1][1] = core_sbtmvp->best_sbTmvp[blk].mv[1][1];

							cu_data_16->mvd[idx + i][0][0] = 0;
							cu_data_16->mvd[idx + i][0][1] = 0;
							cu_data_16->mvd[idx + i][1][0] = 0;
							cu_data_16->mvd[idx + i][1][1] = 0;

						}
					}
#endif
				}
			}

			idx += w >> 2;
			}
		//if (mod_info_best->affine_flag) {
		//	enc_set_affine_mvf(affine_subblock_size_idx, cu_data, mod_info_best);
		//}
		}

	NS_luma_pred_mode[0] = cu_data_16->pred_mode[0];

		}
int mode_cu_init_16(RDOQ_MODEL * rdoq_model, RDOQ_MODEL * model_cnt, RDOQ_ARRAY * rdoq_array,
	MD_COM_MODE * mod_info_curr_ptr, MD_COM_MODE_BEST_16 * bst_info_ptr_16,
	U13 x, U13 y, U3 cu_width_log2,
	U3 cu_height_log2, U4 cud, U11 pic_width_in_scu, U2 tree_status,
	U2 * cons_pred_mode
	, ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_temp_ptr_16
)
{
#pragma HLS ARRAY_PARTITION variable=bst_info_ptr_16->num_nz_y complete dim=1
#pragma HLS ARRAY_PARTITION variable=cu_data_temp_ptr_16->ipm complete dim=0
	MD_COM_MODE* mod_info_curr = mod_info_curr_ptr;
	bst_info_ptr_16->x_luma = mod_info_curr->x_luma = x;
	bst_info_ptr_16->y_luma = mod_info_curr->y_luma = y;
	bst_info_ptr_16->x_pos = mod_info_curr->x_pos = x;
	bst_info_ptr_16->y_pos = mod_info_curr->y_pos = y;
	bst_info_ptr_16->cu_width = mod_info_curr->cu_width = (1 << cu_width_log2);
	bst_info_ptr_16->cu_height = mod_info_curr->cu_height = (1 << cu_height_log2);
	bst_info_ptr_16->cu_width_log2 = mod_info_curr->cu_width_log2 = cu_width_log2;
	bst_info_ptr_16->cu_height_log2 = mod_info_curr->cu_height_log2 = cu_height_log2;
	bst_info_ptr_16->x_scu = mod_info_curr->x_scu = x >> 2;
	bst_info_ptr_16->y_scu = mod_info_curr->y_scu = y >> 2;
	bst_info_ptr_16->scup = mod_info_curr->scup = mod_info_curr->y_scu * pic_width_in_scu + mod_info_curr->x_scu;
	bst_info_ptr_16->cud = mod_info_curr->cud = cud;
	bst_info_ptr_16->chroma_motion = 0;

	mod_info_curr->chroma_motion = /*0*/ mod_info_curr->last_child && tree_status == TREE_L;
	U5 cuw_scu = 1 << (cu_width_log2 - 2);
	U5 cuh_scu = 1 << (cu_height_log2 - 2);
	int m;
	cu_nz_cln(mod_info_curr->num_nz);
	for (int i = 0; i < 4; i++) {
#pragma HLS unroll
		bst_info_ptr_16->num_nz_y[i] = 0;
	}

	if (tree_status != TREE_C) {
		//for (m = 0; m < cuw_scu * cuh_scu; m++) {
#if !DISABLE_RDO_LUMA_16_8 || !DISABLE_RDO_LUMA_8_16
		for (m = 0; m < 16; m++) {
#else
		for (m = 0; m < 8; m++) {
#endif // !DISABLE_RDO_LUMA_16_8 || !DISABLE_RDO_LUMA_8_16
#pragma HLS unroll
			cu_data_temp_ptr_16->ipm[0][m] = 0;
			cu_data_temp_ptr_16->ipm[1][m] = 0;
		}
	}

	int i;
	mod_info_curr->cu_mode = 0;
	mod_info_curr->pb_part = 0;
	mod_info_curr->tb_part = 0;
	mod_info_curr->ipf_flag = 0;

	mod_info_curr->mvr_idx = 0;
	mod_info_curr->skip_idx = 0;
	mod_info_curr->umve_flag = 0;
	mod_info_curr->umve_idx = ((-1));
	mod_info_curr->mvp_from_hmvp_flag = 0;
	mod_info_curr->affine_flag = 0;
	mod_info_curr->smvd_flag = 0;


	bst_info_ptr_16->cu_mode = 0;
	bst_info_ptr_16->pb_part = 0;
	bst_info_ptr_16->tb_part = 0;
	bst_info_ptr_16->ipf_flag = 0;

	bst_info_ptr_16->mvr_idx = 0;
	bst_info_ptr_16->skip_idx = 0;
	bst_info_ptr_16->umve_flag = 0;
	bst_info_ptr_16->umve_idx = ((-1));
	bst_info_ptr_16->mvp_from_hmvp_flag = 0;
	bst_info_ptr_16->affine_flag = 0;
	bst_info_ptr_16->smvd_flag = 0;

	enc_rdoq_bit_est(rdoq_model, model_cnt, rdoq_array);
	U8 cu_width = (1 << cu_width_log2);
	U8 cu_height = (1 << cu_height_log2);
	u8 luma_pred_mode;

	return 0;
}

s64 init_basic_leaf_16(U1 isNS_allow, RDOQ_MODEL * rdoq_model, RDOQ_MODEL * model_cnt, RDOQ_ARRAY * rdoq_array, MD_FW * md_fw_ptr, s64 lambdaY, U3 cu_width_log2,
	U3 cu_height_log2, U4 cud, MD_COM_MODE_BEST_16 * bst_info_ptr_16,
	U3 qt_depth, U3 bet_depth, U13 x0, U13 y0, U9 cup, U2 tree_status,
	U2 * cons_pred_mode, MD_COM_MODE * mod_info_curr_temp_ptr,
	ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_temp_ptr_16
)
{
	if (!isNS_allow)
		return MAX_S64;

	U1 split_allow[6];
	U8 cu_width = (1 << cu_width_log2);
	U8 cu_height = (1 << cu_height_log2);
	int bit_cnt;
	s64 cost_temp = 0;
	int pos = 0 + ((cu_height >> 1 >> 2) * (cu_width >> 2) + (cu_width >> 1 >> 2));
	int shape = (SQUARE)+(com_tbl_log2[cu_width] - com_tbl_log2[cu_height]);
	U13 pic_width = md_fw_ptr->pic_width;
	U13 pic_height = md_fw_ptr->pic_height;
	U1 boundary = 0;
	U1 boundary_b = 0;
	U1 boundary_r = 0;
	boundary_b = boundary && y0 + cu_height > pic_height && !(x0 + cu_width > pic_width);
	boundary_r = boundary && x0 + cu_width > pic_width && !(y0 + cu_height > pic_height);
	com_check_split_mode_ECO(md_fw_ptr, split_allow, com_tbl_log2[cu_width], com_tbl_log2[cu_height],
		boundary, boundary_b, boundary_r, qt_depth, bet_depth);

	if ((cu_height_log2 >= 4 || cu_width_log2 >= 4) && split_allow[SPLIT_QUAD])
		bit_cnt = 2;
	else
		bit_cnt = 1;
	cost_temp += (bit_cnt * lambdaY + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
	mode_cu_init_16(rdoq_model, model_cnt, rdoq_array, mod_info_curr_temp_ptr, bst_info_ptr_16, x0, y0, cu_width_log2, cu_height_log2, cud, md_fw_ptr->pic_width_in_scu,
		tree_status, cons_pred_mode, cu_data_temp_ptr_16);
	return cost_temp;
}

//#define MD_TB_LUMA_16
#ifdef MD_TB_LUMA_16
#include "md_testbench.h"
FILE* fp_md_kernel_16_output_golden = NULL;
FILE* fp_md_kernel_16_input_golden = NULL;
#endif

#ifdef MD_TB_LUMA_16
static void md_kernel_16_get_golden_data(bool b_input, int f_cu, int ptr, RDOQ_MODEL * rdoq_model, RDOQ_MODEL * model_cnt, MD_FW * md_fw_ptr, MD_INPUT * md_input_ptr, u8 rmd_mode[IPD_RDO_CNT],
	U8 RefWindowLCU[SWW * SWH], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS], pel p_fenc_LCU_Y[MAX_CU_SIZE_FETCH * MAX_CU_SIZE_FETCH],
	ENC_ME_LINE_MAP * me_line_map_ptr,
	ENC_ME_NEB_INFO inner_nebs[2][SCU_IN_LCU_NUMS_LEN][SCU_IN_LCU_NUMS_LEN], ENC_ME_NEB_INFO above_nebs_line[ABOVE_LINE_LEN],
	SKIP_MERGE_INPUT * skip_in, U1 boundary, U1 isNS_allow, U2 NS_luma_pred_mode[1], U13 x0,
	U13 y0, U12 cup, U3 cu_width_log2, U3 cu_height_log2, U4 cud, U3 qt_depth, U3 bet_depth, U2 cons_pred_mode,
	U2 tree_status, ENC_CU_DATA_ARRAY * cu_data_temp_ptr,
	ENC_FME_INFO_ALL * fme_mv_info,
	IP_ARRAY * IP_buffer_ptr, MPM_ARRAY * MPM_buffer_ptr, IP_MAP_SCU * MAP_SCU_IP_ptr,
	U8 refwin_md[88][88], S14 CtrPosFME[RANGE_NUM][DIR_DIM][MAP_DIMS])
{
	static const int ptr_max = 3, f_cu_max = 10;
	if (b_input)
	{
		/******************************************************tb_data_input********************************************/
		if (fp_md_kernel_16_input_golden == NULL) {
			fp_md_kernel_16_input_golden = fopen("md_kernel_16_input_golden.dat", "wb");
			assert(fp_md_run_input_golden);
		}

		if (ptr < ptr_max && f_cu < f_cu_max) {

			printf("ptr:%d, f_cu:%d\n", ptr, f_cu);
			MD_16_PORT* md = new MD_16_PORT(rdoq_model, model_cnt, md_fw_ptr, md_input_ptr, rmd_mode, RefWindowLCU, CtrPos, p_fenc_LCU_Y, me_line_map_ptr, inner_nebs,
				above_nebs_line, skip_in, boundary, isNS_allow, NS_luma_pred_mode, x0, y0, cup, cu_width_log2, cu_height_log2, cud, qt_depth, bet_depth, cons_pred_mode,
				tree_status, cu_data_temp_ptr, fme_mv_info, IP_buffer_ptr, MPM_buffer_ptr, MAP_SCU_IP_ptr, refwin_md, CtrPosFME);

			size_t cnt = md->write_bin(fp_md_kernel_16_input_golden);
			printf("md_input_golden=%d\n", cnt);
			if (!cnt) {
				printf("Write input error!\n");
			}

			fflush(stdout);
			delete md;
		}

		if (ptr >= ptr_max && fp_md_kernel_16_input_golden != NULL) { fclose(fp_md_kernel_16_input_golden); }
		/******************************************************tb_data_input********************************************/
	}
	else
	{
		/******************************************************tb_data_output********************************************/


		if (fp_md_kernel_16_output_golden == NULL) {
			fp_md_kernel_16_output_golden = fopen("md_kernel_16_output_golden.dat", "wb");
			assert(fp_md_run_output_golden);
		}

		if (ptr < ptr_max && f_cu < f_cu_max) {

			MD_16_PORT* md = new MD_16_PORT(rdoq_model, model_cnt, md_fw_ptr, md_input_ptr, rmd_mode, RefWindowLCU, CtrPos, p_fenc_LCU_Y, me_line_map_ptr, inner_nebs,
				above_nebs_line, skip_in, boundary, isNS_allow, NS_luma_pred_mode, x0, y0, cup, cu_width_log2, cu_height_log2, cud, qt_depth, bet_depth, cons_pred_mode,
				tree_status, cu_data_temp_ptr, fme_mv_info, IP_buffer_ptr, MPM_buffer_ptr, MAP_SCU_IP_ptr, refwin_md, CtrPosFME);

			size_t cnt = md->write_bin(fp_md_kernel_16_output_golden);
			printf("fp_md_kernel_16_output_golden=%d\n", cnt);
			if (!cnt) {
				printf("Write output error!\n");
			}

			fflush(stdout);

			delete md;
		}

		if (ptr >= ptr_max && fp_md_kernel_16_output_golden != NULL)
		{
			fclose(fp_md_kernel_16_output_golden);
		}

		/******************************************************tb_data_output********************************************/
	}

}
#endif
#if DEBUG_MD_16
#define USE_FACADE 0
#ifdef WIN32
static FilePrinter fp = FilePrinter("D:\\working\\bframe\\data", -1, -1);
static FileReader fr = FileReader("D:\\working\\bframe\\data", -1);
#else
static FilePrinter fp = FilePrinter("/home/zhuxz/avs3ip/bframe/bframe/data", -1, -1);
#endif
#endif

#if USE_FACADE_MD_16
#if !MD_KERNEL_16_DUMMY
s64 md_kernel_16(RDOQ_MODEL * rdoq_model, RDOQ_MODEL * model_cnt, MD_FW * md_fw_ptr, MD_INPUT * md_input_ptr, u8 rmd_mode[IPD_RDO_CNT],
#if ENABLE_BFRAME
	ME_MV_DIR_16 * me_mv_dir,
#endif
	pel p_fenc_LCU_Y[MAX_CU_SIZE_FETCH * MAX_CU_SIZE_FETCH],
	ENC_ME_LINE_MAP * me_line_map_ptr,
	ENC_ME_NEB_INFO inner_nebs[2][SCU_IN_LCU_NUMS_LEN][SCU_IN_LCU_NUMS_LEN], ENC_ME_NEB_INFO above_nebs_line[ABOVE_LINE_LEN],
	SKIP_MERGE_INPUT * skip_in, U1 boundary, U1 isNS_allow, U2 NS_luma_pred_mode[1], U13 x0,
	U13 y0, U12 cup, U3 cu_width_log2, U3 cu_height_log2, U4 cud, U3 qt_depth, U3 bet_depth, U2 cons_pred_mode,
	U2 tree_status, ENC_CU_DATA_ARRAY * cu_data_temp_ptr,
	ENC_FME_INFO_ALL * fme_mv_info,
	IP_ARRAY * IP_buffer_ptr, MPM_ARRAY * MPM_buffer_ptr, IP_MAP_SCU * MAP_SCU_IP_ptr,
	pel fme2mdrefbuf[2560][8][2][16],
	strFetch_ref_window * Fetch_Ref_window_ptr)
#endif
#else
#if !MD_KERNEL_16_DUMMY
void init_four(RDOQ_ARRAY* rdoq_array, RDOQ_MODEL* rdoq_model_t, RDOQ_MODEL* model_cnt_t,
	CORE_SBTMVP* core_sbtmvp)
{
#pragma HLS inline off
	for (int j = 0; j < 2; j++)
	{
#pragma HLS pipeline
		for (int i = 0; i < 24; i++)
		{
			rdoq_array->rdoq_est_run[i][j] = 0;
			rdoq_array->rdoq_est_level[i][j] = 0;
			if (i < 3) {
				rdoq_array->rdoq_est_cbf[i][j] = 0;
			}
			if (i < 6) {
				for (int k = 0; k < 12; k++)
				{
					for (int l = 0; l < 2; l++)
					{
						rdoq_array->rdoq_est_last[j][i][k][l] = 0;
					}
				}
			}
#if SUB_TMVP
			if (i < 2) {
				for (int k = 0; k < 4; k++)
				{
					core_sbtmvp->sbTmvp[k].ref_idx[i] = -1;
					core_sbtmvp->best_sbTmvp[k].ref_idx[i] = -1;
					core_sbtmvp->sbTmvp[k].mv[i][j] = 0;
					core_sbtmvp->best_sbTmvp[k].mv[i][j] = 0;

				}
			}
#endif
			}
			}
	int i;
	for (i = 0; i < 12; i++) {
#pragma HLS UNROLL
		//#pragma HLS pipeline
		rdoq_model_t->last1[i] = PROB_INIT;
		model_cnt_t->last1[i] = 0;
		}
	for (i = 0; i < 22; i++) {
		//#pragma HLS pipeline
#pragma HLS UNROLL
		rdoq_model_t->last2[i] = PROB_INIT;
		model_cnt_t->last2[i] = 0;
	}
	for (i = 0; i < 24; i++) {
		//#pragma HLS pipeline
#pragma HLS UNROLL
		rdoq_model_t->run_rdoq[i] = PROB_INIT;
		model_cnt_t->run_rdoq[i] = 0;
		rdoq_model_t->level[i] = PROB_INIT;
		model_cnt_t->level[i] = 0;
	}
	for (i = 0; i < 3; i++) {
		//#pragma HLS pipeline
#pragma HLS UNROLL
		rdoq_model_t->cbf[i] = PROB_INIT;
		model_cnt_t->cbf[i] = 0;
	}
	};
s64 md_kernel_16(MD_FW* md_fw_ptr, MD_INPUT* md_input_ptr, u8 rmd_mode[IPRED_LIST_NUM],
#if ENABLE_BFRAME
	ME_MV_DIR_16 * me_mv_dir,
#endif
	pel p_fenc_LCU_Y[16][16],
	ENC_ME_LINE_MAP_SIZE<16>*me_line_map_ptr_16,
	ENC_ME_NEB_INFO up_nebs[1 + (16 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(16 >> 2)],
	SKIP_MERGE_INPUT_16 * skip_in_16,
	U1 boundary, U1 isNS_allow, U2 NS_luma_pred_mode[1], U13 x0,
	U13 y0, U12 cup, U3 cu_width_log2, U3 cu_height_log2, U4 cud, U3 qt_depth, U3 bet_depth, U2 cons_pred_mode, U2 tree_status,
	ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_temp_ptr_16,
	ENC_FME_INFO_ALL_16 * fme_mv_info,
	IP_ARRAY_SIZE<16, 16>*IP_buffer_ptr_16x16, IP_ARRAY_SIZE<8, 16>*IP_buffer_ptr_8x16, IP_ARRAY_SIZE<16, 8>*IP_buffer_ptr_16x8,
	MPM_ARRAY_SIZE<16, 16>*MPM_buffer_ptr_16x16, MPM_ARRAY_SIZE<8, 16>*MPM_buffer_ptr_8x16, MPM_ARRAY_SIZE<16, 8>*MPM_buffer_ptr_16x8,
	IP_MAP_SCU_SIZE<16, 16>*IP_map_scu_ptr_16x16, IP_MAP_SCU_SIZE<8, 16>*IP_map_scu_ptr_8x16, IP_MAP_SCU_SIZE<16, 8>*IP_map_scu_ptr_16x8,
	Arbitor& ref,
	strFetch_ref_window_16 * Fetch_Ref_window_ptr
#if SUB_TMVP
	, SKIP_MERGE_INPUT * skip_in
#endif
)
{
#if DISABLE_CU_16
	return MAX_S64;
#endif

#ifdef MD_TB_LUMA_16
	static int f_cu = 0, ptr = -1;
	if (ptr != md_fw_ptr->cur_ptr) { ptr = md_fw_ptr->cur_ptr; f_cu = 0; }
	else { ++f_cu; }
	md_kernel_16_get_golden_data(1, f_cu, ptr, rdoq_model, model_cnt, md_fw_ptr, md_input_ptr, rmd_mode, RefWindowLCU, CtrPos, p_fenc_LCU_Y, me_line_map_ptr, inner_nebs,
		above_nebs_line, skip_in, boundary, isNS_allow, NS_luma_pred_mode, x0, y0, cup, cu_width_log2, cu_height_log2, cud, qt_depth, bet_depth, cons_pred_mode,
		tree_status, cu_data_temp_ptr, fme_mv_info, IP_buffer_ptr, MPM_buffer_ptr, MAP_SCU_IP_ptr, refwin_md, CtrPosFME);

#endif
	s64 ns_cost = (s64)MAX_S64;

#if DEBUG_MD_16
	if (x0 == 144 && y0 == 64 && cu_width_log2 == 4 && cu_height_log2 == 4 && cud == 2 && pic_cnt == 14 && qt_depth == 0 && bet_depth == 4)
	{
		isProblem = 1;
		
	}
#endif
	static MD_COM_MODE mod_info_curr_temp;
	static MD_COM_MODE_BEST_16 best_info_ptr_16;
	static MD_KERNEL_INPUT md_kernel_input;
	s8 coef_rec_write_flag = 0;
	static RDOQ_ARRAY rdoq_array;
	static RDOQ_MODEL rdoq_model_t;
	static RDOQ_MODEL model_cnt_t;
	U6 qp_y_copy = md_input_ptr->qp_y;
//#if !DISABLE_RDO_LUMA_16_16
#if 0
#pragma HLS resource variable=best_info_ptr_16.ipm core=RAM_T2P_BRAM 
#pragma HLS resource variable=best_info_ptr_16.mpm core=RAM_T2P_BRAM 
#endif // DISABLE_RDO_LUMA_16_16
#if SUB_TMVP
	static CORE_SBTMVP core_sbtmvp;
	CORE_SBTMVP* core_sbtmvp_ptr = &core_sbtmvp;
	core_sbtmvp.sbTmvp_flag = 0;
	core_sbtmvp.best_sbTmvp_flag = 0;
#endif
	U8 cu_width = 1 << cu_width_log2;
	U8 cu_height = 1 << cu_height_log2;
	mod_info_curr_temp.x_chroma = cu_data_temp_ptr_16->x_chroma;
	mod_info_curr_temp.y_chroma = cu_data_temp_ptr_16->y_chroma;
	mod_info_curr_temp.last_child = cu_data_temp_ptr_16->last_child;
#pragma HLS ARRAY_PARTITION variable=core_sbtmvp.sbTmvp[0].ref_idx complete dim=1
#pragma HLS ARRAY_PARTITION variable=core_sbtmvp.sbTmvp[0].mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=core_sbtmvp.best_sbTmvp[0].ref_idx complete dim=1
#pragma HLS ARRAY_PARTITION variable=core_sbtmvp.best_sbTmvp[0].mv complete dim=0
	init_four(&rdoq_array, &rdoq_model_t, &model_cnt_t, &core_sbtmvp);

	if (!boundary) {
#if CUDQP_QP_MAP
		if (md_input_ptr->cu_dqp_enable) {
			u32 luma_map_scu;
			int scu_stride = 16;
			int x_scu_in_LCU = (x0 % 64) >> 2;
			int y_scu_in_LCU = (y0 % 64) >> 2;
			int luma_cup;
			U6 cu_w_scu = cu_width >> 2;
			U6 cu_h_scu = cu_height >> 2;
			luma_cup = (y_scu_in_LCU + (cu_h_scu - 1)) * scu_stride + (x_scu_in_LCU + (cu_w_scu - 1));
			// md_input_ptr->qp_y = md_input_ptr->CuQPMap[luma_cup];	//因为对qy_y变量做写操作，会出现读写冲突。故将写操作去掉，根据罗老师的分析，该变量不需要回写。
			qp_y_copy = md_input_ptr->CuQPMap[luma_cup];
			// md_input_ptr->cu_qp_group_pred_qp = md_input_ptr->qp_y;	//因为上面修改了赋值的变量，需要相应的修改。
			md_input_ptr->cu_qp_group_pred_qp = qp_y_copy;
			//assert(core->qp_y >= 0 && core->qp_y <= MAX_QUANT_BASE + ctx->info.qp_offset_bit_depth);
		}
#endif
		ns_cost = init_basic_leaf_16(isNS_allow, &rdoq_model_t, &model_cnt_t, &rdoq_array, md_fw_ptr, md_input_ptr->lambda_y, cu_width_log2, cu_height_log2, cud, &best_info_ptr_16, qt_depth, bet_depth, x0, y0, cup, tree_status, &cons_pred_mode,
			&mod_info_curr_temp, cu_data_temp_ptr_16
		);

		init_md_kernel_input_16(&md_kernel_input,
			cu_data_temp_ptr_16,
			x0, y0, cu_width_log2, cu_height_log2, md_fw_ptr->pic_width_in_scu, tree_status);
		if (cu_width == 16 && cu_height == 16) {
#if !DISABLE_RDO_LUMA_16_16
			ns_cost += rdo_luma_16_16(isNS_allow, cu_width, cu_height, &rdoq_array, md_fw_ptr,
				me_line_map_ptr_16,
				up_nebs, left_nebs,
				skip_in_16,
				tree_status, &best_info_ptr_16, md_input_ptr, p_fenc_LCU_Y,
#if ENABLE_BFRAME
				me_mv_dir,
#endif
				& mod_info_curr_temp,
				cu_data_temp_ptr_16,
				cons_pred_mode, cup, qt_depth, fme_mv_info,
				rmd_mode,
				IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
				MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
				IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
				ref,
				&md_kernel_input, Fetch_Ref_window_ptr
#if SUB_TMVP
				, core_sbtmvp_ptr, skip_in
#endif
			);
#else 
			ns_cost = (s64)MAX_S64;
#endif //!DISABLE_RDO_LUMA_16_16
			copy_to_cu_data_luma_16_16(isNS_allow, cu_width, cu_height, /*md_input_ptr->qp_y*/qp_y_copy,
				cu_data_temp_ptr_16,
				&best_info_ptr_16, tree_status, 0, 0, &coef_rec_write_flag, NS_luma_pred_mode
#if SUB_TMVP
				, core_sbtmvp_ptr
#endif
#if CUDQP_QP_MAP
				, md_input_ptr->cu_dqp_enable, md_input_ptr->cu_qp_group_pred_qp
#endif
			);
		}
#if !SIMPLE_MD
		else if (cu_width == 8 && cu_height == 16) {
#if !DISABLE_RDO_LUMA_8_16
			ns_cost += rdo_luma_8_16(isNS_allow, cu_width, cu_height, &rdoq_array, md_fw_ptr,
				me_line_map_ptr_16,
				up_nebs, left_nebs,
				skip_in_16,
				tree_status, &best_info_ptr_16, md_input_ptr, p_fenc_LCU_Y,
#if ENABLE_BFRAME
				me_mv_dir,
#endif
				& mod_info_curr_temp,
				cu_data_temp_ptr_16,
				cons_pred_mode, cup, qt_depth, fme_mv_info,
				rmd_mode,
				IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
				MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
				IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
				ref,
				&md_kernel_input, Fetch_Ref_window_ptr
#if SUB_TMVP
				, core_sbtmvp_ptr, skip_in
#endif
			);
#else
			ns_cost = (s64)MAX_S64;
#endif //!DISABLE_RDO_LUMA_8_16
		}
		else {
#if !DISABLE_RDO_LUMA_16_8
			ns_cost += rdo_luma_16_8(isNS_allow, cu_width, cu_height, &rdoq_array, md_fw_ptr,
				me_line_map_ptr_16,
				up_nebs, left_nebs,
				skip_in_16,
				tree_status, &best_info_ptr_16, md_input_ptr, p_fenc_LCU_Y,
#if ENABLE_BFRAME
				me_mv_dir,
#endif
				& mod_info_curr_temp,
				cu_data_temp_ptr_16,
				cons_pred_mode, cup, qt_depth, fme_mv_info,
				rmd_mode,
				IP_buffer_ptr_16x16, IP_buffer_ptr_8x16, IP_buffer_ptr_16x8,
				MPM_buffer_ptr_16x16, MPM_buffer_ptr_8x16, MPM_buffer_ptr_16x8,
				IP_map_scu_ptr_16x16, IP_map_scu_ptr_8x16, IP_map_scu_ptr_16x8,
				ref,
				&md_kernel_input, Fetch_Ref_window_ptr
#if SUB_TMVP
				, core_sbtmvp_ptr, skip_in
#endif
			);
#else
			ns_cost = (s64)MAX_S64;
#endif //!DISABLE_RDO_LUMA_16_8
		
		}
#endif
		
		
	}
	//printf("pos=(%d %d) size=(%d %d) cost=%lld\n", x0, y0, 1 << cu_width_log2, 1 << cu_height_log2, ns_cost);

#ifdef MD_TB_LUMA_16
	md_kernel_16_get_golden_data(0, f_cu, ptr, rdoq_model, model_cnt, md_fw_ptr, md_input_ptr, rmd_mode, RefWindowLCU, CtrPos, p_fenc_LCU_Y, me_line_map_ptr, inner_nebs,
		above_nebs_line, skip_in, boundary, isNS_allow, NS_luma_pred_mode, x0, y0, cup, cu_width_log2, cu_height_log2, cud, qt_depth, bet_depth, cons_pred_mode,
		tree_status, cu_data_temp_ptr, fme_mv_info, IP_buffer_ptr, MPM_buffer_ptr, MAP_SCU_IP_ptr, refwin_md, CtrPosFME);
#endif

#if DEBUG_MD_16
	if (isProblem)
		isProblem = 0;
#endif

	return ns_cost;
}
#endif


void init_md_kernel_input_16(MD_KERNEL_INPUT * md_kernel_input,
	ENC_CU_DATA_ARRAY_SIZE<16>*cu_data_temp_ptr_16,
	U13 x0, U13 y0, U3 cu_width_log2, U3 cu_height_log2, U11 pic_width_in_scu, U2 tree_status)
{
	md_kernel_input->x_chroma = cu_data_temp_ptr_16->x_chroma;
	md_kernel_input->y_chroma = cu_data_temp_ptr_16->y_chroma;
	md_kernel_input->x_pos = x0;
	md_kernel_input->y_pos = y0;
	md_kernel_input->chroma_motion = (cu_data_temp_ptr_16->last_child && tree_status == TREE_L);
	md_kernel_input->scup = (y0 >> 2) * pic_width_in_scu + (x0 >> 2);
	md_kernel_input->cu_width = (1 << cu_width_log2);
	md_kernel_input->cu_height = (1 << cu_height_log2);
	md_kernel_input->cu_width_log2 = cu_width_log2;
	md_kernel_input->cu_height_log2 = cu_height_log2;
}

#endif

