#include "md_kernel_32.h"
#include "md_dummy.h"
//#include "md_kernel_32_hls.h"
#pragma warning(disable:4334)
#pragma warning(disable:4018)
#pragma warning(disable:26453)
#pragma warning(disable:6297)
#define MD_INFO_NZ_FLAT 1
//#define _MD_32x16_      1

#define MD_KERNEL_32_MOD_YHY 1

extern int op_patch_mode_on;
static const s8 com_tbl_log2[257] = {
	/* 0, 1 */
	-1, -1,
	/* 2, 3 */
	1, -1,
	/* 4 ~ 7 */
	2, -1, -1, -1,
	/* 8 ~ 15 */
	3, -1, -1, -1, -1, -1, -1, -1,
	/* 16 ~ 31 */
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 31 ~ 63 */
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 64 ~ 127 */
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 128 ~ 255 */
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	/* 256 */
	8
};

#define GET_I_COST(rate, lamba)  (rate*lamba)


void Ipred_32_diff(U8 w, U8 h, s16 orgY_32x32[32][32], s16 pred_cache_32x32[32][32], s16 coef_tmp_32x32[32][32])
{
	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < 32; j++) {
			if (j < w) {
				coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}
}

#if MD_KERNEL_32_MOD_YHY

void Ipred_vert_32_pred(U8 w, U8 h, pel src_up[32 * 2 + 3], s16 pred_cache_32x32[32][32])
{

#pragma HLS ARRAY_PARTITION variable=pred_cache_32x32 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0

	int i, j;
	for (i = 0; i < 32; i++) 
	{
#pragma HLS PIPELINE
		for (j = 0; j < 32; j++) 
		{
			if (j < w && i < h)
			{
				pred_cache_32x32[i][j] = src_up[j];
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}
}

void Ipred_hor_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], s16 pred_cache_32x32[32][32])
{

#pragma HLS ARRAY_PARTITION variable=pred_cache_32x32 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src_le complete dim=1

	int i, j;
	for (i = 0; i < 32; i++) 
	{
#pragma HLS PIPELINE
		for (j = 0; j < 32; j++) 
		{
			if (j < w && i < h)
			{
				pred_cache_32x32[i][j] = src_le[i];
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}
}
void Ipred_dc_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, u16 avail_cu, s16 pred_cache_32x32[32][32])
{
	int dc = 0;
	//	int wh;
	int i;
	int j;
	int offset_s1 = 0;
	int s_src2 = w;
	int s_diff = w;

#pragma HLS array_partition variable = pred_cache_32x32 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0

	if (((avail_cu) & 1 << 1) == 1 << 1) 
	{
		for (i = 0; i < 32; i++) 
		{
#pragma HLS UNROLL
			if (i < h) 
			{
				dc += (src_le[i]);
			}

		}
		if (((avail_cu) & 1 << 0) == 1 << 0) 
		{
			for (j = 0; j < 32; j++) 
			{
#pragma HLS UNROLL
				if (j < w) 
				{
					dc += (src_up[j]);
				}
			}
			if (w == h)
				dc = (dc + ((64) >> 1)) * (4096 / (64)) >> 12;
			if ((w + h) == 48)
				dc = (dc + ((48) >> 1)) * (4096 / (48)) >> 12;
			if ((w + h) == 40)
				dc = (dc + ((40) >> 1)) * (4096 / (40)) >> 12;
			//dc = (dc + ((w + h) >> 1)) * (4096 / (w + h)) >> 12;
		}
		else 
		{
			dc = (dc + (h >> 1)) >> (com_tbl_log2[h]);
		}
	}
	else if (((avail_cu) & 1 << 0) == 1 << 0) 
	{
		for (j = 0; j < 32; j++) 
		{
#pragma HLS UNROLL
			if (j < w) 
			{
				dc += (src_up[j]);
			}
		}
		dc = (dc + (w >> 1)) >> (com_tbl_log2[w]);
	}
	else 
	{
		dc = 1 << (bit_depth - 1);
	}

	for (i = 0; i < 32; i++) 
	{
#pragma HLS PIPELINE
		for (j = 0; j < 32; j++) 
		{
			if (j < w && i < h)
			{
				pred_cache_32x32[i][j] = dc;
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}

}
void Ipred_plane_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, s16 pred_cache_32x32[32][32])
{
	int coef_h = 0;
	int coef_v = 0;
	int a;
	int b;
	int c;
	int x;
	int y;
	int w2 = w >> 1;
	int h2 = h >> 1;
	int ib_mult[5] = { (13), (17), (5), (11), (23) };
	int ib_shift[5] = { (7), (10), (11), (15), (19) };
	int idx_w = (com_tbl_log2[w]) - 2;
	int idx_h = (com_tbl_log2[h]) - 2;
	int im_h;
	int is_h;
	int im_v;
	int is_v;
	int temp;

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = w;
	int s_diff = w;
	int pred_cache;

	im_h = ib_mult[idx_w];
	is_h = ib_shift[idx_w];
	im_v = ib_mult[idx_h];
	is_v = ib_shift[idx_h];

#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
#pragma HLS array_partition variable = ib_mult complete dim=0
#pragma HLS array_partition variable = ib_shift complete dim=0
#pragma HLS array_partition variable = pred_cache_32x32 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0

	//rsrc = src_up + (w2 - 1);
	//rsrc = src_up;
	for (x = 1; x < 17; x++) 
	{
#pragma HLS UNROLL
		if (x < w2 + 1) 
		{
			coef_h += x * ((src_up[w2 + x]) - (src_up[w2 - x]));
		}
	}
	//rsrc = src_le + (h2 - 1);
	//rsrc = src_le;
	for (y = 1; y < 17; y++) 
	{
#pragma HLS UNROLL
		if (y < h2 + 1) 
		{
			coef_v += y * ((src_le[h2 + y]) - (src_le[h2 - y]));
		}
	}
	a = (src_le[h] + src_up[w]) << 4;
	b = ((coef_h << 5) * im_h + (1 << (is_h - 1))) >> is_h;
	c = ((coef_v << 5) * im_v + (1 << (is_v - 1))) >> is_v;
	temp = a - (h2 - 1) * c - (w2 - 1) * b + 16;

	int i, j;
	for (i = 0; i < 32; i++) 
	{
#pragma HLS PIPELINE
		for (j = 0; j < 32; j++) 
		{
			if (j < w)
			{
				pred_cache = ((temp + i * c + j * b) >> 5);
				pred_cache_32x32[i][j] = (((0 > (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))) ? 0 : (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))))));
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}

}
void Ipred_bi_32_pred(U8 w, U8 h, pel* src_le, pel* src_up, U4 bit_depth, s16 pred_cache_32x32[32][32])
{
	int x;
	int y;
	int ishift_x = com_tbl_log2[w];
	int ishift_y = com_tbl_log2[h];
	int ishift = ishift_x < ishift_y ? ishift_x : ishift_y;
	int ishift_xy = ishift_x + ishift_y + 1;
	int offset = 1 << (ishift_x + ishift_y);
	int a;
	int b;
	int c;
	int wt;
	int wxy, wxya, wxyb, wxyc;
	int tmp;
	int predx, predxa, predxb, predxc;
	static int ref_up[128 >> 1];
	static int ref_le[128 >> 1];
	static int up[128 >> 1];
	static int le[128 >> 1];
	static int wy[128 >> 1];
	int wc;
	int tbl_wc[6] = { (-1), (21), (13), (7), (4), (2) };

#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
#pragma HLS array_partition variable = pred_cache_32x32 complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
#pragma HLS array_partition variable = ref_up complete dim=0
#pragma HLS array_partition variable = ref_le complete dim=0
#pragma HLS array_partition variable = up complete dim=0
#pragma HLS array_partition variable = le complete dim=0
#pragma HLS array_partition variable = wy complete dim=0

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = w;
	int s_diff = w;
	wc = (ishift_x > ishift_y ? ishift_x - ishift_y : ishift_y - ishift_x);
	wc = tbl_wc[wc];
	a = (src_up[w - 1]);
	b = (src_le[h - 1]);
	c = (w == h ? (a + b + 1) >> 1 : (((a << ishift_x) + (b << ishift_y)) * wc + (1 << (ishift + 5))) >> (ishift + 6));
	wt = (c << 1) - a - b;
	for (x = 0; x < 32; x++) 
	{
#pragma HLS UNROLL
		if (x < w)
		{
			up[x] = b - src_up[x];
			//		ref_up[x] = src_up[x] << ishift_y;
			ref_up[x] = src_up[x];
			ref_up[x] <<= ishift_y;
		}
	}
	tmp = 0;
	for (y = 0; y < 32; y++) 
	{
#pragma HLS UNROLL
		if (y < h)
		{
			le[y] = a - src_le[y];
			//		ref_le[y] = src_le[y] << ishift_x;
			ref_le[y] = src_le[y];
			ref_le[y] <<= ishift_x;
			wy[y] = wt * y;
		}
	}
	int i, j; int temp, tempa, tempb, tempc;
	for (i = 0; i < 32; i++) 
	{
#pragma HLS PIPELINE
		for (j = 0; j < 32; j++) 
		{
			if (j < w && i < h)
			{
				predx = ref_le[i] + (j + 1) * le[i];
				ref_up[j] += up[j];
				wxy = j * wy[i];
				temp = ((predx << ishift_y) + (ref_up[j] << ishift_x) + wxy + offset) >> ishift_xy;
				pred_cache_32x32[i][j] = (((0 > (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))) ? 0 : (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))))));
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}

}
void ipred_ang1_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, int ipm, s16 pred_cache_32x32[32][32]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[9][2] = { { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) } };

#pragma HLS array_partition variable = ipred_dxdy complete dim=0
#pragma HLS array_partition variable = pred_cache_32x32  complete dim=2
//#pragma HLS array_partition variable = pred_cache_32x32  cyclic factor=8 dim=1
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0

	int i, j, t_dxa, t_dxb, t_dxc, t_dxd, offseta, offsetb, offsetc, offsetd;
	int pa, pna, pn_n1a, pn_p2a, pos_maxa;
	int xa = 2147483647;
	int pb, pnb, pn_n1b, pn_p2b, pos_maxb;
	int xb = 2147483647;
	int pc, pnc, pn_n1c, pn_p2c, pos_maxc;
	int xc = 2147483647;
	int pd, pnd, pn_n1d, pn_p2d, pos_maxd;
	int xd = 2147483647;
	for (j = 0; j < 32; j++)
	{
#pragma HLS PIPELINE

		for (i = 0; i < 32; i++)
		{

			if (i < w && j < h)
			{
				/* case x-line */
				/**************************** 1 ****************************/
				t_dxa = (j + 1) * ipred_dxdy[ipm - 3][0] >> 10;
				offseta = ((j + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dxa << 5);
				xa = i + t_dxa;

				pn_n1a = xa - 1;
				pa = xa;
				pna = xa + 1;
				pn_p2a = xa + 2;
				pos_maxa = w * 2 - 1;

				pn_n1a = (pn_n1a < pos_maxa ? pn_n1a : pos_maxa);
				pa = (pa < pos_maxa ? pa : pos_maxa);
				pna = (pna < pos_maxa ? pna : pos_maxa);
				pn_p2a = (pn_p2a < pos_maxa ? pn_p2a : pos_maxa);
#if MIPF
				filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
				
				s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][0] : com_tbl_ipred_adi_bilinear[offseta][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][1] : com_tbl_ipred_adi_bilinear[offseta][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][2] : com_tbl_ipred_adi_bilinear[offseta][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][3] : com_tbl_ipred_adi_bilinear[offseta][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];


				s32 buffer1 = src_up[pn_n1a + 3] * data1;
				s32 buffer2 = src_up[pa + 3] * data2;
				s32 buffer3 = src_up[pna + 3] * data3;
				s32 buffer4 = src_up[pn_p2a + 3] * data4;

				temp_pel = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j][i] = temp_pel;
#else
				pred_cache_32x32[j][i] = ((src_up[pn_n1a + 3]) * (32 - offseta) + (src_up[pa + 3]) * (64 - offseta) + (src_up[pna + 3]) * (32 + offseta) + (src_up[pn_p2a + 3]) * offseta + 64) >> 7;
				//coef_tmp_32x32[j][i] = orgY_32x32[j][i] - pred_cache_32x32[j][i];
#endif
			}
		}
	}

}

void ipred_ang2_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, int ipm, s16 pred_cache_32x32[32][32]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#if MIPF
			static const s16 tbl_mc_c_coeff_hp[32][4] =
			{
				{ 0, 64, 0, 0 },
				{ -1, 63,  2,  0 },
				{ -2, 62,  4,  0 },
				{ -2, 60,  7,  -1 },
				{ -2, 58, 10, -2 },
				{ -3, 57, 12, -2 },
				{ -4, 56, 14, -2 },
				{ -4, 55, 15, -2 },
				{ -4, 54, 16, -2 },
				{ -5, 53, 18, -2 },
				{ -6, 52, 20, -2 },
				{ -6, 49, 24, -3 },
				{ -6, 46, 28, -4 },
				{ -5, 44, 29, -4 },
				{ -4, 42, 30, -4 },
				{ -4, 39, 33, -4 },
				{ -4, 36, 36, -4 },
				{ -4, 33, 39, -4 },
				{ -4, 30, 42, -4 },
				{ -4, 29, 44, -5 },
				{ -4, 28, 46, -6 },
				{ -3, 24, 49, -6 },
				{ -2, 20, 52, -6 },
				{ -2, 18, 53, -5 },
				{ -2, 16, 54, -4 },
				{ -2, 15, 55, -4 },
				{ -2, 14, 56, -4 },
				{ -2, 12, 57, -3 },
				{ -2, 10, 58, -2 },
				{ -1,  7, 60, -2 },
				{ 0,  4, 62, -2 },
				{ 0,  2, 63, -1 },
			};

			static const s16 com_tbl_ipred_adi_bilinear[32][4] =
			{
				/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
				{ 32, 64, 32,  0 },
				{ 31, 63, 33,  1 },
				{ 30, 62, 34,  2 },
				{ 29, 61, 35,  3 },
				{ 28, 60, 36,  4 },
				{ 27, 59, 37,  5 },
				{ 26, 58, 38,  6 },
				{ 25, 57, 39,  7 },
				{ 24, 56, 40,  8 },
				{ 23, 55, 41,  9 },
				{ 22, 54, 42, 10 },
				{ 21, 53, 43, 11 },
				{ 20, 52, 44, 12 },
				{ 19, 51, 45, 13 },
				{ 18, 50, 46, 14 },
				{ 17, 49, 47, 15 },
				{ 16, 48, 48, 16 },
				{ 15, 47, 49, 17 },
				{ 14, 46, 50, 18 },
				{ 13, 45, 51, 19 },
				{ 12, 44, 52, 20 },
				{ 11, 43, 53, 21 },
				{ 10, 42, 54, 22 },
				{ 9, 41, 55, 23 },
				{ 8, 40, 56, 24 },
				{ 7, 39, 57, 25 },
				{ 6, 38, 58, 26 },
				{ 5, 37, 59, 27 },
				{ 4, 36, 60, 28 },
				{ 3, 35, 61, 29 },
				{ 2, 34, 62, 30 },
				{ 1, 33, 63, 31 },
			};

			static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
			{
				/* best for CfP extra smooth */
				{ 23, 82, 21, 2 },
				{ 21, 82, 23, 2 },
				{ 19, 82, 25, 2 },
				{ 18, 81, 27, 2 },
				{ 16, 80, 30, 2 },
				{ 15, 79, 32, 2 },
				{ 13, 78, 35, 2 },
				{ 12, 77, 37, 2 },
				{ 11, 75, 40, 2 },
				{ 10, 74, 42, 2 },
				{ 9, 72, 45, 2 },
				{ 8, 70, 47, 3 },
				{ 7, 68, 50, 3 },
				{ 6, 67, 52, 3 },
				{ 6, 64, 54, 4 },
				{ 5, 62, 57, 4 },
				{ 4, 60, 60, 4 },
				{ 4, 57, 62, 5 },
				{ 4, 54, 64, 6 },
				{ 3, 52, 67, 6 },
				{ 3, 50, 68, 7 },
				{ 3, 47, 70, 8 },
				{ 2, 45, 72, 9 },
				{ 2, 42, 74, 10 },
				{ 2, 40, 75, 11 },
				{ 2, 37, 77, 12 },
				{ 2, 35, 78, 13 },
				{ 2, 32, 79, 15 },
				{ 2, 30, 80, 16 },
				{ 2, 27, 81, 18 },
				{ 2, 25, 82, 19 },
				{ 2, 23, 82, 21 },
			};

			static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
			{
				// semi-sharp
				{ 11, 106, 12, -1 },
				{ 9, 105, 15, -1 },
				{ 7, 105, 18, -2 },
				{ 6, 103, 21, -2 },
				{ 4, 102, 25, -3 },
				{ 2, 100, 29, -3 },
				{ 1, 99, 32, -4 },
				{ 0, 96, 36, -4 },
				{ -1, 94, 39, -4 },
				{ -2, 92, 43, -5 },
				{ -3, 89, 47, -5 },
				{ -4, 86, 51, -5 },
				{ -4, 83, 55, -6 },
				{ -5, 80, 59, -6 },
				{ -5, 77, 62, -6 },
				{ -6, 74, 66, -6 },
				{ -6, 70, 70, -6 },
				{ -6, 66, 74, -6 },
				{ -6, 62, 77, -5 },
				{ -6, 59, 80, -5 },
				{ -6, 55, 83, -4 },
				{ -5, 51, 86, -4 },
				{ -5, 47, 89, -3 },
				{ -5, 43, 92, -2 },
				{ -4, 39, 94, -1 },
				{ -4, 36, 96, 0 },
				{ -4, 32, 99, 1 },
				{ -3, 29, 100, 2 },
				{ -3, 25, 102, 4 },
				{ -2, 21, 103, 6 },
				{ -2, 18, 105, 7 },
				{ -1, 15, 105, 9 },
			};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[8][2] = { { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };

#pragma HLS array_partition variable = pred_cache_32x32  complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
//#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
#pragma HLS array_partition variable = ipred_dxdy complete dim=0

	int i, j, t_dya, offseta;
	int pa, pna, pn_n1a, pn_p2a, pos_maxa;
	int ya = 2147483647;
	int t_dyb, offsetb;
	int pb, pnb, pn_n1b, pn_p2b, pos_maxb;
	int yb = 2147483647;
	int t_dyc, offsetc;
	int pc, pnc, pn_n1c, pn_p2c, pos_maxc;
	int yc = 2147483647;
	int t_dyd, offsetd;
	int pd, pnd, pn_n1d, pn_p2d, pos_maxd;
	int yd = 2147483647;

	for (j = 0; j < 32; j++)
	{
#pragma HLS PIPELINE

		for (i = 0; i < 32; i++)
		{

			if (i < w && j < h)
			{
				/**************************** 1 ****************************/
				t_dya = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
				offseta = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dya << 5);
				ya = j + t_dya;
				pn_n1a = ya - 1;
				pa = ya;
				pna = ya + 1;
				pn_p2a = ya + 2;
				pos_maxa = h * 2 - 1;

				pn_n1a = (pn_n1a < pos_maxa ? pn_n1a : pos_maxa);
				pa = (pa < pos_maxa ? pa : pos_maxa);
				pna = (pna < pos_maxa ? pna : pos_maxa);
				pn_p2a = (pn_p2a < pos_maxa ? pn_p2a : pos_maxa);

#if MIPF									
				filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;

				s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][0] : com_tbl_ipred_adi_bilinear[offseta][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][1] : com_tbl_ipred_adi_bilinear[offseta][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][2] : com_tbl_ipred_adi_bilinear[offseta][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][3] : com_tbl_ipred_adi_bilinear[offseta][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];
				s32 buffer1 = src_le[pn_n1a+3] * data1;
				s32 buffer2 = src_le[pa+3] * data2;
				s32 buffer3 = src_le[pna+3] * data3;
				s32 buffer4 = src_le[pn_p2a+3] * data4;
				temp_pel = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j][i] = temp_pel;
#else
				pred_cache_32x32[j][i] = ((src_le[pn_n1a + 3]) * (32 - offseta) + (src_le[pa + 3]) * (64 - offseta) + (src_le[pna + 3]) * (32 + offseta) + (src_le[pn_p2a + 3]) * offseta + 64) >> 7;
				//coef_tmp_32x32[j][i] = orgY_32x32[j][i] - pred_cache_32x32[j][i];
#endif
			}
		}
	}
}


void ipred_ang3_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, int ipm, s16 pred_cache_32x32[32][32]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	//pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[11][2] = { { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) } };
	int i, j;
	int offseta, offset_xa, offset_ya, xxa, yya, t_dxa, t_dya;
	int pa, pna, pn_n1a, pn_p2a, pos_maxa;
	pel temp_pela = 0;
	int offsetb, offset_xb, offset_yb, xxb, yyb, t_dxb, t_dyb;
	int pb, pnb, pn_n1b, pn_p2b, pos_maxb;
	pel temp_pelb = 0;
	int offsetc, offset_xc, offset_yc, xxc, yyc, t_dxc, t_dyc;
	int pc, pnc, pn_n1c, pn_p2c, pos_maxc;
	pel temp_pelc = 0;
	int offsetd, offset_xd, offset_yd, xxd, yyd, t_dxd, t_dyd;
	int pd, pnd, pn_n1d, pn_p2d, pos_maxd;
	pel temp_peld = 0;

	int xy = -1, yx = -1;
	int xa, xb, ya, yb, xc, yc, xd, yd;

#pragma HLS array_partition variable = pred_cache_32x32  complete dim=2
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
#pragma HLS array_partition variable = ipred_dxdy complete dim=0

	for (j = 0; j < 32; j++)
	{
#pragma HLS PIPELINE

		for (i = 0; i < 32; i++)
		{			
#pragma HLS UNROLL

			if (i < w && j < h)
			{
				/**************************** 1 ****************************/
				
				if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
					filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
				}
				else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
					filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				}
				t_dxa = (j + 1) * ipred_dxdy[ipm - 13][0] >> 10;
				offset_xa = ((j + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dxa << 5);
				t_dxa = -t_dxa;
				xxa = i + t_dxa;
				t_dya = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
				offset_ya = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dya << 5);
				t_dya = -t_dya;
				yya = j + t_dya;

				if (yya <= -1) {
					offseta = offset_xa;
					xa = xxa;
					ya = yx;
				}
				else {
					offseta = offset_ya;
					ya = yya;
					xa = xy;
				}
				if (ya == -1) {
					pn_n1a = xa + 1;
					pa = xa;
					pna = xa - 1;
					pn_p2a = xa - 2;
					pos_maxa = w * 2 - 1;
				}
				else {
					pn_n1a = ya + 1;
					pa = ya;
					pna = ya - 1;
					pn_p2a = ya - 2;
					pos_maxa = h * 2 - 1;
				}

				pn_n1a += 3;
				pa += 3;
				pna += 3;
				pn_p2a += 3;

				int src_pa, src_pna, src_pn_n1a, src_pn_p2a;

				if (ya == -1) {
					src_pn_n1a = src_up[pn_n1a];
					src_pa = src_up[pa];
					src_pna = src_up[pna];
					src_pn_p2a = src_up[pn_p2a];
				}
				else if (xa == -1) {
					src_pn_n1a = src_le[pn_n1a];
					src_pa = src_le[pa];
					src_pna = src_le[pna];
					src_pn_p2a = src_le[pn_p2a];
				}
				else {
					src_pn_n1a = 0;
					src_pa = 0;
					src_pna = 0;
					src_pn_p2a = 0;
				}

#if MIPF

                s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][0] : com_tbl_ipred_adi_bilinear[offseta][0];
				s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][1] : com_tbl_ipred_adi_bilinear[offseta][1];
				s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][2] : com_tbl_ipred_adi_bilinear[offseta][2];
				s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offseta][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offseta][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offseta][3] : com_tbl_ipred_adi_bilinear[offseta][3];
				s16 data5 = filter_offset_list[filter_idx];
				s16 data6 = filter_bits_list[filter_idx];

				s32 buffer1 = src_pn_n1a * data1;
				s32 buffer2 = src_pa * data2;
				s32 buffer3 = src_pna * data3;
				s32 buffer4 = src_pn_p2a * data4;

				temp_pela = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
				temp_pela = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pela);
				pred_cache_32x32[j][i] = temp_pela;
#else
				temp_pela = ((src_up[pn_n1a + 3]) * (32 - offseta) + (src_up[pa + 3]) * (64 - offseta) + ((
					int)src_up[pna + 3]) * (32 + offseta) + (src_up[pn_p2a + 3]) * offseta + 64) >> 7;
#endif					
			}

		}

	}
}
#else
void Ipred_vert_32_pred(U8 w, U8 h, pel src_up[32 * 2 + 3], s16 pred_cache_32x32[32][32])
{
	int i, j;
	for (i = 0; i < 32; i++) {
		for (j = 0; j < 32; j++) {
			if (j < w)
			{
				pred_cache_32x32[i][j] = src_up[j];
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}
}
void Ipred_hor_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], s16 pred_cache_32x32[32][32])
{
	int i, j;
	for (i = 0; i < 32; i++) {
		for (j = 0; j < 32; j++) {
			if (j < w)
			{
				pred_cache_32x32[i][j] = src_le[i];
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}
}
void Ipred_dc_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, u16 avail_cu, s16 pred_cache_32x32[32][32])
{
	int dc = 0;
	//	int wh;
	int i;
	int j;
	int offset_s1 = 0;
	int s_src2 = w;
	int s_diff = w;
	if (((avail_cu) & 1 << 1) == 1 << 1) {
		for (i = 0; i < 32; i = i + 4) {
			if (i < h) {
				dc += (src_le[i]);
				dc += (src_le[i + 1]);
				dc += (src_le[i + 2]);
				dc += (src_le[i + 3]);
			}

		}
		if (((avail_cu) & 1 << 0) == 1 << 0) {
			for (j = 0; j < 32; j = j + 4) {
				if (j < w) {
					dc += (src_up[j]);
					dc += (src_up[j + 1]);
					dc += (src_up[j + 2]);
					dc += (src_up[j + 3]);
				}
			}
			if (w == h)
				dc = (dc + ((64) >> 1)) * (4096 / (64)) >> 12;
			if ((w + h) == 48)
				dc = (dc + ((48) >> 1)) * (4096 / (48)) >> 12;
			if ((w + h) == 40)
				dc = (dc + ((40) >> 1)) * (4096 / (40)) >> 12;
			//dc = (dc + ((w + h) >> 1)) * (4096 / (w + h)) >> 12;
		}
		else {
			dc = (dc + (h >> 1)) >> (com_tbl_log2[h]);
		}
	}
	else if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (j = 0; j < 32; j = j + 4) {
			if (j < w) {
				dc += (src_up[j]);
				dc += (src_up[j + 1]);
				dc += (src_up[j + 2]);
				dc += (src_up[j + 3]);
			}
		}
		dc = (dc + (w >> 1)) >> (com_tbl_log2[w]);
	}
	else {
		dc = 1 << (bit_depth - 1);
	}

	for (i = 0; i < 32; i++) {
		for (j = 0; j < 32; j++) {
			if (j < w)
			{
				pred_cache_32x32[i][j] = dc;
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}

}
void Ipred_plane_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, s16 pred_cache_32x32[32][32])
{
	int coef_h = 0;
	int coef_v = 0;
	int a;
	int b;
	int c;
	int x;
	int y;
	int w2 = w >> 1;
	int h2 = h >> 1;
	int ib_mult[5] = { (13), (17), (5), (11), (23) };
	int ib_shift[5] = { (7), (10), (11), (15), (19) };
	int idx_w = (com_tbl_log2[w]) - 2;
	int idx_h = (com_tbl_log2[h]) - 2;
	int im_h;
	int is_h;
	int im_v;
	int is_v;
	int temp;

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = w;
	int s_diff = w;
	int pred_cache;

	im_h = ib_mult[idx_w];
	is_h = ib_shift[idx_w];
	im_v = ib_mult[idx_h];
	is_v = ib_shift[idx_h];
	//rsrc = src_up + (w2 - 1);
	//rsrc = src_up;
	for (x = 1; x < 17; x = x + 4) {
		if (x < w2 + 1) {
			coef_h += x * ((src_up[w2 + x]) - (src_up[w2 - x]));
			coef_h += (x + 1) * ((src_up[w2 + x + 1]) - (src_up[w2 - (x + 1)]));
			coef_h += (x + 2) * ((src_up[w2 + x + 2]) - (src_up[w2 - (x + 2)]));
			coef_h += (x + 3) * ((src_up[w2 + x + 3]) - (src_up[w2 - (x + 3)]));
		}
	}
	//rsrc = src_le + (h2 - 1);
	//rsrc = src_le;
	for (y = 1; y < 17; y = y + 4) {
		if (y < h2 + 1) {
			coef_v += y * ((src_le[h2 + y]) - (src_le[h2 - y]));
			coef_v += (y + 1) * ((src_le[h2 + y + 1]) - (src_le[h2 - (y + 1)]));
			coef_v += (y + 2) * ((src_le[h2 + y + 2]) - (src_le[h2 - (y + 2)]));
			coef_v += (y + 3) * ((src_le[h2 + y + 3]) - (src_le[h2 - (y + 3)]));
		}
	}
	a = (src_le[h] + src_up[w]) << 4;
	b = ((coef_h << 5) * im_h + (1 << (is_h - 1))) >> is_h;
	c = ((coef_v << 5) * im_v + (1 << (is_v - 1))) >> is_v;
	temp = a - (h2 - 1) * c - (w2 - 1) * b + 16;

	int i, j;
	for (i = 0; i < 32; i++) {
		for (j = 0; j < 32; j++) {
			if (j < w)
			{
				pred_cache = ((temp + i * c + j * b) >> 5);
				pred_cache_32x32[i][j] = (((0 > (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))) ? 0 : (((1 << bit_depth) - 1 < (pred_cache) ? (1 << bit_depth) - 1 : (pred_cache))))));
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}

}
void Ipred_bi_32_pred(U8 w, U8 h, pel* src_le, pel* src_up, U4 bit_depth, s16 pred_cache_32x32[32][32])
{
	int x;
	int y;
	int ishift_x = com_tbl_log2[w];
	int ishift_y = com_tbl_log2[h];
	int ishift = ishift_x < ishift_y ? ishift_x : ishift_y;
	int ishift_xy = ishift_x + ishift_y + 1;
	int offset = 1 << (ishift_x + ishift_y);
	int a;
	int b;
	int c;
	int wt;
	int wxy, wxya, wxyb, wxyc;
	int tmp;
	int predx, predxa, predxb, predxc;
	static int ref_up[128 >> 1];
	static int ref_le[128 >> 1];
	static int up[128 >> 1];
	static int le[128 >> 1];
	static int wy[128 >> 1];
	int wc;
	int tbl_wc[6] = { (-1), (21), (13), (7), (4), (2) };

	int offset_s1 = 0;
	int offset_s2 = 0;
	int offset_diff = 0;
	int s_src2 = w;
	int s_diff = w;
	wc = (ishift_x > ishift_y ? ishift_x - ishift_y : ishift_y - ishift_x);
	wc = tbl_wc[wc];
	a = (src_up[w - 1]);
	b = (src_le[h - 1]);
	c = (w == h ? (a + b + 1) >> 1 : (((a << ishift_x) + (b << ishift_y)) * wc + (1 << (ishift + 5))) >> (ishift + 6));
	wt = (c << 1) - a - b;
	for (x = 0; x < 32; x++) {
		if (x < w)
		{
			up[x] = b - src_up[x];
			//		ref_up[x] = src_up[x] << ishift_y;
			ref_up[x] = src_up[x];
			ref_up[x] <<= ishift_y;
		}
	}
	tmp = 0;
	for (y = 0; y < 32; y++) {
		if (y < h)
		{
			le[y] = a - src_le[y];
			//		ref_le[y] = src_le[y] << ishift_x;
			ref_le[y] = src_le[y];
			ref_le[y] <<= ishift_x;
			wy[y] = wt * y;
		}
	}
	int i, j; int temp, tempa, tempb, tempc;
	for (i = 0; i < 32; i++) {
		for (j = 0; j < 32; j++) {
			if (j < w)
			{
				predx = ref_le[i] + (j + 1) * le[i];
				ref_up[j] += up[j];
				wxy = j * wy[i];
				temp = ((predx << ishift_y) + (ref_up[j] << ishift_x) + wxy + offset) >> ishift_xy;
				pred_cache_32x32[i][j] = (((0 > (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))) ? 0 : (((1 << bit_depth) - 1 < (temp) ? (1 << bit_depth) - 1 : (temp))))));
				//coef_tmp_32x32[i][j] = orgY_32x32[i][j] - pred_cache_32x32[i][j];
			}
		}
	}

}
void ipred_ang1_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, int ipm, s16 pred_cache_32x32[32][32]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[9][2] = { { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) } };
#pragma HLS array_partition variable = ipred_dxdy complete dim=0
//#pragma HLS array_partition variable = orgY_32x32 cyclic factor=256 dim=1
#pragma HLS array_partition variable = pred_cache_32x32  complete dim=2
#pragma HLS array_partition variable = pred_cache_32x32  cyclic factor=8 dim=1
//#pragma HLS array_partition variable = coef_tmp_32x32  complete dim=2
//#pragma HLS array_partition variable = coef_tmp_32x32 cyclic factor=8 dim=1
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
	int i, j, t_dxa, t_dxb, t_dxc, t_dxd, offseta, offsetb, offsetc, offsetd;
	int pa, pna, pn_n1a, pn_p2a, pos_maxa;
	int xa = 2147483647;
	int pb, pnb, pn_n1b, pn_p2b, pos_maxb;
	int xb = 2147483647;
	int pc, pnc, pn_n1c, pn_p2c, pos_maxc;
	int xc = 2147483647;
	int pd, pnd, pn_n1d, pn_p2d, pos_maxd;
	int xd = 2147483647;
	for (j = 0; j < 32; j = j + 4)
	{
		//#pragma HLS loop_tripcount max = 32
#pragma HLS PIPELINE
		for (i = 0; i < 32; i++)
		{
			//#pragma HLS UNROLL
			if (i < w)
			{
				/* case x-line */
				/**************************** 1 ****************************/
				t_dxa = (j + 1) * ipred_dxdy[ipm - 3][0] >> 10;
				offseta = ((j + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dxa << 5);
				xa = i + t_dxa;

				pn_n1a = xa - 1;
				pa = xa;
				pna = xa + 1;
				pn_p2a = xa + 2;
				pos_maxa = w * 2 - 1;

				pn_n1a = (pn_n1a < pos_maxa ? pn_n1a : pos_maxa);
				pa = (pa < pos_maxa ? pa : pos_maxa);
				pna = (pna < pos_maxa ? pna : pos_maxa);
				pn_p2a = (pn_p2a < pos_maxa ? pn_p2a : pos_maxa);



#if MIPF
				filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offseta)[0];
				//temp_pel = (pel)((src_up[pn_n1a + 3] * filter[0] + src_up[pa + 3] * filter[1] +
				//	src_up[pna + 3] * filter[2] + src_up[pn_p2a + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_up[pn_n1a + 3] * com_tbl_ipred_adi_extra_smooth[offseta][0] + src_up[pa + 3] * com_tbl_ipred_adi_extra_smooth[offseta][1] +
						src_up[pna + 3] * com_tbl_ipred_adi_extra_smooth[offseta][2] + src_up[pn_p2a + 3] * com_tbl_ipred_adi_extra_smooth[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_up[pn_n1a + 3] * com_tbl_ipred_adi_semi_sharp[offseta][0] + src_up[pa + 3] * com_tbl_ipred_adi_semi_sharp[offseta][1] +
						src_up[pna + 3] * com_tbl_ipred_adi_semi_sharp[offseta][2] + src_up[pn_p2a + 3] * com_tbl_ipred_adi_semi_sharp[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_up[pn_n1a + 3] * tbl_mc_c_coeff_hp[offseta][0] + src_up[pa + 3] * tbl_mc_c_coeff_hp[offseta][1] +
						src_up[pna + 3] * tbl_mc_c_coeff_hp[offseta][2] + src_up[pn_p2a + 3] * tbl_mc_c_coeff_hp[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_up[pn_n1a + 3] * com_tbl_ipred_adi_bilinear[offseta][0] + src_up[pa + 3] * com_tbl_ipred_adi_bilinear[offseta][1] +
						src_up[pna + 3] * com_tbl_ipred_adi_bilinear[offseta][2] + src_up[pn_p2a + 3] * com_tbl_ipred_adi_bilinear[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j][i] = temp_pel;
				//coef_tmp_32x32[j][i] = orgY_32x32[j][i] - pred_cache_32x32[j][i];
#else
				pred_cache_32x32[j][i] = ((src_up[pn_n1a + 3]) * (32 - offseta) + (src_up[pa + 3]) * (64 - offseta) + (src_up[pna + 3]) * (32 + offseta) + (src_up[pn_p2a + 3]) * offseta + 64) >> 7;
				//coef_tmp_32x32[j][i] = orgY_32x32[j][i] - pred_cache_32x32[j][i];
#endif


				/**************************** 2 ****************************/
				t_dxb = (j + 1 + 1) * ipred_dxdy[ipm - 3][0] >> 10;
				offsetb = ((j + 1 + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dxb << 5);
				xb = i + t_dxb;

				pn_n1b = xb - 1;
				pb = xb;
				pnb = xb + 1;
				pn_p2b = xb + 2;
				pos_maxb = w * 2 - 1;

				pn_n1b = (pn_n1b < pos_maxb ? pn_n1b : pos_maxb);
				pb = (pb < pos_maxb ? pb : pos_maxb);
				pnb = (pnb < pos_maxb ? pnb : pos_maxb);
				pn_p2b = (pn_p2b < pos_maxb ? pn_p2b : pos_maxb);

#if MIPF
				filter_idx = mipf_enable_flag ? ((j + 1) < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offsetb)[0];
				//temp_pel = (pel)((src_up[pn_n1b + 3] * filter[0] + src_up[pb + 3] * filter[1] +
				//	src_up[pnb + 3] * filter[2] + src_up[pn_p2b + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_up[pn_n1b + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][0] + src_up[pb + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][1] +
						src_up[pnb + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][2] + src_up[pn_p2b + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_up[pn_n1b + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][0] + src_up[pb + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][1] +
						src_up[pnb + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][2] + src_up[pn_p2b + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_up[pn_n1b + 3] * tbl_mc_c_coeff_hp[offsetb][0] + src_up[pb + 3] * tbl_mc_c_coeff_hp[offsetb][1] +
						src_up[pnb + 3] * tbl_mc_c_coeff_hp[offsetb][2] + src_up[pn_p2b + 3] * tbl_mc_c_coeff_hp[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_up[pn_n1b + 3] * com_tbl_ipred_adi_bilinear[offsetb][0] + src_up[pb + 3] * com_tbl_ipred_adi_bilinear[offsetb][1] +
						src_up[pnb + 3] * com_tbl_ipred_adi_bilinear[offsetb][2] + src_up[pn_p2b + 3] * com_tbl_ipred_adi_bilinear[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j + 1][i] = temp_pel;
				//coef_tmp_32x32[j + 1][i] = orgY_32x32[j + 1][i] - pred_cache_32x32[j + 1][i];
#else

				pred_cache_32x32[j + 1][i] = ((src_up[pn_n1b + 3]) * (32 - offsetb) + (src_up[pb + 3]) * (64 - offsetb) + (src_up[pnb + 3]) * (32 + offsetb) + (src_up[pn_p2b + 3]) * offsetb + 64) >> 7;
				//coef_tmp_32x32[j + 1][i] = orgY_32x32[j + 1][i] - pred_cache_32x32[j + 1][i];
#endif




				/**************************** 3 ****************************/
				t_dxc = (j + 2 + 1) * ipred_dxdy[ipm - 3][0] >> 10;
				offsetc = ((j + 2 + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dxc << 5);
				xc = i + t_dxc;

				pn_n1c = xc - 1;
				pc = xc;
				pnc = xc + 1;
				pn_p2c = xc + 2;
				pos_maxc = w * 2 - 1;

				pn_n1c = (pn_n1c < pos_maxc ? pn_n1c : pos_maxc);
				pc = (pc < pos_maxc ? pc : pos_maxc);
				pnc = (pnc < pos_maxc ? pnc : pos_maxc);
				pn_p2c = (pn_p2c < pos_maxc ? pn_p2c : pos_maxc);

#if MIPF
				filter_idx = mipf_enable_flag ? ((j + 2) < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offsetc)[0];
				//temp_pel = (pel)((src_up[pn_n1c + 3] * filter[0] + src_up[pc + 3] * filter[1] +
				//	src_up[pnc + 3] * filter[2] + src_up[pn_p2c + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_up[pn_n1c + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][0] + src_up[pc + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][1] +
						src_up[pnc + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][2] + src_up[pn_p2c + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_up[pn_n1c + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][0] + src_up[pc + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][1] +
						src_up[pnc + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][2] + src_up[pn_p2c + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_up[pn_n1c + 3] * tbl_mc_c_coeff_hp[offsetc][0] + src_up[pc + 3] * tbl_mc_c_coeff_hp[offsetc][1] +
						src_up[pnc + 3] * tbl_mc_c_coeff_hp[offsetc][2] + src_up[pn_p2c + 3] * tbl_mc_c_coeff_hp[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_up[pn_n1c + 3] * com_tbl_ipred_adi_bilinear[offsetc][0] + src_up[pc + 3] * com_tbl_ipred_adi_bilinear[offsetc][1] +
						src_up[pnc + 3] * com_tbl_ipred_adi_bilinear[offsetc][2] + src_up[pn_p2c + 3] * com_tbl_ipred_adi_bilinear[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j + 2][i] = temp_pel;
				//coef_tmp_32x32[j + 2][i] = orgY_32x32[j + 2][i] - pred_cache_32x32[j + 2][i];
#else

				pred_cache_32x32[j + 2][i] = ((src_up[pn_n1c + 3]) * (32 - offsetc) + (src_up[pc + 3]) * (64 - offsetc) + (src_up[pnc + 3]) * (32 + offsetc) + (src_up[pn_p2c + 3]) * offsetc + 64) >> 7;
				//coef_tmp_32x32[j + 2][i] = orgY_32x32[j + 2][i] - pred_cache_32x32[j + 2][i];

#endif



				/**************************** 4 ****************************/
				t_dxd = (j + 3 + 1) * ipred_dxdy[ipm - 3][0] >> 10;
				offsetd = ((j + 3 + 1) * ipred_dxdy[ipm - 3][0] >> 5) - (t_dxd << 5);
				xd = i + t_dxd;

				pn_n1d = xd - 1;
				pd = xd;
				pnd = xd + 1;
				pn_p2d = xd + 2;
				pos_maxd = w * 2 - 1;

				pn_n1d = (pn_n1d < pos_maxd ? pn_n1d : pos_maxd);
				pd = (pd < pos_maxd ? pd : pos_maxd);
				pnd = (pnd < pos_maxd ? pnd : pos_maxd);
				pn_p2d = (pn_p2d < pos_maxd ? pn_p2d : pos_maxd);

#if MIPF
				filter_idx = mipf_enable_flag ? ((j + 3) < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offsetd)[0];
				//temp_pel = (pel)((src_up[pn_n1d + 3] * filter[0] + src_up[pd + 3] * filter[1] +
				//	src_up[pnd + 3] * filter[2] + src_up[pn_p2d + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_up[pn_n1d + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][0] + src_up[pd + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][1] +
						src_up[pnd + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][2] + src_up[pn_p2d + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_up[pn_n1d + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][0] + src_up[pd + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][1] +
						src_up[pnd + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][2] + src_up[pn_p2d + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_up[pn_n1d + 3] * tbl_mc_c_coeff_hp[offsetd][0] + src_up[pd + 3] * tbl_mc_c_coeff_hp[offsetd][1] +
						src_up[pnd + 3] * tbl_mc_c_coeff_hp[offsetd][2] + src_up[pn_p2d + 3] * tbl_mc_c_coeff_hp[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_up[pn_n1d + 3] * com_tbl_ipred_adi_bilinear[offsetd][0] + src_up[pd + 3] * com_tbl_ipred_adi_bilinear[offsetd][1] +
						src_up[pnd + 3] * com_tbl_ipred_adi_bilinear[offsetd][2] + src_up[pn_p2d + 3] * com_tbl_ipred_adi_bilinear[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// y == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j + 3][i] = temp_pel;
				//coef_tmp_32x32[j + 3][i] = orgY_32x32[j + 3][i] - pred_cache_32x32[j + 3][i];
#else

				pred_cache_32x32[j + 3][i] = ((src_up[pn_n1d + 3]) * (32 - offsetd) + (src_up[pd + 3]) * (64 - offsetd) + (src_up[pnd + 3]) * (32 + offsetd) + (src_up[pn_p2d + 3]) * offsetd + 64) >> 7;
				//coef_tmp_32x32[j + 3][i] = orgY_32x32[j + 3][i] - pred_cache_32x32[j + 3][i];
#endif

			}
		}
	}

}

void ipred_ang2_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, int ipm, s16 pred_cache_32x32[32][32]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#if MIPF
			static const s16 tbl_mc_c_coeff_hp[32][4] =
			{
				{ 0, 64, 0, 0 },
				{ -1, 63,  2,  0 },
				{ -2, 62,  4,  0 },
				{ -2, 60,  7,  -1 },
				{ -2, 58, 10, -2 },
				{ -3, 57, 12, -2 },
				{ -4, 56, 14, -2 },
				{ -4, 55, 15, -2 },
				{ -4, 54, 16, -2 },
				{ -5, 53, 18, -2 },
				{ -6, 52, 20, -2 },
				{ -6, 49, 24, -3 },
				{ -6, 46, 28, -4 },
				{ -5, 44, 29, -4 },
				{ -4, 42, 30, -4 },
				{ -4, 39, 33, -4 },
				{ -4, 36, 36, -4 },
				{ -4, 33, 39, -4 },
				{ -4, 30, 42, -4 },
				{ -4, 29, 44, -5 },
				{ -4, 28, 46, -6 },
				{ -3, 24, 49, -6 },
				{ -2, 20, 52, -6 },
				{ -2, 18, 53, -5 },
				{ -2, 16, 54, -4 },
				{ -2, 15, 55, -4 },
				{ -2, 14, 56, -4 },
				{ -2, 12, 57, -3 },
				{ -2, 10, 58, -2 },
				{ -1,  7, 60, -2 },
				{ 0,  4, 62, -2 },
				{ 0,  2, 63, -1 },
			};

			static const s16 com_tbl_ipred_adi_bilinear[32][4] =
			{
				/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
				{ 32, 64, 32,  0 },
				{ 31, 63, 33,  1 },
				{ 30, 62, 34,  2 },
				{ 29, 61, 35,  3 },
				{ 28, 60, 36,  4 },
				{ 27, 59, 37,  5 },
				{ 26, 58, 38,  6 },
				{ 25, 57, 39,  7 },
				{ 24, 56, 40,  8 },
				{ 23, 55, 41,  9 },
				{ 22, 54, 42, 10 },
				{ 21, 53, 43, 11 },
				{ 20, 52, 44, 12 },
				{ 19, 51, 45, 13 },
				{ 18, 50, 46, 14 },
				{ 17, 49, 47, 15 },
				{ 16, 48, 48, 16 },
				{ 15, 47, 49, 17 },
				{ 14, 46, 50, 18 },
				{ 13, 45, 51, 19 },
				{ 12, 44, 52, 20 },
				{ 11, 43, 53, 21 },
				{ 10, 42, 54, 22 },
				{ 9, 41, 55, 23 },
				{ 8, 40, 56, 24 },
				{ 7, 39, 57, 25 },
				{ 6, 38, 58, 26 },
				{ 5, 37, 59, 27 },
				{ 4, 36, 60, 28 },
				{ 3, 35, 61, 29 },
				{ 2, 34, 62, 30 },
				{ 1, 33, 63, 31 },
			};

			static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
			{
				/* best for CfP extra smooth */
				{ 23, 82, 21, 2 },
				{ 21, 82, 23, 2 },
				{ 19, 82, 25, 2 },
				{ 18, 81, 27, 2 },
				{ 16, 80, 30, 2 },
				{ 15, 79, 32, 2 },
				{ 13, 78, 35, 2 },
				{ 12, 77, 37, 2 },
				{ 11, 75, 40, 2 },
				{ 10, 74, 42, 2 },
				{ 9, 72, 45, 2 },
				{ 8, 70, 47, 3 },
				{ 7, 68, 50, 3 },
				{ 6, 67, 52, 3 },
				{ 6, 64, 54, 4 },
				{ 5, 62, 57, 4 },
				{ 4, 60, 60, 4 },
				{ 4, 57, 62, 5 },
				{ 4, 54, 64, 6 },
				{ 3, 52, 67, 6 },
				{ 3, 50, 68, 7 },
				{ 3, 47, 70, 8 },
				{ 2, 45, 72, 9 },
				{ 2, 42, 74, 10 },
				{ 2, 40, 75, 11 },
				{ 2, 37, 77, 12 },
				{ 2, 35, 78, 13 },
				{ 2, 32, 79, 15 },
				{ 2, 30, 80, 16 },
				{ 2, 27, 81, 18 },
				{ 2, 25, 82, 19 },
				{ 2, 23, 82, 21 },
			};

			static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
			{
				// semi-sharp
				{ 11, 106, 12, -1 },
				{ 9, 105, 15, -1 },
				{ 7, 105, 18, -2 },
				{ 6, 103, 21, -2 },
				{ 4, 102, 25, -3 },
				{ 2, 100, 29, -3 },
				{ 1, 99, 32, -4 },
				{ 0, 96, 36, -4 },
				{ -1, 94, 39, -4 },
				{ -2, 92, 43, -5 },
				{ -3, 89, 47, -5 },
				{ -4, 86, 51, -5 },
				{ -4, 83, 55, -6 },
				{ -5, 80, 59, -6 },
				{ -5, 77, 62, -6 },
				{ -6, 74, 66, -6 },
				{ -6, 70, 70, -6 },
				{ -6, 66, 74, -6 },
				{ -6, 62, 77, -5 },
				{ -6, 59, 80, -5 },
				{ -6, 55, 83, -4 },
				{ -5, 51, 86, -4 },
				{ -5, 47, 89, -3 },
				{ -5, 43, 92, -2 },
				{ -4, 39, 94, -1 },
				{ -4, 36, 96, 0 },
				{ -4, 32, 99, 1 },
				{ -3, 29, 100, 2 },
				{ -3, 25, 102, 4 },
				{ -2, 21, 103, 6 },
				{ -2, 18, 105, 7 },
				{ -1, 15, 105, 9 },
			};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[8][2] = { { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };
//#pragma HLS array_partition variable = orgY_32x32 cyclic factor=256 dim=1
#pragma HLS array_partition variable = pred_cache_32x32  complete dim=2
#pragma HLS array_partition variable = pred_cache_32x32  cyclic factor=8 dim=1
//#pragma HLS array_partition variable = coef_tmp_32x32  complete dim=2
//#pragma HLS array_partition variable = coef_tmp_32x32 cyclic factor=8 dim=1
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
#pragma HLS array_partition variable = ipred_dxdy complete dim=0
	int i, j, t_dya, offseta;
	int pa, pna, pn_n1a, pn_p2a, pos_maxa;
	int ya = 2147483647;
	int t_dyb, offsetb;
	int pb, pnb, pn_n1b, pn_p2b, pos_maxb;
	int yb = 2147483647;
	int t_dyc, offsetc;
	int pc, pnc, pn_n1c, pn_p2c, pos_maxc;
	int yc = 2147483647;
	int t_dyd, offsetd;
	int pd, pnd, pn_n1d, pn_p2d, pos_maxd;
	int yd = 2147483647;
	//#pragma HLS PIPELINE
	for (j = 0; j < 32; j = j + 4)
		//for (j = 0; j < 32; j=j+1)
	{
		//#pragma HLS loop_tripcount max = 32
#pragma HLS PIPELINE
		for (i = 0; i < 32; i++)
		{
			//#pragma HLS UNROLL
			if (i < w)
			{
				/**************************** 1 ****************************/
				t_dya = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
				offseta = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dya << 5);
				ya = j + t_dya;
				pn_n1a = ya - 1;
				pa = ya;
				pna = ya + 1;
				pn_p2a = ya + 2;
				pos_maxa = h * 2 - 1;

				pn_n1a = (pn_n1a < pos_maxa ? pn_n1a : pos_maxa);
				pa = (pa < pos_maxa ? pa : pos_maxa);
				pna = (pna < pos_maxa ? pna : pos_maxa);
				pn_p2a = (pn_p2a < pos_maxa ? pn_p2a : pos_maxa);

#if MIPF									
				filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offseta)[0];
				//temp_pel = (pel)((src_le[pn_n1a + 3] * filter[0] + src_le[pa + 3] * filter[1] +
				//	src_le[pna + 3] * filter[2] + src_le[pn_p2a + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_le[pn_n1a + 3] * com_tbl_ipred_adi_extra_smooth[offseta][0] + src_le[pa + 3] * com_tbl_ipred_adi_extra_smooth[offseta][1] +
						src_le[pna + 3] * com_tbl_ipred_adi_extra_smooth[offseta][2] + src_le[pn_p2a + 3] * com_tbl_ipred_adi_extra_smooth[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_le[pn_n1a + 3] * com_tbl_ipred_adi_semi_sharp[offseta][0] + src_le[pa + 3] * com_tbl_ipred_adi_semi_sharp[offseta][1] +
						src_le[pna + 3] * com_tbl_ipred_adi_semi_sharp[offseta][2] + src_le[pn_p2a + 3] * com_tbl_ipred_adi_semi_sharp[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_le[pn_n1a + 3] * tbl_mc_c_coeff_hp[offseta][0] + src_le[pa + 3] * tbl_mc_c_coeff_hp[offseta][1] +
						src_le[pna + 3] * tbl_mc_c_coeff_hp[offseta][2] + src_le[pn_p2a + 3] * tbl_mc_c_coeff_hp[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_le[pn_n1a + 3] * com_tbl_ipred_adi_bilinear[offseta][0] + src_le[pa + 3] * com_tbl_ipred_adi_bilinear[offseta][1] +
						src_le[pna + 3] * com_tbl_ipred_adi_bilinear[offseta][2] + src_le[pn_p2a + 3] * com_tbl_ipred_adi_bilinear[offseta][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j][i] = temp_pel;
				//coef_tmp_32x32[j][i] = orgY_32x32[j][i] - pred_cache_32x32[j][i];

#else

				pred_cache_32x32[j][i] = ((src_le[pn_n1a + 3]) * (32 - offseta) + (src_le[pa + 3]) * (64 - offseta) + (src_le[pna + 3]) * (32 + offseta) + (src_le[pn_p2a + 3]) * offseta + 64) >> 7;
				//coef_tmp_32x32[j][i] = orgY_32x32[j][i] - pred_cache_32x32[j][i];
#endif




				/**************************** 2 ****************************/
				t_dyb = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
				offsetb = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dyb << 5);
				yb = (j + 1) + t_dyb;
				pn_n1b = yb - 1;
				pb = yb;
				pnb = yb + 1;
				pn_p2b = yb + 2;
				pos_maxb = h * 2 - 1;

				pn_n1b = (pn_n1b < pos_maxb ? pn_n1b : pos_maxb);
				pb = (pb < pos_maxb ? pb : pos_maxb);
				pnb = (pnb < pos_maxb ? pnb : pos_maxb);
				pn_p2b = (pn_p2b < pos_maxb ? pn_p2b : pos_maxb);

#if MIPF									
				filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offsetb)[0];
				//temp_pel = (pel)((src_le[pn_n1b + 3] * filter[0] + src_le[pb + 3] * filter[1] +
				//	src_le[pnb + 3] * filter[2] + src_le[pn_p2b + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_le[pn_n1b + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][0] + src_le[pb + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][1] +
						src_le[pnb + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][2] + src_le[pn_p2b + 3] * com_tbl_ipred_adi_extra_smooth[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_le[pn_n1b + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][0] + src_le[pb + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][1] +
						src_le[pnb + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][2] + src_le[pn_p2b + 3] * com_tbl_ipred_adi_semi_sharp[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_le[pn_n1b + 3] * tbl_mc_c_coeff_hp[offsetb][0] + src_le[pb + 3] * tbl_mc_c_coeff_hp[offsetb][1] +
						src_le[pnb + 3] * tbl_mc_c_coeff_hp[offsetb][2] + src_le[pn_p2b + 3] * tbl_mc_c_coeff_hp[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_le[pn_n1b + 3] * com_tbl_ipred_adi_bilinear[offsetb][0] + src_le[pb + 3] * com_tbl_ipred_adi_bilinear[offsetb][1] +
						src_le[pnb + 3] * com_tbl_ipred_adi_bilinear[offsetb][2] + src_le[pn_p2b + 3] * com_tbl_ipred_adi_bilinear[offsetb][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j + 1][i] = temp_pel;
				//coef_tmp_32x32[j + 1][i] = orgY_32x32[j + 1][i] - pred_cache_32x32[j + 1][i];

#else

				pred_cache_32x32[j + 1][i] = ((src_le[pn_n1b + 3]) * (32 - offsetb) + (src_le[pb + 3]) * (64 - offsetb) + (src_le[pnb + 3]) * (32 + offsetb) + (src_le[pn_p2b + 3]) * offsetb + 64) >> 7;
				//coef_tmp_32x32[j + 1][i] = orgY_32x32[j + 1][i] - pred_cache_32x32[j + 1][i];
#endif



				/**************************** 3 ****************************/
				t_dyc = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
				offsetc = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dyc << 5);
				yc = (j + 2) + t_dyc;
				pn_n1c = yc - 1;
				pc = yc;
				pnc = yc + 1;
				pn_p2c = yc + 2;
				pos_maxc = h * 2 - 1;

				pn_n1c = (pn_n1c < pos_maxc ? pn_n1c : pos_maxc);
				pc = (pc < pos_maxc ? pc : pos_maxc);
				pnc = (pnc < pos_maxc ? pnc : pos_maxc);
				pn_p2c = (pn_p2c < pos_maxc ? pn_p2c : pos_maxc);

#if MIPF									
				filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offsetc)[0];
				//temp_pel = (pel)((src_le[pn_n1c + 3] * filter[0] + src_le[pc + 3] * filter[1] +
				//	src_le[pnc + 3] * filter[2] + src_le[pn_p2c + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_le[pn_n1c + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][0] + src_le[pc + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][1] +
						src_le[pnc + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][2] + src_le[pn_p2c + 3] * com_tbl_ipred_adi_extra_smooth[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_le[pn_n1c + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][0] + src_le[pc + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][1] +
						src_le[pnc + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][2] + src_le[pn_p2c + 3] * com_tbl_ipred_adi_semi_sharp[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_le[pn_n1c + 3] * tbl_mc_c_coeff_hp[offsetc][0] + src_le[pc + 3] * tbl_mc_c_coeff_hp[offsetc][1] +
						src_le[pnc + 3] * tbl_mc_c_coeff_hp[offsetc][2] + src_le[pn_p2c + 3] * tbl_mc_c_coeff_hp[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_le[pn_n1c + 3] * com_tbl_ipred_adi_bilinear[offsetc][0] + src_le[pc + 3] * com_tbl_ipred_adi_bilinear[offsetc][1] +
						src_le[pnc + 3] * com_tbl_ipred_adi_bilinear[offsetc][2] + src_le[pn_p2c + 3] * com_tbl_ipred_adi_bilinear[offsetc][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j + 2][i] = temp_pel;
				//coef_tmp_32x32[j + 2][i] = orgY_32x32[j + 2][i] - pred_cache_32x32[j + 2][i];

#else
				pred_cache_32x32[j + 2][i] = ((src_le[pn_n1c + 3]) * (32 - offsetc) + (src_le[pc + 3]) * (64 - offsetc) + (src_le[pnc + 3]) * (32 + offsetc) + (src_le[pn_p2c + 3]) * offsetc + 64) >> 7;
				//coef_tmp_32x32[j + 2][i] = orgY_32x32[j + 2][i] - pred_cache_32x32[j + 2][i];
#endif




				/**************************** 4 ****************************/
				t_dyd = (i + 1) * ipred_dxdy[ipm - 25][1] >> 10;
				offsetd = ((i + 1) * ipred_dxdy[ipm - 25][1] >> 5) - (t_dyd << 5);
				yd = (j + 3) + t_dyd;
				pn_n1d = yd - 1;
				pd = yd;
				pnd = yd + 1;
				pn_p2d = yd + 2;
				pos_maxd = h * 2 - 1;

				pn_n1d = (pn_n1d < pos_maxd ? pn_n1d : pos_maxd);
				pd = (pd < pos_maxd ? pd : pos_maxd);
				pnd = (pnd < pos_maxd ? pnd : pos_maxd);
				pn_p2d = (pn_p2d < pos_maxd ? pn_p2d : pos_maxd);

#if MIPF									
				filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
				//filter = (tbl_filt_list[filter_idx] + offsetd)[0];
				//temp_pel = (pel)((src_le[pn_n1d + 3] * filter[0] + src_le[pd + 3] * filter[1] +
				//	src_le[pnd + 3] * filter[2] + src_le[pn_p2d + 3] * filter[3] +
				//	filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1

				if (filter_idx == 0)
					temp_pel = (pel)((src_le[pn_n1d + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][0] + src_le[pd + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][1] +
						src_le[pnd + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][2] + src_le[pn_p2d + 3] * com_tbl_ipred_adi_extra_smooth[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 1)
					temp_pel = (pel)((src_le[pn_n1d + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][0] + src_le[pd + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][1] +
						src_le[pnd + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][2] + src_le[pn_p2d + 3] * com_tbl_ipred_adi_semi_sharp[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 2)
					temp_pel = (pel)((src_le[pn_n1d + 3] * tbl_mc_c_coeff_hp[offsetd][0] + src_le[pd + 3] * tbl_mc_c_coeff_hp[offsetd][1] +
						src_le[pnd + 3] * tbl_mc_c_coeff_hp[offsetd][2] + src_le[pn_p2d + 3] * tbl_mc_c_coeff_hp[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				else if (filter_idx == 3)
					temp_pel = (pel)((src_le[pn_n1d + 3] * com_tbl_ipred_adi_bilinear[offsetd][0] + src_le[pd + 3] * com_tbl_ipred_adi_bilinear[offsetd][1] +
						src_le[pnd + 3] * com_tbl_ipred_adi_bilinear[offsetd][2] + src_le[pn_p2d + 3] * com_tbl_ipred_adi_bilinear[offsetd][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]); // x == -1
				temp_pel = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pel);
				pred_cache_32x32[j + 3][i] = temp_pel;
				//coef_tmp_32x32[j + 3][i] = orgY_32x32[j + 3][i] - pred_cache_32x32[j + 3][i];

#else

				pred_cache_32x32[j + 3][i] = ((src_le[pn_n1d + 3]) * (32 - offsetd) + (src_le[pd + 3]) * (64 - offsetd) + (src_le[pnd + 3]) * (32 + offsetd) + (src_le[pn_p2d + 3]) * offsetd + 64) >> 7;
				//coef_tmp_32x32[j + 3][i] = orgY_32x32[j + 3][i] - pred_cache_32x32[j + 3][i];
#endif


			}
		}
	}
}
void ipred_ang3_32_pred(U8 w, U8 h, pel src_le[32 * 2 + 3], pel src_up[32 * 2 + 3], U4 bit_depth, int ipm, s16 pred_cache_32x32[32][32]
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#endif
#if MIPF
	//const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
	//const s16* filter;
	//pel temp_pel = (pel)0;
#endif

	static const int ipred_dxdy[11][2] = { { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) } };
	int i, j;
	int offseta, offset_xa, offset_ya, xxa, yya, t_dxa, t_dya;
	int pa, pna, pn_n1a, pn_p2a, pos_maxa;
	pel temp_pela = 0;
	int offsetb, offset_xb, offset_yb, xxb, yyb, t_dxb, t_dyb;
	int pb, pnb, pn_n1b, pn_p2b, pos_maxb;
	pel temp_pelb = 0;
	int offsetc, offset_xc, offset_yc, xxc, yyc, t_dxc, t_dyc;
	int pc, pnc, pn_n1c, pn_p2c, pos_maxc;
	pel temp_pelc = 0;
	int offsetd, offset_xd, offset_yd, xxd, yyd, t_dxd, t_dyd;
	int pd, pnd, pn_n1d, pn_p2d, pos_maxd;
	pel temp_peld = 0;

	int xy = -1, yx = -1;
	int xa, xb, ya, yb, xc, yc, xd, yd;
	//#pragma HLS array_partition variable = orgY_32x32 cyclic factor=256 dim=1
#pragma HLS array_partition variable = pred_cache_32x32  complete dim=2
#pragma HLS array_partition variable = pred_cache_32x32  cyclic factor=8 dim=1
//#pragma HLS array_partition variable = coef_tmp_32x32  complete dim=2
//#pragma HLS array_partition variable = coef_tmp_32x32 cyclic factor=8 dim=1
#pragma HLS array_partition variable = src_le complete dim=0
#pragma HLS array_partition variable = src_up complete dim=0
#pragma HLS array_partition variable = com_tbl_log2 complete dim=0
#pragma HLS array_partition variable = ipred_dxdy complete dim=0
	for (j = 0; j < 32; j = j + 4)
	{
		//#pragma HLS loop_tripcount max = 32
#pragma HLS PIPELINE
		for (i = 0; i < 32; i++)
		{
#pragma HLS UNROLL
			if (i < w)
			{
				/**************************** 1 ****************************/
				{
					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					}
					t_dxa = (j + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_xa = ((j + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dxa << 5);
					t_dxa = -t_dxa;
					xxa = i + t_dxa;
					t_dya = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_ya = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dya << 5);
					t_dya = -t_dya;
					yya = j + t_dya;

					if (yya <= -1) {
						offseta = offset_xa;
						xa = xxa;
						ya = yx;
					}
					else {
						offseta = offset_ya;
						ya = yya;
						xa = xy;
					}
					if (ya == -1) {
						pn_n1a = xa + 1;
						pa = xa;
						pna = xa - 1;
						pn_p2a = xa - 2;
						pos_maxa = w * 2 - 1;
					}
					else {
						pn_n1a = ya + 1;
						pa = ya;
						pna = ya - 1;
						pn_p2a = ya - 2;
						pos_maxa = h * 2 - 1;
					}

					pn_n1a += 3;
					pa += 3;
					pna += 3;
					pn_p2a += 3;

					int src_pa, src_pna, src_pn_n1a, src_pn_p2a;

					if (ya == -1) {
						src_pn_n1a = src_up[pn_n1a];
						src_pa = src_up[pa];
						src_pna = src_up[pna];
						src_pn_p2a = src_up[pn_p2a];
					}
					else if (xa == -1) {
						src_pn_n1a = src_le[pn_n1a];
						src_pa = src_le[pa];
						src_pna = src_le[pna];
						src_pn_p2a = src_le[pn_p2a];
					}
					else {
						src_pn_n1a = 0;
						src_pa = 0;
						src_pna = 0;
						src_pn_p2a = 0;
					}

#if MIPF
					//filter = (tbl_filt_list[filter_idx] + offseta)[0];
					/*temp_pela = (pel)((src_up[pn_n1a + 3] * filter[0] + src_up[pa + 3] * filter[1] +
						src_up[pna + 3] * filter[2] + src_up[pn_p2a + 3] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

					if (filter_idx == 0)
						temp_pela = (pel)((src_pn_n1a * com_tbl_ipred_adi_extra_smooth[offseta][0] + src_pa * com_tbl_ipred_adi_extra_smooth[offseta][1] +
							src_pna * com_tbl_ipred_adi_extra_smooth[offseta][2] + src_pn_p2a * com_tbl_ipred_adi_extra_smooth[offseta][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 1)
						temp_pela = (pel)((src_pn_n1a * com_tbl_ipred_adi_semi_sharp[offseta][0] + src_pa * com_tbl_ipred_adi_semi_sharp[offseta][1] +
							src_pna * com_tbl_ipred_adi_semi_sharp[offseta][2] + src_pn_p2a * com_tbl_ipred_adi_semi_sharp[offseta][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 2)
						temp_pela = (pel)((src_pn_n1a * tbl_mc_c_coeff_hp[offseta][0] + src_pa * tbl_mc_c_coeff_hp[offseta][1] +
							src_pna * tbl_mc_c_coeff_hp[offseta][2] + src_pn_p2a * tbl_mc_c_coeff_hp[offseta][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 3)
						temp_pela = (pel)((src_pn_n1a * com_tbl_ipred_adi_bilinear[offseta][0] + src_pa * com_tbl_ipred_adi_bilinear[offseta][1] +
							src_pna * com_tbl_ipred_adi_bilinear[offseta][2] + src_pn_p2a * com_tbl_ipred_adi_bilinear[offseta][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF

					temp_pela = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pela);
#else
					temp_pela = ((src_up[pn_n1a + 3]) * (32 - offseta) + (src_up[pa + 3]) * (64 - offseta) + ((
						int)src_up[pna + 3]) * (32 + offseta) + (src_up[pn_p2a + 3]) * offseta + 64) >> 7;
#endif					

					pred_cache_32x32[j][i] = temp_pela;
					//coef_tmp_32x32[j][i] = orgY_32x32[j][i] - pred_cache_32x32[j][i];
				}

				/**************************** 2 ****************************/
				{
					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? ((j + 1) < td ? is_small + 1 : is_small) : 3;
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					}
					t_dxb = (j + 1 + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_xb = ((j + 1 + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dxb << 5);
					t_dxb = -t_dxb;
					xxb = i + t_dxb;
					t_dyb = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_yb = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dyb << 5);
					t_dyb = -t_dyb;
					yyb = j + 1 + t_dyb;

					if (yyb <= -1) {
						offsetb = offset_xb;
						xb = xxb;
						yb = yx;
					}
					else {
						offsetb = offset_yb;
						yb = yyb;
						xb = xy;
					}
					if (yb == -1) {
						pn_n1b = xb + 1;
						pb = xb;
						pnb = xb - 1;
						pn_p2b = xb - 2;
						pos_maxb = w * 2 - 1;
					}
					else {
						pn_n1b = yb + 1;
						pb = yb;
						pnb = yb - 1;
						pn_p2b = yb - 2;
						pos_maxb = h * 2 - 1;
					}

					pn_n1b += 3;
					pb += 3;
					pnb += 3;
					pn_p2b += 3;

					int src_pb, src_pnb, src_pn_n1b, src_pn_p2b;

					if (yb == -1) {
						src_pn_n1b = src_up[pn_n1b];
						src_pb = src_up[pb];
						src_pnb = src_up[pnb];
						src_pn_p2b = src_up[pn_p2b];
					}
					else if (xb == -1) {
						src_pn_n1b = src_le[pn_n1b];
						src_pb = src_le[pb];
						src_pnb = src_le[pnb];
						src_pn_p2b = src_le[pn_p2b];
					}
					else {
						src_pn_n1b = 0;
						src_pb = 0;
						src_pnb = 0;
						src_pn_p2b = 0;
					}
#if MIPF

					/*filter = (tbl_filt_list[filter_idx] + offsetb)[0];
					temp_pelb = (pel)((src_up[pn_n1b + 3] * filter[0] + src_up[pb + 3] * filter[1] +
						src_up[pnb + 3] * filter[2] + src_up[pn_p2b + 3] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

					if (filter_idx == 0)
						temp_pelb = (pel)((src_pn_n1b * com_tbl_ipred_adi_extra_smooth[offsetb][0] + src_pb * com_tbl_ipred_adi_extra_smooth[offsetb][1] +
							src_pnb * com_tbl_ipred_adi_extra_smooth[offsetb][2] + src_pn_p2b * com_tbl_ipred_adi_extra_smooth[offsetb][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 1)
						temp_pelb = (pel)((src_pn_n1b * com_tbl_ipred_adi_semi_sharp[offsetb][0] + src_pb * com_tbl_ipred_adi_semi_sharp[offsetb][1] +
							src_pnb * com_tbl_ipred_adi_semi_sharp[offsetb][2] + src_pn_p2b * com_tbl_ipred_adi_semi_sharp[offsetb][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 2)
						temp_pelb = (pel)((src_pn_n1b * tbl_mc_c_coeff_hp[offsetb][0] + src_pb * tbl_mc_c_coeff_hp[offsetb][1] +
							src_pnb * tbl_mc_c_coeff_hp[offsetb][2] + src_pn_p2b * tbl_mc_c_coeff_hp[offsetb][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 3)
						temp_pelb = (pel)((src_pn_n1b * com_tbl_ipred_adi_bilinear[offsetb][0] + src_pb * com_tbl_ipred_adi_bilinear[offsetb][1] +
							src_pnb * com_tbl_ipred_adi_bilinear[offsetb][2] + src_pn_p2b * com_tbl_ipred_adi_bilinear[offsetb][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF

					temp_pelb = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pelb);
#else
					temp_pelb = ((src_up[pn_n1b + 3]) * (32 - offsetb) + (src_up[pb + 3]) * (64 - offsetb) + ((
						int)src_up[pnb + 3]) * (32 + offsetb) + (src_up[pn_p2b + 3]) * offsetb + 64) >> 7;
#endif
					pred_cache_32x32[j + 1][i] = temp_pelb;
					//coef_tmp_32x32[j + 1][i] = orgY_32x32[j + 1][i] - pred_cache_32x32[j + 1][i];
				}

				/**************************** 3 ****************************/
				{
					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? ((j + 1) < td ? is_small + 1 : is_small) : 3;
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					}
					t_dxc = (j + 2 + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_xc = ((j + 2 + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dxc << 5);
					t_dxc = -t_dxc;
					xxc = i + t_dxc;
					t_dyc = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_yc = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dyc << 5);
					t_dyc = -t_dyc;
					yyc = j + 2 + t_dyc;

					if (yyc <= -1) {
						offsetc = offset_xc;
						xc = xxc;
						yc = yx;
					}
					else {
						offsetc = offset_yc;
						yc = yyc;
						xc = xy;
					}
					if (yc == -1) {
						pn_n1c = xc + 1;
						pc = xc;
						pnc = xc - 1;
						pn_p2c = xc - 2;
						pos_maxc = w * 2 - 1;
					}
					else {
						pn_n1c = yc + 1;
						pc = yc;
						pnc = yc - 1;
						pn_p2c = yc - 2;
						pos_maxc = h * 2 - 1;
					}

					pn_n1c += 3;
					pc += 3;
					pnc += 3;
					pn_p2c += 3;

					int src_pc, src_pnc, src_pn_n1c, src_pn_p2c;

					if (yc == -1) {
						src_pn_n1c = src_up[pn_n1c];
						src_pc = src_up[pc];
						src_pnc = src_up[pnc];
						src_pn_p2c = src_up[pn_p2c];
					}
					else if (xc == -1) {
						src_pn_n1c = src_le[pn_n1c];
						src_pc = src_le[pc];
						src_pnc = src_le[pnc];
						src_pn_p2c = src_le[pn_p2c];
					}
					else {
						src_pn_n1c = 0;
						src_pc = 0;
						src_pnc = 0;
						src_pn_p2c = 0;
					}
#if MIPF

					/*filter = (tbl_filt_list[filter_idx] + offsetb)[0];
					temp_pelb = (pel)((src_up[pn_n1b + 3] * filter[0] + src_up[pb + 3] * filter[1] +
						src_up[pnb + 3] * filter[2] + src_up[pn_p2b + 3] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

					if (filter_idx == 0)
						temp_pelc = (pel)((src_pn_n1c * com_tbl_ipred_adi_extra_smooth[offsetc][0] + src_pc * com_tbl_ipred_adi_extra_smooth[offsetc][1] +
							src_pnc * com_tbl_ipred_adi_extra_smooth[offsetc][2] + src_pn_p2c * com_tbl_ipred_adi_extra_smooth[offsetc][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 1)
						temp_pelc = (pel)((src_pn_n1c * com_tbl_ipred_adi_semi_sharp[offsetc][0] + src_pc * com_tbl_ipred_adi_semi_sharp[offsetc][1] +
							src_pnc * com_tbl_ipred_adi_semi_sharp[offsetc][2] + src_pn_p2c * com_tbl_ipred_adi_semi_sharp[offsetc][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 2)
						temp_pelc = (pel)((src_pn_n1c * tbl_mc_c_coeff_hp[offsetc][0] + src_pc * tbl_mc_c_coeff_hp[offsetc][1] +
							src_pnc * tbl_mc_c_coeff_hp[offsetc][2] + src_pn_p2c * tbl_mc_c_coeff_hp[offsetc][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 3)
						temp_pelc = (pel)((src_pn_n1c * com_tbl_ipred_adi_bilinear[offsetc][0] + src_pc * com_tbl_ipred_adi_bilinear[offsetc][1] +
							src_pnc * com_tbl_ipred_adi_bilinear[offsetc][2] + src_pn_p2c * com_tbl_ipred_adi_bilinear[offsetc][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF

					temp_pelc = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_pelc);
#else
					temp_pelc = ((src_up[pn_n1c + 3]) * (32 - offsetc) + (src_up[pc + 3]) * (64 - offsetc) + ((
						int)src_up[pnc + 3]) * (32 + offsetc) + (src_up[pn_p2c + 3]) * offsetc + 64) >> 7;
#endif
					pred_cache_32x32[j + 2][i] = temp_pelc;
					//coef_tmp_32x32[j + 2][i] = orgY_32x32[j + 2][i] - pred_cache_32x32[j + 2][i];
					}

				/**************************** 4 ****************************/
				{
					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? ((j + 3) < td ? is_small + 1 : is_small) : 3;
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					}
					t_dxd = (j + 3 + 1) * ipred_dxdy[ipm - 13][0] >> 10;
					offset_xd = ((j + 3 + 1) * ipred_dxdy[ipm - 13][0] >> 5) - (t_dxd << 5);
					t_dxd = -t_dxd;
					xxd = i + t_dxd;
					t_dyd = (i + 1) * ipred_dxdy[ipm - 13][1] >> 10;
					offset_yd = ((i + 1) * ipred_dxdy[ipm - 13][1] >> 5) - (t_dyd << 5);
					t_dyd = -t_dyd;
					yyd = j + 3 + t_dyd;

					if (yyd <= -1) {
						offsetd = offset_xd;
						xd = xxd;
						yd = yx;
					}
					else {
						offsetd = offset_yd;
						yd = yyd;
						xd = xy;
					}
					if (yd == -1) {
						pn_n1d = xd + 1;
						pd = xd;
						pnd = xd - 1;
						pn_p2d = xd - 2;
						pos_maxd = w * 2 - 1;
					}
					else {
						pn_n1d = yd + 1;
						pd = yd;
						pnd = yd - 1;
						pn_p2d = yd - 2;
						pos_maxd = h * 2 - 1;
					}

					pn_n1d += 3;
					pd += 3;
					pnd += 3;
					pn_p2d += 3;

					int src_pd, src_pnd, src_pn_n1d, src_pn_p2d;

					if (yd == -1) {
						src_pn_n1d = src_up[pn_n1d];
						src_pd = src_up[pd];
						src_pnd = src_up[pnd];
						src_pn_p2d = src_up[pn_p2d];
					}
					else if (xd == -1) {
						src_pn_n1d = src_le[pn_n1d];
						src_pd = src_le[pd];
						src_pnd = src_le[pnd];
						src_pn_p2d = src_le[pn_p2d];
					}
					else {
						src_pn_n1d = 0;
						src_pd = 0;
						src_pnd = 0;
						src_pn_p2d = 0;
					}
#if MIPF

					/*filter = (tbl_filt_list[filter_idx] + offsetb)[0];
					temp_pelb = (pel)((src_up[pn_n1b + 3] * filter[0] + src_up[pb + 3] * filter[1] +
						src_up[pnb + 3] * filter[2] + src_up[pn_p2b + 3] * filter[3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);*/

					if (filter_idx == 0)
						temp_peld = (pel)((src_pn_n1d * com_tbl_ipred_adi_extra_smooth[offsetd][0] + src_pd * com_tbl_ipred_adi_extra_smooth[offsetd][1] +
							src_pnd * com_tbl_ipred_adi_extra_smooth[offsetd][2] + src_pn_p2d * com_tbl_ipred_adi_extra_smooth[offsetd][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 1)
						temp_peld = (pel)((src_pn_n1d * com_tbl_ipred_adi_semi_sharp[offsetd][0] + src_pd * com_tbl_ipred_adi_semi_sharp[offsetd][1] +
							src_pnd * com_tbl_ipred_adi_semi_sharp[offsetd][2] + src_pn_p2d * com_tbl_ipred_adi_semi_sharp[offsetd][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 2)
						temp_peld = (pel)((src_pn_n1d * tbl_mc_c_coeff_hp[offsetd][0] + src_pd * tbl_mc_c_coeff_hp[offsetd][1] +
							src_pnd * tbl_mc_c_coeff_hp[offsetd][2] + src_pn_p2d * tbl_mc_c_coeff_hp[offsetd][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
					else if (filter_idx == 3)
						temp_peld = (pel)((src_pn_n1d * com_tbl_ipred_adi_bilinear[offsetd][0] + src_pd * com_tbl_ipred_adi_bilinear[offsetd][1] +
							src_pnd * com_tbl_ipred_adi_bilinear[offsetd][2] + src_pn_p2d * com_tbl_ipred_adi_bilinear[offsetd][3] +
							filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF

					temp_peld = COM_CLIP3(0, ((1 << bit_depth) - 1), temp_peld);

#else					
					temp_peld = ((src_le[pn_n1d + 3]) * (32 - offsetd) + (src_le[pd + 3]) * (64 - offsetd) + (src_le[pnd + 3]) * (32 + offsetd) + (src_le[pn_p2d + 3]) * offsetd + 64) >> 7;

#endif
					pred_cache_32x32[j + 3][i] = temp_peld;
					//coef_tmp_32x32[j + 3][i] = orgY_32x32[j + 3][i] - pred_cache_32x32[j + 3][i];
				}
				}

			}

		}
	}
#endif

void com_mc_l_00_32(pel* ref, int gmv_x, int gmv_y, int s_ref, int s_pred, pel pred[32][32], U7 w_l, U7 h_u, U7 w, U7 h, int bHpFilter)
{
	int i;
	int j;
	int offset_ref = 0;
	int offset_pred = 0;
	if (bHpFilter) {
		gmv_x >>= 4;
		gmv_y >>= 4;
	}
	else {
		gmv_x >>= 2;
		gmv_y >>= 2;
	}
	offset_ref += gmv_y * s_ref + gmv_x;
	{
		for (i = 0; i < 32; i++) {
			if (i < h)
			{
				for (j = 0; j < 32; j++) {
					if (j < w)
						pred[i + h_u][j + w_l] = ref[j + offset_ref];
				}
				offset_pred += s_pred;
				offset_ref += s_ref;
			}

		}
	}
}

static void inter_hor_32(S32 hor_buf[8][32], int dx, pel refwin[8][40], int add1, int shift1)
{
	static S8 tbl_mc_l_coeff[4][8] =
	{
		{ 0, 0, 0, 64, 0, 0, 0, 0 },
		{ -1, 4, -10, 57, 19, -7, 3, -1 },
		{ -1, 4, -11, 40, 40, -11, 4, -1 },
		{ -1, 3, -7, 19, 57, -10, 4, -1 }
	};

	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 32; j++)
		{
			hor_buf[i][j] = (MAC_8TAP(tbl_mc_l_coeff[dx], refwin[i], j) + add1) >> shift1;
		}
	}
}


//////////////////////trans&quant
static void dct_row_Chroma32(U8 cu_width, U8 cu_height, s16 src[32][32], s16 dst[32][32], U4 shift)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst complete dim=2
	U7 size = 32;
	U8 size_b = size - 1;

	int j, k;
	S16 E[16], O[16];
	S16 EE[8], EO[8];
	S16 EEE[4], EEO[4];
	S16 EEEE[2], EEEO[2];
	S16 tmp[32];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEE complete dim=1

#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEO complete dim=1

#pragma HLS ARRAY_PARTITION variable=tmp complete dim=1
	int add;
	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 32; j++)
	{
#pragma HLS PIPELINE ii=1
		if (j < cu_height) {
		for (k = 0; k < 16; k++)
		{
				E[k] = src[j][k] + src[j][31 - k];
				O[k] = src[j][k] - src[j][31 - k];
		}
		/* EE and EO */
		if (cu_width == 32) {
			for (k = 0; k < 8; k++)
			{
					EE[k] = E[k] + E[15 - k];
					EO[k] = E[k] - E[15 - k];
			}
		}
		else if (cu_width == 16) {
			for (k = 0; k < 8; k++)
			{
					EE[k] = src[j][k] + src[j][15 - k];
					EO[k] = src[j][k] - src[j][15 - k];
			}
		}
		/* EEE and EEO */
		if (cu_width == 32 || cu_width == 16) {
			for (k = 0; k < 4; k++)
			{
					EEE[k] = EE[k] + EE[7 - k];
					EEO[k] = EE[k] - EE[7 - k];
			}
		}
		else if (cu_width == 8) {
			for (k = 0; k < 4; k++)
			{
					EEE[k] = src[j][k] + src[j][7 - k];
					EEO[k] = src[j][k] - src[j][7 - k];
			}
		}
		/* EEEE and EEEO */
		if (cu_width == 32 || cu_width == 16 || cu_width == 8) {
				EEEE[0] = EEE[0] + EEE[3];
				EEEO[0] = EEE[0] - EEE[3];
				EEEE[1] = EEE[1] + EEE[2];
				EEEO[1] = EEE[1] - EEE[2];
		}
		else if (cu_width == 4) {
				EEEE[0] = src[j][0] + src[j][3];
				EEEO[0] = src[j][0] - src[j][3];
				EEEE[1] = src[j][1] + src[j][2];
				EEEO[1] = src[j][1] - src[j][2];
		}
			tmp[0] = ((32 * EEEE[0] + 32 * EEEE[1] + add) >> shift);
			tmp[1] = ((32 * EEEE[0] - 32 * EEEE[1] + add) >> shift);
			tmp[2] = ((42 * EEEO[0] + 17 * EEEO[1] + add) >> shift);
			tmp[3] = ((17 * EEEO[0] - 42 * EEEO[1] + add) >> shift);
			tmp[4] = (((44) * EEO[0] + (38) * EEO[1] + (25) * EEO[2] + (9) * EEO[3] + add) >> shift);
			tmp[5] = (((38) * EEO[0] + (-9) * EEO[1] + (-44) * EEO[2] + (-25) * EEO[3] + add) >> shift);
			tmp[6] = (((25) * EEO[0] + (-44) * EEO[1] + (9) * EEO[2] + (38) * EEO[3] + add) >> shift);
			tmp[7] = (((9) * EEO[0] + (-25) * EEO[1] + (38) * EEO[2] + (-44) * EEO[3] + add) >> shift);
			tmp[8] = (((45) * EO[0] + (43) * EO[1] + (40) * EO[2] + (35) * EO[3] + (29) * EO[4] + (21) * EO[5] + (13) * EO[6] + (4) * EO[7] + add) >> shift);
			tmp[9] = (((43) * EO[0] + (29) * EO[1] + (4) * EO[2] + (-21) * EO[3] + (-40) * EO[4] + (-45) * EO[5] + (-35) * EO[6] + (-13) * EO[7] + add) >> shift);
			tmp[10] = (((40) * EO[0] + (4) * EO[1] + (-35) * EO[2] + (-43) * EO[3] + (-13) * EO[4] + (29) * EO[5] + (45) * EO[6] + (21) * EO[7] + add) >> shift);
			tmp[11] = (((35) * EO[0] + (-21) * EO[1] + (-43) * EO[2] + (4) * EO[3] + (45) * EO[4] + (13) * EO[5] + (-40) * EO[6] + (-29) * EO[7] + add) >> shift);
			tmp[12] = (((29) * EO[0] + (-40) * EO[1] + (-13) * EO[2] + (45) * EO[3] + (-4) * EO[4] + (-43) * EO[5] + (21) * EO[6] + (35) * EO[7] + add) >> shift);
			tmp[13] = (((21) * EO[0] + (-45) * EO[1] + (29) * EO[2] + (13) * EO[3] + (-43) * EO[4] + (35) * EO[5] + (4) * EO[6] + (-40) * EO[7] + add) >> shift);
			tmp[14] = (((13) * EO[0] + (-35) * EO[1] + (45) * EO[2] + (-40) * EO[3] + (21) * EO[4] + (4) * EO[5] + (-29) * EO[6] + (43) * EO[7] + add) >> shift);
			tmp[15] = (((4) * EO[0] + (-13) * EO[1] + (21) * EO[2] + (-29) * EO[3] + (35) * EO[4] + (-40) * EO[5] + (43) * EO[6] + (-45) * EO[7] + add) >> shift);
			tmp[16] = (((45) * O[0] + (45) * O[1] + (44) * O[2] + (43) * O[3] + (41) * O[4] + (39) * O[5] + (36) * O[6] + (34) * O[7] + (30) * O[8] + (27) * O[9] + (23) * O[10] + (19) * O[11] + (15) * O[12] + (11) * O[13] + (7) * O[14] + (2) * O[15] + add) >> shift);
			tmp[17] = (((45) * O[0] + (41) * O[1] + (34) * O[2] + (23) * O[3] + (11) * O[4] + (-2) * O[5] + (-15) * O[6] + (-27) * O[7] + (-36) * O[8] + (-43) * O[9] + (-45) * O[10] + (-44) * O[11] + (-39) * O[12] + (-30) * O[13] + (-19) * O[14] + (-7) * O[15] + add) >> shift);
			tmp[18] = (((44) * O[0] + (34) * O[1] + (15) * O[2] + (-7) * O[3] + (-27) * O[4] + (-41) * O[5] + (-45) * O[6] + (-39) * O[7] + (-23) * O[8] + (-2) * O[9] + (19) * O[10] + (36) * O[11] + (45) * O[12] + (43) * O[13] + (30) * O[14] + (11) * O[15] + add) >> shift);
			tmp[19] = (((43) * O[0] + (23) * O[1] + (-7) * O[2] + (-34) * O[3] + (-45) * O[4] + (-36) * O[5] + (-11) * O[6] + (19) * O[7] + (41) * O[8] + (44) * O[9] + (27) * O[10] + (-2) * O[11] + (-30) * O[12] + (-45) * O[13] + (-39) * O[14] + (-15) * O[15] + add) >> shift);
			tmp[20] = (((41) * O[0] + (11) * O[1] + (-27) * O[2] + (-45) * O[3] + (-30) * O[4] + (7) * O[5] + (39) * O[6] + (43) * O[7] + (15) * O[8] + (-23) * O[9] + (-45) * O[10] + (-34) * O[11] + (2) * O[12] + (36) * O[13] + (44) * O[14] + (19) * O[15] + add) >> shift);
			tmp[21] = (((39) * O[0] + (-2) * O[1] + (-41) * O[2] + (-36) * O[3] + (7) * O[4] + (43) * O[5] + (34) * O[6] + (-11) * O[7] + (-44) * O[8] + (-30) * O[9] + (15) * O[10] + (45) * O[11] + (27) * O[12] + (-19) * O[13] + (-45) * O[14] + (-23) * O[15] + add) >> shift);
			tmp[22] = (((36) * O[0] + (-15) * O[1] + (-45) * O[2] + (-11) * O[3] + (39) * O[4] + (34) * O[5] + (-19) * O[6] + (-45) * O[7] + (-7) * O[8] + (41) * O[9] + (30) * O[10] + (-23) * O[11] + (-44) * O[12] + (-2) * O[13] + (43) * O[14] + (27) * O[15] + add) >> shift);
			tmp[23] = (((34) * O[0] + (-27) * O[1] + (-39) * O[2] + (19) * O[3] + (43) * O[4] + (-11) * O[5] + (-45) * O[6] + (2) * O[7] + (45) * O[8] + (7) * O[9] + (-44) * O[10] + (-15) * O[11] + (41) * O[12] + (23) * O[13] + (-36) * O[14] + (-30) * O[15] + add) >> shift);
			tmp[24] = (((30) * O[0] + (-36) * O[1] + (-23) * O[2] + (41) * O[3] + (15) * O[4] + (-44) * O[5] + (-7) * O[6] + (45) * O[7] + (-2) * O[8] + (-45) * O[9] + (11) * O[10] + (43) * O[11] + (-19) * O[12] + (-39) * O[13] + (27) * O[14] + (34) * O[15] + add) >> shift);
			tmp[25] = (((27) * O[0] + (-43) * O[1] + (-2) * O[2] + (44) * O[3] + (-23) * O[4] + (-30) * O[5] + (41) * O[6] + (7) * O[7] + (-45) * O[8] + (19) * O[9] + (34) * O[10] + (-39) * O[11] + (-11) * O[12] + (45) * O[13] + (-15) * O[14] + (-36) * O[15] + add) >> shift);
			tmp[26] = (((23) * O[0] + (-45) * O[1] + (19) * O[2] + (27) * O[3] + (-45) * O[4] + (15) * O[5] + (30) * O[6] + (-44) * O[7] + (11) * O[8] + (34) * O[9] + (-43) * O[10] + (7) * O[11] + (36) * O[12] + (-41) * O[13] + (2) * O[14] + (39) * O[15] + add) >> shift);
			tmp[27] = (((19) * O[0] + (-44) * O[1] + (36) * O[2] + (-2) * O[3] + (-34) * O[4] + (45) * O[5] + (-23) * O[6] + (-15) * O[7] + (43) * O[8] + (-39) * O[9] + (7) * O[10] + (30) * O[11] + (-45) * O[12] + (27) * O[13] + (11) * O[14] + (-41) * O[15] + add) >> shift);
			tmp[28] = (((15) * O[0] + (-39) * O[1] + (45) * O[2] + (-30) * O[3] + (2) * O[4] + (27) * O[5] + (-44) * O[6] + (41) * O[7] + (-19) * O[8] + (-11) * O[9] + (36) * O[10] + (-45) * O[11] + (34) * O[12] + (-7) * O[13] + (-23) * O[14] + (43) * O[15] + add) >> shift);
			tmp[29] = (((11) * O[0] + (-30) * O[1] + (43) * O[2] + (-45) * O[3] + (36) * O[4] + (-19) * O[5] + (-2) * O[6] + (23) * O[7] + (-39) * O[8] + (45) * O[9] + (-41) * O[10] + (27) * O[11] + (-7) * O[12] + (-15) * O[13] + (34) * O[14] + (-44) * O[15] + add) >> shift);
			tmp[30] = (((7) * O[0] + (-19) * O[1] + (30) * O[2] + (-39) * O[3] + (44) * O[4] + (-45) * O[5] + (43) * O[6] + (-36) * O[7] + (27) * O[8] + (-15) * O[9] + (2) * O[10] + (11) * O[11] + (-23) * O[12] + (34) * O[13] + (-41) * O[14] + (45) * O[15] + add) >> shift);
			tmp[31] = (((2) * O[0] + (-7) * O[1] + (11) * O[2] + (-15) * O[3] + (19) * O[4] + (-23) * O[5] + (27) * O[6] + (-30) * O[7] + (34) * O[8] + (-36) * O[9] + (39) * O[10] + (-41) * O[11] + (43) * O[12] + (-44) * O[13] + (45) * O[14] + (-45) * O[15] + add) >> shift);

		if (cu_width == 4) {
			if (j == 0)			{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 1)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 2)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 3)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 4)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 5)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 6)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 7)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 8)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 9)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 10)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 11)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 12)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 13)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 14)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 15)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 16)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 17)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 18)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 19)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 20)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 21)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 22)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 23)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 24)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 25)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 26)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 27)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 28)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 29)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 30)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}
			else if (j == 31)	{dst[0][(j + 0) & size_b] = tmp[0];dst[2][(j + 2) & size_b] = tmp[1];dst[1][(j + 1) & size_b] = tmp[2];dst[3][(j + 3) & size_b] = tmp[3];}

		}
		else if (cu_width == 8) {
			if (j == 0)		  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 1)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 2)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 3)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 4)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 5)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 6)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 7)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 8)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 9)  {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 10) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 11) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 12) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 13) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 14) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 15) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 16) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 17) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 18) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 19) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 20) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 21) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 22) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 23) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 24) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 25) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 26) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 27) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 28) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 29) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 30) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
			else if (j == 31) {dst[0][(j + 0) & size_b] = tmp[0];dst[4][(j + 4) & size_b] = tmp[1];dst[2][(j + 2) & size_b] = tmp[2];dst[6][(j + 6) & size_b] = tmp[3];dst[1][(j + 1) & size_b] = tmp[4];dst[3][(j + 3) & size_b] = tmp[5];dst[5][(j + 5) & size_b] = tmp[6];dst[7][(j + 7) & size_b] = tmp[7];
}
		}
		else if (cu_width == 16) {
			if (j == 0)		  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 1)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 2)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 3)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 4)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 5)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 6)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 7)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 8)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 9)  {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 10) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 11) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 12) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 13) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 14) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 15) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 16) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 17) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 18) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 19) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 20) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 21) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 22) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 23) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 24) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 25) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 26) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 27) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 28) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 29) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 30) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
			else if (j == 31) {dst[0][(j + 0) & size_b] = tmp[0];dst[8][(j + 8) & size_b] = tmp[1];dst[4][(j + 4) & size_b] = tmp[2];dst[12][(j + 12) & size_b] = tmp[3];dst[2][(j + 2) & size_b] = tmp[4];dst[6][(j + 6) & size_b] = tmp[5];dst[10][(j + 10) & size_b] = tmp[6];dst[14][(j + 14) & size_b] = tmp[7];dst[1][(j + 1) & size_b] = tmp[8];dst[3][(j + 3) & size_b] = tmp[9];dst[5][(j + 5) & size_b] = tmp[10];dst[7][(j + 7) & size_b] = tmp[11];dst[9][(j + 9) & size_b] = tmp[12];dst[11][(j + 11) & size_b] = tmp[13];dst[13][(j + 13) & size_b] = tmp[14];dst[15][(j + 15) & size_b] = tmp[15];
}
		}
		else if (cu_width == 32) {
		if (j == 0)		  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 1)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 2)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 3)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 4)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 5)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 6)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 7)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 8)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 9)  {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 10) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 11) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 12) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 13) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 14) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 15) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 16) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 17) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 18) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 19) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 20) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 21) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 22) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 23) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 24) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 25) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 26) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 27) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 28) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 29) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 30) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
		else if (j == 31) {dst[0][(j + 0) & size_b] = tmp[0];dst[16][(j + 16) & size_b] = tmp[1];dst[8][(j + 8) & size_b] = tmp[2];dst[24][(j + 24) & size_b] = tmp[3];dst[4][(j + 4) & size_b] = tmp[4];dst[12][(j + 12) & size_b] = tmp[5];dst[20][(j + 20) & size_b] = tmp[6];dst[28][(j + 28) & size_b] = tmp[7];dst[2][(j + 2) & size_b] = tmp[8];dst[6][(j + 6) & size_b] = tmp[9];dst[10][(j + 10) & size_b] = tmp[10];dst[14][(j + 14) & size_b] = tmp[11];dst[18][(j + 18) & size_b] = tmp[12];dst[22][(j + 22) & size_b] = tmp[13];dst[26][(j + 26) & size_b] = tmp[14];dst[30][(j + 30) & size_b] = tmp[15];dst[1][(j + 1) & size_b] = tmp[16];dst[3][(j + 3) & size_b] = tmp[17];dst[5][(j + 5) & size_b] = tmp[18];dst[7][(j + 7) & size_b] = tmp[19];dst[9][(j + 9) & size_b] = tmp[20];dst[11][(j + 11) & size_b] = tmp[21];dst[13][(j + 13) & size_b] = tmp[22];dst[15][(j + 15) & size_b] = tmp[23];dst[17][(j + 17) & size_b] = tmp[24];dst[19][(j + 19) & size_b] = tmp[25];dst[21][(j + 21) & size_b] = tmp[26];dst[23][(j + 23) & size_b] = tmp[27];dst[25][(j + 25) & size_b] = tmp[28];dst[27][(j + 27) & size_b] = tmp[29];dst[29][(j + 29) & size_b] = tmp[30];dst[31][(j + 31) & size_b] = tmp[31];
}
			}
		}
	}
}
static void dct_row_luma_32(U8 cu_width, U8 cu_height, s16 src[32][32], s16 dst[32][32], U4 shift)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst complete dim=2
	U7 size = 32;
	U8 size_b = size - 1;

	int j, k;
	S16 E[16], O[16];
	S16 EE[8], EO[8];
	S16 EEE[4], EEO[4];
	S16 EEEE[2], EEEO[2];
	S16 tmp[32];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEE complete dim=1

#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEO complete dim=1

#pragma HLS ARRAY_PARTITION variable=tmp complete dim=1
	int add;
	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

	for (j = 0; j < 32; j++)
	{
#pragma HLS PIPELINE ii=1
		if (j < cu_height) {
			for (k = 0; k < 16; k++)
			{
				E[k] = src[j][k] + src[j][31 - k];
				O[k] = src[j][k] - src[j][31 - k];
			}
			/* EE and EO */
			if (cu_width == 32) {
				for (k = 0; k < 8; k++)
				{
					EE[k] = E[k] + E[15 - k];
					EO[k] = E[k] - E[15 - k];
				}
			}
			else if (cu_width == 16) {
				for (k = 0; k < 8; k++)
				{
					EE[k] = src[j][k] + src[j][15 - k];
					EO[k] = src[j][k] - src[j][15 - k];
				}
			}
			/* EEE and EEO */
			if (cu_width == 32 || cu_width == 16) {
				for (k = 0; k < 4; k++)
				{
					EEE[k] = EE[k] + EE[7 - k];
					EEO[k] = EE[k] - EE[7 - k];
				}
			}
			else if (cu_width == 8) {
				for (k = 0; k < 4; k++)
				{
					EEE[k] = src[j][k] + src[j][7 - k];
					EEO[k] = src[j][k] - src[j][7 - k];
				}
			}
			/* EEEE and EEEO */
			if (cu_width == 32 || cu_width == 16 || cu_width == 8) {
				EEEE[0] = EEE[0] + EEE[3];
				EEEO[0] = EEE[0] - EEE[3];
				EEEE[1] = EEE[1] + EEE[2];
				EEEO[1] = EEE[1] - EEE[2];
			}
			else if (cu_width == 4) {
				EEEE[0] = src[j][0] + src[j][3];
				EEEO[0] = src[j][0] - src[j][3];
				EEEE[1] = src[j][1] + src[j][2];
				EEEO[1] = src[j][1] - src[j][2];
			}
			tmp[0] = ((32 * EEEE[0] + 32 * EEEE[1] + add) >> shift);
			tmp[1] = ((32 * EEEE[0] - 32 * EEEE[1] + add) >> shift);
			tmp[2] = ((42 * EEEO[0] + 17 * EEEO[1] + add) >> shift);
			tmp[3] = ((17 * EEEO[0] - 42 * EEEO[1] + add) >> shift);
			tmp[4] = (((44) * EEO[0] + (38) * EEO[1] + (25) * EEO[2] + (9) * EEO[3] + add) >> shift);
			tmp[5] = (((38) * EEO[0] + (-9) * EEO[1] + (-44) * EEO[2] + (-25) * EEO[3] + add) >> shift);
			tmp[6] = (((25) * EEO[0] + (-44) * EEO[1] + (9) * EEO[2] + (38) * EEO[3] + add) >> shift);
			tmp[7] = (((9) * EEO[0] + (-25) * EEO[1] + (38) * EEO[2] + (-44) * EEO[3] + add) >> shift);
			tmp[8] = (((45) * EO[0] + (43) * EO[1] + (40) * EO[2] + (35) * EO[3] + (29) * EO[4] + (21) * EO[5] + (13) * EO[6] + (4) * EO[7] + add) >> shift);
			tmp[9] = (((43) * EO[0] + (29) * EO[1] + (4) * EO[2] + (-21) * EO[3] + (-40) * EO[4] + (-45) * EO[5] + (-35) * EO[6] + (-13) * EO[7] + add) >> shift);
			tmp[10] = (((40) * EO[0] + (4) * EO[1] + (-35) * EO[2] + (-43) * EO[3] + (-13) * EO[4] + (29) * EO[5] + (45) * EO[6] + (21) * EO[7] + add) >> shift);
			tmp[11] = (((35) * EO[0] + (-21) * EO[1] + (-43) * EO[2] + (4) * EO[3] + (45) * EO[4] + (13) * EO[5] + (-40) * EO[6] + (-29) * EO[7] + add) >> shift);
			tmp[12] = (((29) * EO[0] + (-40) * EO[1] + (-13) * EO[2] + (45) * EO[3] + (-4) * EO[4] + (-43) * EO[5] + (21) * EO[6] + (35) * EO[7] + add) >> shift);
			tmp[13] = (((21) * EO[0] + (-45) * EO[1] + (29) * EO[2] + (13) * EO[3] + (-43) * EO[4] + (35) * EO[5] + (4) * EO[6] + (-40) * EO[7] + add) >> shift);
			tmp[14] = (((13) * EO[0] + (-35) * EO[1] + (45) * EO[2] + (-40) * EO[3] + (21) * EO[4] + (4) * EO[5] + (-29) * EO[6] + (43) * EO[7] + add) >> shift);
			tmp[15] = (((4) * EO[0] + (-13) * EO[1] + (21) * EO[2] + (-29) * EO[3] + (35) * EO[4] + (-40) * EO[5] + (43) * EO[6] + (-45) * EO[7] + add) >> shift);
			tmp[16] = (((45) * O[0] + (45) * O[1] + (44) * O[2] + (43) * O[3] + (41) * O[4] + (39) * O[5] + (36) * O[6] + (34) * O[7] + (30) * O[8] + (27) * O[9] + (23) * O[10] + (19) * O[11] + (15) * O[12] + (11) * O[13] + (7) * O[14] + (2) * O[15] + add) >> shift);
			tmp[17] = (((45) * O[0] + (41) * O[1] + (34) * O[2] + (23) * O[3] + (11) * O[4] + (-2) * O[5] + (-15) * O[6] + (-27) * O[7] + (-36) * O[8] + (-43) * O[9] + (-45) * O[10] + (-44) * O[11] + (-39) * O[12] + (-30) * O[13] + (-19) * O[14] + (-7) * O[15] + add) >> shift);
			tmp[18] = (((44) * O[0] + (34) * O[1] + (15) * O[2] + (-7) * O[3] + (-27) * O[4] + (-41) * O[5] + (-45) * O[6] + (-39) * O[7] + (-23) * O[8] + (-2) * O[9] + (19) * O[10] + (36) * O[11] + (45) * O[12] + (43) * O[13] + (30) * O[14] + (11) * O[15] + add) >> shift);
			tmp[19] = (((43) * O[0] + (23) * O[1] + (-7) * O[2] + (-34) * O[3] + (-45) * O[4] + (-36) * O[5] + (-11) * O[6] + (19) * O[7] + (41) * O[8] + (44) * O[9] + (27) * O[10] + (-2) * O[11] + (-30) * O[12] + (-45) * O[13] + (-39) * O[14] + (-15) * O[15] + add) >> shift);
			tmp[20] = (((41) * O[0] + (11) * O[1] + (-27) * O[2] + (-45) * O[3] + (-30) * O[4] + (7) * O[5] + (39) * O[6] + (43) * O[7] + (15) * O[8] + (-23) * O[9] + (-45) * O[10] + (-34) * O[11] + (2) * O[12] + (36) * O[13] + (44) * O[14] + (19) * O[15] + add) >> shift);
			tmp[21] = (((39) * O[0] + (-2) * O[1] + (-41) * O[2] + (-36) * O[3] + (7) * O[4] + (43) * O[5] + (34) * O[6] + (-11) * O[7] + (-44) * O[8] + (-30) * O[9] + (15) * O[10] + (45) * O[11] + (27) * O[12] + (-19) * O[13] + (-45) * O[14] + (-23) * O[15] + add) >> shift);
			tmp[22] = (((36) * O[0] + (-15) * O[1] + (-45) * O[2] + (-11) * O[3] + (39) * O[4] + (34) * O[5] + (-19) * O[6] + (-45) * O[7] + (-7) * O[8] + (41) * O[9] + (30) * O[10] + (-23) * O[11] + (-44) * O[12] + (-2) * O[13] + (43) * O[14] + (27) * O[15] + add) >> shift);
			tmp[23] = (((34) * O[0] + (-27) * O[1] + (-39) * O[2] + (19) * O[3] + (43) * O[4] + (-11) * O[5] + (-45) * O[6] + (2) * O[7] + (45) * O[8] + (7) * O[9] + (-44) * O[10] + (-15) * O[11] + (41) * O[12] + (23) * O[13] + (-36) * O[14] + (-30) * O[15] + add) >> shift);
			tmp[24] = (((30) * O[0] + (-36) * O[1] + (-23) * O[2] + (41) * O[3] + (15) * O[4] + (-44) * O[5] + (-7) * O[6] + (45) * O[7] + (-2) * O[8] + (-45) * O[9] + (11) * O[10] + (43) * O[11] + (-19) * O[12] + (-39) * O[13] + (27) * O[14] + (34) * O[15] + add) >> shift);
			tmp[25] = (((27) * O[0] + (-43) * O[1] + (-2) * O[2] + (44) * O[3] + (-23) * O[4] + (-30) * O[5] + (41) * O[6] + (7) * O[7] + (-45) * O[8] + (19) * O[9] + (34) * O[10] + (-39) * O[11] + (-11) * O[12] + (45) * O[13] + (-15) * O[14] + (-36) * O[15] + add) >> shift);
			tmp[26] = (((23) * O[0] + (-45) * O[1] + (19) * O[2] + (27) * O[3] + (-45) * O[4] + (15) * O[5] + (30) * O[6] + (-44) * O[7] + (11) * O[8] + (34) * O[9] + (-43) * O[10] + (7) * O[11] + (36) * O[12] + (-41) * O[13] + (2) * O[14] + (39) * O[15] + add) >> shift);
			tmp[27] = (((19) * O[0] + (-44) * O[1] + (36) * O[2] + (-2) * O[3] + (-34) * O[4] + (45) * O[5] + (-23) * O[6] + (-15) * O[7] + (43) * O[8] + (-39) * O[9] + (7) * O[10] + (30) * O[11] + (-45) * O[12] + (27) * O[13] + (11) * O[14] + (-41) * O[15] + add) >> shift);
			tmp[28] = (((15) * O[0] + (-39) * O[1] + (45) * O[2] + (-30) * O[3] + (2) * O[4] + (27) * O[5] + (-44) * O[6] + (41) * O[7] + (-19) * O[8] + (-11) * O[9] + (36) * O[10] + (-45) * O[11] + (34) * O[12] + (-7) * O[13] + (-23) * O[14] + (43) * O[15] + add) >> shift);
			tmp[29] = (((11) * O[0] + (-30) * O[1] + (43) * O[2] + (-45) * O[3] + (36) * O[4] + (-19) * O[5] + (-2) * O[6] + (23) * O[7] + (-39) * O[8] + (45) * O[9] + (-41) * O[10] + (27) * O[11] + (-7) * O[12] + (-15) * O[13] + (34) * O[14] + (-44) * O[15] + add) >> shift);
			tmp[30] = (((7) * O[0] + (-19) * O[1] + (30) * O[2] + (-39) * O[3] + (44) * O[4] + (-45) * O[5] + (43) * O[6] + (-36) * O[7] + (27) * O[8] + (-15) * O[9] + (2) * O[10] + (11) * O[11] + (-23) * O[12] + (34) * O[13] + (-41) * O[14] + (45) * O[15] + add) >> shift);
			tmp[31] = (((2) * O[0] + (-7) * O[1] + (11) * O[2] + (-15) * O[3] + (19) * O[4] + (-23) * O[5] + (27) * O[6] + (-30) * O[7] + (34) * O[8] + (-36) * O[9] + (39) * O[10] + (-41) * O[11] + (43) * O[12] + (-44) * O[13] + (45) * O[14] + (-45) * O[15] + add) >> shift);

			if (cu_width == 4) {
				if (j == 0) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 1) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 2) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 3) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 4) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 5) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 6) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 7) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 8) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 9) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 10) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 11) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 12) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 13) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 14) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 15) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 16) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 17) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 18) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 19) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 20) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 21) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 22) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 23) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 24) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 25) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 26) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 27) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 28) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 29) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 30) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }
				else if (j == 31) { dst[0][(j + 0) & size_b] = tmp[0]; dst[2][(j + 2) & size_b] = tmp[1]; dst[1][(j + 1) & size_b] = tmp[2]; dst[3][(j + 3) & size_b] = tmp[3]; }

			}
			else if (cu_width == 8) {
				if (j == 0) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 1) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 2) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 3) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 4) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 5) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 6) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 7) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 8) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 9) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 10) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 11) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 12) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 13) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 14) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 15) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 16) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 17) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 18) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 19) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 20) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 21) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 22) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 23) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 24) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 25) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 26) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 27) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 28) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 29) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 30) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
				else if (j == 31) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[4][(j + 4) & size_b] = tmp[1]; dst[2][(j + 2) & size_b] = tmp[2]; dst[6][(j + 6) & size_b] = tmp[3]; dst[1][(j + 1) & size_b] = tmp[4]; dst[3][(j + 3) & size_b] = tmp[5]; dst[5][(j + 5) & size_b] = tmp[6]; dst[7][(j + 7) & size_b] = tmp[7];
				}
			}
			else if (cu_width == 16) {
				if (j == 0) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 1) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 2) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 3) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 4) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 5) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 6) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 7) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 8) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 9) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 10) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 11) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 12) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 13) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 14) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 15) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 16) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 17) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 18) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 19) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 20) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 21) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 22) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 23) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 24) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 25) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 26) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 27) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 28) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 29) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 30) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
				else if (j == 31) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[8][(j + 8) & size_b] = tmp[1]; dst[4][(j + 4) & size_b] = tmp[2]; dst[12][(j + 12) & size_b] = tmp[3]; dst[2][(j + 2) & size_b] = tmp[4]; dst[6][(j + 6) & size_b] = tmp[5]; dst[10][(j + 10) & size_b] = tmp[6]; dst[14][(j + 14) & size_b] = tmp[7]; dst[1][(j + 1) & size_b] = tmp[8]; dst[3][(j + 3) & size_b] = tmp[9]; dst[5][(j + 5) & size_b] = tmp[10]; dst[7][(j + 7) & size_b] = tmp[11]; dst[9][(j + 9) & size_b] = tmp[12]; dst[11][(j + 11) & size_b] = tmp[13]; dst[13][(j + 13) & size_b] = tmp[14]; dst[15][(j + 15) & size_b] = tmp[15];
				}
			}
			else if (cu_width == 32) {
				if (j == 0) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 1) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 2) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 3) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 4) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 5) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 6) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 7) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 8) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 9) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 10) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 11) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 12) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 13) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 14) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 15) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 16) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 17) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 18) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 19) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 20) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 21) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 22) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 23) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 24) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 25) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 26) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 27) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 28) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 29) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 30) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
				else if (j == 31) {
					dst[0][(j + 0) & size_b] = tmp[0]; dst[16][(j + 16) & size_b] = tmp[1]; dst[8][(j + 8) & size_b] = tmp[2]; dst[24][(j + 24) & size_b] = tmp[3]; dst[4][(j + 4) & size_b] = tmp[4]; dst[12][(j + 12) & size_b] = tmp[5]; dst[20][(j + 20) & size_b] = tmp[6]; dst[28][(j + 28) & size_b] = tmp[7]; dst[2][(j + 2) & size_b] = tmp[8]; dst[6][(j + 6) & size_b] = tmp[9]; dst[10][(j + 10) & size_b] = tmp[10]; dst[14][(j + 14) & size_b] = tmp[11]; dst[18][(j + 18) & size_b] = tmp[12]; dst[22][(j + 22) & size_b] = tmp[13]; dst[26][(j + 26) & size_b] = tmp[14]; dst[30][(j + 30) & size_b] = tmp[15]; dst[1][(j + 1) & size_b] = tmp[16]; dst[3][(j + 3) & size_b] = tmp[17]; dst[5][(j + 5) & size_b] = tmp[18]; dst[7][(j + 7) & size_b] = tmp[19]; dst[9][(j + 9) & size_b] = tmp[20]; dst[11][(j + 11) & size_b] = tmp[21]; dst[13][(j + 13) & size_b] = tmp[22]; dst[15][(j + 15) & size_b] = tmp[23]; dst[17][(j + 17) & size_b] = tmp[24]; dst[19][(j + 19) & size_b] = tmp[25]; dst[21][(j + 21) & size_b] = tmp[26]; dst[23][(j + 23) & size_b] = tmp[27]; dst[25][(j + 25) & size_b] = tmp[28]; dst[27][(j + 27) & size_b] = tmp[29]; dst[29][(j + 29) & size_b] = tmp[30]; dst[31][(j + 31) & size_b] = tmp[31];
				}
			}
		}
	}
}
static void dct_row_32_lite(U8 cu_width, U8 cu_height, s16 src[32][32], s16 dst[32][32], U4 shift)
{
	U7 size = 32;
	U8 size_b = size - 1;

 // int j, k;
	static int E   [32][16], O   [32][16];
	static int EE  [32][8],  EO  [32][8];
	static int EEE [32][4],  EEO [32][4];
	static int EEEE[32][2],  EEEO[32][2];
	static int tmp [32];
	int add;
#pragma HLS ARRAY_PARTITION variable=E     dim=2 complete
#pragma HLS ARRAY_PARTITION variable=O     dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EE    dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EO    dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEE   dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEO   dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEEE  dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEEO  dim=2 complete
#pragma HLS ARRAY_PARTITION variable=tmp   dim=0 complete

	if (cu_width == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);

    for (int j = 0; j < cu_height; j++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 min=32
#pragma HLS PIPELINE
		/* E and O*/
        for (int k = 0; k < 16; k++) {
			E[j][k] = src[j][k] + src[j][31 - k];
			O[j][k] = src[j][k] - src[j][31 - k];
		}
		/* EE and EO */
		if (cu_width == 32) {
            for (int k = 0; k < 8; k++) {
				EE[j][k] = E[j][k] + E[j][15 - k];
				EO[j][k] = E[j][k] - E[j][15 - k];
			}
		}
		else if (cu_width == 16) {
            for (int k = 0; k < 8; k++) {
				EE[j][k] = src[j][k] + src[j][15 - k];
				EO[j][k] = src[j][k] - src[j][15 - k];
			}
		}
		/* EEE and EEO */
		if (cu_width == 32 || cu_width == 16) {
            for (int k = 0; k < 4; k++) {
				EEE[j][k] = EE[j][k] + EE[j][7 - k];
				EEO[j][k] = EE[j][k] - EE[j][7 - k];
			}
		}
		//		else if (cu_width == 8) {
		//			for (k = 0; k < 4; k++)
		//			{
		//				EEE[j][k] = src[j][k] + src[j][7 - k];
		//				EEO[j][k] = src[j][k] - src[j][7 - k];
		//			}
		//		}
				/* EEEE and EEEO */
		//		if (cu_width == 32 || cu_width == 16 || cu_width == 8) {
		EEEE[j][0] = EEE[j][0] + EEE[j][3];
		EEEO[j][0] = EEE[j][0] - EEE[j][3];
		EEEE[j][1] = EEE[j][1] + EEE[j][2];
		EEEO[j][1] = EEE[j][1] - EEE[j][2];
		//}
		//else if (cu_width == 4) {
		//	EEEE[j][0] = src[j][0] + src[j][3];
		//	EEEO[j][0] = src[j][0] - src[j][3];
		//	EEEE[j][1] = src[j][1] + src[j][2];
		//	EEEO[j][1] = src[j][1] - src[j][2];
		//}
		tmp[0] = ((32 * EEEE[j][0] + 32 * EEEE[j][1] + add) >> shift);
		tmp[1] = ((32 * EEEE[j][0] - 32 * EEEE[j][1] + add) >> shift);
		tmp[2] = ((42 * EEEO[j][0] + 17 * EEEO[j][1] + add) >> shift);
		tmp[3] = ((17 * EEEO[j][0] - 42 * EEEO[j][1] + add) >> shift);
		tmp[4] = (((44) * EEO[j][0] + (38) * EEO[j][1] + (25) * EEO[j][2] + (9) * EEO[j][3] + add) >> shift);
		tmp[5] = (((38) * EEO[j][0] + (-9) * EEO[j][1] + (-44) * EEO[j][2] + (-25) * EEO[j][3] + add) >> shift);
		tmp[6] = (((25) * EEO[j][0] + (-44) * EEO[j][1] + (9) * EEO[j][2] + (38) * EEO[j][3] + add) >> shift);
		tmp[7] = (((9) * EEO[j][0] + (-25) * EEO[j][1] + (38) * EEO[j][2] + (-44) * EEO[j][3] + add) >> shift);
		tmp[8] = (((45) * EO[j][0] + (43) * EO[j][1] + (40) * EO[j][2] + (35) * EO[j][3] + (29) * EO[j][4] + (21) * EO[j][5] + (13) * EO[j][6] + (4) * EO[j][7] + add) >> shift);
		tmp[9] = (((43) * EO[j][0] + (29) * EO[j][1] + (4) * EO[j][2] + (-21) * EO[j][3] + (-40) * EO[j][4] + (-45) * EO[j][5] + (-35) * EO[j][6] + (-13) * EO[j][7] + add) >> shift);
		tmp[10] = (((40) * EO[j][0] + (4) * EO[j][1] + (-35) * EO[j][2] + (-43) * EO[j][3] + (-13) * EO[j][4] + (29) * EO[j][5] + (45) * EO[j][6] + (21) * EO[j][7] + add) >> shift);
		tmp[11] = (((35) * EO[j][0] + (-21) * EO[j][1] + (-43) * EO[j][2] + (4) * EO[j][3] + (45) * EO[j][4] + (13) * EO[j][5] + (-40) * EO[j][6] + (-29) * EO[j][7] + add) >> shift);
		tmp[12] = (((29) * EO[j][0] + (-40) * EO[j][1] + (-13) * EO[j][2] + (45) * EO[j][3] + (-4) * EO[j][4] + (-43) * EO[j][5] + (21) * EO[j][6] + (35) * EO[j][7] + add) >> shift);
		tmp[13] = (((21) * EO[j][0] + (-45) * EO[j][1] + (29) * EO[j][2] + (13) * EO[j][3] + (-43) * EO[j][4] + (35) * EO[j][5] + (4) * EO[j][6] + (-40) * EO[j][7] + add) >> shift);
		tmp[14] = (((13) * EO[j][0] + (-35) * EO[j][1] + (45) * EO[j][2] + (-40) * EO[j][3] + (21) * EO[j][4] + (4) * EO[j][5] + (-29) * EO[j][6] + (43) * EO[j][7] + add) >> shift);
		tmp[15] = (((4) * EO[j][0] + (-13) * EO[j][1] + (21) * EO[j][2] + (-29) * EO[j][3] + (35) * EO[j][4] + (-40) * EO[j][5] + (43) * EO[j][6] + (-45) * EO[j][7] + add) >> shift);
		tmp[16] = (((45) * O[j][0] + (45) * O[j][1] + (44) * O[j][2] + (43) * O[j][3] + (41) * O[j][4] + (39) * O[j][5] + (36) * O[j][6] + (34) * O[j][7] + (30) * O[j][8] + (27) * O[j][9] + (23) * O[j][10] + (19) * O[j][11] + (15) * O[j][12] + (11) * O[j][13] + (7) * O[j][14] + (2) * O[j][15] + add) >> shift);
		tmp[17] = (((45) * O[j][0] + (41) * O[j][1] + (34) * O[j][2] + (23) * O[j][3] + (11) * O[j][4] + (-2) * O[j][5] + (-15) * O[j][6] + (-27) * O[j][7] + (-36) * O[j][8] + (-43) * O[j][9] + (-45) * O[j][10] + (-44) * O[j][11] + (-39) * O[j][12] + (-30) * O[j][13] + (-19) * O[j][14] + (-7) * O[j][15] + add) >> shift);
		tmp[18] = (((44) * O[j][0] + (34) * O[j][1] + (15) * O[j][2] + (-7) * O[j][3] + (-27) * O[j][4] + (-41) * O[j][5] + (-45) * O[j][6] + (-39) * O[j][7] + (-23) * O[j][8] + (-2) * O[j][9] + (19) * O[j][10] + (36) * O[j][11] + (45) * O[j][12] + (43) * O[j][13] + (30) * O[j][14] + (11) * O[j][15] + add) >> shift);
		tmp[19] = (((43) * O[j][0] + (23) * O[j][1] + (-7) * O[j][2] + (-34) * O[j][3] + (-45) * O[j][4] + (-36) * O[j][5] + (-11) * O[j][6] + (19) * O[j][7] + (41) * O[j][8] + (44) * O[j][9] + (27) * O[j][10] + (-2) * O[j][11] + (-30) * O[j][12] + (-45) * O[j][13] + (-39) * O[j][14] + (-15) * O[j][15] + add) >> shift);
		tmp[20] = (((41) * O[j][0] + (11) * O[j][1] + (-27) * O[j][2] + (-45) * O[j][3] + (-30) * O[j][4] + (7) * O[j][5] + (39) * O[j][6] + (43) * O[j][7] + (15) * O[j][8] + (-23) * O[j][9] + (-45) * O[j][10] + (-34) * O[j][11] + (2) * O[j][12] + (36) * O[j][13] + (44) * O[j][14] + (19) * O[j][15] + add) >> shift);
		tmp[21] = (((39) * O[j][0] + (-2) * O[j][1] + (-41) * O[j][2] + (-36) * O[j][3] + (7) * O[j][4] + (43) * O[j][5] + (34) * O[j][6] + (-11) * O[j][7] + (-44) * O[j][8] + (-30) * O[j][9] + (15) * O[j][10] + (45) * O[j][11] + (27) * O[j][12] + (-19) * O[j][13] + (-45) * O[j][14] + (-23) * O[j][15] + add) >> shift);
		tmp[22] = (((36) * O[j][0] + (-15) * O[j][1] + (-45) * O[j][2] + (-11) * O[j][3] + (39) * O[j][4] + (34) * O[j][5] + (-19) * O[j][6] + (-45) * O[j][7] + (-7) * O[j][8] + (41) * O[j][9] + (30) * O[j][10] + (-23) * O[j][11] + (-44) * O[j][12] + (-2) * O[j][13] + (43) * O[j][14] + (27) * O[j][15] + add) >> shift);
		tmp[23] = (((34) * O[j][0] + (-27) * O[j][1] + (-39) * O[j][2] + (19) * O[j][3] + (43) * O[j][4] + (-11) * O[j][5] + (-45) * O[j][6] + (2) * O[j][7] + (45) * O[j][8] + (7) * O[j][9] + (-44) * O[j][10] + (-15) * O[j][11] + (41) * O[j][12] + (23) * O[j][13] + (-36) * O[j][14] + (-30) * O[j][15] + add) >> shift);
		tmp[24] = (((30) * O[j][0] + (-36) * O[j][1] + (-23) * O[j][2] + (41) * O[j][3] + (15) * O[j][4] + (-44) * O[j][5] + (-7) * O[j][6] + (45) * O[j][7] + (-2) * O[j][8] + (-45) * O[j][9] + (11) * O[j][10] + (43) * O[j][11] + (-19) * O[j][12] + (-39) * O[j][13] + (27) * O[j][14] + (34) * O[j][15] + add) >> shift);
		tmp[25] = (((27) * O[j][0] + (-43) * O[j][1] + (-2) * O[j][2] + (44) * O[j][3] + (-23) * O[j][4] + (-30) * O[j][5] + (41) * O[j][6] + (7) * O[j][7] + (-45) * O[j][8] + (19) * O[j][9] + (34) * O[j][10] + (-39) * O[j][11] + (-11) * O[j][12] + (45) * O[j][13] + (-15) * O[j][14] + (-36) * O[j][15] + add) >> shift);
		tmp[26] = (((23) * O[j][0] + (-45) * O[j][1] + (19) * O[j][2] + (27) * O[j][3] + (-45) * O[j][4] + (15) * O[j][5] + (30) * O[j][6] + (-44) * O[j][7] + (11) * O[j][8] + (34) * O[j][9] + (-43) * O[j][10] + (7) * O[j][11] + (36) * O[j][12] + (-41) * O[j][13] + (2) * O[j][14] + (39) * O[j][15] + add) >> shift);
		tmp[27] = (((19) * O[j][0] + (-44) * O[j][1] + (36) * O[j][2] + (-2) * O[j][3] + (-34) * O[j][4] + (45) * O[j][5] + (-23) * O[j][6] + (-15) * O[j][7] + (43) * O[j][8] + (-39) * O[j][9] + (7) * O[j][10] + (30) * O[j][11] + (-45) * O[j][12] + (27) * O[j][13] + (11) * O[j][14] + (-41) * O[j][15] + add) >> shift);
		tmp[28] = (((15) * O[j][0] + (-39) * O[j][1] + (45) * O[j][2] + (-30) * O[j][3] + (2) * O[j][4] + (27) * O[j][5] + (-44) * O[j][6] + (41) * O[j][7] + (-19) * O[j][8] + (-11) * O[j][9] + (36) * O[j][10] + (-45) * O[j][11] + (34) * O[j][12] + (-7) * O[j][13] + (-23) * O[j][14] + (43) * O[j][15] + add) >> shift);
		tmp[29] = (((11) * O[j][0] + (-30) * O[j][1] + (43) * O[j][2] + (-45) * O[j][3] + (36) * O[j][4] + (-19) * O[j][5] + (-2) * O[j][6] + (23) * O[j][7] + (-39) * O[j][8] + (45) * O[j][9] + (-41) * O[j][10] + (27) * O[j][11] + (-7) * O[j][12] + (-15) * O[j][13] + (34) * O[j][14] + (-44) * O[j][15] + add) >> shift);
		tmp[30] = (((7) * O[j][0] + (-19) * O[j][1] + (30) * O[j][2] + (-39) * O[j][3] + (44) * O[j][4] + (-45) * O[j][5] + (43) * O[j][6] + (-36) * O[j][7] + (27) * O[j][8] + (-15) * O[j][9] + (2) * O[j][10] + (11) * O[j][11] + (-23) * O[j][12] + (34) * O[j][13] + (-41) * O[j][14] + (45) * O[j][15] + add) >> shift);
		tmp[31] = (((2) * O[j][0] + (-7) * O[j][1] + (11) * O[j][2] + (-15) * O[j][3] + (19) * O[j][4] + (-23) * O[j][5] + (27) * O[j][6] + (-30) * O[j][7] + (34) * O[j][8] + (-36) * O[j][9] + (39) * O[j][10] + (-41) * O[j][11] + (43) * O[j][12] + (-44) * O[j][13] + (45) * O[j][14] + (-45) * O[j][15] + add) >> shift);

		/* if (cu_width == 4) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[2][(j + 2) & size_b] = tmp[1];
			dst[1][(j + 1) & size_b] = tmp[2];
			dst[3][(j + 3) & size_b] = tmp[3];
		}
		else if (cu_width == 8) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[4][(j + 4) & size_b] = tmp[1];
			dst[2][(j + 2) & size_b] = tmp[2];
			dst[6][(j + 6) & size_b] = tmp[3];
			dst[1][(j + 1) & size_b] = tmp[4];
			dst[3][(j + 3) & size_b] = tmp[5];
			dst[5][(j + 5) & size_b] = tmp[6];
			dst[7][(j + 7) & size_b] = tmp[7];
		}
		else */
		if (cu_width == 16) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[8][(j + 8) & size_b] = tmp[1];
			dst[4][(j + 4) & size_b] = tmp[2];
			dst[12][(j + 12) & size_b] = tmp[3];
			dst[2][(j + 2) & size_b] = tmp[4];
			dst[6][(j + 6) & size_b] = tmp[5];
			dst[10][(j + 10) & size_b] = tmp[6];
			dst[14][(j + 14) & size_b] = tmp[7];
			dst[1][(j + 1) & size_b] = tmp[8];
			dst[3][(j + 3) & size_b] = tmp[9];
			dst[5][(j + 5) & size_b] = tmp[10];
			dst[7][(j + 7) & size_b] = tmp[11];
			dst[9][(j + 9) & size_b] = tmp[12];
			dst[11][(j + 11) & size_b] = tmp[13];
			dst[13][(j + 13) & size_b] = tmp[14];
			dst[15][(j + 15) & size_b] = tmp[15];
		}
		else if (cu_width == 32) {
			dst[0][(j + 0) & size_b] = tmp[0];
			dst[16][(j + 16) & size_b] = tmp[1];
			dst[8][(j + 8) & size_b] = tmp[2];
			dst[24][(j + 24) & size_b] = tmp[3];
			dst[4][(j + 4) & size_b] = tmp[4];
			dst[12][(j + 12) & size_b] = tmp[5];
			dst[20][(j + 20) & size_b] = tmp[6];
			dst[28][(j + 28) & size_b] = tmp[7];
			dst[2][(j + 2) & size_b] = tmp[8];
			dst[6][(j + 6) & size_b] = tmp[9];
			dst[10][(j + 10) & size_b] = tmp[10];
			dst[14][(j + 14) & size_b] = tmp[11];
			dst[18][(j + 18) & size_b] = tmp[12];
			dst[22][(j + 22) & size_b] = tmp[13];
			dst[26][(j + 26) & size_b] = tmp[14];
			dst[30][(j + 30) & size_b] = tmp[15];
			dst[1][(j + 1) & size_b] = tmp[16];
			dst[3][(j + 3) & size_b] = tmp[17];
			dst[5][(j + 5) & size_b] = tmp[18];
			dst[7][(j + 7) & size_b] = tmp[19];
			dst[9][(j + 9) & size_b] = tmp[20];
			dst[11][(j + 11) & size_b] = tmp[21];
			dst[13][(j + 13) & size_b] = tmp[22];
			dst[15][(j + 15) & size_b] = tmp[23];
			dst[17][(j + 17) & size_b] = tmp[24];
			dst[19][(j + 19) & size_b] = tmp[25];
			dst[21][(j + 21) & size_b] = tmp[26];
			dst[23][(j + 23) & size_b] = tmp[27];
			dst[25][(j + 25) & size_b] = tmp[28];
			dst[27][(j + 27) & size_b] = tmp[29];
			dst[29][(j + 29) & size_b] = tmp[30];
			dst[31][(j + 31) & size_b] = tmp[31];
		}
	}
}

static void dct_col_Chroma32(U8 cu_width, U8 cu_height, s16 src[32][32], s16 dst[32][32], U4 shift)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst complete dim=1
	U7 size = 32;
	U8 size_b = size - 1;

	int j, k;
	static int E[16], O[16];
	static int EE[8], EO[8];
	static int EEE[4], EEO[4];
	static int EEEE[2], EEEO[2];
	static int tmp[32];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEO complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp complete dim=1
	int add;
	if (cu_height == 4)
		add = shift == 0 ? 0 : 1 << (shift - 1);
	else
		add = 1 << (shift - 1);
	for (j = 0; j < 32; j++)
	{
#pragma HLS PIPELINE
		if (j < cu_width) {
		for (k = 0; k < 16; k++)
		{
				E[k] = src[j][(k + j) & size_b] + src[j][(31 - k + j) & size_b];
				O[k] = src[j][(k + j) & size_b] - src[j][(31 - k + j) & size_b];
		}
		/* EE and EO */
		if (cu_height == 32) {
			for (k = 0; k < 8; k++)
			{
					EE[k] = E[k] + E[15 - k];
					EO[k] = E[k] - E[15 - k];
			}
		}
		else if (cu_height == 16) {
			for (k = 0; k < 8; k++)
			{
					EE[k] = src[j][(k + j) & size_b] + src[j][(15 - k + j) & size_b];
					EO[k] = src[j][(k + j) & size_b] - src[j][(15 - k + j) & size_b];
			}
		}

		/* EEE and EEO */
		if (cu_height == 32 || cu_height == 16) {
			for (k = 0; k < 4; k++)
			{
					EEE[k] = EE[k] + EE[7 - k];
					EEO[k] = EE[k] - EE[7 - k];
			}
		}
		else if (cu_height == 8) {
			for (k = 0; k < 4; k++)
			{
					EEE[k] = src[j][(k + j) & size_b] + src[j][(7 - k + j) & size_b];
					EEO[k] = src[j][(k + j) & size_b] - src[j][(7 - k + j) & size_b];
			}
		}

		/* EEEE and EEEO */
		if (cu_height == 32 || cu_height == 16 || cu_height == 8) {
				EEEE[0] = EEE[0] + EEE[3];
				EEEO[0] = EEE[0] - EEE[3];
				EEEE[1] = EEE[1] + EEE[2];
				EEEO[1] = EEE[1] - EEE[2];
		}
		else if (cu_height == 4) {
				EEEE[0] = src[j][(0 + j) & size_b] + src[j][(3 + j) & size_b];
				EEEO[0] = src[j][(0 + j) & size_b] - src[j][(3 + j) & size_b];
				EEEE[1] = src[j][(1 + j) & size_b] + src[j][(2 + j) & size_b];
				EEEO[1] = src[j][(1 + j) & size_b] - src[j][(2 + j) & size_b];
		}
			tmp[0] = ((32 * EEEE[0] + 32 * EEEE[1] + add) >> shift);
			tmp[1] = ((32 * EEEE[0] - 32 * EEEE[1] + add) >> shift);
			tmp[2] = ((42 * EEEO[0] + 17 * EEEO[1] + add) >> shift);
			tmp[3] = ((17 * EEEO[0] - 42 * EEEO[1] + add) >> shift);
			tmp[4] = (((44) * EEO[0] + (38) * EEO[1] + (25) * EEO[2] + (9) * EEO[3] + add) >> shift);
			tmp[5] = (((38) * EEO[0] + (-9) * EEO[1] + (-44) * EEO[2] + (-25) * EEO[3] + add) >> shift);
			tmp[6] = (((25) * EEO[0] + (-44) * EEO[1] + (9) * EEO[2] + (38) * EEO[3] + add) >> shift);
			tmp[7] = (((9) * EEO[0] + (-25) * EEO[1] + (38) * EEO[2] + (-44) * EEO[3] + add) >> shift);
			tmp[8] = (((45) * EO[0] + (43) * EO[1] + (40) * EO[2] + (35) * EO[3] + (29) * EO[4] + (21) * EO[5] + (13) * EO[6] + (4) * EO[7] + add) >> shift);
			tmp[9] = (((43) * EO[0] + (29) * EO[1] + (4) * EO[2] + (-21) * EO[3] + (-40) * EO[4] + (-45) * EO[5] + (-35) * EO[6] + (-13) * EO[7] + add) >> shift);
			tmp[10] = (((40) * EO[0] + (4) * EO[1] + (-35) * EO[2] + (-43) * EO[3] + (-13) * EO[4] + (29) * EO[5] + (45) * EO[6] + (21) * EO[7] + add) >> shift);
			tmp[11] = (((35) * EO[0] + (-21) * EO[1] + (-43) * EO[2] + (4) * EO[3] + (45) * EO[4] + (13) * EO[5] + (-40) * EO[6] + (-29) * EO[7] + add) >> shift);
			tmp[12] = (((29) * EO[0] + (-40) * EO[1] + (-13) * EO[2] + (45) * EO[3] + (-4) * EO[4] + (-43) * EO[5] + (21) * EO[6] + (35) * EO[7] + add) >> shift);
			tmp[13] = (((21) * EO[0] + (-45) * EO[1] + (29) * EO[2] + (13) * EO[3] + (-43) * EO[4] + (35) * EO[5] + (4) * EO[6] + (-40) * EO[7] + add) >> shift);
			tmp[14] = (((13) * EO[0] + (-35) * EO[1] + (45) * EO[2] + (-40) * EO[3] + (21) * EO[4] + (4) * EO[5] + (-29) * EO[6] + (43) * EO[7] + add) >> shift);
			tmp[15] = (((4) * EO[0] + (-13) * EO[1] + (21) * EO[2] + (-29) * EO[3] + (35) * EO[4] + (-40) * EO[5] + (43) * EO[6] + (-45) * EO[7] + add) >> shift);
			tmp[16] = (((45) * O[0] + (45) * O[1] + (44) * O[2] + (43) * O[3] + (41) * O[4] + (39) * O[5] + (36) * O[6] + (34) * O[7] + (30) * O[8] + (27) * O[9] + (23) * O[10] + (19) * O[11] + (15) * O[12] + (11) * O[13] + (7) * O[14] + (2) * O[15] + add) >> shift);
			tmp[17] = (((45) * O[0] + (41) * O[1] + (34) * O[2] + (23) * O[3] + (11) * O[4] + (-2) * O[5] + (-15) * O[6] + (-27) * O[7] + (-36) * O[8] + (-43) * O[9] + (-45) * O[10] + (-44) * O[11] + (-39) * O[12] + (-30) * O[13] + (-19) * O[14] + (-7) * O[15] + add) >> shift);
			tmp[18] = (((44) * O[0] + (34) * O[1] + (15) * O[2] + (-7) * O[3] + (-27) * O[4] + (-41) * O[5] + (-45) * O[6] + (-39) * O[7] + (-23) * O[8] + (-2) * O[9] + (19) * O[10] + (36) * O[11] + (45) * O[12] + (43) * O[13] + (30) * O[14] + (11) * O[15] + add) >> shift);
			tmp[19] = (((43) * O[0] + (23) * O[1] + (-7) * O[2] + (-34) * O[3] + (-45) * O[4] + (-36) * O[5] + (-11) * O[6] + (19) * O[7] + (41) * O[8] + (44) * O[9] + (27) * O[10] + (-2) * O[11] + (-30) * O[12] + (-45) * O[13] + (-39) * O[14] + (-15) * O[15] + add) >> shift);
			tmp[20] = (((41) * O[0] + (11) * O[1] + (-27) * O[2] + (-45) * O[3] + (-30) * O[4] + (7) * O[5] + (39) * O[6] + (43) * O[7] + (15) * O[8] + (-23) * O[9] + (-45) * O[10] + (-34) * O[11] + (2) * O[12] + (36) * O[13] + (44) * O[14] + (19) * O[15] + add) >> shift);
			tmp[21] = (((39) * O[0] + (-2) * O[1] + (-41) * O[2] + (-36) * O[3] + (7) * O[4] + (43) * O[5] + (34) * O[6] + (-11) * O[7] + (-44) * O[8] + (-30) * O[9] + (15) * O[10] + (45) * O[11] + (27) * O[12] + (-19) * O[13] + (-45) * O[14] + (-23) * O[15] + add) >> shift);
			tmp[22] = (((36) * O[0] + (-15) * O[1] + (-45) * O[2] + (-11) * O[3] + (39) * O[4] + (34) * O[5] + (-19) * O[6] + (-45) * O[7] + (-7) * O[8] + (41) * O[9] + (30) * O[10] + (-23) * O[11] + (-44) * O[12] + (-2) * O[13] + (43) * O[14] + (27) * O[15] + add) >> shift);
			tmp[23] = (((34) * O[0] + (-27) * O[1] + (-39) * O[2] + (19) * O[3] + (43) * O[4] + (-11) * O[5] + (-45) * O[6] + (2) * O[7] + (45) * O[8] + (7) * O[9] + (-44) * O[10] + (-15) * O[11] + (41) * O[12] + (23) * O[13] + (-36) * O[14] + (-30) * O[15] + add) >> shift);
			tmp[24] = (((30) * O[0] + (-36) * O[1] + (-23) * O[2] + (41) * O[3] + (15) * O[4] + (-44) * O[5] + (-7) * O[6] + (45) * O[7] + (-2) * O[8] + (-45) * O[9] + (11) * O[10] + (43) * O[11] + (-19) * O[12] + (-39) * O[13] + (27) * O[14] + (34) * O[15] + add) >> shift);
			tmp[25] = (((27) * O[0] + (-43) * O[1] + (-2) * O[2] + (44) * O[3] + (-23) * O[4] + (-30) * O[5] + (41) * O[6] + (7) * O[7] + (-45) * O[8] + (19) * O[9] + (34) * O[10] + (-39) * O[11] + (-11) * O[12] + (45) * O[13] + (-15) * O[14] + (-36) * O[15] + add) >> shift);
			tmp[26] = (((23) * O[0] + (-45) * O[1] + (19) * O[2] + (27) * O[3] + (-45) * O[4] + (15) * O[5] + (30) * O[6] + (-44) * O[7] + (11) * O[8] + (34) * O[9] + (-43) * O[10] + (7) * O[11] + (36) * O[12] + (-41) * O[13] + (2) * O[14] + (39) * O[15] + add) >> shift);
			tmp[27] = (((19) * O[0] + (-44) * O[1] + (36) * O[2] + (-2) * O[3] + (-34) * O[4] + (45) * O[5] + (-23) * O[6] + (-15) * O[7] + (43) * O[8] + (-39) * O[9] + (7) * O[10] + (30) * O[11] + (-45) * O[12] + (27) * O[13] + (11) * O[14] + (-41) * O[15] + add) >> shift);
			tmp[28] = (((15) * O[0] + (-39) * O[1] + (45) * O[2] + (-30) * O[3] + (2) * O[4] + (27) * O[5] + (-44) * O[6] + (41) * O[7] + (-19) * O[8] + (-11) * O[9] + (36) * O[10] + (-45) * O[11] + (34) * O[12] + (-7) * O[13] + (-23) * O[14] + (43) * O[15] + add) >> shift);
			tmp[29] = (((11) * O[0] + (-30) * O[1] + (43) * O[2] + (-45) * O[3] + (36) * O[4] + (-19) * O[5] + (-2) * O[6] + (23) * O[7] + (-39) * O[8] + (45) * O[9] + (-41) * O[10] + (27) * O[11] + (-7) * O[12] + (-15) * O[13] + (34) * O[14] + (-44) * O[15] + add) >> shift);
			tmp[30] = (((7) * O[0] + (-19) * O[1] + (30) * O[2] + (-39) * O[3] + (44) * O[4] + (-45) * O[5] + (43) * O[6] + (-36) * O[7] + (27) * O[8] + (-15) * O[9] + (2) * O[10] + (11) * O[11] + (-23) * O[12] + (34) * O[13] + (-41) * O[14] + (45) * O[15] + add) >> shift);
			tmp[31] = (((2) * O[0] + (-7) * O[1] + (11) * O[2] + (-15) * O[3] + (19) * O[4] + (-23) * O[5] + (27) * O[6] + (-30) * O[7] + (34) * O[8] + (-36) * O[9] + (39) * O[10] + (-41) * O[11] + (43) * O[12] + (-44) * O[13] + (45) * O[14] + (-45) * O[15] + add) >> shift);

		if (cu_height == 4) {
			if (j == 0 ) { dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3]; }
			else if (j == 1) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 2) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 3) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 4) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 5) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 6) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 7) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 8) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 9) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 10) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 11) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 12) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 13) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 14) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 15) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 16) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 17) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 18) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 19) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 20) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 21) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 22) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 23) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 24) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 25) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 26) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 27) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 28) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 29) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 30) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}
			else if (j == 31) {dst[0][j] = tmp[0]; dst[2][j] = tmp[1]; dst[1][j] = tmp[2]; dst[3][j] = tmp[3];}

		}
		else if (cu_height == 8) {
			if (j == 0) { dst[0][j] = tmp[0]; dst[4][j] = tmp[1]; dst[2][j] = tmp[2]; dst[6][j] = tmp[3]; dst[1][j] = tmp[4]; dst[3][j] = tmp[5]; dst[5][j] = tmp[6]; dst[7][j] = tmp[7]; }
			else if (j == 1) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 2) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 3) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 4) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 5) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 6) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 7) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 8) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 9) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 10) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 11) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 12) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 13) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 14) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 15) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 16) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 17) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 18) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 19) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 20) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 21) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 22) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 23) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 24) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 25) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 26) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 27) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 28) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 29) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 30) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
			else if (j == 31) {dst[0][j] = tmp[0];dst[4][j] = tmp[1];dst[2][j] = tmp[2];dst[6][j] = tmp[3];dst[1][j] = tmp[4];dst[3][j] = tmp[5];dst[5][j] = tmp[6];dst[7][j] = tmp[7];}
		}
		else if (cu_height == 16) {
			if (j == 0)		  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 1)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 2)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 3)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 4)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 5)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 6)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 7)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 8)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 9)  {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 10) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 11) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 12) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 13) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 14) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 15) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 16) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 17) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 18) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 19) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 20) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 21) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 22) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 23) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 24) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 25) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 26) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 27) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 28) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 29) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 30) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}
			else if (j == 31) {dst[0][j] = tmp[0];dst[8][j] = tmp[1];dst[4][j] = tmp[2];dst[12][j] = tmp[3];dst[2][j] = tmp[4];dst[6][j] = tmp[5];dst[10][j] = tmp[6];dst[14][j] = tmp[7];dst[1][j] = tmp[8];dst[3][j] = tmp[9];dst[5][j] = tmp[10];dst[7][j] = tmp[11];dst[9][j] = tmp[12];dst[11][j] = tmp[13];dst[13][j] = tmp[14];dst[15][j] = tmp[15];
}

		}
		else if (cu_height == 32) {
		if (j == 0)       {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 1)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 2)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 3)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 4)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 5)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 6)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 7)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 8)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 9)  {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 10) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 11) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 12) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 13) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 14) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 15) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 16) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 17) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 18) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 19) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 20) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 21) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 22) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 23) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 24) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 25) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 26) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 27) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 28) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 29) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 30) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}
		else if (j == 31) {dst[0][j] = tmp[0];dst[16][j] = tmp[1];dst[8][j] = tmp[2];dst[24][j] = tmp[3];dst[4][j] = tmp[4];dst[12][j] = tmp[5];dst[20][j] = tmp[6];dst[28][j] = tmp[7];dst[2][j] = tmp[8];dst[6][j] = tmp[9];dst[10][j] = tmp[10];dst[14][j] = tmp[11];dst[18][j] = tmp[12];dst[22][j] = tmp[13];dst[26][j] = tmp[14];dst[30][j] = tmp[15];dst[1][j] = tmp[16];dst[3][j] = tmp[17];dst[5][j] = tmp[18];dst[7][j] = tmp[19];dst[9][j] = tmp[20];dst[11][j] = tmp[21];dst[13][j] = tmp[22];dst[15][j] = tmp[23];dst[17][j] = tmp[24];dst[19][j] = tmp[25];dst[21][j] = tmp[26];dst[23][j] = tmp[27];dst[25][j] = tmp[28];dst[27][j] = tmp[29];dst[29][j] = tmp[30];dst[31][j] = tmp[31];
}

			}
		}
	}
}

static void dct_col_32_lite(U8 cu_width, U8 cu_height, s16 src[32][32], s16 dst[32][32], U4 shift)
{
	U7 size = 32;
	U8 size_b = size - 1;

 // int j, k;
	static int E   [32][16], O   [32][16];
	static int EE  [32][ 8], EO  [32][ 8];
	static int EEE [32][ 4], EEO [32][ 4];
	static int EEEE[32][ 2], EEEO[32][ 2];
	static int tmp [32];
	int add;
#pragma HLS ARRAY_PARTITION variable=E     dim=2 complete
#pragma HLS ARRAY_PARTITION variable=O     dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EE    dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EO    dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEE   dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEO   dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEEE  dim=2 complete
#pragma HLS ARRAY_PARTITION variable=EEEO  dim=2 complete
#pragma HLS ARRAY_PARTITION variable=tmp   dim=0 complete

	//if (cu_height == 4)
	//	add = shift == 0 ? 0 : 1 << (shift - 1);
	//else
	add = 1 << (shift - 1);

    for (int j = 0; j < cu_width; j++) {
#pragma HLS LOOP_TRIPCOUNT max=32 min=32
#pragma HLS PIPELINE

		/* E and O*/
        for (int k = 0; k < 16; k++) {
			E[j][k] = src[j][(k + j) & size_b] + src[j][(31 - k + j) & size_b];
			O[j][k] = src[j][(k + j) & size_b] - src[j][(31 - k + j) & size_b];
		}
		/* EE and EO */
		if (cu_height == 32) {
            for (int k = 0; k < 8; k++) {
				EE[j][k] = E[j][k] + E[j][15 - k];
				EO[j][k] = E[j][k] - E[j][15 - k];
			}
		}
		else if (cu_height == 16) {
            for (int k = 0; k < 8; k++) {
				EE[j][k] = src[j][(k + j) & size_b] + src[j][(15 - k + j) & size_b];
				EO[j][k] = src[j][(k + j) & size_b] - src[j][(15 - k + j) & size_b];
			}
		}

		/* EEE and EEO */
//		if (cu_height == 32 || cu_height == 16) {
        for (int k = 0; k < 4; k++) {
			EEE[j][k] = EE[j][k] + EE[j][7 - k];
			EEO[j][k] = EE[j][k] - EE[j][7 - k];
		}
		//		}
		//		else if (cu_height == 8) {
		//			for (k = 0; k < 4; k++)
		//			{
		//				EEE[j][k] = src[j][(k + j) & size_b] + src[j][(7 - k + j) & size_b];
		//				EEO[j][k] = src[j][(k + j) & size_b] - src[j][(7 - k + j) & size_b];
		//			}
		//		}

				/* EEEE and EEEO */
		//		if (cu_height == 32 || cu_height == 16 || cu_height == 8) {
		EEEE[j][0] = EEE[j][0] + EEE[j][3];
		EEEO[j][0] = EEE[j][0] - EEE[j][3];
		EEEE[j][1] = EEE[j][1] + EEE[j][2];
		EEEO[j][1] = EEE[j][1] - EEE[j][2];
		//}
		//else if (cu_height == 4) {
		//	EEEE[j][0] = src[j][(0 + j) & size_b] + src[j][(3 + j) & size_b];
		//	EEEO[j][0] = src[j][(0 + j) & size_b] - src[j][(3 + j) & size_b];
		//	EEEE[j][1] = src[j][(1 + j) & size_b] + src[j][(2 + j) & size_b];
		//	EEEO[j][1] = src[j][(1 + j) & size_b] - src[j][(2 + j) & size_b];
		//}
		tmp[ 0] = ((32 * EEEE[j][0] + 32 * EEEE[j][1] + add) >> shift);
		tmp[ 1] = ((32 * EEEE[j][0] - 32 * EEEE[j][1] + add) >> shift);
		tmp[ 2] = ((42 * EEEO[j][0] + 17 * EEEO[j][1] + add) >> shift);
		tmp[ 3] = ((17 * EEEO[j][0] - 42 * EEEO[j][1] + add) >> shift);

		tmp[ 4] = (((44) * EEO[j][0] + ( 38) * EEO[j][1] + ( 25) * EEO[j][2] + (  9) * EEO[j][3] + add) >> shift);
		tmp[ 5] = (((38) * EEO[j][0] + (-9 ) * EEO[j][1] + (-44) * EEO[j][2] + (-25) * EEO[j][3] + add) >> shift);
		tmp[ 6] = (((25) * EEO[j][0] + (-44) * EEO[j][1] + (  9) * EEO[j][2] + ( 38) * EEO[j][3] + add) >> shift);
		tmp[ 7] = ((( 9) * EEO[j][0] + (-25) * EEO[j][1] + ( 38) * EEO[j][2] + (-44) * EEO[j][3] + add) >> shift);

		tmp[ 8] = (((45) * EO[j][0] + ( 43) * EO[j][1] + ( 40) * EO[j][2] + ( 35) * EO[j][3] + ( 29) * EO[j][4] + ( 21) * EO[j][5] + ( 13) * EO[j][6] + (  4) * EO[j][7] + add) >> shift);
		tmp[ 9] = (((43) * EO[j][0] + ( 29) * EO[j][1] + (  4) * EO[j][2] + (-21) * EO[j][3] + (-40) * EO[j][4] + (-45) * EO[j][5] + (-35) * EO[j][6] + (-13) * EO[j][7] + add) >> shift);
		tmp[10] = (((40) * EO[j][0] + (  4) * EO[j][1] + (-35) * EO[j][2] + (-43) * EO[j][3] + (-13) * EO[j][4] + ( 29) * EO[j][5] + ( 45) * EO[j][6] + ( 21) * EO[j][7] + add) >> shift);
		tmp[11] = (((35) * EO[j][0] + (-21) * EO[j][1] + (-43) * EO[j][2] + (  4) * EO[j][3] + ( 45) * EO[j][4] + ( 13) * EO[j][5] + (-40) * EO[j][6] + (-29) * EO[j][7] + add) >> shift);
		tmp[12] = (((29) * EO[j][0] + (-40) * EO[j][1] + (-13) * EO[j][2] + ( 45) * EO[j][3] + (-4 ) * EO[j][4] + (-43) * EO[j][5] + ( 21) * EO[j][6] + ( 35) * EO[j][7] + add) >> shift);
		tmp[13] = (((21) * EO[j][0] + (-45) * EO[j][1] + ( 29) * EO[j][2] + ( 13) * EO[j][3] + (-43) * EO[j][4] + ( 35) * EO[j][5] + (  4) * EO[j][6] + (-40) * EO[j][7] + add) >> shift);
		tmp[14] = (((13) * EO[j][0] + (-35) * EO[j][1] + ( 45) * EO[j][2] + (-40) * EO[j][3] + ( 21) * EO[j][4] + (  4) * EO[j][5] + (-29) * EO[j][6] + ( 43) * EO[j][7] + add) >> shift);
		tmp[15] = ((( 4) * EO[j][0] + (-13) * EO[j][1] + ( 21) * EO[j][2] + (-29) * EO[j][3] + ( 35) * EO[j][4] + (-40) * EO[j][5] + ( 43) * EO[j][6] + (-45) * EO[j][7] + add) >> shift);

		tmp[16] = (((45) * O[j][0] + ( 45) * O[j][1] + ( 44) * O[j][2] + ( 43) * O[j][3] + ( 41) * O[j][4] + ( 39) * O[j][5] + (36) * O[j][6] + (34) * O[j][7] + (30) * O[j][8] + (27) * O[j][9] + (23) * O[j][10] + (19) * O[j][11] + (15) * O[j][12] + (11) * O[j][13] + (7) * O[j][14] + (2) * O[j][15] + add) >> shift);
		tmp[17] = (((45) * O[j][0] + ( 41) * O[j][1] + ( 34) * O[j][2] + ( 23) * O[j][3] + ( 11) * O[j][4] + (-2 ) * O[j][5] + (-15) * O[j][6] + (-27) * O[j][7] + (-36) * O[j][8] + (-43) * O[j][9] + (-45) * O[j][10] + (-44) * O[j][11] + (-39) * O[j][12] + (-30) * O[j][13] + (-19) * O[j][14] + (-7) * O[j][15] + add) >> shift);
		tmp[18] = (((44) * O[j][0] + ( 34) * O[j][1] + ( 15) * O[j][2] + (-7 ) * O[j][3] + (-27) * O[j][4] + (-41) * O[j][5] + (-45) * O[j][6] + (-39) * O[j][7] + (-23) * O[j][8] + (-2) * O[j][9] + (19) * O[j][10] + (36) * O[j][11] + (45) * O[j][12] + (43) * O[j][13] + (30) * O[j][14] + (11) * O[j][15] + add) >> shift);
		tmp[19] = (((43) * O[j][0] + ( 23) * O[j][1] + (-7 ) * O[j][2] + (-34) * O[j][3] + (-45) * O[j][4] + (-36) * O[j][5] + (-11) * O[j][6] + (19) * O[j][7] + (41) * O[j][8] + (44) * O[j][9] + (27) * O[j][10] + (-2) * O[j][11] + (-30) * O[j][12] + (-45) * O[j][13] + (-39) * O[j][14] + (-15) * O[j][15] + add) >> shift);
		tmp[20] = (((41) * O[j][0] + ( 11) * O[j][1] + (-27) * O[j][2] + (-45) * O[j][3] + (-30) * O[j][4] + (  7) * O[j][5] + (39) * O[j][6] + (43) * O[j][7] + (15) * O[j][8] + (-23) * O[j][9] + (-45) * O[j][10] + (-34) * O[j][11] + (2) * O[j][12] + (36) * O[j][13] + (44) * O[j][14] + (19) * O[j][15] + add) >> shift);
		tmp[21] = (((39) * O[j][0] + (-2 ) * O[j][1] + (-41) * O[j][2] + (-36) * O[j][3] + (  7) * O[j][4] + ( 43) * O[j][5] + (34) * O[j][6] + (-11) * O[j][7] + (-44) * O[j][8] + (-30) * O[j][9] + (15) * O[j][10] + (45) * O[j][11] + (27) * O[j][12] + (-19) * O[j][13] + (-45) * O[j][14] + (-23) * O[j][15] + add) >> shift);
		tmp[22] = (((36) * O[j][0] + (-15) * O[j][1] + (-45) * O[j][2] + (-11) * O[j][3] + ( 39) * O[j][4] + ( 34) * O[j][5] + (-19) * O[j][6] + (-45) * O[j][7] + (-7) * O[j][8] + (41) * O[j][9] + (30) * O[j][10] + (-23) * O[j][11] + (-44) * O[j][12] + (-2) * O[j][13] + (43) * O[j][14] + (27) * O[j][15] + add) >> shift);
		tmp[23] = (((34) * O[j][0] + (-27) * O[j][1] + (-39) * O[j][2] + ( 19) * O[j][3] + ( 43) * O[j][4] + (-11) * O[j][5] + (-45) * O[j][6] + (2) * O[j][7] + (45) * O[j][8] + (7) * O[j][9] + (-44) * O[j][10] + (-15) * O[j][11] + (41) * O[j][12] + (23) * O[j][13] + (-36) * O[j][14] + (-30) * O[j][15] + add) >> shift);
		tmp[24] = (((30) * O[j][0] + (-36) * O[j][1] + (-23) * O[j][2] + ( 41) * O[j][3] + ( 15) * O[j][4] + (-44) * O[j][5] + (-7) * O[j][6] + (45) * O[j][7] + (-2) * O[j][8] + (-45) * O[j][9] + (11) * O[j][10] + (43) * O[j][11] + (-19) * O[j][12] + (-39) * O[j][13] + (27) * O[j][14] + (34) * O[j][15] + add) >> shift);
		tmp[25] = (((27) * O[j][0] + (-43) * O[j][1] + (-2 ) * O[j][2] + ( 44) * O[j][3] + (-23) * O[j][4] + (-30) * O[j][5] + (41) * O[j][6] + (7) * O[j][7] + (-45) * O[j][8] + (19) * O[j][9] + (34) * O[j][10] + (-39) * O[j][11] + (-11) * O[j][12] + (45) * O[j][13] + (-15) * O[j][14] + (-36) * O[j][15] + add) >> shift);
		tmp[26] = (((23) * O[j][0] + (-45) * O[j][1] + ( 19) * O[j][2] + ( 27) * O[j][3] + (-45) * O[j][4] + ( 15) * O[j][5] + (30) * O[j][6] + (-44) * O[j][7] + (11) * O[j][8] + (34) * O[j][9] + (-43) * O[j][10] + (7) * O[j][11] + (36) * O[j][12] + (-41) * O[j][13] + (2) * O[j][14] + (39) * O[j][15] + add) >> shift);
		tmp[27] = (((19) * O[j][0] + (-44) * O[j][1] + ( 36) * O[j][2] + (-2 ) * O[j][3] + (-34) * O[j][4] + ( 45) * O[j][5] + (-23) * O[j][6] + (-15) * O[j][7] + (43) * O[j][8] + (-39) * O[j][9] + (7) * O[j][10] + (30) * O[j][11] + (-45) * O[j][12] + (27) * O[j][13] + (11) * O[j][14] + (-41) * O[j][15] + add) >> shift);
		tmp[28] = (((15) * O[j][0] + (-39) * O[j][1] + ( 45) * O[j][2] + (-30) * O[j][3] + (  2) * O[j][4] + ( 27) * O[j][5] + (-44) * O[j][6] + (41) * O[j][7] + (-19) * O[j][8] + (-11) * O[j][9] + (36) * O[j][10] + (-45) * O[j][11] + (34) * O[j][12] + (-7) * O[j][13] + (-23) * O[j][14] + (43) * O[j][15] + add) >> shift);
		tmp[29] = (((11) * O[j][0] + (-30) * O[j][1] + ( 43) * O[j][2] + (-45) * O[j][3] + ( 36) * O[j][4] + (-19) * O[j][5] + (-2) * O[j][6] + (23) * O[j][7] + (-39) * O[j][8] + (45) * O[j][9] + (-41) * O[j][10] + (27) * O[j][11] + (-7) * O[j][12] + (-15) * O[j][13] + (34) * O[j][14] + (-44) * O[j][15] + add) >> shift);
		tmp[30] = ((( 7) * O[j][0] + (-19) * O[j][1] + ( 30) * O[j][2] + (-39) * O[j][3] + ( 44) * O[j][4] + (-45) * O[j][5] + (43) * O[j][6] + (-36) * O[j][7] + (27) * O[j][8] + (-15) * O[j][9] + (2) * O[j][10] + (11) * O[j][11] + (-23) * O[j][12] + (34) * O[j][13] + (-41) * O[j][14] + (45) * O[j][15] + add) >> shift);
		tmp[31] = ((( 2) * O[j][0] + (-7 ) * O[j][1] + ( 11) * O[j][2] + (-15) * O[j][3] + ( 19) * O[j][4] + (-23) * O[j][5] + (27) * O[j][6] + (-30) * O[j][7] + (34) * O[j][8] + (-36) * O[j][9] + (39) * O[j][10] + (-41) * O[j][11] + (43) * O[j][12] + (-44) * O[j][13] + (45) * O[j][14] + (-45) * O[j][15] + add) >> shift);

		/*if (cu_height == 4) {
			dst[0][j] = tmp[0];
			dst[2][j] = tmp[1];
			dst[1][j] = tmp[2];
			dst[3][j] = tmp[3];
		}
		else if (cu_height == 8) {
			dst[0][j] = tmp[0];
			dst[4][j] = tmp[1];
			dst[2][j] = tmp[2];
			dst[6][j] = tmp[3];
			dst[1][j] = tmp[4];
			dst[3][j] = tmp[5];
			dst[5][j] = tmp[6];
			dst[7][j] = tmp[7];
		}
		else */
		if (cu_height == 16) {
			dst[ 0][j] = tmp[ 0];
			dst[ 8][j] = tmp[ 1];
			dst[ 4][j] = tmp[ 2];
			dst[12][j] = tmp[ 3];
			dst[ 2][j] = tmp[ 4];
			dst[ 6][j] = tmp[ 5];
			dst[10][j] = tmp[ 6];
			dst[14][j] = tmp[ 7];
			dst[ 1][j] = tmp[ 8];
			dst[ 3][j] = tmp[ 9];
			dst[ 5][j] = tmp[10];
			dst[ 7][j] = tmp[11];
			dst[ 9][j] = tmp[12];
			dst[11][j] = tmp[13];
			dst[13][j] = tmp[14];
			dst[15][j] = tmp[15];
		}
		else if (cu_height == 32) {
			dst[ 0][j] = tmp[ 0];
			dst[16][j] = tmp[ 1];
			dst[ 8][j] = tmp[ 2];
			dst[24][j] = tmp[ 3];
			dst[ 4][j] = tmp[ 4];
			dst[12][j] = tmp[ 5];
			dst[20][j] = tmp[ 6];
			dst[28][j] = tmp[ 7];
			dst[ 2][j] = tmp[ 8];
			dst[ 6][j] = tmp[ 9];
			dst[10][j] = tmp[10];
			dst[14][j] = tmp[11];
			dst[18][j] = tmp[12];
			dst[22][j] = tmp[13];
			dst[26][j] = tmp[14];
			dst[30][j] = tmp[15];
			dst[ 1][j] = tmp[16];
			dst[ 3][j] = tmp[17];
			dst[ 5][j] = tmp[18];
			dst[ 7][j] = tmp[19];
			dst[ 9][j] = tmp[20];
			dst[11][j] = tmp[21];
			dst[13][j] = tmp[22];
			dst[15][j] = tmp[23];
			dst[17][j] = tmp[24];
			dst[19][j] = tmp[25];
			dst[21][j] = tmp[26];
			dst[23][j] = tmp[27];
			dst[25][j] = tmp[28];
			dst[27][j] = tmp[29];
			dst[29][j] = tmp[30];
			dst[31][j] = tmp[31];
		}
	}
}

static void inv_dct_col_32(U8 cu_width, U8 cu_height, s16 coeff[32][32], s16 block[32][32], U4 shift)
{
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=1
	U7 size = 32;
	U8 size_b = size - 1;

	if (cu_height == 4)
	{

		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];

			if (i == 0)		  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 1)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 2)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 3)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 4)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 5)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 6)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 7)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 8)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 9)  {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 10) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 11) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 12) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 13) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 14) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 15) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 16) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 17) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 18) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 19) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 20) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 21) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 22) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 23) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 24) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 25) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 26) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 27) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 28) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 29) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 30) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
			else if (i == 31) {block[(i + 0) & 31][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);block[(i + 1) & 31][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);block[(i + 2) & 31][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);block[(i + 3) & 31][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
}
		}
	}
	else if (cu_height == 8)
	{

		int E[4], O[4];
		int EE[2], EO[2];
#pragma HLS ARRAY_PARTITION variable = E complete dim = 1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];

			if (i == 0)		  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 1)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 2)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 3)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 4)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 5)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 6)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 7)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 8)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 9)  {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 10) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 11) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 12) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 13) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 14) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 15) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 16) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 17) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 18) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 19) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 20) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 21) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 22) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 23) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 24) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 25) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 26) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 27) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 28) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 29) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 30) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
}
			else if (i == 31) {for (k = 0; k < 4; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);}
			}
		}
	}
	else if (cu_height == 16)
	{

		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}

			if (i == 0)		  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 1)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
			}
			else if (i == 2)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 3)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 4)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 5)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 6)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 7)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 8)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 9)  {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 10) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 11) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 12) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 13) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 14) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 15) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 16) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 17) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 18) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 19) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 20) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 21) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 22) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 23) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 24) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 25) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 26) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 27) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 28) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 29) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 30) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
			else if (i == 31) {for (k = 0; k < 8; k++) {block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);}
}
		}
	}
	else {

		int E[16], O[16];
		int EE[8], EO[8];
		int EEE[4], EEO[4];
		int EEEE[2], EEEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[1][i] + (45) * coeff[3][i] + (44) * coeff[5][i] + (43) * coeff[7][i] + (41) * coeff[9][i] + (39) * coeff[11][i] + (36) * coeff[13][i] + (34) * coeff[15][i] + (30) * coeff[17][i] + (27) * coeff[19][i] + (23) * coeff[21][i] + (19) * coeff[23][i] + (15) * coeff[25][i] + (11) * coeff[27][i] + (7) * coeff[29][i] + (2) * coeff[31][i];
			O[1] = (45) * coeff[1][i] + (41) * coeff[3][i] + (34) * coeff[5][i] + (23) * coeff[7][i] + (11) * coeff[9][i] + (-2) * coeff[11][i] + (-15) * coeff[13][i] + (-27) * coeff[15][i] + (-36) * coeff[17][i] + (-43) * coeff[19][i] + (-45) * coeff[21][i] + (-44) * coeff[23][i] + (-39) * coeff[25][i] + (-30) * coeff[27][i] + (-19) * coeff[29][i] + (-7) * coeff[31][i];
			O[2] = (44) * coeff[1][i] + (34) * coeff[3][i] + (15) * coeff[5][i] + (-7) * coeff[7][i] + (-27) * coeff[9][i] + (-41) * coeff[11][i] + (-45) * coeff[13][i] + (-39) * coeff[15][i] + (-23) * coeff[17][i] + (-2) * coeff[19][i] + (19) * coeff[21][i] + (36) * coeff[23][i] + (45) * coeff[25][i] + (43) * coeff[27][i] + (30) * coeff[29][i] + (11) * coeff[31][i];
			O[3] = (43) * coeff[1][i] + (23) * coeff[3][i] + (-7) * coeff[5][i] + (-34) * coeff[7][i] + (-45) * coeff[9][i] + (-36) * coeff[11][i] + (-11) * coeff[13][i] + (19) * coeff[15][i] + (41) * coeff[17][i] + (44) * coeff[19][i] + (27) * coeff[21][i] + (-2) * coeff[23][i] + (-30) * coeff[25][i] + (-45) * coeff[27][i] + (-39) * coeff[29][i] + (-15) * coeff[31][i];
			O[4] = (41) * coeff[1][i] + (11) * coeff[3][i] + (-27) * coeff[5][i] + (-45) * coeff[7][i] + (-30) * coeff[9][i] + (7) * coeff[11][i] + (39) * coeff[13][i] + (43) * coeff[15][i] + (15) * coeff[17][i] + (-23) * coeff[19][i] + (-45) * coeff[21][i] + (-34) * coeff[23][i] + (2) * coeff[25][i] + (36) * coeff[27][i] + (44) * coeff[29][i] + (19) * coeff[31][i];
			O[5] = (39) * coeff[1][i] + (-2) * coeff[3][i] + (-41) * coeff[5][i] + (-36) * coeff[7][i] + (7) * coeff[9][i] + (43) * coeff[11][i] + (34) * coeff[13][i] + (-11) * coeff[15][i] + (-44) * coeff[17][i] + (-30) * coeff[19][i] + (15) * coeff[21][i] + (45) * coeff[23][i] + (27) * coeff[25][i] + (-19) * coeff[27][i] + (-45) * coeff[29][i] + (-23) * coeff[31][i];
			O[6] = (36) * coeff[1][i] + (-15) * coeff[3][i] + (-45) * coeff[5][i] + (-11) * coeff[7][i] + (39) * coeff[9][i] + (34) * coeff[11][i] + (-19) * coeff[13][i] + (-45) * coeff[15][i] + (-7) * coeff[17][i] + (41) * coeff[19][i] + (30) * coeff[21][i] + (-23) * coeff[23][i] + (-44) * coeff[25][i] + (-2) * coeff[27][i] + (43) * coeff[29][i] + (27) * coeff[31][i];
			O[7] = (34) * coeff[1][i] + (-27) * coeff[3][i] + (-39) * coeff[5][i] + (19) * coeff[7][i] + (43) * coeff[9][i] + (-11) * coeff[11][i] + (-45) * coeff[13][i] + (2) * coeff[15][i] + (45) * coeff[17][i] + (7) * coeff[19][i] + (-44) * coeff[21][i] + (-15) * coeff[23][i] + (41) * coeff[25][i] + (23) * coeff[27][i] + (-36) * coeff[29][i] + (-30) * coeff[31][i];
			O[8] = (30) * coeff[1][i] + (-36) * coeff[3][i] + (-23) * coeff[5][i] + (41) * coeff[7][i] + (15) * coeff[9][i] + (-44) * coeff[11][i] + (-7) * coeff[13][i] + (45) * coeff[15][i] + (-2) * coeff[17][i] + (-45) * coeff[19][i] + (11) * coeff[21][i] + (43) * coeff[23][i] + (-19) * coeff[25][i] + (-39) * coeff[27][i] + (27) * coeff[29][i] + (34) * coeff[31][i];
			O[9] = (27) * coeff[1][i] + (-43) * coeff[3][i] + (-2) * coeff[5][i] + (44) * coeff[7][i] + (-23) * coeff[9][i] + (-30) * coeff[11][i] + (41) * coeff[13][i] + (7) * coeff[15][i] + (-45) * coeff[17][i] + (19) * coeff[19][i] + (34) * coeff[21][i] + (-39) * coeff[23][i] + (-11) * coeff[25][i] + (45) * coeff[27][i] + (-15) * coeff[29][i] + (-36) * coeff[31][i];
			O[10] = (23) * coeff[1][i] + (-45) * coeff[3][i] + (19) * coeff[5][i] + (27) * coeff[7][i] + (-45) * coeff[9][i] + (15) * coeff[11][i] + (30) * coeff[13][i] + (-44) * coeff[15][i] + (11) * coeff[17][i] + (34) * coeff[19][i] + (-43) * coeff[21][i] + (7) * coeff[23][i] + (36) * coeff[25][i] + (-41) * coeff[27][i] + (2) * coeff[29][i] + (39) * coeff[31][i];
			O[11] = (19) * coeff[1][i] + (-44) * coeff[3][i] + (36) * coeff[5][i] + (-2) * coeff[7][i] + (-34) * coeff[9][i] + (45) * coeff[11][i] + (-23) * coeff[13][i] + (-15) * coeff[15][i] + (43) * coeff[17][i] + (-39) * coeff[19][i] + (7) * coeff[21][i] + (30) * coeff[23][i] + (-45) * coeff[25][i] + (27) * coeff[27][i] + (11) * coeff[29][i] + (-41) * coeff[31][i];
			O[12] = (15) * coeff[1][i] + (-39) * coeff[3][i] + (45) * coeff[5][i] + (-30) * coeff[7][i] + (2) * coeff[9][i] + (27) * coeff[11][i] + (-44) * coeff[13][i] + (41) * coeff[15][i] + (-19) * coeff[17][i] + (-11) * coeff[19][i] + (36) * coeff[21][i] + (-45) * coeff[23][i] + (34) * coeff[25][i] + (-7) * coeff[27][i] + (-23) * coeff[29][i] + (43) * coeff[31][i];
			O[13] = (11) * coeff[1][i] + (-30) * coeff[3][i] + (43) * coeff[5][i] + (-45) * coeff[7][i] + (36) * coeff[9][i] + (-19) * coeff[11][i] + (-2) * coeff[13][i] + (23) * coeff[15][i] + (-39) * coeff[17][i] + (45) * coeff[19][i] + (-41) * coeff[21][i] + (27) * coeff[23][i] + (-7) * coeff[25][i] + (-15) * coeff[27][i] + (34) * coeff[29][i] + (-44) * coeff[31][i];
			O[14] = (7) * coeff[1][i] + (-19) * coeff[3][i] + (30) * coeff[5][i] + (-39) * coeff[7][i] + (44) * coeff[9][i] + (-45) * coeff[11][i] + (43) * coeff[13][i] + (-36) * coeff[15][i] + (27) * coeff[17][i] + (-15) * coeff[19][i] + (2) * coeff[21][i] + (11) * coeff[23][i] + (-23) * coeff[25][i] + (34) * coeff[27][i] + (-41) * coeff[29][i] + (45) * coeff[31][i];
			O[15] = (2) * coeff[1][i] + (-7) * coeff[3][i] + (11) * coeff[5][i] + (-15) * coeff[7][i] + (19) * coeff[9][i] + (-23) * coeff[11][i] + (27) * coeff[13][i] + (-30) * coeff[15][i] + (34) * coeff[17][i] + (-36) * coeff[19][i] + (39) * coeff[21][i] + (-41) * coeff[23][i] + (43) * coeff[25][i] + (-44) * coeff[27][i] + (45) * coeff[29][i] + (-45) * coeff[31][i];

			EO[0] = (45) * coeff[2][i] + (43) * coeff[6][i] + (40) * coeff[10][i] + (35) * coeff[14][i] + (29) * coeff[18][i] + (21) * coeff[22][i] + (13) * coeff[26][i] + (4) * coeff[30][i];
			EO[1] = (43) * coeff[2][i] + (29) * coeff[6][i] + (4) * coeff[10][i] + (-21) * coeff[14][i] + (-40) * coeff[18][i] + (-45) * coeff[22][i] + (-35) * coeff[26][i] + (-13) * coeff[30][i];
			EO[2] = (40) * coeff[2][i] + (4) * coeff[6][i] + (-35) * coeff[10][i] + (-43) * coeff[14][i] + (-13) * coeff[18][i] + (29) * coeff[22][i] + (45) * coeff[26][i] + (21) * coeff[30][i];
			EO[3] = (35) * coeff[2][i] + (-21) * coeff[6][i] + (-43) * coeff[10][i] + (4) * coeff[14][i] + (45) * coeff[18][i] + (13) * coeff[22][i] + (-40) * coeff[26][i] + (-29) * coeff[30][i];
			EO[4] = (29) * coeff[2][i] + (-40) * coeff[6][i] + (-13) * coeff[10][i] + (45) * coeff[14][i] + (-4) * coeff[18][i] + (-43) * coeff[22][i] + (21) * coeff[26][i] + (35) * coeff[30][i];
			EO[5] = (21) * coeff[2][i] + (-45) * coeff[6][i] + (29) * coeff[10][i] + (13) * coeff[14][i] + (-43) * coeff[18][i] + (35) * coeff[22][i] + (4) * coeff[26][i] + (-40) * coeff[30][i];
			EO[6] = (13) * coeff[2][i] + (-35) * coeff[6][i] + (45) * coeff[10][i] + (-40) * coeff[14][i] + (21) * coeff[18][i] + (4) * coeff[22][i] + (-29) * coeff[26][i] + (43) * coeff[30][i];
			EO[7] = (4) * coeff[2][i] + (-13) * coeff[6][i] + (21) * coeff[10][i] + (-29) * coeff[14][i] + (35) * coeff[18][i] + (-40) * coeff[22][i] + (43) * coeff[26][i] + (-45) * coeff[30][i];

			EEO[0] = (44) * coeff[4][i] + (38) * coeff[12][i] + (25) * coeff[20][i] + (9) * coeff[28][i];
			EEO[1] = (38) * coeff[4][i] + (-9) * coeff[12][i] + (-44) * coeff[20][i] + (-25) * coeff[28][i];
			EEO[2] = (25) * coeff[4][i] + (-44) * coeff[12][i] + (9) * coeff[20][i] + (38) * coeff[28][i];
			EEO[3] = (9) * coeff[4][i] + (-25) * coeff[12][i] + (38) * coeff[20][i] + (-44) * coeff[28][i];

			EEEO[0] = (42) * coeff[8][i] + (17) * coeff[24][i];
			EEEO[1] = (17) * coeff[8][i] + (-42) * coeff[24][i];
			EEEE[0] = (32) * coeff[0][i] + (32) * coeff[16][i];
			EEEE[1] = (32) * coeff[0][i] + (-32) * coeff[16][i];

			EEE[0] = EEEE[0] + EEEO[0];
			EEE[3] = EEEE[0] - EEEO[0];
			EEE[1] = EEEE[1] + EEEO[1];
			EEE[2] = EEEE[1] - EEEO[1];

			for (k = 0; k < 4; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 4] = EEE[3 - k] - EEO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 8] = EE[7 - k] - EO[7 - k];
			}

			if (i == 0)		  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 1)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 2)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 3)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 4)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 5)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 6)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 7)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 8)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 9)  {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 10) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 11) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 12) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 13) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 14) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 15) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 16) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 17) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 18) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 19) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 20) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 21) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 22) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 23) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 24) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 25) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 26) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 27) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 28) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 29) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 30) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
}
			else if (i == 31) {for (k = 0; k < 16; k++) {block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);}
			}
		}


	}
}

static void inv_dct_col_32_lite(U8 cu_width, U8 cu_height, s16 coeff[32][32], s16 block[32][32], U4 shift)
{
	U7 size = 32;
	U8 size_b = size - 1;

    if (cu_height == 16) {
		int E  [8], O  [8];
		int EE [4], EO [4];
		int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=O      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EE     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EO     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEE    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEO    dim=0 complete
		int rnd_factor = 1 << (shift - 1);
	//int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[1][i] + ( 43) * coeff[3][i] + ( 40) * coeff[5][i] + ( 35) * coeff[7][i] + ( 29) * coeff[9][i] + ( 21) * coeff[11][i] + ( 13) * coeff[13][i] + (  4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + ( 29) * coeff[3][i] + (  4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (  4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + ( 29) * coeff[11][i] + ( 45) * coeff[13][i] + ( 21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (  4) * coeff[7][i] + ( 45) * coeff[9][i] + ( 13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + ( 45) * coeff[7][i] + (-4 ) * coeff[9][i] + (-43) * coeff[11][i] + ( 21) * coeff[13][i] + ( 35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + ( 29) * coeff[5][i] + ( 13) * coeff[7][i] + (-43) * coeff[9][i] + ( 35) * coeff[11][i] + (  4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + ( 45) * coeff[5][i] + (-40) * coeff[7][i] + ( 21) * coeff[9][i] + (  4) * coeff[11][i] + (-29) * coeff[13][i] + ( 43) * coeff[15][i];
			O[7] = ( 4) * coeff[1][i] + (-13) * coeff[3][i] + ( 21) * coeff[5][i] + (-29) * coeff[7][i] + ( 35) * coeff[9][i] + (-40) * coeff[11][i] + ( 43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + ( 38) * coeff[6][i] + ( 25) * coeff[10][i] + (  9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9 ) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (  9) * coeff[10][i] + ( 38) * coeff[14][i];
			EO[3] = ( 9) * coeff[2][i] + (-25) * coeff[6][i] + ( 38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + ( 17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + ( 32) * coeff[ 8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[ 8][i];

			for (int k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (int k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (int k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
	else {
		int E   [16], O   [16];
		int EE  [ 8], EO  [ 8];
		int EEE [ 4], EEO [ 4];
		int EEEE[ 2], EEEO[ 2];
#pragma HLS ARRAY_PARTITION variable=E      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=O      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EE     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EO     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEE    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEO    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEEE   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEEO   dim=0 complete
		int rnd_factor = 1 << (shift - 1);
	//int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[ 0] = (45) * coeff[1][i] + ( 45) * coeff[3][i] + ( 44) * coeff[5][i] + ( 43) * coeff[7][i] + ( 41) * coeff[9][i] + ( 39) * coeff[11][i] + (36) * coeff[13][i] + (34) * coeff[15][i] + (30) * coeff[17][i] + (27) * coeff[19][i] + (23) * coeff[21][i] + (19) * coeff[23][i] + (15) * coeff[25][i] + (11) * coeff[27][i] + (7) * coeff[29][i] + (2) * coeff[31][i];
			O[ 1] = (45) * coeff[1][i] + ( 41) * coeff[3][i] + ( 34) * coeff[5][i] + ( 23) * coeff[7][i] + ( 11) * coeff[9][i] + (-2 ) * coeff[11][i] + (-15) * coeff[13][i] + (-27) * coeff[15][i] + (-36) * coeff[17][i] + (-43) * coeff[19][i] + (-45) * coeff[21][i] + (-44) * coeff[23][i] + (-39) * coeff[25][i] + (-30) * coeff[27][i] + (-19) * coeff[29][i] + (-7) * coeff[31][i];
			O[ 2] = (44) * coeff[1][i] + ( 34) * coeff[3][i] + ( 15) * coeff[5][i] + (-7 ) * coeff[7][i] + (-27) * coeff[9][i] + (-41) * coeff[11][i] + (-45) * coeff[13][i] + (-39) * coeff[15][i] + (-23) * coeff[17][i] + (-2) * coeff[19][i] + (19) * coeff[21][i] + (36) * coeff[23][i] + (45) * coeff[25][i] + (43) * coeff[27][i] + (30) * coeff[29][i] + (11) * coeff[31][i];
			O[ 3] = (43) * coeff[1][i] + ( 23) * coeff[3][i] + (-7 ) * coeff[5][i] + (-34) * coeff[7][i] + (-45) * coeff[9][i] + (-36) * coeff[11][i] + (-11) * coeff[13][i] + (19) * coeff[15][i] + (41) * coeff[17][i] + (44) * coeff[19][i] + (27) * coeff[21][i] + (-2) * coeff[23][i] + (-30) * coeff[25][i] + (-45) * coeff[27][i] + (-39) * coeff[29][i] + (-15) * coeff[31][i];
			O[ 4] = (41) * coeff[1][i] + ( 11) * coeff[3][i] + (-27) * coeff[5][i] + (-45) * coeff[7][i] + (-30) * coeff[9][i] + (  7) * coeff[11][i] + (39) * coeff[13][i] + (43) * coeff[15][i] + (15) * coeff[17][i] + (-23) * coeff[19][i] + (-45) * coeff[21][i] + (-34) * coeff[23][i] + (2) * coeff[25][i] + (36) * coeff[27][i] + (44) * coeff[29][i] + (19) * coeff[31][i];
			O[ 5] = (39) * coeff[1][i] + (-2 ) * coeff[3][i] + (-41) * coeff[5][i] + (-36) * coeff[7][i] + (  7) * coeff[9][i] + ( 43) * coeff[11][i] + (34) * coeff[13][i] + (-11) * coeff[15][i] + (-44) * coeff[17][i] + (-30) * coeff[19][i] + (15) * coeff[21][i] + (45) * coeff[23][i] + (27) * coeff[25][i] + (-19) * coeff[27][i] + (-45) * coeff[29][i] + (-23) * coeff[31][i];
			O[ 6] = (36) * coeff[1][i] + (-15) * coeff[3][i] + (-45) * coeff[5][i] + (-11) * coeff[7][i] + ( 39) * coeff[9][i] + ( 34) * coeff[11][i] + (-19) * coeff[13][i] + (-45) * coeff[15][i] + (-7) * coeff[17][i] + (41) * coeff[19][i] + (30) * coeff[21][i] + (-23) * coeff[23][i] + (-44) * coeff[25][i] + (-2) * coeff[27][i] + (43) * coeff[29][i] + (27) * coeff[31][i];
			O[ 7] = (34) * coeff[1][i] + (-27) * coeff[3][i] + (-39) * coeff[5][i] + ( 19) * coeff[7][i] + ( 43) * coeff[9][i] + (-11) * coeff[11][i] + (-45) * coeff[13][i] + (2) * coeff[15][i] + (45) * coeff[17][i] + (7) * coeff[19][i] + (-44) * coeff[21][i] + (-15) * coeff[23][i] + (41) * coeff[25][i] + (23) * coeff[27][i] + (-36) * coeff[29][i] + (-30) * coeff[31][i];
			O[ 8] = (30) * coeff[1][i] + (-36) * coeff[3][i] + (-23) * coeff[5][i] + ( 41) * coeff[7][i] + ( 15) * coeff[9][i] + (-44) * coeff[11][i] + (-7) * coeff[13][i] + (45) * coeff[15][i] + (-2) * coeff[17][i] + (-45) * coeff[19][i] + (11) * coeff[21][i] + (43) * coeff[23][i] + (-19) * coeff[25][i] + (-39) * coeff[27][i] + (27) * coeff[29][i] + (34) * coeff[31][i];
			O[ 9] = (27) * coeff[1][i] + (-43) * coeff[3][i] + (-2 ) * coeff[5][i] + ( 44) * coeff[7][i] + (-23) * coeff[9][i] + (-30) * coeff[11][i] + (41) * coeff[13][i] + (7) * coeff[15][i] + (-45) * coeff[17][i] + (19) * coeff[19][i] + (34) * coeff[21][i] + (-39) * coeff[23][i] + (-11) * coeff[25][i] + (45) * coeff[27][i] + (-15) * coeff[29][i] + (-36) * coeff[31][i];
			O[10] = (23) * coeff[1][i] + (-45) * coeff[3][i] + ( 19) * coeff[5][i] + ( 27) * coeff[7][i] + (-45) * coeff[9][i] + ( 15) * coeff[11][i] + (30) * coeff[13][i] + (-44) * coeff[15][i] + (11) * coeff[17][i] + (34) * coeff[19][i] + (-43) * coeff[21][i] + (7) * coeff[23][i] + (36) * coeff[25][i] + (-41) * coeff[27][i] + (2) * coeff[29][i] + (39) * coeff[31][i];
			O[11] = (19) * coeff[1][i] + (-44) * coeff[3][i] + ( 36) * coeff[5][i] + (-2 ) * coeff[7][i] + (-34) * coeff[9][i] + ( 45) * coeff[11][i] + (-23) * coeff[13][i] + (-15) * coeff[15][i] + (43) * coeff[17][i] + (-39) * coeff[19][i] + (7) * coeff[21][i] + (30) * coeff[23][i] + (-45) * coeff[25][i] + (27) * coeff[27][i] + (11) * coeff[29][i] + (-41) * coeff[31][i];
			O[12] = (15) * coeff[1][i] + (-39) * coeff[3][i] + ( 45) * coeff[5][i] + (-30) * coeff[7][i] + (  2) * coeff[9][i] + ( 27) * coeff[11][i] + (-44) * coeff[13][i] + (41) * coeff[15][i] + (-19) * coeff[17][i] + (-11) * coeff[19][i] + (36) * coeff[21][i] + (-45) * coeff[23][i] + (34) * coeff[25][i] + (-7) * coeff[27][i] + (-23) * coeff[29][i] + (43) * coeff[31][i];
			O[13] = (11) * coeff[1][i] + (-30) * coeff[3][i] + ( 43) * coeff[5][i] + (-45) * coeff[7][i] + ( 36) * coeff[9][i] + (-19) * coeff[11][i] + (-2) * coeff[13][i] + (23) * coeff[15][i] + (-39) * coeff[17][i] + (45) * coeff[19][i] + (-41) * coeff[21][i] + (27) * coeff[23][i] + (-7) * coeff[25][i] + (-15) * coeff[27][i] + (34) * coeff[29][i] + (-44) * coeff[31][i];
			O[14] = ( 7) * coeff[1][i] + (-19) * coeff[3][i] + ( 30) * coeff[5][i] + (-39) * coeff[7][i] + ( 44) * coeff[9][i] + (-45) * coeff[11][i] + (43) * coeff[13][i] + (-36) * coeff[15][i] + (27) * coeff[17][i] + (-15) * coeff[19][i] + (2) * coeff[21][i] + (11) * coeff[23][i] + (-23) * coeff[25][i] + (34) * coeff[27][i] + (-41) * coeff[29][i] + (45) * coeff[31][i];
			O[15] = ( 2) * coeff[1][i] + (-7 ) * coeff[3][i] + ( 11) * coeff[5][i] + (-15) * coeff[7][i] + ( 19) * coeff[9][i] + (-23) * coeff[11][i] + (27) * coeff[13][i] + (-30) * coeff[15][i] + (34) * coeff[17][i] + (-36) * coeff[19][i] + (39) * coeff[21][i] + (-41) * coeff[23][i] + (43) * coeff[25][i] + (-44) * coeff[27][i] + (45) * coeff[29][i] + (-45) * coeff[31][i];

			EO[0] = (45) * coeff[2][i] + ( 43) * coeff[6][i] + ( 40) * coeff[10][i] + ( 35) * coeff[14][i] + ( 29) * coeff[18][i] + ( 21) * coeff[22][i] + ( 13) * coeff[26][i] + (  4) * coeff[30][i];
			EO[1] = (43) * coeff[2][i] + ( 29) * coeff[6][i] + (  4) * coeff[10][i] + (-21) * coeff[14][i] + (-40) * coeff[18][i] + (-45) * coeff[22][i] + (-35) * coeff[26][i] + (-13) * coeff[30][i];
			EO[2] = (40) * coeff[2][i] + (  4) * coeff[6][i] + (-35) * coeff[10][i] + (-43) * coeff[14][i] + (-13) * coeff[18][i] + ( 29) * coeff[22][i] + ( 45) * coeff[26][i] + ( 21) * coeff[30][i];
			EO[3] = (35) * coeff[2][i] + (-21) * coeff[6][i] + (-43) * coeff[10][i] + (  4) * coeff[14][i] + ( 45) * coeff[18][i] + ( 13) * coeff[22][i] + (-40) * coeff[26][i] + (-29) * coeff[30][i];
			EO[4] = (29) * coeff[2][i] + (-40) * coeff[6][i] + (-13) * coeff[10][i] + ( 45) * coeff[14][i] + (-4 ) * coeff[18][i] + (-43) * coeff[22][i] + ( 21) * coeff[26][i] + ( 35) * coeff[30][i];
			EO[5] = (21) * coeff[2][i] + (-45) * coeff[6][i] + ( 29) * coeff[10][i] + ( 13) * coeff[14][i] + (-43) * coeff[18][i] + ( 35) * coeff[22][i] + (  4) * coeff[26][i] + (-40) * coeff[30][i];
			EO[6] = (13) * coeff[2][i] + (-35) * coeff[6][i] + ( 45) * coeff[10][i] + (-40) * coeff[14][i] + ( 21) * coeff[18][i] + (  4) * coeff[22][i] + (-29) * coeff[26][i] + ( 43) * coeff[30][i];
			EO[7] = ( 4) * coeff[2][i] + (-13) * coeff[6][i] + ( 21) * coeff[10][i] + (-29) * coeff[14][i] + ( 35) * coeff[18][i] + (-40) * coeff[22][i] + ( 43) * coeff[26][i] + (-45) * coeff[30][i];

			EEO[0] = (44) * coeff[4][i] + ( 38) * coeff[12][i] + ( 25) * coeff[20][i] + (  9) * coeff[28][i];
			EEO[1] = (38) * coeff[4][i] + (-9 ) * coeff[12][i] + (-44) * coeff[20][i] + (-25) * coeff[28][i];
			EEO[2] = (25) * coeff[4][i] + (-44) * coeff[12][i] + (  9) * coeff[20][i] + ( 38) * coeff[28][i];
			EEO[3] = ( 9) * coeff[4][i] + (-25) * coeff[12][i] + ( 38) * coeff[20][i] + (-44) * coeff[28][i];

			EEEO[0] = (42) * coeff[8][i] + ( 17) * coeff[24][i];
			EEEO[1] = (17) * coeff[8][i] + (-42) * coeff[24][i];
			EEEE[0] = (32) * coeff[0][i] + ( 32) * coeff[16][i];
			EEEE[1] = (32) * coeff[0][i] + (-32) * coeff[16][i];

			EEE[0] = EEEE[0] + EEEO[0];
			EEE[3] = EEEE[0] - EEEO[0];
			EEE[1] = EEEE[1] + EEEO[1];
			EEE[2] = EEEE[1] - EEEO[1];

			for (int k = 0; k < 4; k++) {
				EE[k    ] = EEE[k    ] + EEO[k    ];
				EE[k + 4] = EEE[3 - k] - EEO[3 - k];
			}
			for (int k = 0; k < 8; k++) {
				E[k    ] = EE[k    ] + EO[k    ];
				E[k + 8] = EE[7 - k] - EO[7 - k];
			}
			for (int k = 0; k < 16; k++) {
				block[(i + k     ) & size_b][k     ] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k     ] + O[k     ] + rnd_factor) >> shift);
				block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
			}
		}
	}
}
static void inv_dct_col_32_luma( s16 coeff[32][32], s16 block[32][32], U4 shift,U8 cu_height)

{
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=1
	U7 size = 32;
	U8 size_b = size - 1;

	
	if (cu_height == 8)
	{

		int E[4], O[4];
		int EE[2], EO[2];
#pragma HLS ARRAY_PARTITION variable = E complete dim = 1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];

			if (i == 0) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 1) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 2) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 3) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 4) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 5) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 6) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 7) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 8) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 9) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 10) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 11) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 12) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 13) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 14) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 15) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 16) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 17) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 18) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 19) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 20) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 21) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 22) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 23) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 24) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 25) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 26) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 27) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 28) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 29) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 30) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
			else if (i == 31) {
				for (k = 0; k < 4; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift); block[(i + k + 4) & 31][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift); }
			}
		}
	}
	else if (cu_height == 16)
	{

		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}

			if (i == 0) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 1) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 2) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 3) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 4) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 5) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 6) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 7) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 8) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 9) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 10) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 11) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 12) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 13) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 14) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 15) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 16) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 17) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 18) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 19) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 20) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 21) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 22) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 23) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 24) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 25) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 26) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 27) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 28) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 29) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 30) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
			else if (i == 31) {
				for (k = 0; k < 8; k++) { block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 8) & 31][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift); }
			}
		}
	}
	else {

		int E[16], O[16];
		int EE[8], EO[8];
		int EEE[4], EEO[4];
		int EEEE[2], EEEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=1
#pragma HLS ARRAY_PARTITION variable=O complete dim=1
#pragma HLS ARRAY_PARTITION variable=EE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEE complete dim=1
#pragma HLS ARRAY_PARTITION variable=EEEO complete dim=1
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[1][i] + (45) * coeff[3][i] + (44) * coeff[5][i] + (43) * coeff[7][i] + (41) * coeff[9][i] + (39) * coeff[11][i] + (36) * coeff[13][i] + (34) * coeff[15][i] + (30) * coeff[17][i] + (27) * coeff[19][i] + (23) * coeff[21][i] + (19) * coeff[23][i] + (15) * coeff[25][i] + (11) * coeff[27][i] + (7) * coeff[29][i] + (2) * coeff[31][i];
			O[1] = (45) * coeff[1][i] + (41) * coeff[3][i] + (34) * coeff[5][i] + (23) * coeff[7][i] + (11) * coeff[9][i] + (-2) * coeff[11][i] + (-15) * coeff[13][i] + (-27) * coeff[15][i] + (-36) * coeff[17][i] + (-43) * coeff[19][i] + (-45) * coeff[21][i] + (-44) * coeff[23][i] + (-39) * coeff[25][i] + (-30) * coeff[27][i] + (-19) * coeff[29][i] + (-7) * coeff[31][i];
			O[2] = (44) * coeff[1][i] + (34) * coeff[3][i] + (15) * coeff[5][i] + (-7) * coeff[7][i] + (-27) * coeff[9][i] + (-41) * coeff[11][i] + (-45) * coeff[13][i] + (-39) * coeff[15][i] + (-23) * coeff[17][i] + (-2) * coeff[19][i] + (19) * coeff[21][i] + (36) * coeff[23][i] + (45) * coeff[25][i] + (43) * coeff[27][i] + (30) * coeff[29][i] + (11) * coeff[31][i];
			O[3] = (43) * coeff[1][i] + (23) * coeff[3][i] + (-7) * coeff[5][i] + (-34) * coeff[7][i] + (-45) * coeff[9][i] + (-36) * coeff[11][i] + (-11) * coeff[13][i] + (19) * coeff[15][i] + (41) * coeff[17][i] + (44) * coeff[19][i] + (27) * coeff[21][i] + (-2) * coeff[23][i] + (-30) * coeff[25][i] + (-45) * coeff[27][i] + (-39) * coeff[29][i] + (-15) * coeff[31][i];
			O[4] = (41) * coeff[1][i] + (11) * coeff[3][i] + (-27) * coeff[5][i] + (-45) * coeff[7][i] + (-30) * coeff[9][i] + (7) * coeff[11][i] + (39) * coeff[13][i] + (43) * coeff[15][i] + (15) * coeff[17][i] + (-23) * coeff[19][i] + (-45) * coeff[21][i] + (-34) * coeff[23][i] + (2) * coeff[25][i] + (36) * coeff[27][i] + (44) * coeff[29][i] + (19) * coeff[31][i];
			O[5] = (39) * coeff[1][i] + (-2) * coeff[3][i] + (-41) * coeff[5][i] + (-36) * coeff[7][i] + (7) * coeff[9][i] + (43) * coeff[11][i] + (34) * coeff[13][i] + (-11) * coeff[15][i] + (-44) * coeff[17][i] + (-30) * coeff[19][i] + (15) * coeff[21][i] + (45) * coeff[23][i] + (27) * coeff[25][i] + (-19) * coeff[27][i] + (-45) * coeff[29][i] + (-23) * coeff[31][i];
			O[6] = (36) * coeff[1][i] + (-15) * coeff[3][i] + (-45) * coeff[5][i] + (-11) * coeff[7][i] + (39) * coeff[9][i] + (34) * coeff[11][i] + (-19) * coeff[13][i] + (-45) * coeff[15][i] + (-7) * coeff[17][i] + (41) * coeff[19][i] + (30) * coeff[21][i] + (-23) * coeff[23][i] + (-44) * coeff[25][i] + (-2) * coeff[27][i] + (43) * coeff[29][i] + (27) * coeff[31][i];
			O[7] = (34) * coeff[1][i] + (-27) * coeff[3][i] + (-39) * coeff[5][i] + (19) * coeff[7][i] + (43) * coeff[9][i] + (-11) * coeff[11][i] + (-45) * coeff[13][i] + (2) * coeff[15][i] + (45) * coeff[17][i] + (7) * coeff[19][i] + (-44) * coeff[21][i] + (-15) * coeff[23][i] + (41) * coeff[25][i] + (23) * coeff[27][i] + (-36) * coeff[29][i] + (-30) * coeff[31][i];
			O[8] = (30) * coeff[1][i] + (-36) * coeff[3][i] + (-23) * coeff[5][i] + (41) * coeff[7][i] + (15) * coeff[9][i] + (-44) * coeff[11][i] + (-7) * coeff[13][i] + (45) * coeff[15][i] + (-2) * coeff[17][i] + (-45) * coeff[19][i] + (11) * coeff[21][i] + (43) * coeff[23][i] + (-19) * coeff[25][i] + (-39) * coeff[27][i] + (27) * coeff[29][i] + (34) * coeff[31][i];
			O[9] = (27) * coeff[1][i] + (-43) * coeff[3][i] + (-2) * coeff[5][i] + (44) * coeff[7][i] + (-23) * coeff[9][i] + (-30) * coeff[11][i] + (41) * coeff[13][i] + (7) * coeff[15][i] + (-45) * coeff[17][i] + (19) * coeff[19][i] + (34) * coeff[21][i] + (-39) * coeff[23][i] + (-11) * coeff[25][i] + (45) * coeff[27][i] + (-15) * coeff[29][i] + (-36) * coeff[31][i];
			O[10] = (23) * coeff[1][i] + (-45) * coeff[3][i] + (19) * coeff[5][i] + (27) * coeff[7][i] + (-45) * coeff[9][i] + (15) * coeff[11][i] + (30) * coeff[13][i] + (-44) * coeff[15][i] + (11) * coeff[17][i] + (34) * coeff[19][i] + (-43) * coeff[21][i] + (7) * coeff[23][i] + (36) * coeff[25][i] + (-41) * coeff[27][i] + (2) * coeff[29][i] + (39) * coeff[31][i];
			O[11] = (19) * coeff[1][i] + (-44) * coeff[3][i] + (36) * coeff[5][i] + (-2) * coeff[7][i] + (-34) * coeff[9][i] + (45) * coeff[11][i] + (-23) * coeff[13][i] + (-15) * coeff[15][i] + (43) * coeff[17][i] + (-39) * coeff[19][i] + (7) * coeff[21][i] + (30) * coeff[23][i] + (-45) * coeff[25][i] + (27) * coeff[27][i] + (11) * coeff[29][i] + (-41) * coeff[31][i];
			O[12] = (15) * coeff[1][i] + (-39) * coeff[3][i] + (45) * coeff[5][i] + (-30) * coeff[7][i] + (2) * coeff[9][i] + (27) * coeff[11][i] + (-44) * coeff[13][i] + (41) * coeff[15][i] + (-19) * coeff[17][i] + (-11) * coeff[19][i] + (36) * coeff[21][i] + (-45) * coeff[23][i] + (34) * coeff[25][i] + (-7) * coeff[27][i] + (-23) * coeff[29][i] + (43) * coeff[31][i];
			O[13] = (11) * coeff[1][i] + (-30) * coeff[3][i] + (43) * coeff[5][i] + (-45) * coeff[7][i] + (36) * coeff[9][i] + (-19) * coeff[11][i] + (-2) * coeff[13][i] + (23) * coeff[15][i] + (-39) * coeff[17][i] + (45) * coeff[19][i] + (-41) * coeff[21][i] + (27) * coeff[23][i] + (-7) * coeff[25][i] + (-15) * coeff[27][i] + (34) * coeff[29][i] + (-44) * coeff[31][i];
			O[14] = (7) * coeff[1][i] + (-19) * coeff[3][i] + (30) * coeff[5][i] + (-39) * coeff[7][i] + (44) * coeff[9][i] + (-45) * coeff[11][i] + (43) * coeff[13][i] + (-36) * coeff[15][i] + (27) * coeff[17][i] + (-15) * coeff[19][i] + (2) * coeff[21][i] + (11) * coeff[23][i] + (-23) * coeff[25][i] + (34) * coeff[27][i] + (-41) * coeff[29][i] + (45) * coeff[31][i];
			O[15] = (2) * coeff[1][i] + (-7) * coeff[3][i] + (11) * coeff[5][i] + (-15) * coeff[7][i] + (19) * coeff[9][i] + (-23) * coeff[11][i] + (27) * coeff[13][i] + (-30) * coeff[15][i] + (34) * coeff[17][i] + (-36) * coeff[19][i] + (39) * coeff[21][i] + (-41) * coeff[23][i] + (43) * coeff[25][i] + (-44) * coeff[27][i] + (45) * coeff[29][i] + (-45) * coeff[31][i];

			EO[0] = (45) * coeff[2][i] + (43) * coeff[6][i] + (40) * coeff[10][i] + (35) * coeff[14][i] + (29) * coeff[18][i] + (21) * coeff[22][i] + (13) * coeff[26][i] + (4) * coeff[30][i];
			EO[1] = (43) * coeff[2][i] + (29) * coeff[6][i] + (4) * coeff[10][i] + (-21) * coeff[14][i] + (-40) * coeff[18][i] + (-45) * coeff[22][i] + (-35) * coeff[26][i] + (-13) * coeff[30][i];
			EO[2] = (40) * coeff[2][i] + (4) * coeff[6][i] + (-35) * coeff[10][i] + (-43) * coeff[14][i] + (-13) * coeff[18][i] + (29) * coeff[22][i] + (45) * coeff[26][i] + (21) * coeff[30][i];
			EO[3] = (35) * coeff[2][i] + (-21) * coeff[6][i] + (-43) * coeff[10][i] + (4) * coeff[14][i] + (45) * coeff[18][i] + (13) * coeff[22][i] + (-40) * coeff[26][i] + (-29) * coeff[30][i];
			EO[4] = (29) * coeff[2][i] + (-40) * coeff[6][i] + (-13) * coeff[10][i] + (45) * coeff[14][i] + (-4) * coeff[18][i] + (-43) * coeff[22][i] + (21) * coeff[26][i] + (35) * coeff[30][i];
			EO[5] = (21) * coeff[2][i] + (-45) * coeff[6][i] + (29) * coeff[10][i] + (13) * coeff[14][i] + (-43) * coeff[18][i] + (35) * coeff[22][i] + (4) * coeff[26][i] + (-40) * coeff[30][i];
			EO[6] = (13) * coeff[2][i] + (-35) * coeff[6][i] + (45) * coeff[10][i] + (-40) * coeff[14][i] + (21) * coeff[18][i] + (4) * coeff[22][i] + (-29) * coeff[26][i] + (43) * coeff[30][i];
			EO[7] = (4) * coeff[2][i] + (-13) * coeff[6][i] + (21) * coeff[10][i] + (-29) * coeff[14][i] + (35) * coeff[18][i] + (-40) * coeff[22][i] + (43) * coeff[26][i] + (-45) * coeff[30][i];

			EEO[0] = (44) * coeff[4][i] + (38) * coeff[12][i] + (25) * coeff[20][i] + (9) * coeff[28][i];
			EEO[1] = (38) * coeff[4][i] + (-9) * coeff[12][i] + (-44) * coeff[20][i] + (-25) * coeff[28][i];
			EEO[2] = (25) * coeff[4][i] + (-44) * coeff[12][i] + (9) * coeff[20][i] + (38) * coeff[28][i];
			EEO[3] = (9) * coeff[4][i] + (-25) * coeff[12][i] + (38) * coeff[20][i] + (-44) * coeff[28][i];

			EEEO[0] = (42) * coeff[8][i] + (17) * coeff[24][i];
			EEEO[1] = (17) * coeff[8][i] + (-42) * coeff[24][i];
			EEEE[0] = (32) * coeff[0][i] + (32) * coeff[16][i];
			EEEE[1] = (32) * coeff[0][i] + (-32) * coeff[16][i];

			EEE[0] = EEEE[0] + EEEO[0];
			EEE[3] = EEEE[0] - EEEO[0];
			EEE[1] = EEEE[1] + EEEO[1];
			EEE[2] = EEEE[1] - EEEO[1];

			for (k = 0; k < 4; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 4] = EEE[3 - k] - EEO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 8] = EE[7 - k] - EO[7 - k];
			}

			if (i == 0) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 1) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 2) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 3) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 4) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 5) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 6) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 7) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 8) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 9) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 10) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 11) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 12) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 13) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 14) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 15) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 16) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 17) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 18) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 19) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 20) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 21) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 22) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 23) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 24) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 25) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 26) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 27) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 28) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 29) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 30) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
			else if (i == 31) {
				for (k = 0; k < 16; k++) { block[(i + k) & size_b][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift); block[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift); }
			}
		}


	}
}
static void inv_dct_col_32xN_lite(s16 coeff[32][32], /*s16 block[32][32],*/s16 coef_temp[32][32], U4 shift, u8 cu_height)
{
    U7 size = 32;
    U8 size_b = size - 1;

    int E   [16], O   [16];
    int EE  [ 8], EO  [ 8];
    int EEE [ 4], EEO [ 4];
    int EEEE[ 2], EEEO[ 2];
#pragma HLS ARRAY_PARTITION variable=E      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=O      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EE     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EO     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEE    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEO    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEEE   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEEO   dim=0 complete

    int rnd_factor = 1 << (shift - 1);

    for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
        O[ 0] = (45) * coeff[1][i] + ( 45) * coeff[3][i] + ( 44) * coeff[5][i] + ( 43) * coeff[7][i] + ( 41) * coeff[9][i] + ( 39) * coeff[11][i] + ( 36) * coeff[13][i] + ( 34) * coeff[15][i] + ( 30) * coeff[17][i] + ( 27) * coeff[19][i] + ( 23) * coeff[21][i] + ( 19) * coeff[23][i] + ( 15) * coeff[25][i] + ( 11) * coeff[27][i] + (  7) * coeff[29][i] + (  2) * coeff[31][i];
        O[ 1] = (45) * coeff[1][i] + ( 41) * coeff[3][i] + ( 34) * coeff[5][i] + ( 23) * coeff[7][i] + ( 11) * coeff[9][i] + (-2 ) * coeff[11][i] + (-15) * coeff[13][i] + (-27) * coeff[15][i] + (-36) * coeff[17][i] + (-43) * coeff[19][i] + (-45) * coeff[21][i] + (-44) * coeff[23][i] + (-39) * coeff[25][i] + (-30) * coeff[27][i] + (-19) * coeff[29][i] + (-7 ) * coeff[31][i];
        O[ 2] = (44) * coeff[1][i] + ( 34) * coeff[3][i] + ( 15) * coeff[5][i] + (-7 ) * coeff[7][i] + (-27) * coeff[9][i] + (-41) * coeff[11][i] + (-45) * coeff[13][i] + (-39) * coeff[15][i] + (-23) * coeff[17][i] + (-2 ) * coeff[19][i] + ( 19) * coeff[21][i] + ( 36) * coeff[23][i] + ( 45) * coeff[25][i] + ( 43) * coeff[27][i] + ( 30) * coeff[29][i] + ( 11) * coeff[31][i];
        O[ 3] = (43) * coeff[1][i] + ( 23) * coeff[3][i] + (-7 ) * coeff[5][i] + (-34) * coeff[7][i] + (-45) * coeff[9][i] + (-36) * coeff[11][i] + (-11) * coeff[13][i] + ( 19) * coeff[15][i] + ( 41) * coeff[17][i] + ( 44) * coeff[19][i] + ( 27) * coeff[21][i] + (-2 ) * coeff[23][i] + (-30) * coeff[25][i] + (-45) * coeff[27][i] + (-39) * coeff[29][i] + (-15) * coeff[31][i];
        O[ 4] = (41) * coeff[1][i] + ( 11) * coeff[3][i] + (-27) * coeff[5][i] + (-45) * coeff[7][i] + (-30) * coeff[9][i] + (  7) * coeff[11][i] + ( 39) * coeff[13][i] + ( 43) * coeff[15][i] + ( 15) * coeff[17][i] + (-23) * coeff[19][i] + (-45) * coeff[21][i] + (-34) * coeff[23][i] + (  2) * coeff[25][i] + ( 36) * coeff[27][i] + ( 44) * coeff[29][i] + ( 19) * coeff[31][i];
        O[ 5] = (39) * coeff[1][i] + (-2 ) * coeff[3][i] + (-41) * coeff[5][i] + (-36) * coeff[7][i] + (  7) * coeff[9][i] + ( 43) * coeff[11][i] + ( 34) * coeff[13][i] + (-11) * coeff[15][i] + (-44) * coeff[17][i] + (-30) * coeff[19][i] + ( 15) * coeff[21][i] + ( 45) * coeff[23][i] + ( 27) * coeff[25][i] + (-19) * coeff[27][i] + (-45) * coeff[29][i] + (-23) * coeff[31][i];
        O[ 6] = (36) * coeff[1][i] + (-15) * coeff[3][i] + (-45) * coeff[5][i] + (-11) * coeff[7][i] + ( 39) * coeff[9][i] + ( 34) * coeff[11][i] + (-19) * coeff[13][i] + (-45) * coeff[15][i] + (-7 ) * coeff[17][i] + ( 41) * coeff[19][i] + ( 30) * coeff[21][i] + (-23) * coeff[23][i] + (-44) * coeff[25][i] + (-2 ) * coeff[27][i] + ( 43) * coeff[29][i] + ( 27) * coeff[31][i];
        O[ 7] = (34) * coeff[1][i] + (-27) * coeff[3][i] + (-39) * coeff[5][i] + ( 19) * coeff[7][i] + ( 43) * coeff[9][i] + (-11) * coeff[11][i] + (-45) * coeff[13][i] + (  2) * coeff[15][i] + ( 45) * coeff[17][i] + (  7) * coeff[19][i] + (-44) * coeff[21][i] + (-15) * coeff[23][i] + ( 41) * coeff[25][i] + ( 23) * coeff[27][i] + (-36) * coeff[29][i] + (-30) * coeff[31][i];
        O[ 8] = (30) * coeff[1][i] + (-36) * coeff[3][i] + (-23) * coeff[5][i] + ( 41) * coeff[7][i] + ( 15) * coeff[9][i] + (-44) * coeff[11][i] + (-7 ) * coeff[13][i] + ( 45) * coeff[15][i] + (-2 ) * coeff[17][i] + (-45) * coeff[19][i] + ( 11) * coeff[21][i] + ( 43) * coeff[23][i] + (-19) * coeff[25][i] + (-39) * coeff[27][i] + ( 27) * coeff[29][i] + ( 34) * coeff[31][i];
        O[ 9] = (27) * coeff[1][i] + (-43) * coeff[3][i] + (-2 ) * coeff[5][i] + ( 44) * coeff[7][i] + (-23) * coeff[9][i] + (-30) * coeff[11][i] + ( 41) * coeff[13][i] + (  7) * coeff[15][i] + (-45) * coeff[17][i] + ( 19) * coeff[19][i] + ( 34) * coeff[21][i] + (-39) * coeff[23][i] + (-11) * coeff[25][i] + ( 45) * coeff[27][i] + (-15) * coeff[29][i] + (-36) * coeff[31][i];
        O[10] = (23) * coeff[1][i] + (-45) * coeff[3][i] + ( 19) * coeff[5][i] + ( 27) * coeff[7][i] + (-45) * coeff[9][i] + ( 15) * coeff[11][i] + ( 30) * coeff[13][i] + (-44) * coeff[15][i] + ( 11) * coeff[17][i] + ( 34) * coeff[19][i] + (-43) * coeff[21][i] + (  7) * coeff[23][i] + ( 36) * coeff[25][i] + (-41) * coeff[27][i] + (  2) * coeff[29][i] + ( 39) * coeff[31][i];
        O[11] = (19) * coeff[1][i] + (-44) * coeff[3][i] + ( 36) * coeff[5][i] + (-2 ) * coeff[7][i] + (-34) * coeff[9][i] + ( 45) * coeff[11][i] + (-23) * coeff[13][i] + (-15) * coeff[15][i] + ( 43) * coeff[17][i] + (-39) * coeff[19][i] + (  7) * coeff[21][i] + ( 30) * coeff[23][i] + (-45) * coeff[25][i] + ( 27) * coeff[27][i] + ( 11) * coeff[29][i] + (-41) * coeff[31][i];
        O[12] = (15) * coeff[1][i] + (-39) * coeff[3][i] + ( 45) * coeff[5][i] + (-30) * coeff[7][i] + (  2) * coeff[9][i] + ( 27) * coeff[11][i] + (-44) * coeff[13][i] + ( 41) * coeff[15][i] + (-19) * coeff[17][i] + (-11) * coeff[19][i] + ( 36) * coeff[21][i] + (-45) * coeff[23][i] + ( 34) * coeff[25][i] + (-7 ) * coeff[27][i] + (-23) * coeff[29][i] + ( 43) * coeff[31][i];
        O[13] = (11) * coeff[1][i] + (-30) * coeff[3][i] + ( 43) * coeff[5][i] + (-45) * coeff[7][i] + ( 36) * coeff[9][i] + (-19) * coeff[11][i] + (-2 ) * coeff[13][i] + ( 23) * coeff[15][i] + (-39) * coeff[17][i] + ( 45) * coeff[19][i] + (-41) * coeff[21][i] + ( 27) * coeff[23][i] + (-7 ) * coeff[25][i] + (-15) * coeff[27][i] + ( 34) * coeff[29][i] + (-44) * coeff[31][i];
        O[14] = ( 7) * coeff[1][i] + (-19) * coeff[3][i] + ( 30) * coeff[5][i] + (-39) * coeff[7][i] + ( 44) * coeff[9][i] + (-45) * coeff[11][i] + ( 43) * coeff[13][i] + (-36) * coeff[15][i] + ( 27) * coeff[17][i] + (-15) * coeff[19][i] + (  2) * coeff[21][i] + ( 11) * coeff[23][i] + (-23) * coeff[25][i] + ( 34) * coeff[27][i] + (-41) * coeff[29][i] + ( 45) * coeff[31][i];
        O[15] = ( 2) * coeff[1][i] + (-7 ) * coeff[3][i] + ( 11) * coeff[5][i] + (-15) * coeff[7][i] + ( 19) * coeff[9][i] + (-23) * coeff[11][i] + ( 27) * coeff[13][i] + (-30) * coeff[15][i] + ( 34) * coeff[17][i] + (-36) * coeff[19][i] + ( 39) * coeff[21][i] + (-41) * coeff[23][i] + ( 43) * coeff[25][i] + (-44) * coeff[27][i] + ( 45) * coeff[29][i] + (-45) * coeff[31][i];

        EO[0] = (45) * coeff[2][i] + ( 43) * coeff[6][i] + ( 40) * coeff[10][i] + ( 35) * coeff[14][i] + ( 29) * coeff[18][i] + ( 21) * coeff[22][i] + ( 13) * coeff[26][i] + (  4) * coeff[30][i];
        EO[1] = (43) * coeff[2][i] + ( 29) * coeff[6][i] + (  4) * coeff[10][i] + (-21) * coeff[14][i] + (-40) * coeff[18][i] + (-45) * coeff[22][i] + (-35) * coeff[26][i] + (-13) * coeff[30][i];
        EO[2] = (40) * coeff[2][i] + (  4) * coeff[6][i] + (-35) * coeff[10][i] + (-43) * coeff[14][i] + (-13) * coeff[18][i] + ( 29) * coeff[22][i] + ( 45) * coeff[26][i] + ( 21) * coeff[30][i];
        EO[3] = (35) * coeff[2][i] + (-21) * coeff[6][i] + (-43) * coeff[10][i] + (  4) * coeff[14][i] + ( 45) * coeff[18][i] + ( 13) * coeff[22][i] + (-40) * coeff[26][i] + (-29) * coeff[30][i];
        EO[4] = (29) * coeff[2][i] + (-40) * coeff[6][i] + (-13) * coeff[10][i] + ( 45) * coeff[14][i] + (-4 ) * coeff[18][i] + (-43) * coeff[22][i] + ( 21) * coeff[26][i] + ( 35) * coeff[30][i];
        EO[5] = (21) * coeff[2][i] + (-45) * coeff[6][i] + ( 29) * coeff[10][i] + ( 13) * coeff[14][i] + (-43) * coeff[18][i] + ( 35) * coeff[22][i] + (  4) * coeff[26][i] + (-40) * coeff[30][i];
        EO[6] = (13) * coeff[2][i] + (-35) * coeff[6][i] + ( 45) * coeff[10][i] + (-40) * coeff[14][i] + ( 21) * coeff[18][i] + (  4) * coeff[22][i] + (-29) * coeff[26][i] + ( 43) * coeff[30][i];
        EO[7] = ( 4) * coeff[2][i] + (-13) * coeff[6][i] + ( 21) * coeff[10][i] + (-29) * coeff[14][i] + ( 35) * coeff[18][i] + (-40) * coeff[22][i] + ( 43) * coeff[26][i] + (-45) * coeff[30][i];

        EEO[0] = (44) * coeff[4][i] + ( 38) * coeff[12][i] + ( 25) * coeff[20][i] + (  9) * coeff[28][i];
        EEO[1] = (38) * coeff[4][i] + (-9 ) * coeff[12][i] + (-44) * coeff[20][i] + (-25) * coeff[28][i];
        EEO[2] = (25) * coeff[4][i] + (-44) * coeff[12][i] + (  9) * coeff[20][i] + ( 38) * coeff[28][i];
        EEO[3] = ( 9) * coeff[4][i] + (-25) * coeff[12][i] + ( 38) * coeff[20][i] + (-44) * coeff[28][i];

        EEEO[0] = (42) * coeff[8][i] + ( 17) * coeff[24][i];
        EEEO[1] = (17) * coeff[8][i] + (-42) * coeff[24][i];
        EEEE[0] = (32) * coeff[0][i] + ( 32) * coeff[16][i];
        EEEE[1] = (32) * coeff[0][i] + (-32) * coeff[16][i];

        EEE[0] = EEEE[0] + EEEO[0];
        EEE[3] = EEEE[0] - EEEO[0];
        EEE[1] = EEEE[1] + EEEO[1];
        EEE[2] = EEEE[1] - EEEO[1];

        for (int k = 0; k < 4; k++) {
            EE[k    ] = EEE[k    ] + EEO[k    ];
            EE[k + 4] = EEE[3 - k] - EEO[3 - k];
        }
        for (int k = 0; k < 8; k++) {
            E[k    ] = EE[k    ] + EO[k    ];
            E[k + 8] = EE[7 - k] - EO[7 - k];
        }
        for (int k = 0; k < 16; k++) {
			coef_temp[(i + k     ) & size_b][k     ] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k     ] + O[k     ] + rnd_factor) >> shift);
            coef_temp[(i + k + 16) & size_b][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
        }
    }
}
#if 0
static void inv_dct_col_32x16_lite(s16 coeff[32][32], s16 coef_temp[32][32], U4 shift)
{
	U7 size = 32;
	U8 size_b = size - 1;

	int E   [16], O   [16];
	int EE  [ 8], EO  [ 8];
	int EEE [ 4], EEO [ 4];
	int EEEE[ 2], EEEO[ 2];
#pragma HLS ARRAY_PARTITION variable=E      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=O      dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EE     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EO     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEE    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEO    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEEE   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEEO   dim=0 complete

	int rnd_factor = 1 << (shift - 1);

	for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		O[ 0] = (45) * coeff[1][i] + ( 45) * coeff[3][i] + ( 44) * coeff[5][i] + ( 43) * coeff[7][i] + ( 41) * coeff[9][i] + ( 39) * coeff[11][i] + ( 36) * coeff[13][i] + ( 34) * coeff[15][i] + ( 30) * coeff[17][i] + ( 27) * coeff[19][i] + ( 23) * coeff[21][i] + ( 19) * coeff[23][i] + ( 15) * coeff[25][i] + ( 11) * coeff[27][i] + (  7) * coeff[29][i] + (  2) * coeff[31][i];
		O[ 1] = (45) * coeff[1][i] + ( 41) * coeff[3][i] + ( 34) * coeff[5][i] + ( 23) * coeff[7][i] + ( 11) * coeff[9][i] + (-2 ) * coeff[11][i] + (-15) * coeff[13][i] + (-27) * coeff[15][i] + (-36) * coeff[17][i] + (-43) * coeff[19][i] + (-45) * coeff[21][i] + (-44) * coeff[23][i] + (-39) * coeff[25][i] + (-30) * coeff[27][i] + (-19) * coeff[29][i] + (-7 ) * coeff[31][i];
		O[ 2] = (44) * coeff[1][i] + ( 34) * coeff[3][i] + ( 15) * coeff[5][i] + (-7 ) * coeff[7][i] + (-27) * coeff[9][i] + (-41) * coeff[11][i] + (-45) * coeff[13][i] + (-39) * coeff[15][i] + (-23) * coeff[17][i] + (-2 ) * coeff[19][i] + ( 19) * coeff[21][i] + ( 36) * coeff[23][i] + ( 45) * coeff[25][i] + ( 43) * coeff[27][i] + ( 30) * coeff[29][i] + ( 11) * coeff[31][i];
		O[ 3] = (43) * coeff[1][i] + ( 23) * coeff[3][i] + (-7 ) * coeff[5][i] + (-34) * coeff[7][i] + (-45) * coeff[9][i] + (-36) * coeff[11][i] + (-11) * coeff[13][i] + ( 19) * coeff[15][i] + ( 41) * coeff[17][i] + ( 44) * coeff[19][i] + ( 27) * coeff[21][i] + (-2 ) * coeff[23][i] + (-30) * coeff[25][i] + (-45) * coeff[27][i] + (-39) * coeff[29][i] + (-15) * coeff[31][i];
		O[ 4] = (41) * coeff[1][i] + ( 11) * coeff[3][i] + (-27) * coeff[5][i] + (-45) * coeff[7][i] + (-30) * coeff[9][i] + (  7) * coeff[11][i] + ( 39) * coeff[13][i] + ( 43) * coeff[15][i] + ( 15) * coeff[17][i] + (-23) * coeff[19][i] + (-45) * coeff[21][i] + (-34) * coeff[23][i] + (  2) * coeff[25][i] + ( 36) * coeff[27][i] + ( 44) * coeff[29][i] + ( 19) * coeff[31][i];
		O[ 5] = (39) * coeff[1][i] + (-2 ) * coeff[3][i] + (-41) * coeff[5][i] + (-36) * coeff[7][i] + (  7) * coeff[9][i] + ( 43) * coeff[11][i] + ( 34) * coeff[13][i] + (-11) * coeff[15][i] + (-44) * coeff[17][i] + (-30) * coeff[19][i] + ( 15) * coeff[21][i] + ( 45) * coeff[23][i] + ( 27) * coeff[25][i] + (-19) * coeff[27][i] + (-45) * coeff[29][i] + (-23) * coeff[31][i];
		O[ 6] = (36) * coeff[1][i] + (-15) * coeff[3][i] + (-45) * coeff[5][i] + (-11) * coeff[7][i] + ( 39) * coeff[9][i] + ( 34) * coeff[11][i] + (-19) * coeff[13][i] + (-45) * coeff[15][i] + (-7 ) * coeff[17][i] + ( 41) * coeff[19][i] + ( 30) * coeff[21][i] + (-23) * coeff[23][i] + (-44) * coeff[25][i] + (-2 ) * coeff[27][i] + ( 43) * coeff[29][i] + ( 27) * coeff[31][i];
		O[ 7] = (34) * coeff[1][i] + (-27) * coeff[3][i] + (-39) * coeff[5][i] + ( 19) * coeff[7][i] + ( 43) * coeff[9][i] + (-11) * coeff[11][i] + (-45) * coeff[13][i] + (  2) * coeff[15][i] + ( 45) * coeff[17][i] + (  7) * coeff[19][i] + (-44) * coeff[21][i] + (-15) * coeff[23][i] + ( 41) * coeff[25][i] + ( 23) * coeff[27][i] + (-36) * coeff[29][i] + (-30) * coeff[31][i];
		O[ 8] = (30) * coeff[1][i] + (-36) * coeff[3][i] + (-23) * coeff[5][i] + ( 41) * coeff[7][i] + ( 15) * coeff[9][i] + (-44) * coeff[11][i] + (-7 ) * coeff[13][i] + ( 45) * coeff[15][i] + (-2 ) * coeff[17][i] + (-45) * coeff[19][i] + ( 11) * coeff[21][i] + ( 43) * coeff[23][i] + (-19) * coeff[25][i] + (-39) * coeff[27][i] + ( 27) * coeff[29][i] + ( 34) * coeff[31][i];
		O[ 9] = (27) * coeff[1][i] + (-43) * coeff[3][i] + (-2 ) * coeff[5][i] + ( 44) * coeff[7][i] + (-23) * coeff[9][i] + (-30) * coeff[11][i] + ( 41) * coeff[13][i] + (  7) * coeff[15][i] + (-45) * coeff[17][i] + ( 19) * coeff[19][i] + ( 34) * coeff[21][i] + (-39) * coeff[23][i] + (-11) * coeff[25][i] + ( 45) * coeff[27][i] + (-15) * coeff[29][i] + (-36) * coeff[31][i];
		O[10] = (23) * coeff[1][i] + (-45) * coeff[3][i] + ( 19) * coeff[5][i] + ( 27) * coeff[7][i] + (-45) * coeff[9][i] + ( 15) * coeff[11][i] + ( 30) * coeff[13][i] + (-44) * coeff[15][i] + ( 11) * coeff[17][i] + ( 34) * coeff[19][i] + (-43) * coeff[21][i] + (  7) * coeff[23][i] + ( 36) * coeff[25][i] + (-41) * coeff[27][i] + (  2) * coeff[29][i] + ( 39) * coeff[31][i];
		O[11] = (19) * coeff[1][i] + (-44) * coeff[3][i] + ( 36) * coeff[5][i] + (-2 ) * coeff[7][i] + (-34) * coeff[9][i] + ( 45) * coeff[11][i] + (-23) * coeff[13][i] + (-15) * coeff[15][i] + ( 43) * coeff[17][i] + (-39) * coeff[19][i] + (  7) * coeff[21][i] + ( 30) * coeff[23][i] + (-45) * coeff[25][i] + ( 27) * coeff[27][i] + ( 11) * coeff[29][i] + (-41) * coeff[31][i];
		O[12] = (15) * coeff[1][i] + (-39) * coeff[3][i] + ( 45) * coeff[5][i] + (-30) * coeff[7][i] + (  2) * coeff[9][i] + ( 27) * coeff[11][i] + (-44) * coeff[13][i] + ( 41) * coeff[15][i] + (-19) * coeff[17][i] + (-11) * coeff[19][i] + ( 36) * coeff[21][i] + (-45) * coeff[23][i] + ( 34) * coeff[25][i] + (-7 ) * coeff[27][i] + (-23) * coeff[29][i] + ( 43) * coeff[31][i];
		O[13] = (11) * coeff[1][i] + (-30) * coeff[3][i] + ( 43) * coeff[5][i] + (-45) * coeff[7][i] + ( 36) * coeff[9][i] + (-19) * coeff[11][i] + (-2 ) * coeff[13][i] + ( 23) * coeff[15][i] + (-39) * coeff[17][i] + ( 45) * coeff[19][i] + (-41) * coeff[21][i] + ( 27) * coeff[23][i] + (-7 ) * coeff[25][i] + (-15) * coeff[27][i] + ( 34) * coeff[29][i] + (-44) * coeff[31][i];
		O[14] = ( 7) * coeff[1][i] + (-19) * coeff[3][i] + ( 30) * coeff[5][i] + (-39) * coeff[7][i] + ( 44) * coeff[9][i] + (-45) * coeff[11][i] + ( 43) * coeff[13][i] + (-36) * coeff[15][i] + ( 27) * coeff[17][i] + (-15) * coeff[19][i] + (  2) * coeff[21][i] + ( 11) * coeff[23][i] + (-23) * coeff[25][i] + ( 34) * coeff[27][i] + (-41) * coeff[29][i] + ( 45) * coeff[31][i];
		O[15] = ( 2) * coeff[1][i] + (-7 ) * coeff[3][i] + ( 11) * coeff[5][i] + (-15) * coeff[7][i] + ( 19) * coeff[9][i] + (-23) * coeff[11][i] + ( 27) * coeff[13][i] + (-30) * coeff[15][i] + ( 34) * coeff[17][i] + (-36) * coeff[19][i] + ( 39) * coeff[21][i] + (-41) * coeff[23][i] + ( 43) * coeff[25][i] + (-44) * coeff[27][i] + ( 45) * coeff[29][i] + (-45) * coeff[31][i];

		EO[0] = (45) * coeff[2][i] + ( 43) * coeff[6][i] + ( 40) * coeff[10][i] + ( 35) * coeff[14][i] + ( 29) * coeff[18][i] + ( 21) * coeff[22][i] + ( 13) * coeff[26][i] + (  4) * coeff[30][i];
		EO[1] = (43) * coeff[2][i] + ( 29) * coeff[6][i] + (  4) * coeff[10][i] + (-21) * coeff[14][i] + (-40) * coeff[18][i] + (-45) * coeff[22][i] + (-35) * coeff[26][i] + (-13) * coeff[30][i];
		EO[2] = (40) * coeff[2][i] + (  4) * coeff[6][i] + (-35) * coeff[10][i] + (-43) * coeff[14][i] + (-13) * coeff[18][i] + ( 29) * coeff[22][i] + ( 45) * coeff[26][i] + ( 21) * coeff[30][i];
		EO[3] = (35) * coeff[2][i] + (-21) * coeff[6][i] + (-43) * coeff[10][i] + (  4) * coeff[14][i] + ( 45) * coeff[18][i] + ( 13) * coeff[22][i] + (-40) * coeff[26][i] + (-29) * coeff[30][i];
		EO[4] = (29) * coeff[2][i] + (-40) * coeff[6][i] + (-13) * coeff[10][i] + ( 45) * coeff[14][i] + (-4 ) * coeff[18][i] + (-43) * coeff[22][i] + ( 21) * coeff[26][i] + ( 35) * coeff[30][i];
		EO[5] = (21) * coeff[2][i] + (-45) * coeff[6][i] + ( 29) * coeff[10][i] + ( 13) * coeff[14][i] + (-43) * coeff[18][i] + ( 35) * coeff[22][i] + (  4) * coeff[26][i] + (-40) * coeff[30][i];
		EO[6] = (13) * coeff[2][i] + (-35) * coeff[6][i] + ( 45) * coeff[10][i] + (-40) * coeff[14][i] + ( 21) * coeff[18][i] + (  4) * coeff[22][i] + (-29) * coeff[26][i] + ( 43) * coeff[30][i];
		EO[7] = ( 4) * coeff[2][i] + (-13) * coeff[6][i] + ( 21) * coeff[10][i] + (-29) * coeff[14][i] + ( 35) * coeff[18][i] + (-40) * coeff[22][i] + ( 43) * coeff[26][i] + (-45) * coeff[30][i];

		EEO[0] = (44) * coeff[4][i] + ( 38) * coeff[12][i] + ( 25) * coeff[20][i] + (  9) * coeff[28][i];
		EEO[1] = (38) * coeff[4][i] + (-9 ) * coeff[12][i] + (-44) * coeff[20][i] + (-25) * coeff[28][i];
		EEO[2] = (25) * coeff[4][i] + (-44) * coeff[12][i] + (  9) * coeff[20][i] + ( 38) * coeff[28][i];
		EEO[3] = ( 9) * coeff[4][i] + (-25) * coeff[12][i] + ( 38) * coeff[20][i] + (-44) * coeff[28][i];

		EEEO[0] = (42) * coeff[8][i] + ( 17) * coeff[24][i];
		EEEO[1] = (17) * coeff[8][i] + (-42) * coeff[24][i];
		EEEE[0] = (32) * coeff[0][i] + ( 32) * coeff[16][i];
		EEEE[1] = (32) * coeff[0][i] + (-32) * coeff[16][i];

		EEE[0] = EEEE[0] + EEEO[0];
		EEE[3] = EEEE[0] - EEEO[0];
		EEE[1] = EEEE[1] + EEEO[1];
		EEE[2] = EEEE[1] - EEEO[1];

		for (int k = 0; k < 4; k++) {
			EE[k    ] = EEE[k    ] + EEO[k    ];
			EE[k + 4] = EEE[3 - k] - EEO[3 - k];
		}
		for (int k = 0; k < 8; k++) {
			E[k    ] = EE[k    ] + EO[k    ];
			E[k + 8] = EE[7 - k] - EO[7 - k];
		}
		for (int k = 0; k < 16; k++) {
			coef_temp[(i + k     ) & size_b][k   ] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k     ] + O[k     ] + rnd_factor) >> shift);
			coef_temp[(i + k + 16) & size_b][k+16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
		}
	}
}
#endif 

 void inv_dct_row_32(U8 cu_width, U8 cu_height, s16 coeff[32][32], s16 block[32][32], U4 shift)
{
#pragma HLS ARRAY_PARTITION variable=coeff complete dim=1
#pragma HLS ARRAY_PARTITION variable=block complete dim=2
	U7 size = 32;
	U8 size_b = size - 1;
	s16 coeff_tmp[32];
#pragma HLS ARRAY_PARTITION variable=coeff_tmp complete dim=0

	if (cu_width == 4)
	{

		int E[2], O[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (42) * coeff[(i+1)&31][i] + (17) * coeff[(i+3)&31][i];
			O[1] = (17) * coeff[(i+1)&31][i] + (-42) * coeff[(i+3)&31][i];
			E[0] = (32) * coeff[(i+0)&31][i] + (32) * coeff[(i+2)&31][i];
			E[1] = (32) * coeff[(i+0)&31][i] + (-32) * coeff[(i+2)&31][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_width == 8)
	{

		int E[4], O[4];
		int EE[2], EO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (44) * coeff[(i+1)&31][i] + (38) * coeff[(i+3)&31][i] + (25) * coeff[(i+5)&31][i] + (9) * coeff[(i+7)&31][i];
			O[1] = (38) * coeff[(i+1)&31][i] + (-9) * coeff[(i+3)&31][i] + (-44) * coeff[(i+5)&31][i] + (-25) * coeff[(i+7)&31][i];
			O[2] = (25) * coeff[(i+1)&31][i] + (-44) * coeff[(i+3)&31][i] + (9) * coeff[(i+5)&31][i] + (38) * coeff[(i+7)&31][i];
			O[3] = (9) * coeff[(i+1)&31][i] + (-25) * coeff[(i+3)&31][i] + (38) * coeff[(i+5)&31][i] + (-44) * coeff[(i+7)&31][i];

			EO[0] = (42) * coeff[(i+2)&31][i] + (17) * coeff[(i+6)&31][i];
			EO[1] = (17) * coeff[(i+2)&31][i] + (-42) * coeff[(i+6)&31][i];
			EE[0] = (32) * coeff[(i+0)&31][i] + (32) * coeff[(i+4)&31][i];
			EE[1] = (32) * coeff[(i+0)&31][i] + (-32) * coeff[(i+4)&31][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else if (cu_width == 16)
	{

		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			O[0] = (45) * coeff[(i+1)&31][i] + (43) * coeff[(i+3)&31][i] + (40) * coeff[(i+5)&31][i] + (35) * coeff[(i+7)&31][i] + (29) * coeff[(i+9)&31][i] + (21) * coeff[(i+11)&31][i] + (13) * coeff[(i+13)&31][i] + (4) * coeff[(i+15)&31][i];
			O[1] = (43) * coeff[(i+1)&31][i] + (29) * coeff[(i+3)&31][i] + (4) * coeff[(i+5)&31][i] + (-21) * coeff[(i+7)&31][i] + (-40) * coeff[(i+9)&31][i] + (-45) * coeff[(i+11)&31][i] + (-35) * coeff[(i+13)&31][i] + (-13) * coeff[(i+15)&31][i];
			O[2] = (40) * coeff[(i+1)&31][i] + (4) * coeff[(i+3)&31][i] + (-35) * coeff[(i+5)&31][i] + (-43) * coeff[(i+7)&31][i] + (-13) * coeff[(i+9)&31][i] + (29) * coeff[(i+11)&31][i] + (45) * coeff[(i+13)&31][i] + (21) * coeff[(i+15)&31][i];
			O[3] = (35) * coeff[(i+1)&31][i] + (-21) * coeff[(i+3)&31][i] + (-43) * coeff[(i+5)&31][i] + (4) * coeff[(i+7)&31][i] + (45) * coeff[(i+9)&31][i] + (13) * coeff[(i+11)&31][i] + (-40) * coeff[(i+13)&31][i] + (-29) * coeff[(i+15)&31][i];
			O[4] = (29) * coeff[(i+1)&31][i] + (-40) * coeff[(i+3)&31][i] + (-13) * coeff[(i+5)&31][i] + (45) * coeff[(i+7)&31][i] + (-4) * coeff[(i+9)&31][i] + (-43) * coeff[(i+11)&31][i] + (21) * coeff[(i+13)&31][i] + (35) * coeff[(i+15)&31][i];
			O[5] = (21) * coeff[(i+1)&31][i] + (-45) * coeff[(i+3)&31][i] + (29) * coeff[(i+5)&31][i] + (13) * coeff[(i+7)&31][i] + (-43) * coeff[(i+9)&31][i] + (35) * coeff[(i+11)&31][i] + (4) * coeff[(i+13)&31][i] + (-40) * coeff[(i+15)&31][i];
			O[6] = (13) * coeff[(i+1)&31][i] + (-35) * coeff[(i+3)&31][i] + (45) * coeff[(i+5)&31][i] + (-40) * coeff[(i+7)&31][i] + (21) * coeff[(i+9)&31][i] + (4) * coeff[(i+11)&31][i] + (-29) * coeff[(i+13)&31][i] + (43) * coeff[(i+15)&31][i];
			O[7] = (4) * coeff[(i+1)&31][i] + (-13) * coeff[(i+3)&31][i] + (21) * coeff[(i+5)&31][i] + (-29) * coeff[(i+7)&31][i] + (35) * coeff[(i+9)&31][i] + (-40) * coeff[(i+11)&31][i] + (43) * coeff[(i+13)&31][i] + (-45) * coeff[(i+15)&31][i];

			EO[0] = (44) * coeff[(i+2)&31][i] + (38) * coeff[(i+6)&31][i] + (25) * coeff[(i+10)&31][i] + (9) * coeff[(i+14)&31][i];
			EO[1] = (38) * coeff[(i+2)&31][i] + (-9) * coeff[(i+6)&31][i] + (-44) * coeff[(i+10)&31][i] + (-25) * coeff[(i+14)&31][i];
			EO[2] = (25) * coeff[(i+2)&31][i] + (-44) * coeff[(i+6)&31][i] + (9) * coeff[(i+10)&31][i] + (38) * coeff[(i+14)&31][i];
			EO[3] = (9) * coeff[(i+2)&31][i] + (-25) * coeff[(i+6)&31][i] + (38) * coeff[(i+10)&31][i] + (-44) * coeff[(i+14)&31][i];

			EEO[0] = (42) * coeff[(i+4)&31][i] + (17) * coeff[(i+12)&31][i];
			EEE[0] = (32) * coeff[(i+0)&31][i] + (32) * coeff[(i+8)&31][i];
			EEO[1] = (17) * coeff[(i+4)&31][i] + (-42) * coeff[(i+12)&31][i];
			EEE[1] = (32) * coeff[(i+0)&31][i] + (-32) * coeff[(i+8)&31][i];

			for (k = 0; k < 2; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
	else {

		static int E[16], O[16];
		int EE[8], EO[8];
		int EEE[4], EEO[4];
		int EEEE[2], EEEO[2];
#pragma HLS ARRAY_PARTITION variable=E complete dim=0
#pragma HLS ARRAY_PARTITION variable=O complete dim=0
#pragma HLS ARRAY_PARTITION variable=EE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEO complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEEE complete dim=0
#pragma HLS ARRAY_PARTITION variable=EEEO complete dim=0
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			if (i == 0)		  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 1)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 2)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 3)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 4)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 5)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 6)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 7)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 8)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 9)  {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 10) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 11) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 12) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 13) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 14) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 15) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 16) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 17) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 18) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 19) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 20) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 21) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 22) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 23) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 24) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 25) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 26) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 27) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 28) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 29) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 30) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			else if (i == 31) {for (int m = 0; m < 32;m++) {coeff_tmp[m] = coeff[(m + i) & size_b][i];}}
			O[0] = (45) * coeff_tmp[1] + (45) * coeff_tmp[3] + (44) * coeff_tmp[5] + (43) * coeff_tmp[7] + (41) * coeff_tmp[9] + (39) * coeff_tmp[11] + (36) * coeff_tmp[13] + (34) * coeff_tmp[15] + (30) * coeff_tmp[17] + (27) * coeff_tmp[19] + (23) * coeff_tmp[21] + (19) * coeff_tmp[23] + (15) * coeff_tmp[25] + (11) * coeff_tmp[27] + (7) * coeff_tmp[29] + (2) * coeff_tmp[31];
			O[1] = (45) * coeff_tmp[1] + (41) * coeff_tmp[3] + (34) * coeff_tmp[5] + (23) * coeff_tmp[7] + (11) * coeff_tmp[9] + (-2) * coeff_tmp[11] + (-15) * coeff_tmp[13] + (-27) * coeff_tmp[15] + (-36) * coeff_tmp[17] + (-43) * coeff_tmp[19] + (-45) * coeff_tmp[21] + (-44) * coeff_tmp[23] + (-39) * coeff_tmp[25] + (-30) * coeff_tmp[27] + (-19) * coeff_tmp[29] + (-7) * coeff_tmp[31];
			O[2] = (44) * coeff_tmp[1] + (34) * coeff_tmp[3] + (15) * coeff_tmp[5] + (-7) * coeff_tmp[7] + (-27) * coeff_tmp[9] + (-41) * coeff_tmp[11] + (-45) * coeff_tmp[13] + (-39) * coeff_tmp[15] + (-23) * coeff_tmp[17] + (-2) * coeff_tmp[19] + (19) * coeff_tmp[21] + (36) * coeff_tmp[23] + (45) * coeff_tmp[25] + (43) * coeff_tmp[27] + (30) * coeff_tmp[29] + (11) * coeff_tmp[31];
			O[3] = (43) * coeff_tmp[1] + (23) * coeff_tmp[3] + (-7) * coeff_tmp[5] + (-34) * coeff_tmp[7] + (-45) * coeff_tmp[9] + (-36) * coeff_tmp[11] + (-11) * coeff_tmp[13] + (19) * coeff_tmp[15] + (41) * coeff_tmp[17] + (44) * coeff_tmp[19] + (27) * coeff_tmp[21] + (-2) * coeff_tmp[23] + (-30) * coeff_tmp[25] + (-45) * coeff_tmp[27] + (-39) * coeff_tmp[29] + (-15) * coeff_tmp[31];
			O[4] = (41) * coeff_tmp[1] + (11) * coeff_tmp[3] + (-27) * coeff_tmp[5] + (-45) * coeff_tmp[7] + (-30) * coeff_tmp[9] + (7) * coeff_tmp[11] + (39) * coeff_tmp[13] + (43) * coeff_tmp[15] + (15) * coeff_tmp[17] + (-23) * coeff_tmp[19] + (-45) * coeff_tmp[21] + (-34) * coeff_tmp[23] + (2) * coeff_tmp[25] + (36) * coeff_tmp[27] + (44) * coeff_tmp[29] + (19) * coeff_tmp[31];
			O[5] = (39) * coeff_tmp[1] + (-2) * coeff_tmp[3] + (-41) * coeff_tmp[5] + (-36) * coeff_tmp[7] + (7) * coeff_tmp[9] + (43) * coeff_tmp[11] + (34) * coeff_tmp[13] + (-11) * coeff_tmp[15] + (-44) * coeff_tmp[17] + (-30) * coeff_tmp[19] + (15) * coeff_tmp[21] + (45) * coeff_tmp[23] + (27) * coeff_tmp[25] + (-19) * coeff_tmp[27] + (-45) * coeff_tmp[29] + (-23) * coeff_tmp[31];
			O[6] = (36) * coeff_tmp[1] + (-15) * coeff_tmp[3] + (-45) * coeff_tmp[5] + (-11) * coeff_tmp[7] + (39) * coeff_tmp[9] + (34) * coeff_tmp[11] + (-19) * coeff_tmp[13] + (-45) * coeff_tmp[15] + (-7) * coeff_tmp[17] + (41) * coeff_tmp[19] + (30) * coeff_tmp[21] + (-23) * coeff_tmp[23] + (-44) * coeff_tmp[25] + (-2) * coeff_tmp[27] + (43) * coeff_tmp[29] + (27) * coeff_tmp[31];
			O[7] = (34) * coeff_tmp[1] + (-27) * coeff_tmp[3] + (-39) * coeff_tmp[5] + (19) * coeff_tmp[7] + (43) * coeff_tmp[9] + (-11) * coeff_tmp[11] + (-45) * coeff_tmp[13] + (2) * coeff_tmp[15] + (45) * coeff_tmp[17] + (7) * coeff_tmp[19] + (-44) * coeff_tmp[21] + (-15) * coeff_tmp[23] + (41) * coeff_tmp[25] + (23) * coeff_tmp[27] + (-36) * coeff_tmp[29] + (-30) * coeff_tmp[31];
			O[8] = (30) * coeff_tmp[1] + (-36) * coeff_tmp[3] + (-23) * coeff_tmp[5] + (41) * coeff_tmp[7] + (15) * coeff_tmp[9] + (-44) * coeff_tmp[11] + (-7) * coeff_tmp[13] + (45) * coeff_tmp[15] + (-2) * coeff_tmp[17] + (-45) * coeff_tmp[19] + (11) * coeff_tmp[21] + (43) * coeff_tmp[23] + (-19) * coeff_tmp[25] + (-39) * coeff_tmp[27] + (27) * coeff_tmp[29] + (34) * coeff_tmp[31];
			O[9] = (27) * coeff_tmp[1] + (-43) * coeff_tmp[3] + (-2) * coeff_tmp[5] + (44) * coeff_tmp[7] + (-23) * coeff_tmp[9] + (-30) * coeff_tmp[11] + (41) * coeff_tmp[13] + (7) * coeff_tmp[15] + (-45) * coeff_tmp[17] + (19) * coeff_tmp[19] + (34) * coeff_tmp[21] + (-39) * coeff_tmp[23] + (-11) * coeff_tmp[25] + (45) * coeff_tmp[27] + (-15) * coeff_tmp[29] + (-36) * coeff_tmp[31];
			O[10] = (23) * coeff_tmp[1] + (-45) * coeff_tmp[3] + (19) * coeff_tmp[5] + (27) * coeff_tmp[7] + (-45) * coeff_tmp[9] + (15) * coeff_tmp[11] + (30) * coeff_tmp[13] + (-44) * coeff_tmp[15] + (11) * coeff_tmp[17] + (34) * coeff_tmp[19] + (-43) * coeff_tmp[21] + (7) * coeff_tmp[23] + (36) * coeff_tmp[25] + (-41) * coeff_tmp[27] + (2) * coeff_tmp[29] + (39) * coeff_tmp[31];
			O[11] = (19) * coeff_tmp[1] + (-44) * coeff_tmp[3] + (36) * coeff_tmp[5] + (-2) * coeff_tmp[7] + (-34) * coeff_tmp[9] + (45) * coeff_tmp[11] + (-23) * coeff_tmp[13] + (-15) * coeff_tmp[15] + (43) * coeff_tmp[17] + (-39) * coeff_tmp[19] + (7) * coeff_tmp[21] + (30) * coeff_tmp[23] + (-45) * coeff_tmp[25] + (27) * coeff_tmp[27] + (11) * coeff_tmp[29] + (-41) * coeff_tmp[31];
			O[12] = (15) * coeff_tmp[1] + (-39) * coeff_tmp[3] + (45) * coeff_tmp[5] + (-30) * coeff_tmp[7] + (2) * coeff_tmp[9] + (27) * coeff_tmp[11] + (-44) * coeff_tmp[13] + (41) * coeff_tmp[15] + (-19) * coeff_tmp[17] + (-11) * coeff_tmp[19] + (36) * coeff_tmp[21] + (-45) * coeff_tmp[23] + (34) * coeff_tmp[25] + (-7) * coeff_tmp[27] + (-23) * coeff_tmp[29] + (43) * coeff_tmp[31];
			O[13] = (11) * coeff_tmp[1] + (-30) * coeff_tmp[3] + (43) * coeff_tmp[5] + (-45) * coeff_tmp[7] + (36) * coeff_tmp[9] + (-19) * coeff_tmp[11] + (-2) * coeff_tmp[13] + (23) * coeff_tmp[15] + (-39) * coeff_tmp[17] + (45) * coeff_tmp[19] + (-41) * coeff_tmp[21] + (27) * coeff_tmp[23] + (-7) * coeff_tmp[25] + (-15) * coeff_tmp[27] + (34) * coeff_tmp[29] + (-44) * coeff_tmp[31];
			O[14] = (7) * coeff_tmp[1] + (-19) * coeff_tmp[3] + (30) * coeff_tmp[5] + (-39) * coeff_tmp[7] + (44) * coeff_tmp[9] + (-45) * coeff_tmp[11] + (43) * coeff_tmp[13] + (-36) * coeff_tmp[15] + (27) * coeff_tmp[17] + (-15) * coeff_tmp[19] + (2) * coeff_tmp[21] + (11) * coeff_tmp[23] + (-23) * coeff_tmp[25] + (34) * coeff_tmp[27] + (-41) * coeff_tmp[29] + (45) * coeff_tmp[31];
			O[15] = (2) * coeff_tmp[1] + (-7) * coeff_tmp[3] + (11) * coeff_tmp[5] + (-15) * coeff_tmp[7] + (19) * coeff_tmp[9] + (-23) * coeff_tmp[11] + (27) * coeff_tmp[13] + (-30) * coeff_tmp[15] + (34) * coeff_tmp[17] + (-36) * coeff_tmp[19] + (39) * coeff_tmp[21] + (-41) * coeff_tmp[23] + (43) * coeff_tmp[25] + (-44) * coeff_tmp[27] + (45) * coeff_tmp[29] + (-45) * coeff_tmp[31];

			EO[0] = (45) * coeff_tmp[2] + (43) * coeff_tmp[6] + (40) * coeff_tmp[10] + (35) * coeff_tmp[14] + (29) * coeff_tmp[18] + (21) * coeff_tmp[22] + (13) * coeff_tmp[26] + (4) * coeff_tmp[30];
			EO[1] = (43) * coeff_tmp[2] + (29) * coeff_tmp[6] + (4) * coeff_tmp[10] + (-21) * coeff_tmp[14] + (-40) * coeff_tmp[18] + (-45) * coeff_tmp[22] + (-35) * coeff_tmp[26] + (-13) * coeff_tmp[30];
			EO[2] = (40) * coeff_tmp[2] + (4) * coeff_tmp[6] + (-35) * coeff_tmp[10] + (-43) * coeff_tmp[14] + (-13) * coeff_tmp[18] + (29) * coeff_tmp[22] + (45) * coeff_tmp[26] + (21) * coeff_tmp[30];
			EO[3] = (35) * coeff_tmp[2] + (-21) * coeff_tmp[6] + (-43) * coeff_tmp[10] + (4) * coeff_tmp[14] + (45) * coeff_tmp[18] + (13) * coeff_tmp[22] + (-40) * coeff_tmp[26] + (-29) * coeff_tmp[30];
			EO[4] = (29) * coeff_tmp[2] + (-40) * coeff_tmp[6] + (-13) * coeff_tmp[10] + (45) * coeff_tmp[14] + (-4) * coeff_tmp[18] + (-43) * coeff_tmp[22] + (21) * coeff_tmp[26] + (35) * coeff_tmp[30];
			EO[5] = (21) * coeff_tmp[2] + (-45) * coeff_tmp[6] + (29) * coeff_tmp[10] + (13) * coeff_tmp[14] + (-43) * coeff_tmp[18] + (35) * coeff_tmp[22] + (4) * coeff_tmp[26] + (-40) * coeff_tmp[30];
			EO[6] = (13) * coeff_tmp[2] + (-35) * coeff_tmp[6] + (45) * coeff_tmp[10] + (-40) * coeff_tmp[14] + (21) * coeff_tmp[18] + (4) * coeff_tmp[22] + (-29) * coeff_tmp[26] + (43) * coeff_tmp[30];
			EO[7] = (4) * coeff_tmp[2] + (-13) * coeff_tmp[6] + (21) * coeff_tmp[10] + (-29) * coeff_tmp[14] + (35) * coeff_tmp[18] + (-40) * coeff_tmp[22] + (43) * coeff_tmp[26] + (-45) * coeff_tmp[30];

			EEO[0] = (44) * coeff_tmp[4] + (38) * coeff_tmp[12] + (25) * coeff_tmp[20] + (9) * coeff_tmp[28];
			EEO[1] = (38) * coeff_tmp[4] + (-9) * coeff_tmp[12] + (-44) * coeff_tmp[20] + (-25) * coeff_tmp[28];
			EEO[2] = (25) * coeff_tmp[4] + (-44) * coeff_tmp[12] + (9) * coeff_tmp[20] + (38) * coeff_tmp[28];
			EEO[3] = (9) * coeff_tmp[4] + (-25) * coeff_tmp[12] + (38) * coeff_tmp[20] + (-44) * coeff_tmp[28];

			EEEO[0] = (42) * coeff_tmp[8] + (17) * coeff_tmp[24];
			EEEO[1] = (17) * coeff_tmp[8] + (-42) * coeff_tmp[24];
			EEEE[0] = (32) * coeff_tmp[0] + (32) * coeff_tmp[16];
			EEEE[1] = (32) * coeff_tmp[0] + (-32) * coeff_tmp[16];
			EEE[0] = EEEE[0] + EEEO[0];
			EEE[3] = EEEE[0] - EEEO[0];
			EEE[1] = EEEE[1] + EEEO[1];
			EEE[2] = EEEE[1] - EEEO[1];
			for (k = 0; k < 4; k++) {
				EE[k] = EEE[k] + EEO[k];
				EE[k + 4] = EEE[3 - k] - EEO[3 - k];
			}
			for (k = 0; k < 8; k++) {
				E[k] = EE[k] + EO[k];
				E[k + 8] = EE[7 - k] - EO[7 - k];
			}
			for (k = 0; k < 16; k++) {
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
			}
		}
	}
}

static void inv_dct_row_32_lite(U8 cu_width, U8 cu_height, s16 coeff[32][32], s16 block[32][32], U4 shift)
{
	U7 size = 32;
	U8 size_b = size - 1;
    if (cu_width == 16) {
		static int E[8], O[8];
		int EE [4], EO [4];
		int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);

		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE 
			O[0] = (45) * coeff[1][i] + ( 43) * coeff[3][i] + ( 40) * coeff[5][i] + ( 35) * coeff[7][i] + ( 29) * coeff[9][i] + ( 21) * coeff[11][i] + ( 13) * coeff[13][i] + (  4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + ( 29) * coeff[3][i] + (  4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (  4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + ( 29) * coeff[11][i] + ( 45) * coeff[13][i] + ( 21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (  4) * coeff[7][i] + ( 45) * coeff[9][i] + ( 13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + ( 45) * coeff[7][i] + (-4 ) * coeff[9][i] + (-43) * coeff[11][i] + ( 21) * coeff[13][i] + ( 35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + ( 29) * coeff[5][i] + ( 13) * coeff[7][i] + (-43) * coeff[9][i] + ( 35) * coeff[11][i] + (  4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + ( 45) * coeff[5][i] + (-40) * coeff[7][i] + ( 21) * coeff[9][i] + (  4) * coeff[11][i] + (-29) * coeff[13][i] + ( 43) * coeff[15][i];
			O[7] = ( 4) * coeff[1][i] + (-13) * coeff[3][i] + ( 21) * coeff[5][i] + (-29) * coeff[7][i] + ( 35) * coeff[9][i] + (-40) * coeff[11][i] + ( 43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + ( 38) * coeff[6][i] + ( 25) * coeff[10][i] + (  9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9 ) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (  9) * coeff[10][i] + ( 38) * coeff[14][i];
			EO[3] = ( 9) * coeff[2][i] + (-25) * coeff[6][i] + ( 38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + ( 17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + ( 32) * coeff[ 8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[ 8][i];

		for (int k = 0; k < 2; k++) {
				EE[k    ] = EEE[k    ] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
		for (int k = 0; k < 4; k++) {
				E[k    ] = EE[k    ] + EO[k    ];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
		for (int k = 0; k < 8; k++) {
				block[i][k    ] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k    ] + O[k    ] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
    } else {
		static int E[16], O[16];
		int EE  [8], EO  [8];
		int EEE [4], EEO [4];
		int EEEE[2], EEEO[2];
		int rnd_factor = 1 << (shift - 1);

		for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE 
			O[ 0] = (45) * coeff[(1 + i) & size_b][i] + ( 45) * coeff[(3 + i) & size_b][i] + ( 44) * coeff[(5 + i) & size_b][i] + ( 43) * coeff[(7 + i) & size_b][i] + ( 41) * coeff[(9 + i) & size_b][i] + ( 39) * coeff[(11 + i) & size_b][i] + ( 36) * coeff[(13 + i) & size_b][i] + ( 34) * coeff[(15 + i) & size_b][i] + ( 30) * coeff[(17 + i) & size_b][i] + ( 27) * coeff[(19 + i) & size_b][i] + ( 23) * coeff[(21 + i) & size_b][i] + ( 19) * coeff[(23 + i) & size_b][i] + ( 15) * coeff[(25 + i) & size_b][i] + ( 11) * coeff[(27 + i) & size_b][i] + (  7) * coeff[(29 + i) & size_b][i] + (  2) * coeff[(31 + i) & size_b][i];
			O[ 1] = (45) * coeff[(1 + i) & size_b][i] + ( 41) * coeff[(3 + i) & size_b][i] + ( 34) * coeff[(5 + i) & size_b][i] + ( 23) * coeff[(7 + i) & size_b][i] + ( 11) * coeff[(9 + i) & size_b][i] + (-2 ) * coeff[(11 + i) & size_b][i] + (-15) * coeff[(13 + i) & size_b][i] + (-27) * coeff[(15 + i) & size_b][i] + (-36) * coeff[(17 + i) & size_b][i] + (-43) * coeff[(19 + i) & size_b][i] + (-45) * coeff[(21 + i) & size_b][i] + (-44) * coeff[(23 + i) & size_b][i] + (-39) * coeff[(25 + i) & size_b][i] + (-30) * coeff[(27 + i) & size_b][i] + (-19) * coeff[(29 + i) & size_b][i] + (-7 ) * coeff[(31 + i) & size_b][i];
			O[ 2] = (44) * coeff[(1 + i) & size_b][i] + ( 34) * coeff[(3 + i) & size_b][i] + ( 15) * coeff[(5 + i) & size_b][i] + (-7 ) * coeff[(7 + i) & size_b][i] + (-27) * coeff[(9 + i) & size_b][i] + (-41) * coeff[(11 + i) & size_b][i] + (-45) * coeff[(13 + i) & size_b][i] + (-39) * coeff[(15 + i) & size_b][i] + (-23) * coeff[(17 + i) & size_b][i] + (-2 ) * coeff[(19 + i) & size_b][i] + ( 19) * coeff[(21 + i) & size_b][i] + ( 36) * coeff[(23 + i) & size_b][i] + ( 45) * coeff[(25 + i) & size_b][i] + ( 43) * coeff[(27 + i) & size_b][i] + ( 30) * coeff[(29 + i) & size_b][i] + ( 11) * coeff[(31 + i) & size_b][i];
			O[ 3] = (43) * coeff[(1 + i) & size_b][i] + ( 23) * coeff[(3 + i) & size_b][i] + (-7 ) * coeff[(5 + i) & size_b][i] + (-34) * coeff[(7 + i) & size_b][i] + (-45) * coeff[(9 + i) & size_b][i] + (-36) * coeff[(11 + i) & size_b][i] + (-11) * coeff[(13 + i) & size_b][i] + ( 19) * coeff[(15 + i) & size_b][i] + ( 41) * coeff[(17 + i) & size_b][i] + ( 44) * coeff[(19 + i) & size_b][i] + ( 27) * coeff[(21 + i) & size_b][i] + (- 2) * coeff[(23 + i) & size_b][i] + (-30) * coeff[(25 + i) & size_b][i] + (-45) * coeff[(27 + i) & size_b][i] + (-39) * coeff[(29 + i) & size_b][i] + (-15) * coeff[(31 + i) & size_b][i];
			O[ 4] = (41) * coeff[(1 + i) & size_b][i] + ( 11) * coeff[(3 + i) & size_b][i] + (-27) * coeff[(5 + i) & size_b][i] + (-45) * coeff[(7 + i) & size_b][i] + (-30) * coeff[(9 + i) & size_b][i] + (  7) * coeff[(11 + i) & size_b][i] + ( 39) * coeff[(13 + i) & size_b][i] + ( 43) * coeff[(15 + i) & size_b][i] + ( 15) * coeff[(17 + i) & size_b][i] + (-23) * coeff[(19 + i) & size_b][i] + (-45) * coeff[(21 + i) & size_b][i] + (-34) * coeff[(23 + i) & size_b][i] + (  2) * coeff[(25 + i) & size_b][i] + ( 36) * coeff[(27 + i) & size_b][i] + ( 44) * coeff[(29 + i) & size_b][i] + ( 19) * coeff[(31 + i) & size_b][i];
			O[ 5] = (39) * coeff[(1 + i) & size_b][i] + (-2 ) * coeff[(3 + i) & size_b][i] + (-41) * coeff[(5 + i) & size_b][i] + (-36) * coeff[(7 + i) & size_b][i] + (  7) * coeff[(9 + i) & size_b][i] + ( 43) * coeff[(11 + i) & size_b][i] + ( 34) * coeff[(13 + i) & size_b][i] + (-11) * coeff[(15 + i) & size_b][i] + (-44) * coeff[(17 + i) & size_b][i] + (-30) * coeff[(19 + i) & size_b][i] + ( 15) * coeff[(21 + i) & size_b][i] + ( 45) * coeff[(23 + i) & size_b][i] + ( 27) * coeff[(25 + i) & size_b][i] + (-19) * coeff[(27 + i) & size_b][i] + (-45) * coeff[(29 + i) & size_b][i] + (-23) * coeff[(31 + i) & size_b][i];
			O[ 6] = (36) * coeff[(1 + i) & size_b][i] + (-15) * coeff[(3 + i) & size_b][i] + (-45) * coeff[(5 + i) & size_b][i] + (-11) * coeff[(7 + i) & size_b][i] + ( 39) * coeff[(9 + i) & size_b][i] + ( 34) * coeff[(11 + i) & size_b][i] + (-19) * coeff[(13 + i) & size_b][i] + (-45) * coeff[(15 + i) & size_b][i] + (-7 ) * coeff[(17 + i) & size_b][i] + ( 41) * coeff[(19 + i) & size_b][i] + ( 30) * coeff[(21 + i) & size_b][i] + (-23) * coeff[(23 + i) & size_b][i] + (-44) * coeff[(25 + i) & size_b][i] + (-2 ) * coeff[(27 + i) & size_b][i] + ( 43) * coeff[(29 + i) & size_b][i] + ( 27) * coeff[(31 + i) & size_b][i];
			O[ 7] = (34) * coeff[(1 + i) & size_b][i] + (-27) * coeff[(3 + i) & size_b][i] + (-39) * coeff[(5 + i) & size_b][i] + ( 19) * coeff[(7 + i) & size_b][i] + ( 43) * coeff[(9 + i) & size_b][i] + (-11) * coeff[(11 + i) & size_b][i] + (-45) * coeff[(13 + i) & size_b][i] + (  2) * coeff[(15 + i) & size_b][i] + ( 45) * coeff[(17 + i) & size_b][i] + (  7) * coeff[(19 + i) & size_b][i] + (-44) * coeff[(21 + i) & size_b][i] + (-15) * coeff[(23 + i) & size_b][i] + ( 41) * coeff[(25 + i) & size_b][i] + ( 23) * coeff[(27 + i) & size_b][i] + (-36) * coeff[(29 + i) & size_b][i] + (-30) * coeff[(31 + i) & size_b][i];
			O[ 8] = (30) * coeff[(1 + i) & size_b][i] + (-36) * coeff[(3 + i) & size_b][i] + (-23) * coeff[(5 + i) & size_b][i] + ( 41) * coeff[(7 + i) & size_b][i] + ( 15) * coeff[(9 + i) & size_b][i] + (-44) * coeff[(11 + i) & size_b][i] + (-7 ) * coeff[(13 + i) & size_b][i] + ( 45) * coeff[(15 + i) & size_b][i] + (-2 ) * coeff[(17 + i) & size_b][i] + (-45) * coeff[(19 + i) & size_b][i] + ( 11) * coeff[(21 + i) & size_b][i] + ( 43) * coeff[(23 + i) & size_b][i] + (-19) * coeff[(25 + i) & size_b][i] + (-39) * coeff[(27 + i) & size_b][i] + ( 27) * coeff[(29 + i) & size_b][i] + ( 34) * coeff[(31 + i) & size_b][i];
			O[ 9] = (27) * coeff[(1 + i) & size_b][i] + (-43) * coeff[(3 + i) & size_b][i] + (-2 ) * coeff[(5 + i) & size_b][i] + ( 44) * coeff[(7 + i) & size_b][i] + (-23) * coeff[(9 + i) & size_b][i] + (-30) * coeff[(11 + i) & size_b][i] + ( 41) * coeff[(13 + i) & size_b][i] + (  7) * coeff[(15 + i) & size_b][i] + (-45) * coeff[(17 + i) & size_b][i] + ( 19) * coeff[(19 + i) & size_b][i] + ( 34) * coeff[(21 + i) & size_b][i] + (-39) * coeff[(23 + i) & size_b][i] + (-11) * coeff[(25 + i) & size_b][i] + ( 45) * coeff[(27 + i) & size_b][i] + (-15) * coeff[(29 + i) & size_b][i] + (-36) * coeff[(31 + i) & size_b][i];
			O[10] = (23) * coeff[(1 + i) & size_b][i] + (-45) * coeff[(3 + i) & size_b][i] + ( 19) * coeff[(5 + i) & size_b][i] + ( 27) * coeff[(7 + i) & size_b][i] + (-45) * coeff[(9 + i) & size_b][i] + ( 15) * coeff[(11 + i) & size_b][i] + ( 30) * coeff[(13 + i) & size_b][i] + (-44) * coeff[(15 + i) & size_b][i] + ( 11) * coeff[(17 + i) & size_b][i] + ( 34) * coeff[(19 + i) & size_b][i] + (-43) * coeff[(21 + i) & size_b][i] + (  7) * coeff[(23 + i) & size_b][i] + ( 36) * coeff[(25 + i) & size_b][i] + (-41) * coeff[(27 + i) & size_b][i] + (  2) * coeff[(29 + i) & size_b][i] + ( 39) * coeff[(31 + i) & size_b][i];
			O[11] = (19) * coeff[(1 + i) & size_b][i] + (-44) * coeff[(3 + i) & size_b][i] + ( 36) * coeff[(5 + i) & size_b][i] + (-2 ) * coeff[(7 + i) & size_b][i] + (-34) * coeff[(9 + i) & size_b][i] + ( 45) * coeff[(11 + i) & size_b][i] + (-23) * coeff[(13 + i) & size_b][i] + (-15) * coeff[(15 + i) & size_b][i] + ( 43) * coeff[(17 + i) & size_b][i] + (-39) * coeff[(19 + i) & size_b][i] + (  7) * coeff[(21 + i) & size_b][i] + ( 30) * coeff[(23 + i) & size_b][i] + (-45) * coeff[(25 + i) & size_b][i] + ( 27) * coeff[(27 + i) & size_b][i] + ( 11) * coeff[(29 + i) & size_b][i] + (-41) * coeff[(31 + i) & size_b][i];
			O[12] = (15) * coeff[(1 + i) & size_b][i] + (-39) * coeff[(3 + i) & size_b][i] + ( 45) * coeff[(5 + i) & size_b][i] + (-30) * coeff[(7 + i) & size_b][i] + (  2) * coeff[(9 + i) & size_b][i] + ( 27) * coeff[(11 + i) & size_b][i] + (-44) * coeff[(13 + i) & size_b][i] + ( 41) * coeff[(15 + i) & size_b][i] + (-19) * coeff[(17 + i) & size_b][i] + (-11) * coeff[(19 + i) & size_b][i] + ( 36) * coeff[(21 + i) & size_b][i] + (-45) * coeff[(23 + i) & size_b][i] + ( 34) * coeff[(25 + i) & size_b][i] + (-7 ) * coeff[(27 + i) & size_b][i] + (-23) * coeff[(29 + i) & size_b][i] + ( 43) * coeff[(31 + i) & size_b][i];
			O[13] = (11) * coeff[(1 + i) & size_b][i] + (-30) * coeff[(3 + i) & size_b][i] + ( 43) * coeff[(5 + i) & size_b][i] + (-45) * coeff[(7 + i) & size_b][i] + ( 36) * coeff[(9 + i) & size_b][i] + (-19) * coeff[(11 + i) & size_b][i] + (-2 ) * coeff[(13 + i) & size_b][i] + ( 23) * coeff[(15 + i) & size_b][i] + (-39) * coeff[(17 + i) & size_b][i] + ( 45) * coeff[(19 + i) & size_b][i] + (-41) * coeff[(21 + i) & size_b][i] + ( 27) * coeff[(23 + i) & size_b][i] + (-7 ) * coeff[(25 + i) & size_b][i] + (-15) * coeff[(27 + i) & size_b][i] + ( 34) * coeff[(29 + i) & size_b][i] + (-44) * coeff[(31 + i) & size_b][i];
			O[14] = ( 7) * coeff[(1 + i) & size_b][i] + (-19) * coeff[(3 + i) & size_b][i] + ( 30) * coeff[(5 + i) & size_b][i] + (-39) * coeff[(7 + i) & size_b][i] + ( 44) * coeff[(9 + i) & size_b][i] + (-45) * coeff[(11 + i) & size_b][i] + ( 43) * coeff[(13 + i) & size_b][i] + (-36) * coeff[(15 + i) & size_b][i] + ( 27) * coeff[(17 + i) & size_b][i] + (-15) * coeff[(19 + i) & size_b][i] + (  2) * coeff[(21 + i) & size_b][i] + ( 11) * coeff[(23 + i) & size_b][i] + (-23) * coeff[(25 + i) & size_b][i] + ( 34) * coeff[(27 + i) & size_b][i] + (-41) * coeff[(29 + i) & size_b][i] + ( 45) * coeff[(31 + i) & size_b][i];
			O[15] = ( 2) * coeff[(1 + i) & size_b][i] + (-7 ) * coeff[(3 + i) & size_b][i] + ( 11) * coeff[(5 + i) & size_b][i] + (-15) * coeff[(7 + i) & size_b][i] + ( 19) * coeff[(9 + i) & size_b][i] + (-23) * coeff[(11 + i) & size_b][i] + ( 27) * coeff[(13 + i) & size_b][i] + (-30) * coeff[(15 + i) & size_b][i] + ( 34) * coeff[(17 + i) & size_b][i] + (-36) * coeff[(19 + i) & size_b][i] + ( 39) * coeff[(21 + i) & size_b][i] + (-41) * coeff[(23 + i) & size_b][i] + ( 43) * coeff[(25 + i) & size_b][i] + (-44) * coeff[(27 + i) & size_b][i] + ( 45) * coeff[(29 + i) & size_b][i] + (-45) * coeff[(31 + i) & size_b][i];

			EO[0] = (45) * coeff[(2 + i) & size_b][i] + ( 43) * coeff[(6 + i) & size_b][i] + ( 40) * coeff[(10 + i) & size_b][i] + ( 35) * coeff[(14 + i) & size_b][i] + ( 29) * coeff[(18 + i) & size_b][i] + ( 21) * coeff[(22 + i) & size_b][i] + ( 13) * coeff[(26 + i) & size_b][i] + (  4) * coeff[(30 + i) & size_b][i];
			EO[1] = (43) * coeff[(2 + i) & size_b][i] + ( 29) * coeff[(6 + i) & size_b][i] + (  4) * coeff[(10 + i) & size_b][i] + (-21) * coeff[(14 + i) & size_b][i] + (-40) * coeff[(18 + i) & size_b][i] + (-45) * coeff[(22 + i) & size_b][i] + (-35) * coeff[(26 + i) & size_b][i] + (-13) * coeff[(30 + i) & size_b][i];
			EO[2] = (40) * coeff[(2 + i) & size_b][i] + (  4) * coeff[(6 + i) & size_b][i] + (-35) * coeff[(10 + i) & size_b][i] + (-43) * coeff[(14 + i) & size_b][i] + (-13) * coeff[(18 + i) & size_b][i] + ( 29) * coeff[(22 + i) & size_b][i] + ( 45) * coeff[(26 + i) & size_b][i] + ( 21) * coeff[(30 + i) & size_b][i];
			EO[3] = (35) * coeff[(2 + i) & size_b][i] + (-21) * coeff[(6 + i) & size_b][i] + (-43) * coeff[(10 + i) & size_b][i] + (  4) * coeff[(14 + i) & size_b][i] + ( 45) * coeff[(18 + i) & size_b][i] + ( 13) * coeff[(22 + i) & size_b][i] + (-40) * coeff[(26 + i) & size_b][i] + (-29) * coeff[(30 + i) & size_b][i];
			EO[4] = (29) * coeff[(2 + i) & size_b][i] + (-40) * coeff[(6 + i) & size_b][i] + (-13) * coeff[(10 + i) & size_b][i] + ( 45) * coeff[(14 + i) & size_b][i] + (-4 ) * coeff[(18 + i) & size_b][i] + (-43) * coeff[(22 + i) & size_b][i] + ( 21) * coeff[(26 + i) & size_b][i] + ( 35) * coeff[(30 + i) & size_b][i];
			EO[5] = (21) * coeff[(2 + i) & size_b][i] + (-45) * coeff[(6 + i) & size_b][i] + ( 29) * coeff[(10 + i) & size_b][i] + ( 13) * coeff[(14 + i) & size_b][i] + (-43) * coeff[(18 + i) & size_b][i] + ( 35) * coeff[(22 + i) & size_b][i] + (  4) * coeff[(26 + i) & size_b][i] + (-40) * coeff[(30 + i) & size_b][i];
			EO[6] = (13) * coeff[(2 + i) & size_b][i] + (-35) * coeff[(6 + i) & size_b][i] + ( 45) * coeff[(10 + i) & size_b][i] + (-40) * coeff[(14 + i) & size_b][i] + ( 21) * coeff[(18 + i) & size_b][i] + (  4) * coeff[(22 + i) & size_b][i] + (-29) * coeff[(26 + i) & size_b][i] + ( 43) * coeff[(30 + i) & size_b][i];
			EO[7] = ( 4) * coeff[(2 + i) & size_b][i] + (-13) * coeff[(6 + i) & size_b][i] + ( 21) * coeff[(10 + i) & size_b][i] + (-29) * coeff[(14 + i) & size_b][i] + ( 35) * coeff[(18 + i) & size_b][i] + (-40) * coeff[(22 + i) & size_b][i] + ( 43) * coeff[(26 + i) & size_b][i] + (-45) * coeff[(30 + i) & size_b][i];

			EEO[0] = (44) * coeff[(4 + i) & size_b][i] + ( 38) * coeff[(12 + i) & size_b][i] + ( 25) * coeff[(20 + i) & size_b][i] + (  9) * coeff[(28 + i) & size_b][i];
			EEO[1] = (38) * coeff[(4 + i) & size_b][i] + (-9 ) * coeff[(12 + i) & size_b][i] + (-44) * coeff[(20 + i) & size_b][i] + (-25) * coeff[(28 + i) & size_b][i];
			EEO[2] = (25) * coeff[(4 + i) & size_b][i] + (-44) * coeff[(12 + i) & size_b][i] + (  9) * coeff[(20 + i) & size_b][i] + ( 38) * coeff[(28 + i) & size_b][i];
			EEO[3] = ( 9) * coeff[(4 + i) & size_b][i] + (-25) * coeff[(12 + i) & size_b][i] + ( 38) * coeff[(20 + i) & size_b][i] + (-44) * coeff[(28 + i) & size_b][i];

			EEEO[0] = (42) * coeff[(8 + i) & size_b][i] + ( 17) * coeff[(24 + i) & size_b][i];
			EEEO[1] = (17) * coeff[(8 + i) & size_b][i] + (-42) * coeff[(24 + i) & size_b][i];
			EEEE[0] = (32) * coeff[(0 + i) & size_b][i] + ( 32) * coeff[(16 + i) & size_b][i];
			EEEE[1] = (32) * coeff[(0 + i) & size_b][i] + (-32) * coeff[(16 + i) & size_b][i];
			EEE[0] = EEEE[0] + EEEO[0];
			EEE[3] = EEEE[0] - EEEO[0];
			EEE[1] = EEEE[1] + EEEO[1];
			EEE[2] = EEEE[1] - EEEO[1];
		for (int k = 0; k < 4; k++) {
				EE[k    ] = EEE[k    ] + EEO[k    ];
				EE[k + 4] = EEE[3 - k] - EEO[3 - k];
			}
		for (int k = 0; k < 8; k++) {
				E[k    ] = EE[k    ] + EO[k    ];
				E[k + 8] = EE[7 - k] - EO[7 - k];
			}
		for (int k = 0; k < 16; k++) {
				block[i][k     ] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k     ] + O[k     ] + rnd_factor) >> shift);
				block[i][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
			}
		}
	}
}
static void inv_dct_row_32x32_lite(s16 coeff[32][32], s16 resi[32][32], U4 shift)
{
	U7 size = 32;
	U8 size_b = size - 1;
	static int E[16], O[16];
	int EE  [8], EO  [8];
	int EEE [4], EEO [4];
	int EEEE[2], EEEO[2];
	int rnd_factor = 1 << (shift - 1);

	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE 
		O[ 0] = (45) * coeff[(1 + i) & size_b][i] + ( 45) * coeff[(3 + i) & size_b][i] + ( 44) * coeff[(5 + i) & size_b][i] + ( 43) * coeff[(7 + i) & size_b][i] + ( 41) * coeff[(9 + i) & size_b][i] + ( 39) * coeff[(11 + i) & size_b][i] + ( 36) * coeff[(13 + i) & size_b][i] + ( 34) * coeff[(15 + i) & size_b][i] + ( 30) * coeff[(17 + i) & size_b][i] + ( 27) * coeff[(19 + i) & size_b][i] + ( 23) * coeff[(21 + i) & size_b][i] + ( 19) * coeff[(23 + i) & size_b][i] + ( 15) * coeff[(25 + i) & size_b][i] + ( 11) * coeff[(27 + i) & size_b][i] + (  7) * coeff[(29 + i) & size_b][i] + (  2) * coeff[(31 + i) & size_b][i];
		O[ 1] = (45) * coeff[(1 + i) & size_b][i] + ( 41) * coeff[(3 + i) & size_b][i] + ( 34) * coeff[(5 + i) & size_b][i] + ( 23) * coeff[(7 + i) & size_b][i] + ( 11) * coeff[(9 + i) & size_b][i] + (-2 ) * coeff[(11 + i) & size_b][i] + (-15) * coeff[(13 + i) & size_b][i] + (-27) * coeff[(15 + i) & size_b][i] + (-36) * coeff[(17 + i) & size_b][i] + (-43) * coeff[(19 + i) & size_b][i] + (-45) * coeff[(21 + i) & size_b][i] + (-44) * coeff[(23 + i) & size_b][i] + (-39) * coeff[(25 + i) & size_b][i] + (-30) * coeff[(27 + i) & size_b][i] + (-19) * coeff[(29 + i) & size_b][i] + (-7 ) * coeff[(31 + i) & size_b][i];
		O[ 2] = (44) * coeff[(1 + i) & size_b][i] + ( 34) * coeff[(3 + i) & size_b][i] + ( 15) * coeff[(5 + i) & size_b][i] + (-7 ) * coeff[(7 + i) & size_b][i] + (-27) * coeff[(9 + i) & size_b][i] + (-41) * coeff[(11 + i) & size_b][i] + (-45) * coeff[(13 + i) & size_b][i] + (-39) * coeff[(15 + i) & size_b][i] + (-23) * coeff[(17 + i) & size_b][i] + (-2 ) * coeff[(19 + i) & size_b][i] + ( 19) * coeff[(21 + i) & size_b][i] + ( 36) * coeff[(23 + i) & size_b][i] + ( 45) * coeff[(25 + i) & size_b][i] + ( 43) * coeff[(27 + i) & size_b][i] + ( 30) * coeff[(29 + i) & size_b][i] + ( 11) * coeff[(31 + i) & size_b][i];
		O[ 3] = (43) * coeff[(1 + i) & size_b][i] + ( 23) * coeff[(3 + i) & size_b][i] + (-7 ) * coeff[(5 + i) & size_b][i] + (-34) * coeff[(7 + i) & size_b][i] + (-45) * coeff[(9 + i) & size_b][i] + (-36) * coeff[(11 + i) & size_b][i] + (-11) * coeff[(13 + i) & size_b][i] + ( 19) * coeff[(15 + i) & size_b][i] + ( 41) * coeff[(17 + i) & size_b][i] + ( 44) * coeff[(19 + i) & size_b][i] + ( 27) * coeff[(21 + i) & size_b][i] + (- 2) * coeff[(23 + i) & size_b][i] + (-30) * coeff[(25 + i) & size_b][i] + (-45) * coeff[(27 + i) & size_b][i] + (-39) * coeff[(29 + i) & size_b][i] + (-15) * coeff[(31 + i) & size_b][i];
		O[ 4] = (41) * coeff[(1 + i) & size_b][i] + ( 11) * coeff[(3 + i) & size_b][i] + (-27) * coeff[(5 + i) & size_b][i] + (-45) * coeff[(7 + i) & size_b][i] + (-30) * coeff[(9 + i) & size_b][i] + (  7) * coeff[(11 + i) & size_b][i] + ( 39) * coeff[(13 + i) & size_b][i] + ( 43) * coeff[(15 + i) & size_b][i] + ( 15) * coeff[(17 + i) & size_b][i] + (-23) * coeff[(19 + i) & size_b][i] + (-45) * coeff[(21 + i) & size_b][i] + (-34) * coeff[(23 + i) & size_b][i] + (  2) * coeff[(25 + i) & size_b][i] + ( 36) * coeff[(27 + i) & size_b][i] + ( 44) * coeff[(29 + i) & size_b][i] + ( 19) * coeff[(31 + i) & size_b][i];
		O[ 5] = (39) * coeff[(1 + i) & size_b][i] + (-2 ) * coeff[(3 + i) & size_b][i] + (-41) * coeff[(5 + i) & size_b][i] + (-36) * coeff[(7 + i) & size_b][i] + (  7) * coeff[(9 + i) & size_b][i] + ( 43) * coeff[(11 + i) & size_b][i] + ( 34) * coeff[(13 + i) & size_b][i] + (-11) * coeff[(15 + i) & size_b][i] + (-44) * coeff[(17 + i) & size_b][i] + (-30) * coeff[(19 + i) & size_b][i] + ( 15) * coeff[(21 + i) & size_b][i] + ( 45) * coeff[(23 + i) & size_b][i] + ( 27) * coeff[(25 + i) & size_b][i] + (-19) * coeff[(27 + i) & size_b][i] + (-45) * coeff[(29 + i) & size_b][i] + (-23) * coeff[(31 + i) & size_b][i];
		O[ 6] = (36) * coeff[(1 + i) & size_b][i] + (-15) * coeff[(3 + i) & size_b][i] + (-45) * coeff[(5 + i) & size_b][i] + (-11) * coeff[(7 + i) & size_b][i] + ( 39) * coeff[(9 + i) & size_b][i] + ( 34) * coeff[(11 + i) & size_b][i] + (-19) * coeff[(13 + i) & size_b][i] + (-45) * coeff[(15 + i) & size_b][i] + (-7 ) * coeff[(17 + i) & size_b][i] + ( 41) * coeff[(19 + i) & size_b][i] + ( 30) * coeff[(21 + i) & size_b][i] + (-23) * coeff[(23 + i) & size_b][i] + (-44) * coeff[(25 + i) & size_b][i] + (-2 ) * coeff[(27 + i) & size_b][i] + ( 43) * coeff[(29 + i) & size_b][i] + ( 27) * coeff[(31 + i) & size_b][i];
		O[ 7] = (34) * coeff[(1 + i) & size_b][i] + (-27) * coeff[(3 + i) & size_b][i] + (-39) * coeff[(5 + i) & size_b][i] + ( 19) * coeff[(7 + i) & size_b][i] + ( 43) * coeff[(9 + i) & size_b][i] + (-11) * coeff[(11 + i) & size_b][i] + (-45) * coeff[(13 + i) & size_b][i] + (  2) * coeff[(15 + i) & size_b][i] + ( 45) * coeff[(17 + i) & size_b][i] + (  7) * coeff[(19 + i) & size_b][i] + (-44) * coeff[(21 + i) & size_b][i] + (-15) * coeff[(23 + i) & size_b][i] + ( 41) * coeff[(25 + i) & size_b][i] + ( 23) * coeff[(27 + i) & size_b][i] + (-36) * coeff[(29 + i) & size_b][i] + (-30) * coeff[(31 + i) & size_b][i];
		O[ 8] = (30) * coeff[(1 + i) & size_b][i] + (-36) * coeff[(3 + i) & size_b][i] + (-23) * coeff[(5 + i) & size_b][i] + ( 41) * coeff[(7 + i) & size_b][i] + ( 15) * coeff[(9 + i) & size_b][i] + (-44) * coeff[(11 + i) & size_b][i] + (-7 ) * coeff[(13 + i) & size_b][i] + ( 45) * coeff[(15 + i) & size_b][i] + (-2 ) * coeff[(17 + i) & size_b][i] + (-45) * coeff[(19 + i) & size_b][i] + ( 11) * coeff[(21 + i) & size_b][i] + ( 43) * coeff[(23 + i) & size_b][i] + (-19) * coeff[(25 + i) & size_b][i] + (-39) * coeff[(27 + i) & size_b][i] + ( 27) * coeff[(29 + i) & size_b][i] + ( 34) * coeff[(31 + i) & size_b][i];
		O[ 9] = (27) * coeff[(1 + i) & size_b][i] + (-43) * coeff[(3 + i) & size_b][i] + (-2 ) * coeff[(5 + i) & size_b][i] + ( 44) * coeff[(7 + i) & size_b][i] + (-23) * coeff[(9 + i) & size_b][i] + (-30) * coeff[(11 + i) & size_b][i] + ( 41) * coeff[(13 + i) & size_b][i] + (  7) * coeff[(15 + i) & size_b][i] + (-45) * coeff[(17 + i) & size_b][i] + ( 19) * coeff[(19 + i) & size_b][i] + ( 34) * coeff[(21 + i) & size_b][i] + (-39) * coeff[(23 + i) & size_b][i] + (-11) * coeff[(25 + i) & size_b][i] + ( 45) * coeff[(27 + i) & size_b][i] + (-15) * coeff[(29 + i) & size_b][i] + (-36) * coeff[(31 + i) & size_b][i];
		O[10] = (23) * coeff[(1 + i) & size_b][i] + (-45) * coeff[(3 + i) & size_b][i] + ( 19) * coeff[(5 + i) & size_b][i] + ( 27) * coeff[(7 + i) & size_b][i] + (-45) * coeff[(9 + i) & size_b][i] + ( 15) * coeff[(11 + i) & size_b][i] + ( 30) * coeff[(13 + i) & size_b][i] + (-44) * coeff[(15 + i) & size_b][i] + ( 11) * coeff[(17 + i) & size_b][i] + ( 34) * coeff[(19 + i) & size_b][i] + (-43) * coeff[(21 + i) & size_b][i] + (  7) * coeff[(23 + i) & size_b][i] + ( 36) * coeff[(25 + i) & size_b][i] + (-41) * coeff[(27 + i) & size_b][i] + (  2) * coeff[(29 + i) & size_b][i] + ( 39) * coeff[(31 + i) & size_b][i];
		O[11] = (19) * coeff[(1 + i) & size_b][i] + (-44) * coeff[(3 + i) & size_b][i] + ( 36) * coeff[(5 + i) & size_b][i] + (-2 ) * coeff[(7 + i) & size_b][i] + (-34) * coeff[(9 + i) & size_b][i] + ( 45) * coeff[(11 + i) & size_b][i] + (-23) * coeff[(13 + i) & size_b][i] + (-15) * coeff[(15 + i) & size_b][i] + ( 43) * coeff[(17 + i) & size_b][i] + (-39) * coeff[(19 + i) & size_b][i] + (  7) * coeff[(21 + i) & size_b][i] + ( 30) * coeff[(23 + i) & size_b][i] + (-45) * coeff[(25 + i) & size_b][i] + ( 27) * coeff[(27 + i) & size_b][i] + ( 11) * coeff[(29 + i) & size_b][i] + (-41) * coeff[(31 + i) & size_b][i];
		O[12] = (15) * coeff[(1 + i) & size_b][i] + (-39) * coeff[(3 + i) & size_b][i] + ( 45) * coeff[(5 + i) & size_b][i] + (-30) * coeff[(7 + i) & size_b][i] + (  2) * coeff[(9 + i) & size_b][i] + ( 27) * coeff[(11 + i) & size_b][i] + (-44) * coeff[(13 + i) & size_b][i] + ( 41) * coeff[(15 + i) & size_b][i] + (-19) * coeff[(17 + i) & size_b][i] + (-11) * coeff[(19 + i) & size_b][i] + ( 36) * coeff[(21 + i) & size_b][i] + (-45) * coeff[(23 + i) & size_b][i] + ( 34) * coeff[(25 + i) & size_b][i] + (-7 ) * coeff[(27 + i) & size_b][i] + (-23) * coeff[(29 + i) & size_b][i] + ( 43) * coeff[(31 + i) & size_b][i];
		O[13] = (11) * coeff[(1 + i) & size_b][i] + (-30) * coeff[(3 + i) & size_b][i] + ( 43) * coeff[(5 + i) & size_b][i] + (-45) * coeff[(7 + i) & size_b][i] + ( 36) * coeff[(9 + i) & size_b][i] + (-19) * coeff[(11 + i) & size_b][i] + (-2 ) * coeff[(13 + i) & size_b][i] + ( 23) * coeff[(15 + i) & size_b][i] + (-39) * coeff[(17 + i) & size_b][i] + ( 45) * coeff[(19 + i) & size_b][i] + (-41) * coeff[(21 + i) & size_b][i] + ( 27) * coeff[(23 + i) & size_b][i] + (-7 ) * coeff[(25 + i) & size_b][i] + (-15) * coeff[(27 + i) & size_b][i] + ( 34) * coeff[(29 + i) & size_b][i] + (-44) * coeff[(31 + i) & size_b][i];
		O[14] = ( 7) * coeff[(1 + i) & size_b][i] + (-19) * coeff[(3 + i) & size_b][i] + ( 30) * coeff[(5 + i) & size_b][i] + (-39) * coeff[(7 + i) & size_b][i] + ( 44) * coeff[(9 + i) & size_b][i] + (-45) * coeff[(11 + i) & size_b][i] + ( 43) * coeff[(13 + i) & size_b][i] + (-36) * coeff[(15 + i) & size_b][i] + ( 27) * coeff[(17 + i) & size_b][i] + (-15) * coeff[(19 + i) & size_b][i] + (  2) * coeff[(21 + i) & size_b][i] + ( 11) * coeff[(23 + i) & size_b][i] + (-23) * coeff[(25 + i) & size_b][i] + ( 34) * coeff[(27 + i) & size_b][i] + (-41) * coeff[(29 + i) & size_b][i] + ( 45) * coeff[(31 + i) & size_b][i];
		O[15] = ( 2) * coeff[(1 + i) & size_b][i] + (-7 ) * coeff[(3 + i) & size_b][i] + ( 11) * coeff[(5 + i) & size_b][i] + (-15) * coeff[(7 + i) & size_b][i] + ( 19) * coeff[(9 + i) & size_b][i] + (-23) * coeff[(11 + i) & size_b][i] + ( 27) * coeff[(13 + i) & size_b][i] + (-30) * coeff[(15 + i) & size_b][i] + ( 34) * coeff[(17 + i) & size_b][i] + (-36) * coeff[(19 + i) & size_b][i] + ( 39) * coeff[(21 + i) & size_b][i] + (-41) * coeff[(23 + i) & size_b][i] + ( 43) * coeff[(25 + i) & size_b][i] + (-44) * coeff[(27 + i) & size_b][i] + ( 45) * coeff[(29 + i) & size_b][i] + (-45) * coeff[(31 + i) & size_b][i];

		EO[0] = (45) * coeff[(2 + i) & size_b][i] + ( 43) * coeff[(6 + i) & size_b][i] + ( 40) * coeff[(10 + i) & size_b][i] + ( 35) * coeff[(14 + i) & size_b][i] + ( 29) * coeff[(18 + i) & size_b][i] + ( 21) * coeff[(22 + i) & size_b][i] + ( 13) * coeff[(26 + i) & size_b][i] + (  4) * coeff[(30 + i) & size_b][i];
		EO[1] = (43) * coeff[(2 + i) & size_b][i] + ( 29) * coeff[(6 + i) & size_b][i] + (  4) * coeff[(10 + i) & size_b][i] + (-21) * coeff[(14 + i) & size_b][i] + (-40) * coeff[(18 + i) & size_b][i] + (-45) * coeff[(22 + i) & size_b][i] + (-35) * coeff[(26 + i) & size_b][i] + (-13) * coeff[(30 + i) & size_b][i];
		EO[2] = (40) * coeff[(2 + i) & size_b][i] + (  4) * coeff[(6 + i) & size_b][i] + (-35) * coeff[(10 + i) & size_b][i] + (-43) * coeff[(14 + i) & size_b][i] + (-13) * coeff[(18 + i) & size_b][i] + ( 29) * coeff[(22 + i) & size_b][i] + ( 45) * coeff[(26 + i) & size_b][i] + ( 21) * coeff[(30 + i) & size_b][i];
		EO[3] = (35) * coeff[(2 + i) & size_b][i] + (-21) * coeff[(6 + i) & size_b][i] + (-43) * coeff[(10 + i) & size_b][i] + (  4) * coeff[(14 + i) & size_b][i] + ( 45) * coeff[(18 + i) & size_b][i] + ( 13) * coeff[(22 + i) & size_b][i] + (-40) * coeff[(26 + i) & size_b][i] + (-29) * coeff[(30 + i) & size_b][i];
		EO[4] = (29) * coeff[(2 + i) & size_b][i] + (-40) * coeff[(6 + i) & size_b][i] + (-13) * coeff[(10 + i) & size_b][i] + ( 45) * coeff[(14 + i) & size_b][i] + (-4 ) * coeff[(18 + i) & size_b][i] + (-43) * coeff[(22 + i) & size_b][i] + ( 21) * coeff[(26 + i) & size_b][i] + ( 35) * coeff[(30 + i) & size_b][i];
		EO[5] = (21) * coeff[(2 + i) & size_b][i] + (-45) * coeff[(6 + i) & size_b][i] + ( 29) * coeff[(10 + i) & size_b][i] + ( 13) * coeff[(14 + i) & size_b][i] + (-43) * coeff[(18 + i) & size_b][i] + ( 35) * coeff[(22 + i) & size_b][i] + (  4) * coeff[(26 + i) & size_b][i] + (-40) * coeff[(30 + i) & size_b][i];
		EO[6] = (13) * coeff[(2 + i) & size_b][i] + (-35) * coeff[(6 + i) & size_b][i] + ( 45) * coeff[(10 + i) & size_b][i] + (-40) * coeff[(14 + i) & size_b][i] + ( 21) * coeff[(18 + i) & size_b][i] + (  4) * coeff[(22 + i) & size_b][i] + (-29) * coeff[(26 + i) & size_b][i] + ( 43) * coeff[(30 + i) & size_b][i];
		EO[7] = ( 4) * coeff[(2 + i) & size_b][i] + (-13) * coeff[(6 + i) & size_b][i] + ( 21) * coeff[(10 + i) & size_b][i] + (-29) * coeff[(14 + i) & size_b][i] + ( 35) * coeff[(18 + i) & size_b][i] + (-40) * coeff[(22 + i) & size_b][i] + ( 43) * coeff[(26 + i) & size_b][i] + (-45) * coeff[(30 + i) & size_b][i];

		EEO[0] = (44) * coeff[(4 + i) & size_b][i] + ( 38) * coeff[(12 + i) & size_b][i] + ( 25) * coeff[(20 + i) & size_b][i] + (  9) * coeff[(28 + i) & size_b][i];
		EEO[1] = (38) * coeff[(4 + i) & size_b][i] + (-9 ) * coeff[(12 + i) & size_b][i] + (-44) * coeff[(20 + i) & size_b][i] + (-25) * coeff[(28 + i) & size_b][i];
		EEO[2] = (25) * coeff[(4 + i) & size_b][i] + (-44) * coeff[(12 + i) & size_b][i] + (  9) * coeff[(20 + i) & size_b][i] + ( 38) * coeff[(28 + i) & size_b][i];
		EEO[3] = ( 9) * coeff[(4 + i) & size_b][i] + (-25) * coeff[(12 + i) & size_b][i] + ( 38) * coeff[(20 + i) & size_b][i] + (-44) * coeff[(28 + i) & size_b][i];

		EEEO[0] = (42) * coeff[(8 + i) & size_b][i] + ( 17) * coeff[(24 + i) & size_b][i];
		EEEO[1] = (17) * coeff[(8 + i) & size_b][i] + (-42) * coeff[(24 + i) & size_b][i];
		EEEE[0] = (32) * coeff[(0 + i) & size_b][i] + ( 32) * coeff[(16 + i) & size_b][i];
		EEEE[1] = (32) * coeff[(0 + i) & size_b][i] + (-32) * coeff[(16 + i) & size_b][i];

		EEE[0] = EEEE[0] + EEEO[0];
		EEE[3] = EEEE[0] - EEEO[0];
		EEE[1] = EEEE[1] + EEEO[1];
		EEE[2] = EEEE[1] - EEEO[1];

		for (int k = 0; k < 4; k++) {
			EE[k    ] = EEE[k    ] + EEO[k    ];
			EE[k + 4] = EEE[3 - k] - EEO[3 - k];
		}
		for (int k = 0; k < 8; k++) {
			E[k    ] = EE[k    ] + EO[k    ];
			E[k + 8] = EE[7 - k] - EO[7 - k];
		}
		for (int k = 0; k < 16; k++) {
			resi[i][k     ] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k     ] + O[k     ] + rnd_factor) >> shift);
			resi[i][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
		}
	}
}
static void inv_dct_row_32x16_lite(s16 coeff[32][32], s16 resi[32][32], U4 shift)
{
	U7 size = 32;
	U8 size_b = size - 1;
	static int E  [8], O  [8];
	       int EE [4], EO [4];
	       int EEE[2], EEO[2];
#pragma HLS ARRAY_PARTITION variable=E   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=O   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EE  dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EO  dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEE dim=0 complete
#pragma HLS ARRAY_PARTITION variable=EEO dim=0 complete
	int rnd_factor = 1 << (shift - 1);

	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE 
		O[0] = (45) * coeff[(1 + i) & size_b][i] + ( 43) * coeff[(3 + i) & size_b][i] + ( 40) * coeff[(5 + i) & size_b][i] + ( 35) * coeff[(7 + i) & size_b][i] + ( 29) * coeff[(9 + i) & size_b][i] + ( 21) * coeff[(11 + i) & size_b][i] + ( 13) * coeff[(13 + i) & size_b][i] + (  4) * coeff[(15 + i) & size_b][i];
		O[1] = (43) * coeff[(1 + i) & size_b][i] + ( 29) * coeff[(3 + i) & size_b][i] + (  4) * coeff[(5 + i) & size_b][i] + (-21) * coeff[(7 + i) & size_b][i] + (-40) * coeff[(9 + i) & size_b][i] + (-45) * coeff[(11 + i) & size_b][i] + (-35) * coeff[(13 + i) & size_b][i] + (-13) * coeff[(15 + i) & size_b][i];
		O[2] = (40) * coeff[(1 + i) & size_b][i] + (  4) * coeff[(3 + i) & size_b][i] + (-35) * coeff[(5 + i) & size_b][i] + (-43) * coeff[(7 + i) & size_b][i] + (-13) * coeff[(9 + i) & size_b][i] + ( 29) * coeff[(11 + i) & size_b][i] + ( 45) * coeff[(13 + i) & size_b][i] + ( 21) * coeff[(15 + i) & size_b][i];
		O[3] = (35) * coeff[(1 + i) & size_b][i] + (-21) * coeff[(3 + i) & size_b][i] + (-43) * coeff[(5 + i) & size_b][i] + (  4) * coeff[(7 + i) & size_b][i] + ( 45) * coeff[(9 + i) & size_b][i] + ( 13) * coeff[(11 + i) & size_b][i] + (-40) * coeff[(13 + i) & size_b][i] + (-29) * coeff[(15 + i) & size_b][i];
		O[4] = (29) * coeff[(1 + i) & size_b][i] + (-40) * coeff[(3 + i) & size_b][i] + (-13) * coeff[(5 + i) & size_b][i] + ( 45) * coeff[(7 + i) & size_b][i] + (-4 ) * coeff[(9 + i) & size_b][i] + (-43) * coeff[(11 + i) & size_b][i] + ( 21) * coeff[(13 + i) & size_b][i] + ( 35) * coeff[(15 + i) & size_b][i];
		O[5] = (21) * coeff[(1 + i) & size_b][i] + (-45) * coeff[(3 + i) & size_b][i] + ( 29) * coeff[(5 + i) & size_b][i] + ( 13) * coeff[(7 + i) & size_b][i] + (-43) * coeff[(9 + i) & size_b][i] + ( 35) * coeff[(11 + i) & size_b][i] + (  4) * coeff[(13 + i) & size_b][i] + (-40) * coeff[(15 + i) & size_b][i];
		O[6] = (13) * coeff[(1 + i) & size_b][i] + (-35) * coeff[(3 + i) & size_b][i] + ( 45) * coeff[(5 + i) & size_b][i] + (-40) * coeff[(7 + i) & size_b][i] + ( 21) * coeff[(9 + i) & size_b][i] + (  4) * coeff[(11 + i) & size_b][i] + (-29) * coeff[(13 + i) & size_b][i] + ( 43) * coeff[(15 + i) & size_b][i];
		O[7] = ( 4) * coeff[(1 + i) & size_b][i] + (-13) * coeff[(3 + i) & size_b][i] + ( 21) * coeff[(5 + i) & size_b][i] + (-29) * coeff[(7 + i) & size_b][i] + ( 35) * coeff[(9 + i) & size_b][i] + (-40) * coeff[(11 + i) & size_b][i] + ( 43) * coeff[(13 + i) & size_b][i] + (-45) * coeff[(15 + i) & size_b][i];

		EO[0] = (44) * coeff[(2 + i) & size_b][i] + ( 38) * coeff[(6 + i) & size_b][i] + ( 25) * coeff[(10 + i) & size_b][i] + (  9) * coeff[(14 + i) & size_b][i];
		EO[1] = (38) * coeff[(2 + i) & size_b][i] + (-9 ) * coeff[(6 + i) & size_b][i] + (-44) * coeff[(10 + i) & size_b][i] + (-25) * coeff[(14 + i) & size_b][i];
		EO[2] = (25) * coeff[(2 + i) & size_b][i] + (-44) * coeff[(6 + i) & size_b][i] + (  9) * coeff[(10 + i) & size_b][i] + ( 38) * coeff[(14 + i) & size_b][i];
		EO[3] = ( 9) * coeff[(2 + i) & size_b][i] + (-25) * coeff[(6 + i) & size_b][i] + ( 38) * coeff[(10 + i) & size_b][i] + (-44) * coeff[(14 + i) & size_b][i];

		EEO[0] = (42) * coeff[(4 + i) & size_b][i] + ( 17) * coeff[(12 + i) & size_b][i];
		EEE[0] = (32) * coeff[(0 + i) & size_b][i] + ( 32) * coeff[( 8 + i) & size_b][i];
		EEO[1] = (17) * coeff[(4 + i) & size_b][i] + (-42) * coeff[(12 + i) & size_b][i];
		EEE[1] = (32) * coeff[(0 + i) & size_b][i] + (-32) * coeff[( 8 + i) & size_b][i];

	for (int k = 0; k < 2; k++) {
#pragma HLS UNROLL
			EE[k    ] = EEE[k    ] + EEO[k    ];
			EE[k + 2] = EEE[1 - k] - EEO[1 - k];
		}
	for (int k = 0; k < 4; k++) {
#pragma HLS UNROLL
			E[k    ] = EE[k    ] + EO[k    ];
			E[k + 4] = EE[3 - k] - EO[3 - k];
		}
	for (int k = 0; k < 8; k++) {
#pragma HLS UNROLL
			resi[i][k    ] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k    ] + O[k    ] + rnd_factor) >> shift);
			resi[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
		}
	}
}

static void cu_plane_nz_cln(int dst[4][3], U3 plane)
{

	int i;
	for (i = 0; i < 4; i++) {

		dst[i][plane] = 0;
	}
}

static void dquant_32(U8 cu_width, U8 cu_height, U6 qp, s16 coef[32][32], s16 coef_out[32][32], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith)
{
#pragma HLS INLINE off

	int w = 1 << log2_w;
	int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix     = (log2_w + log2_h) & 1;
	static const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
	static const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
	int scale = com_tbl_dq_scale[qp];
	// +1 is used to compensate for the mismatching of shifts in quantization and inverse quantization
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
    int offset = (shift == 0) ? 0 : (1 << (shift - 1));
#if 0
    for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
        if (i < cu_height) {
            for (int j = 0; j < 32; j++) {
                if (j < cu_width) {
					//int weight = (i | j) & 0xE0 ? 0 : 64;
					//int lev = (((coef[j] * weight >> 2) * scale >> 4) + offset) >> shift;
                    int weight = ((i | j) & 0xE0) ? 0 : coef[i][j];
					int lev = (weight * scale + offset) >> shift;
					lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
					if (refix) {
						lev = (lev * 181 + 128) >> 8;
					}
					coef_out[i][j] = (lev);
				}
			}
		}
	}
#else
	int sr_x = 0;
	int sr_y = 0;
    for (int j = 0; j < 32; j++) {
#pragma HLS PIPELINE
        if (j < cu_width) {
            for (int i = 0; i < 32; i++) {
                if (i < cu_height) {
					if (coef[i][j]) {
						sr_y = i > sr_y ? i : sr_y;
						sr_x = j > sr_x ? j : sr_x;
					}
                    int weight = ((i | j) & 0xE0) ? 0 : coef[i][j];
                    int lev = (weight * scale + offset) >> shift;
                    lev = (lev > 32767) ? 32767 : ((lev < -32768) ? -32768 : lev);
                    if (refix) {
                        lev = (lev * 181 + 128) >> 8;
                    }
                    coef_out[i][j] = lev;
                }
            }
        }
    }
	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + *num_nz_ith;
#endif
}
static void dquant_16x32(U6 qp, s16 coef[32][32], s16 coef_out[32][32], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith)
{
#pragma HLS INLINE off

	int w = 1 << log2_w;
	int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix = (log2_w + log2_h) & 1;
	static const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
	static const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
	int scale = com_tbl_dq_scale[qp];
	// +1 is used to compensate for the mismatching of shifts in quantization and inverse quantization
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
	int offset = (shift == 0) ? 0 : (1 << (shift - 1));
#if 0

#else
	int sr_x;
	int sr_y;
	sr_x = 0;
	sr_y = 0;
	int sr_y_temp_0[16];		// 32
	int sr_y_temp_1[16 / 2];	// 16
	int sr_y_temp_2[16 / 4];	//  8
	int sr_y_temp_3[16 / 8];	//  4
	//int sr_y_temp_4[H/16];	//  2
	int sr_y_temp_4;		//		// Max. coord_y in a COL.
	int sr_y_temp_5;
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_0 dim=0 complete
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_1 dim=0 complete
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_2 dim=0 complete
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_3 dim=0 complete

	for (int j = 0; j < 32; j++) {
#pragma HLS PIPELINE
		for (int i = 0; i < 16; i++) {
			s16 coef_temp = coef[i][j];

			if (coef_temp) {
				sr_y_temp_0[i] = i + 1;
			}
			else {
				sr_y_temp_0[i] = 0;
			}

			int weight = ((i | j) & 0xE0) ? 0 : coef_temp;
			int lev = (weight * scale + offset) >> shift;
			lev = (lev > 32767) ? 32767 : ((lev < -32768) ? -32768 : lev);
			if (refix) {
				lev = (lev * 181 + 128) >> 8;
			}
			coef_out[i][j] = lev;
		}

		for (int i = 0; i < (16 / 2); i++) {		// 8
#pragma HLS UNROLL
			if (sr_y_temp_0[2 * i + 1] > sr_y_temp_0[2 * i]) { sr_y_temp_1[i] = sr_y_temp_0[2 * i + 1]; }
			else { sr_y_temp_1[i] = sr_y_temp_0[2 * i]; }
		}
		for (int i = 0; i < (16 / 4); i++) {		//  4
#pragma HLS UNROLL
			if (sr_y_temp_1[2 * i + 1] > sr_y_temp_1[2 * i]) { sr_y_temp_2[i] = sr_y_temp_1[2 * i + 1]; }
			else { sr_y_temp_2[i] = sr_y_temp_1[2 * i]; }
		}
		for (int i = 0; i < (16 / 8); i++) {		//  2
#pragma HLS UNROLL
			if (sr_y_temp_2[2 * i + 1] > sr_y_temp_2[2 * i]) { sr_y_temp_3[i] = sr_y_temp_2[2 * i + 1]; }
			else { sr_y_temp_3[i] = sr_y_temp_2[2 * i]; }
		}
		//		for (int i=0; i < (H/16); i++) {	//  2
		//#pragma HLS UNROLL
		//			if (sr_y_temp_3[2*i+1] > sr_y_temp_3[2*i]) { sr_y_temp_4[i] = sr_y_temp_3[2*i+1]; } else { sr_y_temp_4[i] = sr_y_temp_3[2*i]; }
		//		}
		if (sr_y_temp_3[1] > sr_y_temp_3[0]) { sr_y_temp_4 = sr_y_temp_3[1]; }
		else { sr_y_temp_4 = sr_y_temp_3[0]; }
		sr_y_temp_5 = sr_y_temp_4 - 1;
		if (sr_y_temp_5 > sr_y) {
			sr_y = sr_y_temp_5;
		}
		if (sr_y_temp_4 != 0) {
			if (j > sr_x) {
				sr_x = j;
			}
		}
	}
	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + *num_nz_ith;
#endif
}
template<int H, int W>
static void dquant_32x(U6 qp, s16 coef[32][32], s16 coef_out[32][32], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith)
{
#pragma HLS INLINE off

	//int w = 1 << log2_w;
	//int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix     = (log2_w + log2_h) & 1;
	static const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
	static const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
	int scale = com_tbl_dq_scale[qp];
	// +1 is used to compensate for the mismatching of shifts in quantization and inverse quantization
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
    int offset = (shift == 0) ? 0 : (1 << (shift - 1));
	
#if 0
    for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
        if (i < cu_height) {
            for (int j = 0; j < 32; j++) {
                if (j < cu_width) {
					//int weight = (i | j) & 0xE0 ? 0 : 64;
					//int lev = (((coef[j] * weight >> 2) * scale >> 4) + offset) >> shift;
                    int weight = ((i | j) & 0xE0) ? 0 : coef[i][j];
					int lev = (weight * scale + offset) >> shift;
					lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
					if (refix) {
						lev = (lev * 181 + 128) >> 8;
					}
					coef_out[i][j] = (lev);
				}
			}
		}
	}
#else
	int sr_x;
	int sr_y;
	sr_x = 0;
	sr_y = 0;
	int sr_y_temp_0[H];		// 32
	int sr_y_temp_1[H/2];	// 16
	int sr_y_temp_2[H/4];	//  8
	int sr_y_temp_3[H/8];	//  4
	int sr_y_temp_4[H/16];	//  2
	int sr_y_temp_5;		//		// Max. coord_y in a COL.
	int sr_y_temp_6;
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_0 dim=0 complete
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_1 dim=0 complete
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_2 dim=0 complete
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_3 dim=0 complete
#pragma HLS ARRAY_PARTITION variable=sr_y_temp_4 dim=0 complete

    for (int j = 0; j < W; j++) {
#pragma HLS PIPELINE
		for (int i = 0; i < H; i++) {
			s16 coef_temp = coef[i][j];

			//if (coef_temp) {
			//	sr_y_b = i > sr_y_b ? i : sr_y_b;
			//	sr_x_b = j > sr_x_b ? j : sr_x_b;
			//}
			if (coef_temp) {
				sr_y_temp_0[i] = i+1;
			} else {
				sr_y_temp_0[i] = 0;
			}

			int weight = ((i | j) & 0xE0) ? 0 : coef_temp;
			int lev = (weight * scale + offset) >> shift;
			lev = (lev > 32767) ? 32767 : ((lev < -32768) ? -32768 : lev);
			if (refix) {
				lev = (lev * 181 + 128) >> 8;
			}
			coef_out[i][j] = lev;
		}

		for (int i=0; i < (H/2); i++) {		// 16
#pragma HLS UNROLL
			if (sr_y_temp_0[2*i+1] > sr_y_temp_0[2*i]) { sr_y_temp_1[i] = sr_y_temp_0[2*i+1]; } else { sr_y_temp_1[i] = sr_y_temp_0[2*i]; }
		}
		for (int i=0; i < (H/4); i++) {		//  8
#pragma HLS UNROLL
			if (sr_y_temp_1[2*i+1] > sr_y_temp_1[2*i]) { sr_y_temp_2[i] = sr_y_temp_1[2*i+1]; } else { sr_y_temp_2[i] = sr_y_temp_1[2*i]; }
		}
		for (int i=0; i < (H/8); i++) {		//  4
#pragma HLS UNROLL
			if (sr_y_temp_2[2*i+1] > sr_y_temp_2[2*i]) { sr_y_temp_3[i] = sr_y_temp_2[2*i+1]; } else { sr_y_temp_3[i] = sr_y_temp_2[2*i]; }
		}
		for (int i=0; i < (H/16); i++) {	//  2
#pragma HLS UNROLL
			if (sr_y_temp_3[2*i+1] > sr_y_temp_3[2*i]) { sr_y_temp_4[i] = sr_y_temp_3[2*i+1]; } else { sr_y_temp_4[i] = sr_y_temp_3[2*i]; }
		}
		if (sr_y_temp_4[1] > sr_y_temp_4[0]) { sr_y_temp_5 = sr_y_temp_4[1]; } else { sr_y_temp_5 = sr_y_temp_4[0]; }
		sr_y_temp_6 = sr_y_temp_5 - 1;
		if (sr_y_temp_6 > sr_y) { 
			sr_y = sr_y_temp_6;
		}
		if (sr_y_temp_5 != 0) {
			if (j > sr_x) {
				sr_x = j;
			}
		}
    }

	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + *num_nz_ith;

#endif
}


static void itrans_v_32(U8 cu_width, U8 cu_height, s16 coef_dq[32][32], s16 coef_temp[32][32], U3 cu_width_log2,  U4 bit_depth)
{

	U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);


	inv_dct_col_32(cu_width, cu_height, coef_dq, coef_temp, shift1);


}

static void itrans_v_32_lite(U8 cu_width, U8 cu_height, s16 coef_dq[32][32], s16 coef_temp[32][32], U3 cu_width_log2, U4 bit_depth)
{

	U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);
	static s16 block1[32][32];
#pragma HLS ARRAY_PARTITION variable=block1 dim=2 complete

	U7 size = 32;
	U8 size_b = size - 1;

	inv_dct_col_32_lite(cu_width, cu_height, coef_dq, block1, shift1);


	if (cu_height == 32) {
        for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
            if (i < cu_width) {
				for (int j = 0; j < 32; j++) {
					if (j < cu_height)
						coef_temp[i][j] = block1[(i + j) & size_b][j];
				}
			}
		}
    } else {
        for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
            if (i < cu_width) {
				for (int j = 0; j < 32; j++) {
					if (j < cu_height)
						coef_temp[i][j] = block1[i][j];
				}
			}
		}
    }
}
#if 0
static void itrans_v_32x32_lite(U8 cu_width, U8 cu_height, s16 coef_dq[32][32], s16 coef_temp[32][32], U3 cu_width_log2, U4 bit_depth)
{
	U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);
	
	inv_dct_col_32x32_lite(coef_dq, coef_temp, shift1);
}
#endif //0
static void itrans_v_32x16_lite(s16 coef_dq[32][32], s16 coef_temp[32][32], U3 cu_width_log2, U4 bit_depth)
{

	U4 shift1 = com_get_inverse_trans_shift(cu_width_log2, 0, bit_depth);

	//inv_dct_col_32xN_lite(coef_dq, coef_temp, shift1,32);
	inv_dct_col_32_luma(coef_dq, coef_temp, shift1, 32);
}


static s64 enc_ssd_16b_1_32_chroma(U3 w_log2, U3 h_log2, s16 src1[32][32], s16 src2[32][32], int s_src2, U4 bit_depth)
{
	int offset2 = 0;
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;
	U8 i, j;
	int diff;

	for (i = 0; i < 32; i++) {
		if (i < h)
		{
			for (j = 0; j < 32; j++) {
				if (j < w)
				{
					//diff = ((int)s1[i * s_src1 + j]) - ((int)s2[i * s_src2 + j]);
					diff = (/*(int)*/src1[i][j]) - (/*(int)*/src2[i][j]);
					ssd += ((diff * diff >> shift));
				}
			}
			//offset2 += s_src2;
		}

	}
	return ssd;
	//add by xujch
}

static s64 enc_ssd_16b_1_32(U3 w_log2, U3 h_log2, s16 src1[32][32], s16 src2[32][32], int s_src2, U4 bit_depth)
{
	int offset2 = 0;
	U8 w = 1 << w_log2;
	U8 h = 1 << h_log2;
	const int shift = (bit_depth - 8) << 1;
	s64 ssd = 0;
    int diff;

    for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
        if (i < h) {
            for (int j = 0; j < 32; j++) {
                if (j < w) {
                    //diff = ((int)s1[i * s_src1 + j]) - ((int)s2[i * s_src2 + j]);
                    diff = (/*(int)*/src1[i][j]) - (/*(int)*/src2[i][j]);
                    ssd += ((diff * diff >> shift));
                }
            }
            //offset2 += s_src2;
        }
    }
    return ssd;
    //add by xujch
}
template<int H, int W>
s64 enc_ssd_16b_1_32x(s16 src1[32][32], s16 src2[32][32], U4 bit_depth)
{
	//int offset2 = 0;
	const int shift = (bit_depth - 8) << 1;
    int diff;
	s64 ssd = 0;
	s64 ssd_tmp_1[32];
	s64 ssd_tmp_2[32];
#pragma HLS ARRAY_PARTITION variable=ssd_tmp_1 dim=1 complete
#pragma HLS ARRAY_PARTITION variable=ssd_tmp_2 dim=1 complete

	for (int i=0; i<H; i++) {
#pragma HLS UNROLL
		ssd_tmp_2[i] = 0;
	}

    for (int i = 0; i < H; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < W; j++) {
			diff = src1[i][j] - src2[i][j];
			// ssd += ((diff * diff >> shift));
			ssd_tmp_1[j] = diff * diff >> shift;
		}
		for (int j=0; j<W; j++) {
			ssd_tmp_2[i] += ssd_tmp_1[j];
		}
    }

	for (int i=0; i<H; i++) {
#pragma HLS UNROLL
		ssd += ssd_tmp_2[i];
	}

    return ssd;
    //add by xujch
}


static void itrans_h_32(U8 cu_width, U8 cu_height, s16 resi[32][32], s16 coef_temp[32][32],  U3 cu_height_log2, U4 bit_depth)
{
	U4 shift2;

	//s16 coef_temp[MAX_TR_DIM];
	shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);

	inv_dct_row_32(cu_width, cu_height, coef_temp, resi, shift2);
}

static void itrans_h_32_lite(U8 cu_width, U8 cu_height, s16 resi[32][32], s16 coef_temp[32][32], U3 cu_height_log2, U4 bit_depth)
{
	U4 shift2;
	static s16 block1[32][32];
#pragma HLS ARRAY_PARTITION variable=block1 dim=1 complete
	U7 size = 32;
	U8 size_b = size - 1;

	//s16 coef_temp[MAX_TR_DIM];

	shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);

	for (int i = 0; i < 32; i++) {
		for (int j = 0; j < 32; j++) {
			block1[i][j] = 0;
		}
	}

	if (cu_width == 32) {
		for (int i = 0; i < cu_width; i++) {
			for (int j = 0; j < cu_height; j++) {
				block1[(i + j) & size_b][j] = coef_temp[i][j];
			}
		}
	} else {
		for (int i = 0; i < cu_width; i++) {
			for (int j = 0; j < cu_height; j++) {
				block1[i][j] = coef_temp[i][j];
			}
		}
	}
	inv_dct_row_32_lite(cu_width, cu_height, block1, resi, shift2);
}
static void inv_dct_row_16x32_lite(s16 coeff[32][32], s16 resi[32][32], U4 shift)
{
#pragma HLS INLINE
	U7 size = 32;
	U8 size_b = size - 1;
	static int E[16], O[16];
	int EE[8], EO[8];
	int EEE[4], EEO[4];
	int EEEE[2], EEEO[2];
	int rnd_factor = 1 << (shift - 1);
	//	#pragma HLS ARRAY_PARTITION variable=E   dim=0 complete
	//	#pragma HLS ARRAY_PARTITION variable=O   dim=0 complete
	//	#pragma HLS ARRAY_PARTITION variable=EE  dim=0 complete
	//	#pragma HLS ARRAY_PARTITION variable=EO  dim=0 complete
	//	#pragma HLS ARRAY_PARTITION variable=EEE dim=0 complete
	//	#pragma HLS ARRAY_PARTITION variable=EEO dim=0 complete
	for (int i = 0; i < 16; i++) {
#pragma HLS PIPELINE
		O[0] = (45) * coeff[(1 + i) & size_b][i] + (45) * coeff[(3 + i) & size_b][i] + (44) * coeff[(5 + i) & size_b][i] + (43) * coeff[(7 + i) & size_b][i] + (41) * coeff[(9 + i) & size_b][i] + (39) * coeff[(11 + i) & size_b][i] + (36) * coeff[(13 + i) & size_b][i] + (34) * coeff[(15 + i) & size_b][i] + (30) * coeff[(17 + i) & size_b][i] + (27) * coeff[(19 + i) & size_b][i] + (23) * coeff[(21 + i) & size_b][i] + (19) * coeff[(23 + i) & size_b][i] + (15) * coeff[(25 + i) & size_b][i] + (11) * coeff[(27 + i) & size_b][i] + (7) * coeff[(29 + i) & size_b][i] + (2) * coeff[(31 + i) & size_b][i];
		O[1] = (45) * coeff[(1 + i) & size_b][i] + (41) * coeff[(3 + i) & size_b][i] + (34) * coeff[(5 + i) & size_b][i] + (23) * coeff[(7 + i) & size_b][i] + (11) * coeff[(9 + i) & size_b][i] + (-2) * coeff[(11 + i) & size_b][i] + (-15) * coeff[(13 + i) & size_b][i] + (-27) * coeff[(15 + i) & size_b][i] + (-36) * coeff[(17 + i) & size_b][i] + (-43) * coeff[(19 + i) & size_b][i] + (-45) * coeff[(21 + i) & size_b][i] + (-44) * coeff[(23 + i) & size_b][i] + (-39) * coeff[(25 + i) & size_b][i] + (-30) * coeff[(27 + i) & size_b][i] + (-19) * coeff[(29 + i) & size_b][i] + (-7) * coeff[(31 + i) & size_b][i];
		O[2] = (44) * coeff[(1 + i) & size_b][i] + (34) * coeff[(3 + i) & size_b][i] + (15) * coeff[(5 + i) & size_b][i] + (-7) * coeff[(7 + i) & size_b][i] + (-27) * coeff[(9 + i) & size_b][i] + (-41) * coeff[(11 + i) & size_b][i] + (-45) * coeff[(13 + i) & size_b][i] + (-39) * coeff[(15 + i) & size_b][i] + (-23) * coeff[(17 + i) & size_b][i] + (-2) * coeff[(19 + i) & size_b][i] + (19) * coeff[(21 + i) & size_b][i] + (36) * coeff[(23 + i) & size_b][i] + (45) * coeff[(25 + i) & size_b][i] + (43) * coeff[(27 + i) & size_b][i] + (30) * coeff[(29 + i) & size_b][i] + (11) * coeff[(31 + i) & size_b][i];
		O[3] = (43) * coeff[(1 + i) & size_b][i] + (23) * coeff[(3 + i) & size_b][i] + (-7) * coeff[(5 + i) & size_b][i] + (-34) * coeff[(7 + i) & size_b][i] + (-45) * coeff[(9 + i) & size_b][i] + (-36) * coeff[(11 + i) & size_b][i] + (-11) * coeff[(13 + i) & size_b][i] + (19) * coeff[(15 + i) & size_b][i] + (41) * coeff[(17 + i) & size_b][i] + (44) * coeff[(19 + i) & size_b][i] + (27) * coeff[(21 + i) & size_b][i] + (-2) * coeff[(23 + i) & size_b][i] + (-30) * coeff[(25 + i) & size_b][i] + (-45) * coeff[(27 + i) & size_b][i] + (-39) * coeff[(29 + i) & size_b][i] + (-15) * coeff[(31 + i) & size_b][i];
		O[4] = (41) * coeff[(1 + i) & size_b][i] + (11) * coeff[(3 + i) & size_b][i] + (-27) * coeff[(5 + i) & size_b][i] + (-45) * coeff[(7 + i) & size_b][i] + (-30) * coeff[(9 + i) & size_b][i] + (7) * coeff[(11 + i) & size_b][i] + (39) * coeff[(13 + i) & size_b][i] + (43) * coeff[(15 + i) & size_b][i] + (15) * coeff[(17 + i) & size_b][i] + (-23) * coeff[(19 + i) & size_b][i] + (-45) * coeff[(21 + i) & size_b][i] + (-34) * coeff[(23 + i) & size_b][i] + (2) * coeff[(25 + i) & size_b][i] + (36) * coeff[(27 + i) & size_b][i] + (44) * coeff[(29 + i) & size_b][i] + (19) * coeff[(31 + i) & size_b][i];
		O[5] = (39) * coeff[(1 + i) & size_b][i] + (-2) * coeff[(3 + i) & size_b][i] + (-41) * coeff[(5 + i) & size_b][i] + (-36) * coeff[(7 + i) & size_b][i] + (7) * coeff[(9 + i) & size_b][i] + (43) * coeff[(11 + i) & size_b][i] + (34) * coeff[(13 + i) & size_b][i] + (-11) * coeff[(15 + i) & size_b][i] + (-44) * coeff[(17 + i) & size_b][i] + (-30) * coeff[(19 + i) & size_b][i] + (15) * coeff[(21 + i) & size_b][i] + (45) * coeff[(23 + i) & size_b][i] + (27) * coeff[(25 + i) & size_b][i] + (-19) * coeff[(27 + i) & size_b][i] + (-45) * coeff[(29 + i) & size_b][i] + (-23) * coeff[(31 + i) & size_b][i];
		O[6] = (36) * coeff[(1 + i) & size_b][i] + (-15) * coeff[(3 + i) & size_b][i] + (-45) * coeff[(5 + i) & size_b][i] + (-11) * coeff[(7 + i) & size_b][i] + (39) * coeff[(9 + i) & size_b][i] + (34) * coeff[(11 + i) & size_b][i] + (-19) * coeff[(13 + i) & size_b][i] + (-45) * coeff[(15 + i) & size_b][i] + (-7) * coeff[(17 + i) & size_b][i] + (41) * coeff[(19 + i) & size_b][i] + (30) * coeff[(21 + i) & size_b][i] + (-23) * coeff[(23 + i) & size_b][i] + (-44) * coeff[(25 + i) & size_b][i] + (-2) * coeff[(27 + i) & size_b][i] + (43) * coeff[(29 + i) & size_b][i] + (27) * coeff[(31 + i) & size_b][i];
		O[7] = (34) * coeff[(1 + i) & size_b][i] + (-27) * coeff[(3 + i) & size_b][i] + (-39) * coeff[(5 + i) & size_b][i] + (19) * coeff[(7 + i) & size_b][i] + (43) * coeff[(9 + i) & size_b][i] + (-11) * coeff[(11 + i) & size_b][i] + (-45) * coeff[(13 + i) & size_b][i] + (2) * coeff[(15 + i) & size_b][i] + (45) * coeff[(17 + i) & size_b][i] + (7) * coeff[(19 + i) & size_b][i] + (-44) * coeff[(21 + i) & size_b][i] + (-15) * coeff[(23 + i) & size_b][i] + (41) * coeff[(25 + i) & size_b][i] + (23) * coeff[(27 + i) & size_b][i] + (-36) * coeff[(29 + i) & size_b][i] + (-30) * coeff[(31 + i) & size_b][i];
		O[8] = (30) * coeff[(1 + i) & size_b][i] + (-36) * coeff[(3 + i) & size_b][i] + (-23) * coeff[(5 + i) & size_b][i] + (41) * coeff[(7 + i) & size_b][i] + (15) * coeff[(9 + i) & size_b][i] + (-44) * coeff[(11 + i) & size_b][i] + (-7) * coeff[(13 + i) & size_b][i] + (45) * coeff[(15 + i) & size_b][i] + (-2) * coeff[(17 + i) & size_b][i] + (-45) * coeff[(19 + i) & size_b][i] + (11) * coeff[(21 + i) & size_b][i] + (43) * coeff[(23 + i) & size_b][i] + (-19) * coeff[(25 + i) & size_b][i] + (-39) * coeff[(27 + i) & size_b][i] + (27) * coeff[(29 + i) & size_b][i] + (34) * coeff[(31 + i) & size_b][i];
		O[9] = (27) * coeff[(1 + i) & size_b][i] + (-43) * coeff[(3 + i) & size_b][i] + (-2) * coeff[(5 + i) & size_b][i] + (44) * coeff[(7 + i) & size_b][i] + (-23) * coeff[(9 + i) & size_b][i] + (-30) * coeff[(11 + i) & size_b][i] + (41) * coeff[(13 + i) & size_b][i] + (7) * coeff[(15 + i) & size_b][i] + (-45) * coeff[(17 + i) & size_b][i] + (19) * coeff[(19 + i) & size_b][i] + (34) * coeff[(21 + i) & size_b][i] + (-39) * coeff[(23 + i) & size_b][i] + (-11) * coeff[(25 + i) & size_b][i] + (45) * coeff[(27 + i) & size_b][i] + (-15) * coeff[(29 + i) & size_b][i] + (-36) * coeff[(31 + i) & size_b][i];
		O[10] = (23) * coeff[(1 + i) & size_b][i] + (-45) * coeff[(3 + i) & size_b][i] + (19) * coeff[(5 + i) & size_b][i] + (27) * coeff[(7 + i) & size_b][i] + (-45) * coeff[(9 + i) & size_b][i] + (15) * coeff[(11 + i) & size_b][i] + (30) * coeff[(13 + i) & size_b][i] + (-44) * coeff[(15 + i) & size_b][i] + (11) * coeff[(17 + i) & size_b][i] + (34) * coeff[(19 + i) & size_b][i] + (-43) * coeff[(21 + i) & size_b][i] + (7) * coeff[(23 + i) & size_b][i] + (36) * coeff[(25 + i) & size_b][i] + (-41) * coeff[(27 + i) & size_b][i] + (2) * coeff[(29 + i) & size_b][i] + (39) * coeff[(31 + i) & size_b][i];
		O[11] = (19) * coeff[(1 + i) & size_b][i] + (-44) * coeff[(3 + i) & size_b][i] + (36) * coeff[(5 + i) & size_b][i] + (-2) * coeff[(7 + i) & size_b][i] + (-34) * coeff[(9 + i) & size_b][i] + (45) * coeff[(11 + i) & size_b][i] + (-23) * coeff[(13 + i) & size_b][i] + (-15) * coeff[(15 + i) & size_b][i] + (43) * coeff[(17 + i) & size_b][i] + (-39) * coeff[(19 + i) & size_b][i] + (7) * coeff[(21 + i) & size_b][i] + (30) * coeff[(23 + i) & size_b][i] + (-45) * coeff[(25 + i) & size_b][i] + (27) * coeff[(27 + i) & size_b][i] + (11) * coeff[(29 + i) & size_b][i] + (-41) * coeff[(31 + i) & size_b][i];
		O[12] = (15) * coeff[(1 + i) & size_b][i] + (-39) * coeff[(3 + i) & size_b][i] + (45) * coeff[(5 + i) & size_b][i] + (-30) * coeff[(7 + i) & size_b][i] + (2) * coeff[(9 + i) & size_b][i] + (27) * coeff[(11 + i) & size_b][i] + (-44) * coeff[(13 + i) & size_b][i] + (41) * coeff[(15 + i) & size_b][i] + (-19) * coeff[(17 + i) & size_b][i] + (-11) * coeff[(19 + i) & size_b][i] + (36) * coeff[(21 + i) & size_b][i] + (-45) * coeff[(23 + i) & size_b][i] + (34) * coeff[(25 + i) & size_b][i] + (-7) * coeff[(27 + i) & size_b][i] + (-23) * coeff[(29 + i) & size_b][i] + (43) * coeff[(31 + i) & size_b][i];
		O[13] = (11) * coeff[(1 + i) & size_b][i] + (-30) * coeff[(3 + i) & size_b][i] + (43) * coeff[(5 + i) & size_b][i] + (-45) * coeff[(7 + i) & size_b][i] + (36) * coeff[(9 + i) & size_b][i] + (-19) * coeff[(11 + i) & size_b][i] + (-2) * coeff[(13 + i) & size_b][i] + (23) * coeff[(15 + i) & size_b][i] + (-39) * coeff[(17 + i) & size_b][i] + (45) * coeff[(19 + i) & size_b][i] + (-41) * coeff[(21 + i) & size_b][i] + (27) * coeff[(23 + i) & size_b][i] + (-7) * coeff[(25 + i) & size_b][i] + (-15) * coeff[(27 + i) & size_b][i] + (34) * coeff[(29 + i) & size_b][i] + (-44) * coeff[(31 + i) & size_b][i];
		O[14] = (7) * coeff[(1 + i) & size_b][i] + (-19) * coeff[(3 + i) & size_b][i] + (30) * coeff[(5 + i) & size_b][i] + (-39) * coeff[(7 + i) & size_b][i] + (44) * coeff[(9 + i) & size_b][i] + (-45) * coeff[(11 + i) & size_b][i] + (43) * coeff[(13 + i) & size_b][i] + (-36) * coeff[(15 + i) & size_b][i] + (27) * coeff[(17 + i) & size_b][i] + (-15) * coeff[(19 + i) & size_b][i] + (2) * coeff[(21 + i) & size_b][i] + (11) * coeff[(23 + i) & size_b][i] + (-23) * coeff[(25 + i) & size_b][i] + (34) * coeff[(27 + i) & size_b][i] + (-41) * coeff[(29 + i) & size_b][i] + (45) * coeff[(31 + i) & size_b][i];
		O[15] = (2) * coeff[(1 + i) & size_b][i] + (-7) * coeff[(3 + i) & size_b][i] + (11) * coeff[(5 + i) & size_b][i] + (-15) * coeff[(7 + i) & size_b][i] + (19) * coeff[(9 + i) & size_b][i] + (-23) * coeff[(11 + i) & size_b][i] + (27) * coeff[(13 + i) & size_b][i] + (-30) * coeff[(15 + i) & size_b][i] + (34) * coeff[(17 + i) & size_b][i] + (-36) * coeff[(19 + i) & size_b][i] + (39) * coeff[(21 + i) & size_b][i] + (-41) * coeff[(23 + i) & size_b][i] + (43) * coeff[(25 + i) & size_b][i] + (-44) * coeff[(27 + i) & size_b][i] + (45) * coeff[(29 + i) & size_b][i] + (-45) * coeff[(31 + i) & size_b][i];

		EO[0] = (45) * coeff[(2 + i) & size_b][i] + (43) * coeff[(6 + i) & size_b][i] + (40) * coeff[(10 + i) & size_b][i] + (35) * coeff[(14 + i) & size_b][i] + (29) * coeff[(18 + i) & size_b][i] + (21) * coeff[(22 + i) & size_b][i] + (13) * coeff[(26 + i) & size_b][i] + (4) * coeff[(30 + i) & size_b][i];
		EO[1] = (43) * coeff[(2 + i) & size_b][i] + (29) * coeff[(6 + i) & size_b][i] + (4) * coeff[(10 + i) & size_b][i] + (-21) * coeff[(14 + i) & size_b][i] + (-40) * coeff[(18 + i) & size_b][i] + (-45) * coeff[(22 + i) & size_b][i] + (-35) * coeff[(26 + i) & size_b][i] + (-13) * coeff[(30 + i) & size_b][i];
		EO[2] = (40) * coeff[(2 + i) & size_b][i] + (4) * coeff[(6 + i) & size_b][i] + (-35) * coeff[(10 + i) & size_b][i] + (-43) * coeff[(14 + i) & size_b][i] + (-13) * coeff[(18 + i) & size_b][i] + (29) * coeff[(22 + i) & size_b][i] + (45) * coeff[(26 + i) & size_b][i] + (21) * coeff[(30 + i) & size_b][i];
		EO[3] = (35) * coeff[(2 + i) & size_b][i] + (-21) * coeff[(6 + i) & size_b][i] + (-43) * coeff[(10 + i) & size_b][i] + (4) * coeff[(14 + i) & size_b][i] + (45) * coeff[(18 + i) & size_b][i] + (13) * coeff[(22 + i) & size_b][i] + (-40) * coeff[(26 + i) & size_b][i] + (-29) * coeff[(30 + i) & size_b][i];
		EO[4] = (29) * coeff[(2 + i) & size_b][i] + (-40) * coeff[(6 + i) & size_b][i] + (-13) * coeff[(10 + i) & size_b][i] + (45) * coeff[(14 + i) & size_b][i] + (-4) * coeff[(18 + i) & size_b][i] + (-43) * coeff[(22 + i) & size_b][i] + (21) * coeff[(26 + i) & size_b][i] + (35) * coeff[(30 + i) & size_b][i];
		EO[5] = (21) * coeff[(2 + i) & size_b][i] + (-45) * coeff[(6 + i) & size_b][i] + (29) * coeff[(10 + i) & size_b][i] + (13) * coeff[(14 + i) & size_b][i] + (-43) * coeff[(18 + i) & size_b][i] + (35) * coeff[(22 + i) & size_b][i] + (4) * coeff[(26 + i) & size_b][i] + (-40) * coeff[(30 + i) & size_b][i];
		EO[6] = (13) * coeff[(2 + i) & size_b][i] + (-35) * coeff[(6 + i) & size_b][i] + (45) * coeff[(10 + i) & size_b][i] + (-40) * coeff[(14 + i) & size_b][i] + (21) * coeff[(18 + i) & size_b][i] + (4) * coeff[(22 + i) & size_b][i] + (-29) * coeff[(26 + i) & size_b][i] + (43) * coeff[(30 + i) & size_b][i];
		EO[7] = (4) * coeff[(2 + i) & size_b][i] + (-13) * coeff[(6 + i) & size_b][i] + (21) * coeff[(10 + i) & size_b][i] + (-29) * coeff[(14 + i) & size_b][i] + (35) * coeff[(18 + i) & size_b][i] + (-40) * coeff[(22 + i) & size_b][i] + (43) * coeff[(26 + i) & size_b][i] + (-45) * coeff[(30 + i) & size_b][i];

		EEO[0] = (44) * coeff[(4 + i) & size_b][i] + (38) * coeff[(12 + i) & size_b][i] + (25) * coeff[(20 + i) & size_b][i] + (9) * coeff[(28 + i) & size_b][i];
		EEO[1] = (38) * coeff[(4 + i) & size_b][i] + (-9) * coeff[(12 + i) & size_b][i] + (-44) * coeff[(20 + i) & size_b][i] + (-25) * coeff[(28 + i) & size_b][i];
		EEO[2] = (25) * coeff[(4 + i) & size_b][i] + (-44) * coeff[(12 + i) & size_b][i] + (9) * coeff[(20 + i) & size_b][i] + (38) * coeff[(28 + i) & size_b][i];
		EEO[3] = (9) * coeff[(4 + i) & size_b][i] + (-25) * coeff[(12 + i) & size_b][i] + (38) * coeff[(20 + i) & size_b][i] + (-44) * coeff[(28 + i) & size_b][i];

		EEEO[0] = (42) * coeff[(8 + i) & size_b][i] + (17) * coeff[(24 + i) & size_b][i];
		EEEO[1] = (17) * coeff[(8 + i) & size_b][i] + (-42) * coeff[(24 + i) & size_b][i];
		EEEE[0] = (32) * coeff[(0 + i) & size_b][i] + (32) * coeff[(16 + i) & size_b][i];
		EEEE[1] = (32) * coeff[(0 + i) & size_b][i] + (-32) * coeff[(16 + i) & size_b][i];

		EEE[0] = EEEE[0] + EEEO[0];
		EEE[3] = EEEE[0] - EEEO[0];
		EEE[1] = EEEE[1] + EEEO[1];
		EEE[2] = EEEE[1] - EEEO[1];

		for (int k = 0; k < 4; k++) {
			EE[k] = EEE[k] + EEO[k];
			EE[k + 4] = EEE[3 - k] - EEO[3 - k];
		}
		for (int k = 0; k < 8; k++) {
			E[k] = EE[k] + EO[k];
			E[k + 8] = EE[7 - k] - EO[7 - k];
		}
		for (int k = 0; k < 16; k++) {
			resi[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
			resi[i][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
		}
	}
}
static void itrans_h_16x32_lite(U8 cu_width, U8 cu_height, s16 resi[32][32], /*s16 coef_temp[32][32],*/s16 block1[32][32], U3 cu_height_log2, U4 bit_depth)
{
#pragma HLS INLINE OFF
	U4 shift2;
	//static s16 block1[32][32];
//#pragma HLS ARRAY_PARTITION variable=block1 dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=resi dim=2 complete
	U7 size = 32;
	U8 size_b = size - 1;

	//s16 coef_temp[MAX_TR_DIM];

	shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);

	//	for (int i = 0; i < 32; i++) {
	//		for (int j = 0; j < 32; j++) {
	//			block1[i][j] = 0;
	//		}
	//	}
	//
	//	if (cu_width == 32) {
	//		for (int i = 0; i < cu_width; i++) {
	//			for (int j = 0; j < cu_height; j++) {
	//				block1[(i + j) & size_b][j] = coef_temp[i][j];
	//			}
	//		}
	//	} else {
	//		for (int i = 0; i < cu_width; i++) {
	//			for (int j = 0; j < cu_height; j++) {
	//				block1[i][j] = coef_temp[i][j];
	//			}
	//		}
	//	}
		//inv_dct_row_32_lite(cu_width, cu_height, block1, resi, shift2);
	inv_dct_row_16x32_lite(block1, resi, shift2);
}
static void itrans_h_32x32_lite(U8 cu_width, U8 cu_height, s16 resi[32][32], /*s16 coef_temp[32][32],*/s16 block1[32][32], U3 cu_height_log2, U4 bit_depth)
{
#pragma HLS INLINE off

	U4 shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);

#if 0
	static s16 block1[32][32];
#pragma HLS ARRAY_PARTITION variable=block1 dim=1 complete
	U7 size = 32;
	U8 size_b = size - 1;

	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < 32; j++) {
			block1[(i + j) & size_b][j] = coef_temp[i][j];
		}
	}
#endif

	inv_dct_row_32x32_lite(block1, resi, shift2);
}
static void itrans_h_32x16_lite(U8 cu_width, U8 cu_height, s16 resi[32][32], s16 coef_temp[32][32], U3 cu_height_log2, U4 bit_depth)
{
	U4 shift2 = com_get_inverse_trans_shift(cu_height_log2, 1, bit_depth);

#if 0
	static s16 block1[32][32];
#pragma HLS ARRAY_PARTITION variable=block1 dim=1 complete
	for (int i = 0; i < 32; i++) {
		for (int j = 0; j < 32; j++) {
			block1[i][j] = 0;
		}
	}
	for (int i = 0; i < cu_width; i++) {
		for (int j = 0; j < cu_height; j++) {
			block1[i][j] = coef_temp[i][j];
		}
	}
	inv_dct_row_32x16_lite(block1, resi, shift2);
#else
	inv_dct_row_32x16_lite(coef_temp, resi, shift2);
#endif 
}

static void recon_32(s16 resi[32][32], pel pred[32][32], int is_coef,  U7 cu_width, U7 cu_height, pel rec[32][32], U4 bit_depth)
{
	//get_part_num(part);
	pel p;
	//pel* r;

	//r = rec/* + tb_y * s_rec + tb_x*/;
	/* just copy pred to rec */
	U1 is_coef_not_zero = is_coef != 0;
    for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
        for (int j = 0; j < 32; j++) {			
			if (is_coef_not_zero) {
				p = pred[i][j] + resi[i][j];
			}
			else {
			p = pred[i][j];
			}

			if ((i < cu_height) && (j < cu_width)) {
				rec[i][j] = (0 > p ? 0 : (1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p);
			}
		}
		//r += s_rec;
	}
}

static void recon_32_lite(s16 resi[32][32], pel pred[32][32], int is_coef, U3 plane, U7 cu_width, U7 cu_height, pel rec[32][32], pel rec_local[32][32], U4 bit_depth)
{
#pragma HLS INLINE off

//#pragma HLS ARRAY_PARTITION variable=resi       dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=pred       dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=rec        dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=rec_local  dim=2 complete

	//get_part_num(part);
	pel p;
	//pel* r;
	//r = rec/* + tb_y * s_rec + tb_x*/;
	/* just copy pred to rec */
    U1 is_coef_not_zero = (is_coef != 0);
#if 0
	for (int i = 0; i < cu_height; i++) {
		for (int j = 0; j < cu_width; j++) {
			p = pred[i][j];
			if (is_coef_not_zero)
				p += resi[i][j];
			rec[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
            rec_local[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
		}
		//r += s_rec;
	}
#else
    for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
        if (i < cu_height) {
            for (int j = 0; j < 32; j++) {
                if (j < cu_width) {
                    if (is_coef_not_zero) {
                        p = pred[i][j] + resi[i][j];
                    } else { 
                        p = pred[i][j];
                    }
                    rec      [i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
                    rec_local[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
                }
            }
        }
    }
#endif
}
template<int H, int W>
static void recon_32x_lite(s16 resi[32][32], pel pred[32][32], int is_coef, U3 plane, U7 cu_width, U7 cu_height, pel rec[32][32], pel rec_local[32][32], U4 bit_depth)
{
#pragma HLS INLINE off

	pel p;
    U1 is_coef_not_zero = (is_coef != 0);

    for (int i = 0; i < H; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < W; j++) {
			if (is_coef_not_zero) {
				p = pred[i][j] + resi[i][j];
			} else { 
				p = pred[i][j];
			}
			rec      [i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
			rec_local[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));
		}
    }
}
template<int H, int W>
static void recon_32x_lite_ssd(int is_coef, U4 bit_depth, U3 type, s16 resi[32][32], pel pred[32][32], s16 org[32][32], pel rec[32][32], s32* ssd_rec, s64* ssd_pred)
{
#pragma HLS INLINE off

#ifdef _MD_32x16_
#pragma HLS ARRAY_PARTITION variable=resi dim=1 cyclic factor=2
#pragma HLS ARRAY_PARTITION variable=pred dim=1 cyclic factor=2
#pragma HLS ARRAY_PARTITION variable=org  dim=1 cyclic factor=2
#pragma HLS ARRAY_PARTITION variable=rec  dim=1 cyclic factor=2
#endif //_MD_32x16_

    U1 is_coef_not_zero = (is_coef != 0);
	int shift = (bit_depth - 8) << 1;
	s64 ssd_r = 0;
	s64 ssd_p = 0;
	s64 ssd_tmp_r_1[W];
	s64 ssd_tmp_r_2[H];
#pragma HLS ARRAY_PARTITION variable=ssd_tmp_r_1 dim=1 complete
#pragma HLS ARRAY_PARTITION variable=ssd_tmp_r_2 dim=1 complete
	s64 ssd_tmp_p_1[W];
	s64 ssd_tmp_p_2[H];
#pragma HLS ARRAY_PARTITION variable=ssd_tmp_p_1 dim=1 complete
#pragma HLS ARRAY_PARTITION variable=ssd_tmp_p_2 dim=1 complete

	for (int i=0; i<H; i++) {
#pragma HLS UNROLL
		ssd_tmp_r_2[i] = 0;
		ssd_tmp_p_2[i] = 0;
	}

    LOOP_recon_32x_lite_ssd__0: for (int i = 0; i < H; i++) {
#pragma HLS PIPELINE
#ifdef _MD_32x16_
#pragma HLS UNROLL factor=2
#endif //_MD_32x16_

		for (int j = 0; j < W; j++) {
#pragma HLS UNROLL

			pel p;
			if (is_coef_not_zero) {
				p = pred[i][j] + resi[i][j];
			} else { 
				p = pred[i][j];
			}
			rec[i][j] = (((0 > (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)) ? 0 : (((1 << bit_depth) - 1 < p ? (1 << bit_depth) - 1 : p)))));

			int diff_r = rec [i][j] - org[i][j];
			int diff_p = pred[i][j] - org[i][j];

			ssd_tmp_r_1[j] = diff_r * diff_r >> shift;
			ssd_tmp_p_1[j] = diff_p * diff_p >> shift;
		}

		for (int j=0; j<W; j++) {
#pragma HLS UNROLL
			ssd_tmp_r_2[i] += ssd_tmp_r_1[j];
			ssd_tmp_p_2[i] += ssd_tmp_p_1[j];
		}
    }

	for (int i=0; i<H; i++) {
#pragma HLS UNROLL
		ssd_r += ssd_tmp_r_2[i];
		ssd_p += ssd_tmp_p_2[i];
	}

	if (!type) {
		*ssd_rec  = ssd_r;
		*ssd_pred = ssd_p;
	} else {
		*ssd_rec  = 0;
		*ssd_pred = MAX_S64;
	}
}


 void transform_hor_32_chroma(int cu_width_log2_chroma,U8 cu_width, U8 cu_height, U4 bit_depth, s16 resi[32][32], s16 coef_tmp[32][32], int rdo_idx, int all_rdo_num)
{
	//xingxing pay attention to it

	//cu_plane_nz_cln(num_nz, type);
	 U3 tb_width_log2 = cu_width_log2_chroma;// com_tbl_log2[cu_width];

	U4 shift1;
	if (rdo_idx < all_rdo_num) {

	shift1 = com_get_forward_trans_shift(tb_width_log2, 0, bit_depth);
	/*if (slice_type == 2) {
		if (tree_status == TREE_L && type != 0) {
			num_nz[0][type] = 0;
			return 0;
		}
		if (tree_status == TREE_C && type == 0) {
			num_nz[0][type] = 0;
			return 0;
		}
	}*/
	dct_row_Chroma32(cu_width, cu_height, resi, coef_tmp, shift1);
	}

}

// MD_KERNEL_32 TRANS_H TOP
static u8 transform_hor_32_lite(U8 cu_width, U8 cu_height, U4 bit_depth, s16 resi[32][32], s16 coef_temp[32][32], U2 slice_type)
{
#pragma HLS INLINE off

#pragma HLS ARRAY_PARTITION variable=resi       dim=2 complete
#pragma HLS ARRAY_PARTITION variable=coef_temp  dim=2 complete

	U3 tb_width_log2  = com_tbl_log2[cu_width];
	U3 tb_height_log2 = com_tbl_log2[cu_height];
	U4 shift1;
	shift1 = com_get_forward_trans_shift(tb_width_log2, 0, bit_depth);
	//dct_row_32_lite(cu_width, cu_height, resi, coef_temp, shift1);
	dct_row_luma_32(cu_width, cu_height, resi, coef_temp, shift1);
	return 1;
}

 void transform_ver_32_chroma(int cu_height_log2_chroma,U8 cu_width, U8 cu_height,  U4 bit_depth,   s16 coef_tmp[32][32],s16 coef[32][32], int rdo_idx, int all_rdo_num)
{

	 U3 tb_height_log2 = cu_height_log2_chroma;// com_tbl_log2[cu_height];
	 if (rdo_idx < all_rdo_num) {
	U4 shift2;





	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, bit_depth);
	dct_col_Chroma32(cu_width, cu_height, coef_tmp, coef, shift2);
	 }
}

// MD_KERNEL_32 TRANS_V TOP
static u8 transform_ver_32_lite(U8 cu_width, U8 cu_height, U2 slice_type, U4 bit_depth,  s16 coef_tmp[32][32], s16 coef[32][32])
{
#pragma HLS INLINE off

#pragma HLS ARRAY_PARTITION variable=coef_tmp   dim=2 complete
#pragma HLS ARRAY_PARTITION variable=coef       dim=1 complete

	U3 tb_width_log2  = com_tbl_log2[cu_width];
	U3 tb_height_log2 = com_tbl_log2[cu_height];
	//s16 coef_input[32][32];

	U4 shift2;
	U7 size = 32;
	U8 size_b = size - 1;
	shift2 = com_get_forward_trans_shift(tb_height_log2, 1, bit_depth);
	dct_col_32_lite(cu_width, cu_height, coef_tmp, coef, shift2);

	return 1;
}

// MD_KERNEL_32 I_TRANS_V TOP
static void inv_transform_ver_32_lite(U8 cu_width, U8 cu_height, U4 bit_depth, U6 qp_y, int num_nz_itv, int* num_nz_ith, int num_nz_update[MAX_NUM_TB][N_C], s16 coef_tmp[32][32], U3 cu_width_log2, U3 cu_height_log2, U7 tb_w, U7 tb_h, U3 type, s16 coef_tmp_h_to_it[32][32])
{
#pragma HLS INLINE off

#pragma HLS ARRAY_PARTITION variable=coef_tmp           dim=1 complete
#pragma HLS ARRAY_PARTITION variable=coef_tmp_h_to_it   dim=1 complete

	U3 tb_width_log2  = com_tbl_log2[cu_width];
	U3 tb_height_log2 = com_tbl_log2[cu_height];
	int num_nz_read = num_nz_itv;	// STREAM BUFFER

#ifndef __SYNTHESIS__
	static s16 coef_dq[32][32];
#else
	s16 coef_dq[32][32];
#endif
#pragma HLS ARRAY_PARTITION variable=coef_dq dim=1 complete
	
#ifndef _BLOCK_MD_32x32_ //--------------------------------------------------------------------------------------------------------------------
	if ((cu_width == 32) && (cu_height == 32)) {
		if (num_nz_read) {
			//dquant_32(cu_width, cu_height, qp_y, coef_tmp, coef_dq, tb_width_log2, tb_height_log2, bit_depth, &num_nz_read);
			dquant_32x<32, 32>(qp_y, coef_tmp, coef_dq, tb_width_log2, tb_height_log2, bit_depth, &num_nz_read);

			//itrans_v_32x32_lite(cu_width, cu_height, coef_dq, coef_tmp_h_to_it, tb_width_log2, bit_depth);
			U4 shift1 = com_get_inverse_trans_shift(tb_width_log2, 0, bit_depth);
			//inv_dct_col_32xN_lite(coef_dq, coef_tmp_h_to_it, shift1,32);
			inv_dct_col_32_luma(coef_dq, coef_tmp_h_to_it, shift1, 32);
		}
	} else
#endif //_BLOCK_MD_32x32_

#ifndef _BLOCK_MD_32x16_ //--------------------------------------------------------------------------------------------------------------------
	if ((cu_width == 16) && (cu_height == 32)) {
		if (num_nz_read) {
#if 0 // Try HLS 32x16
			dquant_32(cu_width, cu_height, qp_y, coef_tmp, coef_dq, tb_width_log2, tb_height_log2, bit_depth, &num_nz_read);
			itrans_v_32_lite(cu_width, cu_height, coef_dq, coef_tmp_h_to_it, tb_width_log2, bit_depth);
#else
			dquant_32x<32, 16>(qp_y, coef_tmp, coef_dq, tb_width_log2, tb_height_log2, bit_depth, & num_nz_read);
			itrans_v_32x16_lite(coef_dq, coef_tmp_h_to_it, tb_width_log2, bit_depth);
#endif
		}
	} else
#endif //_BLOCK_MD_32x16_

#ifndef _BLOCK_MD_16x32_ //--------------------------------------------------------------------------------------------------------------------
	if ((cu_width == 32) && (cu_height == 16)) {
	
		if (num_nz_read) {
			dquant_16x32(qp_y, coef_tmp, coef_dq, tb_width_log2, tb_height_log2, bit_depth, &num_nz_read);
			//dquant_32(cu_width, cu_height, qp_y, coef_tmp, coef_dq, tb_width_log2, tb_height_log2, bit_depth, &num_nz_read);
			//itrans_v_32_lite(cu_width, cu_height, coef_dq, coef_tmp_h_to_it, tb_width_log2, bit_depth);
			U4 shift1 = com_get_inverse_trans_shift(tb_width_log2, 0, bit_depth);
			//inv_dct_col_32xN_lite(coef_dq, coef_tmp_h_to_it, shift1,16);
			inv_dct_col_32_luma(coef_dq, coef_tmp_h_to_it, shift1, 16);
		}
	}
#endif //_BLOCK_MD_16x32_

	// WRITE STREAMS
	*num_nz_ith         = num_nz_read;
	num_nz_update[0][0] = num_nz_read;
}

// MD_KERNEL_32 I_TRANS_H TOP
static void inv_transform_hor_32_lite(U8 cu_width, U8 cu_height, U4 bit_depth, int num_nz_ith,
	U3 cu_width_log2, U3 cu_height_log2, pel pred_cache[32][32], s32* dist, s64* dist_fz, pel rec[32][32], s16 coef_temp[32][32], U3 type, pel org[32][32], pel org_1[32][32] /*, pel pred_cache_32x32_update[32][32]*/)
{
#pragma HLS INLINE off


#pragma HLS ARRAY_PARTITION variable=rec        dim=2 complete
#pragma HLS ARRAY_PARTITION variable=org       	dim=2 complete

    pel        rec_local[32][32];
    static s16 resi[32][32];
#pragma HLS ARRAY_PARTITION variable=resi       dim=2 complete

    int s_org = 32;

//	// Move into other sub-module
//    for (int i = 0; i < 32; ++i) {
//#pragma HLS PIPELINE
//        for (int j = 0; j < 32; ++j) {
//			pred_cache_32x32_update[i][j] = pred_cache[i][j];
//		}
//	}

	// STREAM BUFFER
	s32 dist_write; 	// = 0;
	s64 dist_fz_write;  // = MAX_S64;
	int num_nz_read = num_nz_ith;

#if 0
	if (num_nz_read) {
		//com_itrans_h(resi, coef_temp, tb_width_log2, tb_height_log2, bit_depth);
		itrans_h_32_lite(cu_width, cu_height, resi, coef_temp, cu_height_log2, bit_depth);
	}

    recon_32_lite(resi, pred_cache, num_nz_read, type, cu_width, cu_height, rec, rec_local, bit_depth);

	if (!type) {
		dist_write    = enc_ssd_16b_1_32(cu_width_log2, cu_height_log2, rec_local,  org,   s_org, bit_depth);
		dist_fz_write = enc_ssd_16b_1_32(cu_width_log2, cu_height_log2, pred_cache, org_1, s_org, bit_depth);
	} else {
		dist_write    = 0;
		dist_fz_write = MAX_S64;
	}
#else
#ifndef _BLOCK_MD_32x32_ //--------------------------------------------------------------------------------------------------------------------
	if ((cu_width == 32) && (cu_height == 32)) {
		if (num_nz_read) {
			//com_itrans_h(resi, coef_temp, tb_width_log2, tb_height_log2, bit_depth);
			itrans_h_32x32_lite(cu_width, cu_height, resi, coef_temp, cu_height_log2, bit_depth);
		}
#if 0
		recon_32_lite(resi, pred_cache, num_nz_read, type, cu_width, cu_height, rec, rec_local, bit_depth);
		if (!type) {
			dist_write    = enc_ssd_16b_1_32x<32, 32>(rec_local,  org,   bit_depth);
			dist_fz_write = enc_ssd_16b_1_32x<32, 32>(pred_cache, org_1, bit_depth);
		} else {
			dist_write    = 0;
			dist_fz_write = MAX_S64;
		}
#else
		recon_32x_lite_ssd<32, 32>(num_nz_read, bit_depth, type, resi, pred_cache, org, rec, &dist_write, &dist_fz_write);
#endif //0
	} else 
#endif //_BLOCK_MD_32x32_
#ifndef _BLOCK_MD_32x16_ //--------------------------------------------------------------------------------------------------------------------
	if ((cu_width == 16) && (cu_height == 32)) {
		if (num_nz_read) {
			itrans_h_32x16_lite(cu_width, cu_height, resi, coef_temp, cu_height_log2, bit_depth);
		}
		recon_32x_lite_ssd<32, 16>(num_nz_read, bit_depth, type, resi, pred_cache, org, rec, &dist_write, &dist_fz_write);
	} else
#endif // _BLOCK_MD_32x16_
#ifndef _BLOCK_MD_16x32_ //--------------------------------------------------------------------------------------------------------------------
	if ((cu_width == 32) && (cu_height == 16)) {
		if (num_nz_read) {
			//com_itrans_h(resi, coef_temp, tb_width_log2, tb_height_log2, bit_depth);
			//itrans_h_32_lite(cu_width, cu_height, resi, coef_temp, cu_height_log2, bit_depth);
			itrans_h_16x32_lite(cu_width, cu_height, resi, coef_temp, cu_height_log2, bit_depth);
		}

		//recon_32_lite(resi, pred_cache, num_nz_read, type, cu_width, cu_height, rec, rec_local, bit_depth);
		recon_32x_lite_ssd<16, 32>(num_nz_read, bit_depth, type, resi, pred_cache, org, rec, &dist_write, &dist_fz_write);
		/*if (!type) {
			dist_write    = enc_ssd_16b_1_32(cu_width_log2, cu_height_log2, rec_local,  org,   s_org, bit_depth);
			dist_fz_write = enc_ssd_16b_1_32(cu_width_log2, cu_height_log2, pred_cache, org_1, s_org, bit_depth);
		} else {
			dist_write    = 0;
			dist_fz_write = MAX_S64;
		}*/
	}
#endif //_BLOCK_MD_16x32_
#endif

	// WRITE STREAMS
	*dist    = dist_write;
	*dist_fz = dist_fz_write;
}

/////////////////////quant nnz
void level_core_32(U8 cu_width, U8 cu_height, u32 level[24], u32 level1[24], U5 t0[64], U7 i, int max_num)
{
	int tmp = 0;
	int pos = 0;
	int max_pos = cu_width <= cu_height ? 63 : 64;
	for (pos = 0; pos < 64; pos++)
	{
		if (pos < max_num && pos < max_pos)
		{
			tmp += !(t0[pos] - i);
		}
	}
	level[i] += tmp;
	level1[i + 1] += 8 * tmp;
}
void run_core_32(U8 cu_width, U8 cu_height, u32 run[24], u32 run1[24], U5 t0[64], U7 i, U1 mat_run[64], int max_num)
{
	int tmp = 0;
	int tmp2 = 0;
	int pos = 0;
	int max_pos = cu_width <= cu_height ? 63 : 64;
	for (pos = 0; pos < 64; pos++)
	{
		if (pos < max_num && pos < max_pos)
		{
			tmp += !(t0[pos] - i);
			tmp2 += mat_run[pos];
		}
	}
	run[i] += tmp;
	run1[i + 1] += tmp2;
}
void last1_core_32(U8 cu_width, U8 cu_height, u32 last1[12], U4 t0[64], U7 i, int max_num)
{
	int tmp = 0;
	int pos = 0;
	int max_pos = cu_width <= cu_height ? 63 : 64;
	for (pos = 0; pos < 64; pos++)
	{
		if (pos < max_num && pos < max_pos)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last1[i] += tmp;
}
void last2_core_32(U8 cu_width, U8 cu_height, u32 last2[22], U5 t0[64], U7 i, int max_num)
{
	int tmp = 0;
	int pos = 0;
	int max_pos = cu_width <= cu_height ? 63 : 64;
	for (pos = 0; pos < 64; pos++)
	{
		if (pos < max_num && pos < max_pos)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last2[i] += tmp;
}

//void model_update_32(U8 cu_width, U8 cu_height, u32 last1[12], u32 last2[22], u32 run[24], u32 level[24], U1 mat_run[64], U24 mat_prev_level[64], U2 ch_type, int max_num)
void model_update_32(int base_idx,U8 cu_width, U8 cu_height, u32 last1[12], u32 last2[22], u32 run[24], u32 level[24], U1 mat_run[64], U24 mat_prev_level[64], U2 ch_type, int max_num)
{

	U7 scan_pos = 0;
	static U5 t0[64] = { 0 };
	static U4 last1_pos[64] = { 0 };
	static U5 last2_pos[64] = { 0 };
	static u32 last1_tmp[12] = { 0 };
	static u32 last2_tmp[22] = { 0 };
	static u32 level_tmp[24] = { 0 };
	static u32 level_tmp1[24] = { 0 };
	static u32 run_tmp[24] = { 0 };
	static u32 run_tmp1[24] = { 0 };
	int ace_log2 = 0;
	int max_pos = cu_width <= cu_height ? 63 : 64;
	for (scan_pos = 0; scan_pos < 64; scan_pos++)
	{
		if (scan_pos >= max_pos)
			break;

		if (scan_pos < max_num)
		{
			//if (scan_pos + 1 < 2) {
			if (scan_pos + 1 + base_idx < 2) {
				ace_log2 = 0;
			}
			//else if (scan_pos + 1 < 4) {
			else if (scan_pos + 1 + base_idx < 4) {
				ace_log2 = 1;
			}
			//else if (scan_pos + 1 < 8) {
			else if (scan_pos + 1 + base_idx < 8) {
				ace_log2 = 2;
			}
			//else if (scan_pos + 1 < 16) {
			else if (scan_pos + 1 + base_idx < 16) {
				ace_log2 = 3;
			}
			//else if (scan_pos + 1 < 32) {
			else if (scan_pos + 1 + base_idx < 32) {
				ace_log2 = 4;
			}
			//else if (scan_pos + 1 < 64) {
			else if (scan_pos + 1 + base_idx < 64) {
				ace_log2 = 5;
			}
			//else if (scan_pos + 1 < 128) {
			else if (scan_pos + 1 + base_idx < 128) {
				ace_log2 = 6;
			}
			//else if (scan_pos + 1 < 256) {
			else if (scan_pos + 1 + base_idx < 256) {
				ace_log2 = 7;
			}
			//else if (scan_pos + 1 < 512) {
			else if (scan_pos + 1 + base_idx < 512) {
				ace_log2 = 8;
			}
			//else if (scan_pos + 1 < 1024) {
			else if (scan_pos + 1 + base_idx < 1024) {
				ace_log2 = 9;
			}
			//else if (scan_pos + 1 < 2048) {
			else if (scan_pos + 1 + base_idx < 2048) {
				ace_log2 = 10;
			}
			//else if (scan_pos + 1 < 4096) {
			else if (scan_pos + 1 + base_idx < 4096) {
				ace_log2 = 11;
			}
			else {
				ace_log2 = 11;
			}

			t0[scan_pos] = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5)) * 2) + (ch_type == 0 ? 0 : 12);
			last1_pos[scan_pos] = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5))) + (ch_type == 0 ? 0 : 6);
			last2_pos[scan_pos] = ace_log2 + (ch_type == 0 ? 0 : 12);
		}
	}

	for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
	{
		level_core_32(cu_width, cu_height, level_tmp, level_tmp1, t0, scan_pos, max_num);
		run_core_32(cu_width, cu_height, run_tmp, run_tmp1, t0, scan_pos, mat_run, max_num);
	}

	for (scan_pos = 0; scan_pos < 12; scan_pos++)
	{
		last1_core_32(cu_width, cu_height, last1_tmp, last1_pos, scan_pos, max_num);
		last1[scan_pos] += last1_tmp[scan_pos];
	}

	for (scan_pos = 0; scan_pos < 22; scan_pos++)
	{
		last2_core_32(cu_width, cu_height, last2_tmp, last2_pos, scan_pos, max_num);
		last2[scan_pos] += last2_tmp[scan_pos];
	}

	for (scan_pos = 0; scan_pos < 24; scan_pos++)
	{
		level[scan_pos] += level_tmp[scan_pos] + level_tmp1[scan_pos];
		run[scan_pos] += run_tmp[scan_pos] + run_tmp1[scan_pos];
	}
}

void read_data_32(U8 cu_width, U8 cu_height, s16 coef64[64], s16 src_coef[32][32], U7 i)
{
	int a, b;
	int index = i << 1;

	for (int j = 0; j < 64; j++)
	{
		coef64[j] = 0;
	}

	if (cu_width <= cu_height) {
		if (i == 0)
		{
			coef64[0] = src_coef[0][0];
			coef64[1] = src_coef[0][1];
			coef64[2] = src_coef[1][0];
		}
		else
		{
			u8 index = i << 1;

			for (a = 32; a >= 0; a--)
			{
				if (a <= index)
					coef64[index - a] = src_coef[a][index - a];
			}
			for (b = 0; b < 32 + 2; b++)
			{
				if (b < index + 2)
					coef64[index + 1 + b] = src_coef[b][index + 1 - b];
			}
		}
	}
	else {
		if (i == 0)
		{
			coef64[0] = src_coef[0][0];
			coef64[1] = src_coef[0][1];
			coef64[2] = src_coef[1][0];
		}
		else if (i == 1)
		{
			for (a = 2; a >= 0; a--)
			{
				coef64[2 - a] = src_coef[a][2 - a];
			}
			for (b = 0; b < 4; b++)
			{
				coef64[3 + b] = src_coef[b][3 - b];
			}
		}

		else if (cu_height == 4)
		{
			for (a = 3; a >= 0; a--)
			{
				coef64[cu_height - 1 - a] = src_coef[a][index - a];
			}
			for (b = 0; b < 4; b++)
			{
				coef64[cu_height + b] = src_coef[b][index + 1 - b];
			}
		}
		else if (cu_height != 4 && i == 2)
		{
			for (a = 4; a >= 0; a--)
			{
				coef64[4 - a] = src_coef[a][4 - a];
			}
			for (b = 0; b < 6; b++)
			{
				coef64[5 + b] = src_coef[b][5 - b];
			}
		}
		else if (cu_height != 4 && i == 3)
		{
			for (a = 6; a >= 0; a--)
			{
				coef64[6 - a] = src_coef[a][6 - a];
			}
			for (b = 0; b < 8; b++)
			{
				coef64[7 + b] = src_coef[b][7 - b];
			}
		}
		else if (cu_height == 8 || cu_height == 16)
		{
			int index_a = COM_MIN((U8)index, (U8)(cu_height - 1));
			int index_b = COM_MIN((U8)(index + 1), (U8)cu_height);
			for (a = 15; a >= 0; a--)
			{
				if (a <= index_a)
					coef64[index_a - a] = src_coef[a][index - a];
			}
			for (b = 0; b < 16; b++)
			{
				if (b < COM_MIN((U8)(index + 2), cu_height))
					coef64[index_b + b] = src_coef[b][index + 1 - b];
			}
		}
	}
}

void read_data_32_lite(U8 cu_width, U8 cu_height, s16 coef64[64], s16 src_coef[32][32], U7 i)
{
	s8 a, b;
	s8 index = i << 1;

	for (int i = 0; i < 64; i++)
	{
		coef64[i] = 0;
	}

	if (cu_width <= cu_height) {
		if (i == 0)
		{
			coef64[0] = src_coef[0][0];
			coef64[1] = src_coef[0][1];
			coef64[2] = src_coef[1][0];
		}
		else
		{
			for (a = 30; a >= 0; a--)
			{
				if (a <= index)
					coef64[index - a] = src_coef[a][index - a];
			}
			for (b = 0; b < 32; b++)
			{
				if (b < index + 2)
					coef64[index + 1 + b] = src_coef[b][index + 1 - b];
			}
		}
	}
	else {
		if (i == 0)
		{
			coef64[0] = src_coef[0][0];
			coef64[1] = src_coef[0][1];
			coef64[2] = src_coef[1][0];
		}
		//		else if (i == 1)
		//		{
		//			for (a = 2; a >= 0; a--)
		//			{
		//				coef64[2 - a] = src_coef[a][2 - a];
		//			}
		//			for (b = 0; b < 4; b++)
		//			{
		//				coef64[3 + b] = src_coef[b][3 - b];
		//			}
		//		}
		//
		//		else if (cu_height == 4)
		//		{
		//			for (a = 3; a >= 0; a--)
		//			{
		//				coef64[cu_height - 1 - a] = src_coef[a][index - a];
		//			}
		//			for (b = 0; b < 4; b++)
		//			{
		//				coef64[cu_height + b] = src_coef[b][index + 1 - b];
		//			}
		//		}
		//		else if (/*cu_height != 4 && */i == 2)
		//		{
		//			for (a = 4; a >= 0; a--)
		//			{
		//				coef64[4 - a] = src_coef[a][4 - a];
		//			}
		//			for (b = 0; b < 6; b++)
		//			{
		//				coef64[5 + b] = src_coef[b][5 - b];
		//			}
		//		}
		//		else if (/*cu_height != 4 &&*/ i == 3)
		//		{
		//			for (a = 6; a >= 0; a--)
		//			{
		//				coef64[6 - a] = src_coef[a][6 - a];
		//			}
		//			for (b = 0; b < 8; b++)
		//			{
		//				coef64[7 + b] = src_coef[b][7 - b];
		//			}
		//		}
		else if (i < 4)
		{
			for (a = 6; a >= 0; a--)
			{
				if (a <= index)
					coef64[index - a] = src_coef[a][index - a];
			}
			for (b = 0; b < 8; b++)
			{
				if (b < index + 2)
					coef64[index + 1 + b] = src_coef[b][index + 1 - b];
			}
		}
		else if (cu_height == 8 || cu_height == 16)
		{
			int index_a = COM_MIN((U8)index, (U8)(cu_height - 1));
			int index_b = COM_MIN((U8)(index + 1), (U8)cu_height);
			for (a = 15; a >= 0; a--)
			{
				if (a <= index_a)
					coef64[index_a - a] = src_coef[a][index - a];
			}
			for (b = 0; b < 16; b++)
			{
				if (b < COM_MIN((U8)(index + 2), (U8)cu_height))
					coef64[index_b + b] = src_coef[b][index + 1 - b];
			}
		}
	}
}

void rdoq_core_32(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U24 last_level[32 / 2 + 1], U24 prev_level[32 / 2 + 1], int* pzb, s64 base_cost, int* x_pos, int* y_pos, s64 best_cost_out[32 / 2 + 1], s64 last_cost[32 / 2 + 1], int q_value, U7 cyc, int q_bits, s64 err_scale, s64 lambda, U1 is_intra, s16 coef64[64], s16 dst_coef[64], U2 ch_type, RDOQ_ARRAY* rdoq_array)
{
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	int num_nz_coef = 0;
	int cnt = 4 * cyc + 3;
	int scan_pos;
	static s64 d64_base_cost[64] = { 0 };
	s64 d64_coded_cost = 0;
	s64 d64_uncoded_cost = 0;
	static s16 tmp_coef[64] = { 0 };
	static U36 tmp_level_double[64] = { 0 };
	s64 best_cost = best_cost_out[cyc];
	int max_pos = cu_width <= cu_height ? (U9)63 : (U9)(2 * cu_height);

	int base_idx = (2 * cyc + 1) * cyc;

	for (scan_pos = 0; scan_pos < 63; scan_pos++)
	{
		if (scan_pos < max_pos)
		{
			U36 level_double = coef64[scan_pos];
			U24 max_abs_level;
			U1 lower_int;
			U36 temp_level;
			temp_level = ((s64)COM_ABS(coef64[scan_pos]) * (s64)q_value);
			level_double = (int)COM_MIN(((s64)temp_level), (s64)COM_INT32_MAX - ((s64)1 << (q_bits - 1)));
			tmp_level_double[scan_pos] = level_double;
			max_abs_level = (u32)(level_double >> q_bits);
			lower_int = ((level_double - ((s64)max_abs_level << q_bits)) < ((s64)1 << (q_bits - 1))) ? 1 : 0;
			if (!lower_int)
			{
				max_abs_level++;
			}
			tmp_coef[scan_pos] = coef64[scan_pos] > 0 ? (s16)max_abs_level : -(s16)(max_abs_level);
		}
		else
			tmp_coef[scan_pos] = 0;
	}

	static U24 mat_prev_level[64] = { 0 };
	static U1 mat_run[64] = { 0 };

	if (last_level[cyc])
	{
		mat_prev_level[0] = last_level[cyc];
		mat_run[0] = 0;
	}
	else
	{
		mat_prev_level[0] = prev_level[cyc];
		mat_run[0] = 1;
	}

	for (scan_pos = 0; scan_pos < 63; scan_pos++)
	{
		if (scan_pos < max_pos)
		{
			if (COM_ABS(tmp_coef[scan_pos]))
			{
				mat_prev_level[scan_pos] = COM_ABS(tmp_coef[scan_pos]);
				mat_run[scan_pos] = 0;
			}
			else
			{
				mat_prev_level[scan_pos] = 1;
				mat_run[scan_pos] = 1;
			}
		}
	}

	static s64 mat_uncoded_cost[64] = { 0 };
	static s64 mat_coded_cost[64] = { 0 };
	static U24 lev_opt[64] = { 0 };
	u16 ctx_run = 0;

	for (scan_pos = 0; scan_pos < 63; scan_pos++)
	{
		if (scan_pos < max_pos)
		{
			U24 level;
			U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5)) << 1) + (ch_type == Y_C ? 0 : 12);

			level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[scan_pos], COM_ABS(tmp_coef[scan_pos]),
				mat_run[scan_pos], (u16)ctx_run, (u16)ctx_run, q_bits, err_scale, lambda, 0, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level);
			dst_coef[scan_pos] = (s16)(tmp_coef[scan_pos] < 0 ? -(s16)(level) : (s16)level);

			mat_uncoded_cost[scan_pos] = d64_uncoded_cost;
			mat_coded_cost[scan_pos] = d64_coded_cost;
			lev_opt[scan_pos] = level;
		}
	}

	static s64 d64_cost_last_zero[64] = { 0 };
	int ace_log2 = 0;
	if (cyc == 0)
	{
		d64_cost_last_zero[0] = 0;
	}
	else
	{
		if ((base_idx) < 2)
		{
			ace_log2 = 0;
		}
		else if ((base_idx) < 4)
		{
			ace_log2 = 1;
		}
		else if ((base_idx) < 8)
		{
			ace_log2 = 2;
		}
		else if ((base_idx) < 16)
		{
			ace_log2 = 3;
		}
		else if ((base_idx) < 32)
		{
			ace_log2 = 4;
		}
		else if ((base_idx) < 64)
		{
			ace_log2 = 5;
		}
		else if ((base_idx) < 128)
		{
			ace_log2 = 6;
		}
		else if ((base_idx) < 256)
		{
			ace_log2 = 7;
		}
		else if ((base_idx) < 512)
		{
			ace_log2 = 8;
		}
		else if ((base_idx) < 1024)
		{
			ace_log2 = 9;
		}
		else if ((base_idx) < 2048)
		{
			ace_log2 = 10;
		}
		else if ((base_idx) < 4096)
		{
			ace_log2 = 11;
		}
		else
		{
			ace_log2 = 11;
		}
		d64_cost_last_zero[0] = GET_I_COST(rdoq_array->rdoq_est_last[ctx_last][COM_MIN((U24)(prev_level[cyc] - 1), (U24)5)][ace_log2][0], lambda);
		//d64_cost_last_zero[0] = d64_cost_last_zero[0] >> 24;
		//d64_cost_last_zero[0] = d64_cost_last_zero[0] >> 24;
	}

	for (scan_pos = 0; scan_pos < 63; scan_pos++)
	{
		if (scan_pos >= max_pos)
			break;

		if ((scan_pos + base_idx) < 2)
		{
			ace_log2 = 0;
		}
		else if ((scan_pos + base_idx) < 4)
		{
			ace_log2 = 1;
		}
		else if ((scan_pos + base_idx) < 8)
		{
			ace_log2 = 2;
		}
		else if ((scan_pos + base_idx) < 16)
		{
			ace_log2 = 3;
		}
		else if ((scan_pos + base_idx) < 32)
		{
			ace_log2 = 4;
		}
		else if ((scan_pos + base_idx) < 64)
		{
			ace_log2 = 5;
		}
		else if ((scan_pos + base_idx) < 128)
		{
			ace_log2 = 6;
		}
		else if ((scan_pos + base_idx) < 256)
		{
			ace_log2 = 7;
		}
		else if ((scan_pos + base_idx) < 512)
		{
			ace_log2 = 8;
		}
		else if ((scan_pos + base_idx) < 1024)
		{
			ace_log2 = 9;
		}
		else if ((scan_pos + base_idx) < 2048)
		{
			ace_log2 = 10;
		}
		else if ((scan_pos + base_idx) < 4096)
		{
			ace_log2 = 11;
		}
		else
		{
			ace_log2 = 11;
		}
		d64_cost_last_zero[scan_pos] = GET_I_COST(rdoq_array->rdoq_est_last[ctx_last][COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)5)][ace_log2][0], lambda);
		//d64_cost_last_zero[scan_pos] = d64_cost_last_zero[scan_pos] >> 24;
		//d64_cost_last_zero[scan_pos] = d64_cost_last_zero[scan_pos] >> 24;
	}

	if (cyc != 0)
		d64_base_cost[0] = last_cost[cyc];
	else
		d64_base_cost[0] = base_cost;

	d64_base_cost[0] -= mat_uncoded_cost[0];
	d64_base_cost[0] += mat_coded_cost[0];
	d64_base_cost[0] += d64_cost_last_zero[0] * !!(lev_opt[0]);
	for (scan_pos = 1; scan_pos < 63; scan_pos++)
	{
		if (scan_pos < max_pos)
		{
			d64_base_cost[scan_pos] = d64_base_cost[0];
			for (int i = 1; i <= 62; i++)
			{
				if (i <= scan_pos)
					d64_base_cost[scan_pos] += mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i] * !!(lev_opt[i]);
			}
		}
	}

	for (scan_pos = 0; scan_pos < 63; scan_pos++)
	{
		if (scan_pos >= max_pos)
			break;

		if (scan_pos < cnt)
		{
			if ((scan_pos + base_idx + 1) < 2)
			{
				ace_log2 = 0;
			}
			else if ((scan_pos + base_idx + 1) < 4)
			{
				ace_log2 = 1;
			}
			else if ((scan_pos + base_idx + 1) < 8)
			{
				ace_log2 = 2;
			}
			else if ((scan_pos + base_idx + 1) < 16)
			{
				ace_log2 = 3;
			}
			else if ((scan_pos + base_idx + 1) < 32)
			{
				ace_log2 = 4;
			}
			else if ((scan_pos + base_idx + 1) < 64)
			{
				ace_log2 = 5;
			}
			else if ((scan_pos + base_idx + 1) < 128)
			{
				ace_log2 = 6;
			}
			else if ((scan_pos + base_idx + 1) < 256)
			{
				ace_log2 = 7;
			}
			else if ((scan_pos + base_idx + 1) < 512)
			{
				ace_log2 = 8;
			}
			else if ((scan_pos + base_idx + 1) < 1024)
			{
				ace_log2 = 9;
			}
			else if ((scan_pos + base_idx + 1) < 2048)
			{
				ace_log2 = 10;
			}
			else if ((scan_pos + base_idx + 1) < 4096)
			{
				ace_log2 = 11;
			}
			else
			{
				ace_log2 = 11;
			}
			U24 prev_level = mat_prev_level[scan_pos];
			s64 d64_cost_last_one = GET_I_COST(rdoq_array->rdoq_est_last[ctx_last][COM_MIN((U24)(prev_level - 1), (U24)5)][ace_log2][1], lambda);
			//d64_cost_last_one = d64_cost_last_one >> 24;
			//d64_cost_last_one = d64_cost_last_one >> 24;
			if (COM_ABS(dst_coef[scan_pos]))
			{
				s64 d64_cur_is_last_cost = d64_base_cost[scan_pos] + d64_cost_last_one;

				if (d64_cur_is_last_cost < best_cost)
				{
					*pzb = 1;
					best_cost = d64_cur_is_last_cost;

					if (cu_width <= cu_height)
					{
						if (scan_pos < (2 * cyc + 1))
						{
							*x_pos = 2 * cyc;
							*y_pos = 2 * cyc - scan_pos;
						}
						else
						{
							*x_pos = 2 * cyc + 1;
							*y_pos = scan_pos - 2 * cyc - 1;
						}
					}
					else
					{
						if (cyc < cu_height / 2)
						{
							if (scan_pos < (2 * cyc + 1))
							{
								*x_pos = 2 * cyc;
								*y_pos = 2 * cyc - scan_pos;
							}
							else
							{
								*x_pos = 2 * cyc + 1;
								*y_pos = scan_pos - 2 * cyc - 1;
							}
						}
						else
						{
							if (scan_pos < cu_height)
							{
								*x_pos = 2 * cyc;
								*y_pos = cu_height - 1 - scan_pos;
							}
							else
							{
								*x_pos = 2 * cyc + 1;
								*y_pos = scan_pos - cu_height;
							}
						}
					}

				}
			}
		}
	}
	//model_update_32(cu_width, cu_height, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level, mat_run, mat_prev_level, ch_type, cnt);
	model_update_32(base_idx,cu_width, cu_height, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level, mat_run, mat_prev_level, ch_type, cnt);

	if (cnt <= max_pos)
	{
		last_cost[cyc + 1] = d64_base_cost[cnt - 1];
		prev_level[cyc + 1] = mat_prev_level[cnt - 1];
		last_level[cyc + 1] = COM_ABS(tmp_coef[cnt - 1]);
	}
	else
	{
		last_cost[cyc + 1] = d64_base_cost[max_pos - 1];
		prev_level[cyc + 1] = mat_prev_level[max_pos - 1];
		last_level[cyc + 1] = COM_ABS(tmp_coef[max_pos - 1]);
	}
	best_cost_out[cyc + 1] = best_cost;
}
void write_data_32(U8 cu_width, U8 cu_height, s16 dst_tmp[32][32], s16 dst64[64], U7 i)
{
	int a, b;
	int index = i << 1;
	if (cu_width <= cu_height) {
		if (i == 0)
		{
			dst_tmp[0][0] = dst64[0];
			dst_tmp[0][1] = dst64[1];
			dst_tmp[1][0] = dst64[2];
		}
		else
		{
			for (a = 30; a >= 0; a--)
			{
				if (a <= index)
					dst_tmp[a][index - a] = dst64[index - a];
			}
			for (b = 0; b < 30 + 2; b++)
			{
				if (b < index + 2)
					dst_tmp[b][index + 1 - b] = dst64[index + 1 + b];
			}
		}
	}
	else {
		if (i == 0)
		{
			dst_tmp[0][0] = dst64[0];
			dst_tmp[0][1] = dst64[1];
			dst_tmp[1][0] = dst64[2];
		}
		else if (i == 1)
		{
			for (a = 2; a >= 0; a--)
			{
				dst_tmp[a][2 - a] = dst64[2 - a];
			}
			for (b = 0; b < 4; b++)
			{
				dst_tmp[b][3 - b] = dst64[3 + b];
			}
		}
		//#if (H == 4)
		else if (cu_height == 4)
		{
			for (a = 3; a >= 0; a--)
			{
				dst_tmp[a][index - a] = dst64[cu_height - 1 - a];
			}
			for (b = 0; b < 4; b++)
			{
				dst_tmp[b][index + 1 - b] = dst64[cu_height + b];
			}
		}
		//#else
		else if (cu_height != 4 && i == 2)
		{
			for (a = 4; a >= 0; a--)
			{
				dst_tmp[a][4 - a] = dst64[4 - a];
			}
			for (b = 0; b < 6; b++)
			{
				dst_tmp[b][5 - b] = dst64[5 + b];
			}
		}
		else if (cu_height != 4 && i == 3)
		{
			for (a = 6; a >= 0; a--)
			{
				dst_tmp[a][6 - a] = dst64[6 - a];
			}
			for (b = 0; b < 8; b++)
			{
				dst_tmp[b][7 - b] = dst64[7 + b];
			}
		}
		//#if (H == 8)
		else if (cu_height == 8)
		{
			for (a = 7; a >= 0; a--)
			{
				dst_tmp[a][index - a] = dst64[cu_height - 1 - a];
			}
			for (b = 0; b < 8; b++)
			{
				dst_tmp[b][index + 1 - b] = dst64[cu_height + b];
			}
		}
		//#elif (H == 16)
		else if (cu_height == 16)
		{
			for (a = 15; a >= 0; a--)
			{
				if (a <= COM_MIN((U8)index, (U8)(cu_height - 1)))
					dst_tmp[a][index - a] = dst64[COM_MIN((U8)index, (U8)(cu_height - 1)) - a];
			}
			for (b = 0; b < 16; b++)
			{
				if (b < COM_MIN((U8)(index + 2), (U8)cu_height))
					dst_tmp[b][index + 1 - b] = dst64[COM_MIN((U8)(index + 1), (U8)cu_height) + b];
			}
		}
	}
}

void write_data_32_lite(U8 cu_width, U8 cu_height, s16 dst_tmp[32][32], s16 dst64[64], U7 i)
{
	s8 a, b;
	s8 index = i << 1;
	if (cu_width <= cu_height) {
		if (i == 0)
		{
			dst_tmp[0][0] = dst64[0];
			dst_tmp[0][1] = dst64[1];
			dst_tmp[1][0] = dst64[2];
		}
		else
		{
			for (a = 30; a >= 0; a--)
			{
				if (a <= index)
					dst_tmp[a][index - a] = dst64[index - a];
			}
			for (b = 0; b < 32; b++)
			{
				if (b < index + 2)
					dst_tmp[b][index + 1 - b] = dst64[index + 1 + b];
			}
		}
	}
	else {
		if (i == 0)
		{
			dst_tmp[0][0] = dst64[0];
			dst_tmp[0][1] = dst64[1];
			dst_tmp[1][0] = dst64[2];
		}
		else if (i < 4)
		{
			for (a = 6; a >= 0; a--)
			{
				if (a <= index)
					dst_tmp[a][index - a] = dst64[index - a];
			}
			for (b = 0; b < 8; b++)
			{
				if (b < index + 2)
					dst_tmp[b][index + 1 - b] = dst64[index + 1 + b];
			}
		}
		//#if (H == 8)
		else if (cu_height == 8)
		{
			for (a = 7; a >= 0; a--)
			{
				dst_tmp[a][index - a] = dst64[cu_height - 1 - a];
			}
			for (b = 0; b < 8; b++)
			{
				dst_tmp[b][index + 1 - b] = dst64[cu_height + b];
			}
		}
		//#elif (H == 16)
		else if (cu_height == 16)
		{
			for (a = 15; a >= 0; a--)
			{
				if (a <= COM_MIN((U8)index, (U8)(cu_height - 1)))
					dst_tmp[a][index - a] = dst64[COM_MIN((U8)index, (U8)(cu_height - 1)) - a];
			}
			for (b = 0; b < 16; b++)
			{
				if (b < COM_MIN((U8)(index + 2), cu_height))
					dst_tmp[b][index + 1 - b] = dst64[COM_MIN((U8)(index + 1), (U8)cu_height) + b];
			}
		}
	}
}

int clean_nz_32(U8 cu_width, U8 cu_height, s16 dst_tmp[32][32], int x_pos, int y_pos, int pzb)
{
	int i;
	int j;
	static U1 mask[32][32] = { 0 };
	int num_nz_coef = 0;
	for (i = 0; i < 32; i++)
	{
		if (i < cu_height)
		{
			for (j = 0; j < 32; j++)
			{
				if (j < cu_width)
				{
					if (!pzb)
						mask[i][j] = 0;
					else
					{
						if ((i + j) > x_pos)
						{
							mask[i][j] = 0;
						}
						else if ((i + j) == x_pos)
						{
							if (x_pos & 1)
							{
								if (i > y_pos)
								{
									mask[i][j] = 0;
								}
								else
								{
									mask[i][j] = 1;
								}
							}
							else
							{
								if (i < y_pos)
								{
									mask[i][j] = 0;
								}
								else
								{
									mask[i][j] = 1;
								}
							}
						}
						else
						{
							mask[i][j] = 1;
						}
					}
					dst_tmp[i][j] = dst_tmp[i][j] * mask[i][j];
					num_nz_coef += !!(dst_tmp[i][j]);
				}

			}
		}
	}
	return num_nz_coef;
}

int rdoq_top_32(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[32][32], s16 dst_tmp[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{

	//int cu_width = 1<<cu_width_log2;
	//int cu_height = 1 << cu_height_log2;

	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	const U14 scale = quant_scale[qp];
	const int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const int q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	const int q_bits = QUANT_SHIFT + tr_shift;
	int num_nz_coef = 0;
	//const s64 lambda = (s64)(d_lambda * (double)(1 << SCALE_BITS) + 0.5);
	const s64 lambda = (d_lambda * (1 << 15) + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };

	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static s64 last_cost[16 + 1];
	static s64 best_cost[16 + 1];
	int x_pos = 0;
	int y_pos = 0;
	static s16 dst64_tmp[64];
	s64 d64_base_cost0 = 0;
	static s16 tmp_coef[64] = { 0 };
	static U24 last_level[16 + 1];
	static U24 prev_level[16 + 1];
	last_level[0] = 6;
	prev_level[0] = 6;
	int pzb = 0;
	last_cost[0] = 0;

	if (!is_intra && ch_type == Y_C)
	{
		d64_base_cost0 = 0;
		best_cost[0] = 0;
	}
	else
	{
		d64_base_cost0 = GET_I_COST(rdoq_array->rdoq_est_cbf[ch_type][1], lambda);
		//d64_base_cost0 = d64_base_cost0 >> 24;
		//d64_base_cost0 = d64_base_cost0 >> 24;
		best_cost[0] = GET_I_COST(rdoq_array->rdoq_est_cbf[ch_type][0], lambda);
		//best_cost[0] = best_cost[0] >> 24;
		//best_cost[0] = best_cost[0] >> 24;
	}


	for (U7 cyc = 0; cyc < 16; cyc++)
	{
		if (cyc < (cu_width >> 1))
		{
			read_data_32(cu_width, cu_height, tmp_coef, src_coef, cyc);
			rdoq_core_32(cu_width, cu_height, model_cnt, last_level, prev_level, &pzb, d64_base_cost0, &x_pos, &y_pos, best_cost, last_cost, q_value, cyc, q_bits, err_scale, lambda, is_intra, tmp_coef, dst64_tmp, ch_type, rdoq_array);
			write_data_32(cu_width, cu_height, dst_tmp, dst64_tmp, cyc);
		}
	}

	num_nz_coef = clean_nz_32(cu_width, cu_height, dst_tmp, x_pos, y_pos, pzb);
	return num_nz_coef;
}

int rdoq_top_32_luma(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[32][32], s16 dst_tmp[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{

	//int cu_width = 1<<cu_width_log2;
	//int cu_height = 1 << cu_height_log2;

	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	const U14 scale = quant_scale[qp];
	const int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const int q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	const int q_bits = QUANT_SHIFT + tr_shift;
	int num_nz_coef = 0;
	//const s64 lambda = (s64)(d_lambda * (double)(1 << SCALE_BITS) + 0.5);
	const s64 lambda = (d_lambda * (1 << 15) + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };

	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static s64 last_cost[16 + 1];
	static s64 best_cost[16 + 1];
	int x_pos = 0;
	int y_pos = 0;
	static s16 dst64_tmp[64];
	s64 d64_base_cost0 = 0;
	static s16 tmp_coef[64] = { 0 };
	static U24 last_level[16 + 1];
	static U24 prev_level[16 + 1];
	last_level[0] = 6;
	prev_level[0] = 6;
	int pzb = 0;
	last_cost[0] = 0;

	if (!is_intra && ch_type == Y_C)
	{
		d64_base_cost0 = 0;
		best_cost[0] = 0;
	}
	else
	{
		d64_base_cost0 = GET_I_COST(rdoq_array->rdoq_est_cbf[ch_type][1], lambda);
		best_cost[0] = GET_I_COST(rdoq_array->rdoq_est_cbf[ch_type][0], lambda);
	}


	for (U7 cyc = 0; cyc < 16; cyc++)
	{
		if (cyc < (cu_width >> 1))
		{
			read_data_32(cu_width, cu_height, tmp_coef, src_coef, cyc);
			rdoq_core_32(cu_width, cu_height, model_cnt, last_level, prev_level, &pzb, d64_base_cost0, &x_pos, &y_pos, best_cost, last_cost, q_value, cyc, q_bits, err_scale, lambda, is_intra, tmp_coef, dst64_tmp, ch_type, rdoq_array);
			write_data_32(cu_width, cu_height, dst_tmp, dst64_tmp, cyc);
		}
	}

	num_nz_coef = clean_nz_32(cu_width, cu_height, dst_tmp, x_pos, y_pos, pzb);
	return num_nz_coef;
}

int rdoq_top_32_lite(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[32][32], s16 dst_tmp[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth,RDOQ_ARRAY* rdoq_array)
{

	//int cu_width = 1<<cu_width_log2;
	//int cu_height = 1 << cu_height_log2;

	U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	const U14 scale = quant_scale[qp];
	const int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const int q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	const int q_bits = QUANT_SHIFT + tr_shift;
	int num_nz_coef = 0;
	//const s64 lambda = (s64)(d_lambda * (double)(1 << SCALE_BITS) + 0.5);
	const s64 lambda = (d_lambda * (1 << 15) + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };

	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	s64 last_cost[16 + 1];
	s64 best_cost[16 + 1];
	int x_pos = 0;
	int y_pos = 0;
	static s16 dst64_tmp[64];
	s64 d64_base_cost0 = 0;
	static s16 tmp_coef[64];
	static U24 last_level[16 + 1];
	static U24 prev_level[16 + 1];
	last_level[0] = 6;
	prev_level[0] = 6;
	int pzb = 0;
	last_cost[0] = 0;

	if (!is_intra && ch_type == Y_C)
	{
		d64_base_cost0 = 0;
		best_cost[0] = 0;
	}
	else
	{
		d64_base_cost0 = GET_I_COST(rdoq_array->rdoq_est_cbf[ch_type][1], lambda);
		best_cost[0] = GET_I_COST(rdoq_array->rdoq_est_cbf[ch_type][0], lambda);
	}


	for (U7 cyc = 0; cyc < 16; cyc++)
	{
		if (cyc < (cu_width >> 1))
		{
			read_data_32_lite(cu_width, cu_height, tmp_coef, src_coef, cyc);
			rdoq_core_32(cu_width, cu_height, model_cnt, last_level, prev_level, &pzb, d64_base_cost0, &x_pos, &y_pos, best_cost, last_cost, q_value, cyc, q_bits, err_scale, lambda, is_intra, tmp_coef, dst64_tmp, ch_type, rdoq_array);
			write_data_32_lite(cu_width, cu_height, dst_tmp, dst64_tmp, cyc);
		}
	}

	num_nz_coef = clean_nz_32(cu_width, cu_height, dst_tmp, x_pos, y_pos, pzb);
	return num_nz_coef;
}

static U4 get_ace_log2(U32 scan_pos)
{
	U4 ace_log2 = 0;
	if ((scan_pos) < 2)
	{
		ace_log2 = 0;
	}
	else if ((scan_pos) < 4)
	{
		ace_log2 = 1;
	}
	else if ((scan_pos) < 8)
	{
		ace_log2 = 2;
	}
	else if ((scan_pos) < 16)
	{
		ace_log2 = 3;
	}
	else if ((scan_pos) < 32)
	{
		ace_log2 = 4;
	}
	else if ((scan_pos) < 64)
	{
		ace_log2 = 5;
	}
	else if ((scan_pos) < 128)
	{
		ace_log2 = 6;
	}
	else if ((scan_pos) < 256)
	{
		ace_log2 = 7;
	}
	else if ((scan_pos) < 512)
	{
		ace_log2 = 8;
	}
	else if ((scan_pos) < 1024)
	{
		ace_log2 = 9;
	}
	else if ((scan_pos) < 2048)
	{
		ace_log2 = 10;
	}
	else if ((scan_pos) < 4096)
	{
		ace_log2 = 11;
	}
	else
	{
		ace_log2 = 11;
	}
	return ace_log2;
}

void CleanNz_32_32(int* num_nz_coef, s16 dst_tmp[32][32], S16 tmp_dst_coef[1024], int final_x, int final_y)
{
	for (int i = 0; i < 32; i++)
	{
		for (int j = 0; j < 32; j++)
		{
			if (i + j < final_x + final_y) {
				dst_tmp[i][j] = tmp_dst_coef[i * 32 + j];
			}
			else if (i + j == final_x + final_y) {
				if ((final_x + final_y) % 2 == 1) {
					if (i<final_x && j>final_y) {
						dst_tmp[i][j] = 0;
					}
					else {
						dst_tmp[i][j] = tmp_dst_coef[i * 32 + j];
					}
				}
				else {
					if (i > final_x && j < final_y) {
						dst_tmp[i][j] = 0;
					}
					else {
						dst_tmp[i][j] = tmp_dst_coef[i * 32 + j];
					}
				}
			}
			else {
				dst_tmp[i][j] = 0;
			}
			*num_nz_coef += !!(dst_tmp[i][j]);
		}

	}
}


void rdoq_32_32_hardware(s16 src_coef[32][32], U6 qp, S32 q_bits, S16 tmp_dst_coef_out[1024], u32 last1[12], u32 last2[22],
	u32 run[24], u32 level[24],
	s32 rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth,int* final_x,int* final_y)
{
	U3 cu_width_log2 = 5;
	U3 cu_height_log2 = 5;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const int q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	//const int q_bits = QUANT_SHIFT + tr_shift;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	static S16 tmp_dst_coef[32];
	static U36 tmp_level_double[32];
	static S16 tmp_coef[32];
	static S64 d64_cost_last_zero[32] = { 0 };
	//const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	static U24 lev_opt[32];
	static S64 mat_coded_cost[32];
	static S64 mat_uncoded_cost[32];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[1024] = { 0 };
	static S64 base_cost_buffer[1024] = { 0 };
	// added by xfhuang.
	static S64 base_cost_buffer_tmp[32] = { 0 };
	//S64 d64_base_cost_tmp[1024] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	static U24 mat_prev_level[32] = { 0 };
	static U1 mat_run[32] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[32] = { 0 };
	S64 finalRdoqCost = 0;
	static S64 tempCost[32];   // all scan line cost
	static S64 endPosCost[32]; // as the last position cost.
	static S64 rdoqD64LastOne[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	static int last_x[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	static int last_y[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	static int rdoq_last_x[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	static int rdoq_last_y[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	static U5 t0[32] = { 0 };
	static U4 last1_pos[32] = { 0 };
	static U5 last2_pos[32] = { 0 };


	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		//d64_best_cost = d64_best_cost >> 24;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		//cbf_cost = cbf_cost >> 24;
		// optimize: d64bestCost (cbf=0 cost) compare with (base_cost_buffer[scan_pos] + cbf=1 cost)
		// is same: (cbf=0 cost) - (cbf=1 cost) compare with (base_cost_buffer[scan_pos])
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}


#if 1

	for (int j = 0; j < 32; j++) // vertical
	{
		static u32 last1_tmp[12] = { 0 };
		static u32 last2_tmp[22] = { 0 };
		static u32 level_tmp[24] = { 0 };
		static u32 level_tmp1[24] = { 0 };
		static u32 run_tmp[24] = { 0 };
		static u32 run_tmp1[24] = { 0 };
		static U10 pos[32];
		//pre_quant
		for (int i = 0; i < 32; i++)
		{
			if (i < 32 - j) {
				U36 level_double = src_coef[i][j];
				S25 max_abs_level;
				U1 lower_int;
				U36 temp_level;
				temp_level = (U36)abs(src_coef[i][j]) * q_value;
				level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
				tmp_level_double[i] = level_double;
				max_abs_level = (S32)(level_double >> q_bits);
				lower_int = ((level_double - (max_abs_level << q_bits)) < (1 << (q_bits - 1))) ? 1 : 0;
				if (!lower_int)
				{
					max_abs_level++;
				}
				tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
			}
		}
		//doc
		for (int i = 0; i < 32; i++)
		{
			//U32 blk_pos = scan[scan_pos - 1];
			if (i < 32 - j) {
				if (tmp_coef[i])
				{
					mat_prev_level[i] = abs(tmp_coef[i]);
					//tmp = abs(tmp_coef[blk_pos]);
					mat_run[i] = 0;
				}
				else
				{
					mat_prev_level[i] = 1;
					mat_run[i] = 1;
				}
			}
		}

		for (int i = 0; i < 32; i++)
		{
			if (i < 32 - j) {
				//U32 blk_pos = scan[scan_pos];
				U24 level;
				U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);

				int iflast = (i * 32 + j == 1023);
				level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], abs(tmp_coef[i]),
					mat_run[scan_pos], ctx_run, ctx_run, q_bits, err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
				S17 level_cbf = level;
				tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				tmp_dst_coef_out[i * 32 + j] = tmp_dst_coef[i];
				mat_uncoded_cost[i] = d64_uncoded_cost;
				mat_coded_cost[i] = d64_coded_cost;
				lev_opt[i] = level;
			}
		}
		//model update
		for (int i = 0; i < 32; i++)
		{
			if (i + j <= 31) {
				if ((i + j) % 2 == 1) {
					pos[i] = (i + j + 1)*(i + j) / 2 + i;
				}
				else {
					pos[i] = (i + j + 1)*(i + j) / 2 + j;
				}
				ace_log2 = get_ace_log2(pos[i] + 1);
				t0[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == 0 ? 0 : 12);
				last1_pos[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5)))) + (ch_type == 0 ? 0 : 6);
				last2_pos[i] = ace_log2 + (ch_type == 0 ? 0 : 12);
			}
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
		{
			level_core_32(32, 32, level_tmp, level_tmp1, t0, scan_pos, 32 - j);
			run_core_32(32, 32, run_tmp, run_tmp1, t0, scan_pos, mat_run, 32 - j);
		}

		for (scan_pos = 0; scan_pos < 12; scan_pos++)
		{
			last1_core_32(32, 32, last1_tmp, last1_pos, scan_pos, 32 - j);
			last1[scan_pos] += last1_tmp[scan_pos];
		}

		for (scan_pos = 0; scan_pos < 22; scan_pos++)
		{
			last2_core_32(32, 32, last2_tmp, last2_pos, scan_pos, 32 - j);
			last2[scan_pos] += last2_tmp[scan_pos];
		}

		for (scan_pos = 0; scan_pos < 24; scan_pos++)
		{
			level[scan_pos] += level_tmp[scan_pos] + level_tmp1[scan_pos];
			run[scan_pos] += run_tmp[scan_pos] + run_tmp1[scan_pos];
		}

		//dlnp prepare
		for (int i = 0; i < 32; i++)
		{
			//U8 blk_pos = scan[scan_pos];
			if (i + j <= 31) {
				ace_log2 = get_ace_log2(pos[i]);
				U4 flag = 0;
				if (mat_prev_level[i] - 1 < 5)
				{
					flag = mat_prev_level[i] - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
				//d64_cost_last_zero_tmp[blk_pos] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda; // block scan order
			}
		}

		for (int i = 0; i < 32; i++)
		{
			//int blk_pos = scan[scan_pos];
			if (i < 32 - j) {
				if (lev_opt[i])
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				}
				else
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
				}
				// base_cost_buffer_tmp[blk_pos] = -scan_pos;
				//lev_opt_tmp[blk_pos] = lev_opt[scan_pos] != 0;
			}
		}
		for (int i = 0; i < 32; i++)
		{
			//U8 blk_pos = scan[scan_pos];
			if (i < 32 - j) {
				ace_log2 = get_ace_log2(pos[i]);
				U24 prev_level = mat_prev_level[i];
				U4 flag = 0;
				if (prev_level - 1 < 5)
				{
					flag = prev_level - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
			}
		}

		//dlnp core
		for (int i = 0; i < 32; i++) // horizontal
		{
			if (j == 0)
			{
				// tempCost[j] = base_cost_buffer_tmp[j];
				if (lev_opt[i])
				{

					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];

					// a special case (0, 0) position.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{

					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						// add the rdoqD64LastOne consider here.
						// compare the best LNP for bottom-right scan
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}

					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.


					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						// consider d64_cost_last_one_tmp part cost.
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}

					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						// from start to current position (except current pos.)
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}

					tempCost[i] += curCost; // from the start point to current pos cost.

					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}

		// each row assign.

		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];

		int index = rdoq_last_x[0] * 32 + rdoq_last_y[0];

		// cross check.

		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];

		// shift register.
		for (int i = 1; i < 32; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}

	///////////////////////////////////////////////////


	// back to zig-zag scan order this can be optimized later.
#endif
	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
}

void pre_quant_32_32(U32 scan[1024], S16 src_coef[32][32], U6 qp, S32 q_bits, U36 tmp_level_double[1024], S16 tmp_coef[1024])
{
	U3 cu_width_log2 = 5;
	U3 cu_height_log2 = 5;
	static U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	const U16 scale = quant_scale[qp];
	const U4 ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const U8 ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const U8 ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const U20 q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	for (U32 scan_pos = 0; scan_pos < 528; scan_pos++)
	{
		U32 blk_pos = scan[scan_pos];
		U8 x = blk_pos & (32 - 1);
		U8 y = blk_pos >> 5;

		U36 level_double = src_coef[y][x];
		S25 max_abs_level;
		U1 lower_int;
		U36 temp_level;
		temp_level = (U36)abs(src_coef[y][x]) * q_value;
		level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
		tmp_level_double[blk_pos] = level_double;
		max_abs_level = (S32)(level_double >> q_bits);
		lower_int = ((level_double - (max_abs_level << q_bits)) < (1 << (q_bits - 1))) ? 1 : 0;
		if (!lower_int)
		{
			max_abs_level++;
		}
		tmp_coef[blk_pos] = src_coef[y][x] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
	}
}

void doc_32_32(s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2], U24 lev_opt[1024], S64 mat_uncoded_cost[1024], S64 mat_coded_cost[1024], S16 tmp_dst_coef[1024], U36 tmp_level_double[1024], U32 scan[1024], S16 tmp_coef[1024], U24 mat_prev_level[1024], U1 mat_run[1024], U2 ch_type, S32 q_bits, S64 err_scale, S64 lambda)
{
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S16 tmp = 0;
	mat_prev_level[0] = 6;

	for (U32 scan_pos = 0; scan_pos < 528; scan_pos++)
	{
		U32 blk_pos = scan[scan_pos];

		if (tmp_coef[blk_pos])
		{
			mat_prev_level[scan_pos] = abs(tmp_coef[blk_pos]);
			tmp = abs(tmp_coef[blk_pos]);
			mat_run[scan_pos] = 0;
		}
		else
		{
			mat_prev_level[scan_pos] = 1;
			mat_run[scan_pos] = 1;
		}
	}

	for (U32 scan_pos = 0; scan_pos < 528; scan_pos++)
	{

		U32 blk_pos = scan[scan_pos];
		U24 level;
		U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);

		int iflast = (scan_pos == 1023);
		level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[blk_pos], abs(tmp_coef[blk_pos]),
			mat_run[scan_pos], ctx_run, ctx_run, q_bits, err_scale, lambda, iflast, rdoq_est_run_local, rdoq_est_level_local);
		S17 level_cbf = level;
		tmp_dst_coef[blk_pos] = (S16)(tmp_coef[blk_pos] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);

		mat_uncoded_cost[scan_pos] = d64_uncoded_cost;
		mat_coded_cost[scan_pos] = d64_coded_cost;
		lev_opt[scan_pos] = level;
	}
}


void DLNP_32_32_ver(int* best_last_idx_p1, U24 lev_opt[1024], S64 mat_coded_cost[1024], S64 mat_uncoded_cost[1024], S16 tmp_dst_coef[1024],
	S32 rdoq_est_cbf[3][2], U32 scan[1024], U24 mat_prev_level[1024], S32 rdoq_est_last_local[2][6][12][2],
	U3 ch_type, U1 is_intra, S64 lambda,int* final_x,int* final_y)
{
	const U1 ctx_last = (ch_type == Y_C) ? 0 : 1;
	static S64 d64_cost_last_zero[1024] = { 0 };

	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	static S64 d64_base_cost[1024] = { 0 };
	static S64 base_cost_buffer[1024] = { 0 };
	// added by xfhuang.
	static S64 base_cost_buffer_tmp[1024] = { 0 };
	static U1 lev_opt_tmp[1024] = { 0 };
	static S64 d64_cost_last_zero_tmp[1024] = { 0 };
	static S64 d64_base_cost_tmp[1024] = { 0 };
	S64 d64_best_cost_tmp = 0;
	static int count_tmp = 0;
	int best_last_idx_p1_tmp = 0;

	count_tmp++;

	if (count_tmp == 20445)
	{
		int k = 0;
	}

	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		//d64_best_cost = d64_best_cost >> 24;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		//cbf_cost = cbf_cost >> 24;
		// optimize: d64bestCost (cbf=0 cost) compare with (base_cost_buffer[scan_pos] + cbf=1 cost)
		// is same: (cbf=0 cost) - (cbf=1 cost) compare with (base_cost_buffer[scan_pos])
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}

	// added by xfhuang 
	for (scan_pos = 0; scan_pos < 1024; scan_pos++)
	{
		U32 blk_pos = scan[scan_pos];
		ace_log2 = get_ace_log2(scan_pos);
		U4 flag = 0;
		/*if (mat_prev_level[scan_pos] != 1) {
			printf("mat_prev_level[%d]=%d\n", scan_pos, mat_prev_level[scan_pos]);
		}*/
		if (mat_prev_level[scan_pos] - 1 < 5)
		{
			flag = mat_prev_level[scan_pos] - 1;
		}
		else
		{
			flag = 5;
		}
		d64_cost_last_zero[scan_pos] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
		//d64_cost_last_zero[scan_pos] = d64_cost_last_zero[scan_pos] >> 24;
		d64_cost_last_zero_tmp[blk_pos] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda; // block scan order
		//d64_cost_last_zero_tmp[blk_pos] = d64_cost_last_zero_tmp[blk_pos] >> 24;
	}

	// added by xfhuang 
	static S64 d64_cost_last_one_tmp[1024];
	for (scan_pos = 0; scan_pos < 1024; scan_pos++)
	{
		U32 blk_pos = scan[scan_pos];
		ace_log2 = get_ace_log2(scan_pos + 1);
		U24 prev_level = mat_prev_level[scan_pos];
		U4 flag = 0;
		if (prev_level - 1 < 5)
		{
			flag = prev_level - 1;
		}
		else
		{
			flag = 5;
		}
		d64_cost_last_one_tmp[blk_pos] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
		//d64_cost_last_one_tmp[blk_pos] = d64_cost_last_one_tmp[blk_pos] >> 24;
	}

	for (scan_pos = 0; scan_pos < 528; scan_pos++)
	{
		U32 blk_pos = scan[scan_pos];
		for (U32 i = 0; i < 528; i++)
		{
			if (i <= scan_pos)
			{
				if (lev_opt[i])
				{
					base_cost_buffer[scan_pos] += mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				}
				else
				{
					base_cost_buffer[scan_pos] += mat_coded_cost[i] - mat_uncoded_cost[i];
				}
				// base_cost_buffer[scan_pos] += -i;
				d64_base_cost_tmp[blk_pos] = base_cost_buffer[scan_pos];
			}
		}
	}

#if 1
	// backward to block pose
	// mat_coded_cost mat_uncoded_cost lev_opt are input as zig-zag scan ordeer
	for (int scan_pos = 0; scan_pos < 1024; scan_pos++)
	{
		int blk_pos = scan[scan_pos];
		if (lev_opt[scan_pos])
		{
			base_cost_buffer_tmp[blk_pos] = mat_coded_cost[scan_pos] - mat_uncoded_cost[scan_pos] + d64_cost_last_zero[scan_pos];
		}
		else
		{
			base_cost_buffer_tmp[blk_pos] = mat_coded_cost[scan_pos] - mat_uncoded_cost[scan_pos];
		}
		// base_cost_buffer_tmp[blk_pos] = -scan_pos;
		lev_opt_tmp[blk_pos] = lev_opt[scan_pos] != 0;
	}

	S64 finalRdoqCost = 0;
	static S64 tempCost[32];   // all scan line cost
	static S64 endPosCost[32]; // as the last position cost.
	static S64 rdoqD64LastOne[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	static int last_x[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	static int last_y[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	static int rdoq_last_x[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	static int rdoq_last_y[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;

	for (int j = 0; j < 32; j++) // vertical
	{
		int zzz = 0;
		for (int i = 0; i < 32; i++) // horizontal
		{
			if (j == 0)
			{
				// tempCost[j] = base_cost_buffer_tmp[j];
				if (lev_opt_tmp[i * 32 + j])
				{
					last_x[i] = i;
					last_y[i] = j;

					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i * 32 + j];
				}
				tempCost[i] = base_cost_buffer_tmp[i * 32 + j];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt_tmp[i * 32 + j]) endPosCost[i] = base_cost_buffer_tmp[i * 32 + j];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt_tmp[i * 32 + j]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i * 32 + j];

					// a special case (0, 0) position.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt_tmp[i * 32 + j])
					{
						last_x[i] = i;
						last_y[i] = j;
					}

					if (lev_opt_tmp[i * 32 + j] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						// add the rdoqD64LastOne consider here.
						// compare the best LNP for bottom-right scan
						if (tempCost[i] + base_cost_buffer_tmp[i * 32 + j] + d64_cost_last_one_tmp[i * 32 + j] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i * 32 + j];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i * 32 + j];
						}
					}
					if (lev_opt_tmp[i * 32 + j] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i * 32 + j];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i * 32 + j];
					}

					tempCost[i] += base_cost_buffer_tmp[i * 32 + j];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i * 32 + j];  // care the bit-width. not int.

					if (lev_opt_tmp[i * 32 + j] && last_y[i] == -1) // first non-zero position
					{
						last_x[i] = i;
						last_y[i] = j;
					}

					if (lev_opt_tmp[i * 32 + j] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						// consider d64_cost_last_one_tmp part cost.
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i * 32 + j] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i * 32 + j];
						}
					}

					if (lev_opt_tmp[i * 32 + j] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						// from start to current position (except current pos.)
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i * 32 + j];
					}

					tempCost[i] += curCost; // from the start point to current pos cost.

					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}

		// each row assign.
		if (last_y[0] != -1)
		{
			final_last_x = last_x[0];
			final_last_y = last_y[0];
		}

		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];

		int index = rdoq_last_x[0] * 32 + rdoq_last_y[0];

		// cross check.
		if (index >= 0 && temp_RdoqCost != d64_base_cost_tmp[index])
		{
			int check = 0;
			printf("rdoq_last_x[0]=%d rdoq_last_y[0]=%d\n", rdoq_last_x[0], rdoq_last_y[0]);
			printf("file:%s, func: %s, line: %d\n", __FILE__, __func__, __LINE__);
			assert(false);
		}

		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];

		// shift register.
		for (int i = 1; i < 32; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}

	///////////////////////////////////////////////////
	for (int i = 0; i < 32; i++)
	{
		if (last_y[i] != -1)
		{
			final_last_x = last_x[i];
			final_last_y = last_y[i];
		}
	}
	if (final_last_y == -1) {
		final_last_x = 0;
		final_last_y = 0;
	}

	// decide for remaining scan lines 
	// not 8; only need iterate 7 times 
	//for (int i = 0; i < 31; i++)
	//{
	//	if ((rdoq_last_x[i] + rdoq_last_y[i]) % 2 == 0) // above right scan.
	//	{
	//		endPosCost[i] = tempCost[i] - endPosCost[i];
	//	}
	//	S64 temp_RdoqCost = finalRdoqCost + endPosCost[i];
	//	int index = rdoq_last_x[i] * 32 + rdoq_last_y[i];
	//	if (rdoq_last_x[i] != -1 && temp_RdoqCost + d64_cost_last_one_tmp[index] < d64_best_cost_tmp)
	//	{
	//		d64_best_cost_tmp = temp_RdoqCost + d64_cost_last_one_tmp[index];
	//		final_rdoq_last_x = rdoq_last_x[i];
	//		final_rdoq_last_y = rdoq_last_y[i];

	//		if (index > 0 && temp_RdoqCost != d64_base_cost_tmp[index])
	//		{
	//			int check = 0;
	//			// printf("file:%s, func: %s, line: %d\n", __FILE__, __func__, __LINE__);
	//			// assert(false);
	//		}
	//	}
	//	finalRdoqCost += tempCost[i];
	//}

	// back to zig-zag scan order this can be optimized later.
	for (scan_pos = 0; scan_pos < 1024; scan_pos++)
	{
		U32 blk_pos = scan[scan_pos];
		if (blk_pos == final_rdoq_last_x * 32 + final_rdoq_last_y)
		{
			best_last_idx_p1_tmp = scan_pos + 1;
		}
	}
#endif

	for (scan_pos = 0; scan_pos < 1024; scan_pos++)
	{
		d64_base_cost[scan_pos] = base_cost_buffer[scan_pos];
	}

	int doc_last_pos = 0;
	int doc_last_pos_pre = 0;
	int doc_last_blk_pos = 0;
	// FILE* fp = fopen("last_pos.txt", "a+");
	for (scan_pos = 0; scan_pos < 528; scan_pos++)
	{
		U32 blk_pos = scan[scan_pos];
		ace_log2 = get_ace_log2(scan_pos + 1);
		U24 prev_level = mat_prev_level[scan_pos];
		U4 flag = 0;
		if (prev_level - 1 < 5)
		{
			flag = prev_level - 1;
		}
		else
		{
			flag = 5;
		}
		S64 d64_cost_last_one = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda);
		if (tmp_dst_coef[blk_pos])
		{
			S64 d64_cur_is_last_cost = d64_base_cost[scan_pos] + d64_cost_last_one;

			if (d64_cur_is_last_cost < d64_best_cost)
			{
				d64_best_cost = d64_cur_is_last_cost;
				*best_last_idx_p1 = scan_pos + 1;
			}
		}
		// temp code added by xfhuang.
		if (tmp_dst_coef[blk_pos])
		{
			doc_last_blk_pos = blk_pos;
			doc_last_pos_pre = doc_last_pos;
			doc_last_pos = scan_pos + 1;
		}
	}
	// just a check.
	if (doc_last_blk_pos != final_last_x * 32 + final_last_y)
	{
		int k = 0;
	}
	if (*best_last_idx_p1 == best_last_idx_p1_tmp && d64_best_cost_tmp != d64_best_cost)
	{
		int tmp = 0;
	}
	if (*best_last_idx_p1 != best_last_idx_p1_tmp)
	{
		printf("p1=%d p2=%d\n", *best_last_idx_p1, best_last_idx_p1_tmp);
		int tmp = 0;
	}
	//printf("p1=%d p2=%d\n", *best_last_idx_p1, best_last_idx_p1_tmp);
	//printf("p1=%d p2=%d\n", *best_last_idx_p1, best_last_idx_p1_tmp);
	// assign with new method.
	*best_last_idx_p1 = best_last_idx_p1_tmp;
	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
	// fprintf(fp, "%d, %d, %d\n", doc_last_pos, *best_last_idx_p1, doc_last_pos_pre);
	// fclose(fp);
	int tmp_sum = 0;
}

static void level_core_32_32(U8 w, U8 h, U32 level[24], U32 level1[24], U5 t0[1024], U7 i, U14 max_num)
{
	int tmp = 0;
	int pos = 0;
	max_num = COM_MIN(max_num, (U14)1024);
	for (pos = 0; pos < 1024; pos++)
	{
		if (pos < max_num)
			tmp += !(t0[pos] - i);
	}
	level[i] += tmp;
	level1[i + 1] += 8 * tmp;
}
static void run_core_32_32(U8 w, U8 h, U32 run[24], U32 run1[24], U5 t0[1024], U7 i, U1 mat_run[1024], U14 max_num)
{
	int tmp = 0;
	int tmp2 = 0;
	int pos = 0;
	for (pos = 0; pos < 1024; pos++)
	{
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
			tmp2 += mat_run[pos];
		}
	}
	run[i] += tmp;
	run1[i + 1] += tmp2;
}
static void last1_core_32_32(U8 w, U8 h, U32 last1[12], U4 t0[1024], U7 i, U14 max_num)
{
	int tmp = 0;
	int pos = 0;
	for (pos = 0; pos < 1024; pos++)
	{
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last1[i] += tmp;
}
static void last2_core_32_32(U8 w, U8 h, U32 last2[22], U5 t0[1024], U7 i, U14 max_num)
{
	int tmp = 0;
	int pos = 0;
	for (pos = 0; pos < 1024; pos++)
	{
		if (pos < max_num)
		{
			tmp += !(t0[pos] - i);
		}
	}
	last2[i] += tmp;
}


static void model_update_32_32(U8 w, U8 h, U32 last1[12], U32 last2[22], U32 run[24], U32 level[24], U1 mat_run[1024], U24 mat_prev_level[1024], U2 ch_type, U14 max_num)
{

	U32 scan_pos = 0;
	static U5 t0[1024] = { 0 };
	static U4 last1_pos[1024] = { 0 };
	static U5 last2_pos[1024] = { 0 };
	static U32 last1_tmp[12] = { 0 };
	static U32 last2_tmp[22] = { 0 };
	static U32 level_tmp[24] = { 0 };
	static U32 level_tmp1[24] = { 0 };
	static U32 run_tmp[24] = { 0 };
	static U32 run_tmp1[24] = { 0 };
	int ace_log2 = 0;

	for (scan_pos = 0; scan_pos < 1024; scan_pos++)
	{
		if (scan_pos < max_num)
		{
			if (scan_pos + 1 < 2) {
				ace_log2 = 0;
			}
			else if (scan_pos + 1 < 4) {
				ace_log2 = 1;
			}
			else if (scan_pos + 1 < 8) {
				ace_log2 = 2;
			}
			else if (scan_pos + 1 < 16) {
				ace_log2 = 3;
			}
			else if (scan_pos + 1 < 32) {
				ace_log2 = 4;
			}
			else if (scan_pos + 1 < 64) {
				ace_log2 = 5;
			}
			else if (scan_pos + 1 < 128) {
				ace_log2 = 6;
			}
			else if (scan_pos + 1 < 256) {
				ace_log2 = 7;
			}
			else if (scan_pos + 1 < 512) {
				ace_log2 = 8;
			}
			else if (scan_pos + 1 < 1024) {
				ace_log2 = 9;
			}
			else if (scan_pos + 1 < 2048) {
				ace_log2 = 10;
			}
			else if (scan_pos + 1 < 4096) {
				ace_log2 = 11;
			}
			else {
				ace_log2 = 11;
			}
			t0[scan_pos] = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)(5))) << 1) + (ch_type == 0 ? 0 : 12);
			last1_pos[scan_pos] = ((COM_MIN((U24)(mat_prev_level[scan_pos] - 1), (U24)(5)))) + (ch_type == 0 ? 0 : 6);
			last2_pos[scan_pos] = ace_log2 + (ch_type == 0 ? 0 : 12);
		}
	}

	for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
	{
		level_core_32_32(w, h, level_tmp, level_tmp1, t0, scan_pos, max_num);
		run_core_32_32(w, h, run_tmp, run_tmp1, t0, scan_pos, mat_run, max_num);
	}

	for (scan_pos = 0; scan_pos < 12; scan_pos++)
	{
		last1_core_32_32(w, h, last1_tmp, last1_pos, scan_pos, max_num);
		last1[scan_pos] += last1_tmp[scan_pos];
	}

	for (scan_pos = 0; scan_pos < 22; scan_pos++)
	{
		last2_core_32_32(w, h, last2_tmp, last2_pos, scan_pos, max_num);
		last2[scan_pos] += last2_tmp[scan_pos];
	}

	for (scan_pos = 0; scan_pos < 24; scan_pos++)
	{
		level[scan_pos] += level_tmp[scan_pos] + level_tmp1[scan_pos];
		run[scan_pos] += run_tmp[scan_pos] + run_tmp1[scan_pos];
	}
}


int rdoq_top_32_32(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[32][32], s16 dst_tmp[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{

	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);

	const U8 w = 1 << cu_width_log2;
	const U8 h = 1 << cu_height_log2;
	const U14 max_num_coef = 528;
	const s64 lambda = (d_lambda * (1 << 15) + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
	static U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };

	s64 err_scale = err_scale_tbl[qp][log2_size - 1];

	const int q_bits = 14 + tr_shift;
	int num_nz_coef = 0;
	int best_last_idx_p1 = 0;
	static S16 tmp_coef[1024] = { 0 };
	static U36 tmp_level_double[1024] = { 0 };
	static S16 tmp_dst_coef[1024] = { 0 };

	static U24 mat_prev_level[1024] = { 0 };
	static U1 mat_run[1024] = { 0 };
	static S64 mat_uncoded_cost[1024] = { 0 };
	static S64 mat_coded_cost[1024] = { 0 };
	static U24 lev_opt[1024] = { 0 };
	int final_x = 0;
	int final_y = 0;

	/* ===== quantization ===== */

	rdoq_32_32_hardware(src_coef, qp, q_bits, tmp_dst_coef, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level,
		rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
		rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth,&final_x,&final_y);
	CleanNz_32_32(&num_nz_coef, dst_tmp, tmp_dst_coef,final_x,final_y);
	return num_nz_coef;
}
void rdoq_32_all_hardware(U3 cu_width_log2, U3 cu_height_log2, s16 src_coef[32][32], U6 qp, S32 q_bits, S16 tmp_dst_coef_out[1024], u32 last1[12], u32 last2[22],
	u32 run[24], u32 level[24],
	s32 rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
	U8 cu_width = 1 << cu_width_log2;
	U8 cu_height = 1 << cu_height_log2;
	U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const U14 scale = quant_scale[qp];
	const int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const int q_value = (scale * ns_scale + ns_offset) >> ns_shift;
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	S16 tmp_dst_coef[32];
	U36 tmp_level_double[32];
	S16 tmp_coef[32];
	S64 d64_cost_last_zero[32] = { 0 };
	U24 lev_opt[32];
	S64 mat_coded_cost[32];
	S64 mat_uncoded_cost[32];
	d64_cost_last_zero[0] = 0;
	U4 ace_log2 = 0;
	U32 scan_pos = 0;
	S64 d64_best_cost = 0;
	S64 d64_base_cost[1024] = { 0 };
	S64 base_cost_buffer[1024] = { 0 };
	S64 base_cost_buffer_tmp[32] = { 0 };
	S64 d64_best_cost_tmp = 0;
	int best_last_idx_p1_tmp = 0;
	U24 mat_prev_level[32] = { 0 };
	U1 mat_run[32] = { 0 };
	s64 d64_uncoded_cost = 0;
	s64 d64_coded_cost = 0;
	S64 d64_cost_last_one_tmp[32] = { 0 };
	S64 finalRdoqCost = 0;
	S64 tempCost[32];   // all scan line cost
	S64 endPosCost[32]; // as the last position cost.
	S64 rdoqD64LastOne[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	int last_x[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int last_y[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_x[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int rdoq_last_y[32] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	int final_last_x = -1, final_last_y = -1;
	int final_rdoq_last_x = -1, final_rdoq_last_y = -1;
	U5 t0[32] = { 0 };
	U4 last1_pos[32] = { 0 };
	U5 last2_pos[32] = { 0 };
	int shift_t = (cu_width == cu_height ? 32 : 16);
	if (!is_intra && ch_type == Y_C)
	{
		d64_best_cost = 0;
		d64_best_cost_tmp = 0;
	}
	else
	{
		d64_best_cost = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}
#if 1
	for (int j = 0; j < cu_width; j++) // vertical
	{
		u32 last1_tmp[12] = { 0 };
		u32 last2_tmp[22] = { 0 };
		u32 level_tmp[24] = { 0 };
		u32 level_tmp1[24] = { 0 };
		u32 run_tmp[24] = { 0 };
		u32 run_tmp1[24] = { 0 };
		for (int i = 0; i < cu_height; i++)
		{
			if (i < cu_width - j) {
				U36 level_double = src_coef[i][j];
				S25 max_abs_level;
				U1 lower_int;
				U36 temp_level;
				temp_level = (U36)abs(src_coef[i][j]) * q_value;
				level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
				tmp_level_double[i] = level_double;
				max_abs_level = (S32)(level_double >> q_bits);
				lower_int = ((level_double - (max_abs_level << q_bits)) < (1 << (q_bits - 1))) ? 1 : 0;
				if (!lower_int)
				{
					max_abs_level++;
				}
				tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
			}
		}
		for (int i = 0; i < cu_height; i++)
		{
			if (i < cu_width - j) {
				if (tmp_coef[i])
				{
					mat_prev_level[i] = abs(tmp_coef[i]);
					mat_run[i] = 0;
				}
				else
				{
					mat_prev_level[i] = 1;
					mat_run[i] = 1;
				}
			}
		}
		for (int i = 0; i < cu_height; i++)
		{
			if (i < cu_width - j) {
				U24 level;
				U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
				level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], abs(tmp_coef[i]),
					mat_run[i], ctx_run, ctx_run, q_bits, err_scale, lambda, 0, rdoq_est_run_local, rdoq_est_level_local);
				S17 level_cbf = level;
				tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				tmp_dst_coef_out[i * cu_width + j] = tmp_dst_coef[i];
				mat_uncoded_cost[i] = d64_uncoded_cost;
				mat_coded_cost[i] = d64_coded_cost;
				lev_opt[i] = level;
			}
		}
		for (int i = 0; i < cu_height; i++)
		{
			if (i < cu_width - j) {
				if (i + j < 3) {
					ace_log2 = i + j;
				}
				else if (i + j < 4) {
					ace_log2 = 3;
				}
				else if (i + j < 6) {
					ace_log2 = 4;
				}
				else if (i + j < 10) {
					ace_log2 = 5;
				}
				else if (i + j < 14) {
					ace_log2 = 6;
				}
				else if (i + j < 21) {
					ace_log2 = 7;
				}
				else {
					ace_log2 = 8;
				}
				t0[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == 0 ? 0 : 12);
				last1_pos[i] = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5)))) + (ch_type == 0 ? 0 : 6);
				last2_pos[i] = ace_log2 + (ch_type == 0 ? 0 : 12);
			}
		}
		int max_num;
		if (cu_width_log2 == 5 && cu_height_log2 == 4)
		{
			max_num = (j < 16 ? 16 : 32 - j);
		}
		else if (cu_width_log2 == 4 && cu_height_log2 == 5) {
			max_num = 16 - j;
		}
		else {
			max_num = 32 - j;
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos += 2)
		{
			level_core_32(32, 32, level_tmp, level_tmp1, t0, scan_pos, max_num);
			run_core_32(32, 32, run_tmp, run_tmp1, t0, scan_pos, mat_run, max_num);
		}
		for (scan_pos = 0; scan_pos < 12; scan_pos++)
		{
			last1_core_32(32, 32, last1_tmp, last1_pos, scan_pos, max_num);
			last1[scan_pos] += last1_tmp[scan_pos];
		}
		for (scan_pos = 0; scan_pos < 22; scan_pos++)
		{
			last2_core_32(32, 32, last2_tmp, last2_pos, scan_pos, max_num);
			last2[scan_pos] += last2_tmp[scan_pos];
		}
		for (scan_pos = 0; scan_pos < 24; scan_pos++)
		{
			level[scan_pos] += level_tmp[scan_pos] + level_tmp1[scan_pos];
			run[scan_pos] += run_tmp[scan_pos] + run_tmp1[scan_pos];
		}
		for (int i = 0; i < cu_height; i++)
		{
			if (i < cu_width - j) {
				if (i + j < 3) {
					ace_log2 = i + j;
				}
				else if (i + j < 4) {
					ace_log2 = 3;
				}
				else if (i + j < 6) {
					ace_log2 = 4;
				}
				else if (i + j < 10) {
					ace_log2 = 5;
				}
				else if (i + j < 14) {
					ace_log2 = 6;
				}
				else if (i + j < 21) {
					ace_log2 = 7;
				}
				else {
					ace_log2 = 8;
				}
				U4 flag = 0;
				if (mat_prev_level[i] - 1 < 5)
				{
					flag = mat_prev_level[i] - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
			}
		}
		for (int i = 0; i < cu_height; i++)
		{
			if (i < cu_width - j) {
				if (lev_opt[i])
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				}
				else
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
				}
			}
		}
		for (int i = 0; i < cu_height; i++)
		{
			if (i < cu_width - j) {
				if (i + j < 3) {
					ace_log2 = i + j;
				}
				else if (i + j < 4) {
					ace_log2 = 3;
				}
				else if (i + j < 6) {
					ace_log2 = 4;
				}
				else if (i + j < 10) {
					ace_log2 = 5;
				}
				else if (i + j < 14) {
					ace_log2 = 6;
				}
				else if (i + j < 21) {
					ace_log2 = 7;
				}
				else {
					ace_log2 = 8;
				}
				U24 prev_level = mat_prev_level[i];
				U4 flag = 0;
				if (prev_level - 1 < 5)
				{
					flag = prev_level - 1;
				}
				else
				{
					flag = 5;
				}
				d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
			}
		}
		for (int i = 0; i < cu_height; i++) // horizontal
		{
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else if (i == shift_t - 1)
			{
				rdoq_last_x[i] = -1;
				rdoq_last_y[i] = -1;
				rdoqD64LastOne[i] = -1;
				if (lev_opt[i])
				{
					last_x[i] = i;
					last_y[i] = j;
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
		for (int i = 1; i < shift_t; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}
#endif
	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
}
void rdoq_32_all_hardware_luma(U3 cu_width_log2, U3 cu_height_log2, s16 src_coef[32][32], U6 qp, S32 q_bits, S16 tmp_dst_coef_out[1024],
	s32 rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
#pragma HLS ARRAY_PARTITION variable=src_coef               dim=1 complete
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef_out       dim=1 block factor=32
#pragma HLS ARRAY_PARTITION variable=rdoq_est_run_local     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_est_level_local   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local    dim=2 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local    dim=3 complete

	const U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	const U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };

	U8 cu_width  = 1 << cu_width_log2;
	U8 cu_height = 1 << cu_height_log2;
	
	U14 scale = quant_scale[qp];
	int ns_shift  = ((cu_width_log2 + cu_height_log2) & 1) ?   7 : 0;
	int ns_scale  = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	int q_value   = (scale * ns_scale + ns_offset) >> ns_shift;
	int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
#if 0
    int tr_shift = get_transform_shift(bit_depth, log2_size);
#else
    int tr_shift = 15 - bit_depth - log2_size;
#endif
	int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	S16 tmp_dst_coef      [32];
	U36 tmp_level_double  [32];
	S16 tmp_coef          [32];
	U24 lev_opt           [32];
	S64 mat_coded_cost    [32];
	S64 mat_uncoded_cost  [32];
	S64 tempCost          [32];   	// all scan line cost
	S64 endPosCost        [32]; 	// as the last position cost.
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef       dim=0 complete
#pragma HLS ARRAY_PARTITION variable=tmp_level_double   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=tmp_coef           dim=0 complete
#pragma HLS ARRAY_PARTITION variable=lev_opt            dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=tempCost           dim=0 complete
#pragma HLS ARRAY_PARTITION variable=endPosCost         dim=0 complete

	U4 ace_log2           = 0;
	U32 scan_pos          = 0;
	S64 d64_best_cost     = 0;
	S64 d64_best_cost_tmp = 0;
	s64 d64_uncoded_cost  = 0;
	s64 d64_coded_cost    = 0;
	S64 finalRdoqCost     = 0;
	s8 final_last_x       = -1, final_last_y      = -1;
	s8 final_rdoq_last_x  = -1, final_rdoq_last_y = -1;

	//S64 d64_base_cost   [1024] = { 0 };	// NOT used
	//S64 base_cost_buffer[1024] = { 0 };	// NOT used
	S64 base_cost_buffer_tmp [32]; // = { 0 };
	U24 mat_prev_level       [32]; // = { 0 };
	U1 mat_run               [32]; // = { 0 };
	S64 d64_cost_last_one_tmp[32]; // = { 0 };
	S64 d64_cost_last_zero   [32]; // = { 0 };	// d64_cost_last_zero[0] = 0;
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_zero     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=base_cost_buffer_tmp   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_prev_level         dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_run                dim=0 complete
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp  dim=0 complete	
    for (int i=0; i<32; i++) {
#pragma HLS UNROLL
        d64_cost_last_zero   [i] = 0;
        base_cost_buffer_tmp [i] = 0;
        mat_prev_level       [i] = 0;
        mat_run              [i] = 0;
        d64_cost_last_one_tmp[i] = 0;
    }

	S64 rdoqD64LastOne[32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	s8 last_x         [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 last_y         [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_x    [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_y    [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
#pragma HLS ARRAY_PARTITION variable=rdoqD64LastOne dim=0 complete
#pragma HLS ARRAY_PARTITION variable=last_x         dim=0 complete
#pragma HLS ARRAY_PARTITION variable=last_y         dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_last_x    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_last_y    dim=0 complete
    for (int i=0; i<32; i++) {
#pragma HLS UNROLL
        rdoqD64LastOne[i] = -1;
        last_x        [i] = -1;
        last_y        [i] = -1;
        rdoq_last_x   [i] = -1;
        rdoq_last_y   [i] = -1;
    }

	int shift_t = (cu_width == cu_height) ? 32 : 16;

    if ((!is_intra) && (ch_type == Y_C)) {
		d64_best_cost     = 0;
		d64_best_cost_tmp = 0;
    } else {
		d64_best_cost     = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost      = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost     = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}

#if 1
    LOOP_RDOQ_32_LUMA_1: for (int j = 0; j < cu_width; j++) { // vertical
#pragma HLS LOOP_TRIPCOUNT max=32
#pragma HLS PIPELINE

        // for (int i = 0; i < cu_height; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 0; i < 32; i++) {
			if (i < cu_height) {
				if (i < cu_width - j) {
					U36 level_double = src_coef[i][j];
					S25 max_abs_level;
					U1 lower_int;
					U36 temp_level;
					temp_level   = (U36)abs(src_coef[i][j]) * q_value;
					level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
					tmp_level_double[i] = level_double;
					max_abs_level = (S32)(level_double >> q_bits);
					lower_int = ((level_double - (max_abs_level << q_bits)) < (1 << (q_bits - 1))) ? 1 : 0;
					if (!lower_int) {
						max_abs_level++;
					}
					tmp_coef[i] = (src_coef[i][j] > 0) ? (S16)max_abs_level : (S16)(-max_abs_level);
				}
			}
		}

        //for (int i = 0; i < cu_height; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 0; i < 32; i++) {
			if (i < cu_height) {
				if (i < cu_width - j) {
					if (tmp_coef[i]) {
						mat_prev_level[i] = abs(tmp_coef[i]);
						mat_run[i] = 0;
					} else {
						mat_prev_level[i] = 1;
						mat_run[i] = 1;
					}
				}
			}
		}

        //for (int i = 0; i < cu_height; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 0; i < 32; i++) {
			if (i < cu_height) {
				if (i < cu_width - j) {
					U24 level;
					U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
					level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], abs(tmp_coef[i]),
						mat_run[i], ctx_run, ctx_run, q_bits, err_scale, lambda, 0, rdoq_est_run_local, rdoq_est_level_local);
					S17 level_cbf = level;
					tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
					tmp_dst_coef_out[i * cu_width + j] = tmp_dst_coef[i];
					mat_uncoded_cost[i] = d64_uncoded_cost;
					mat_coded_cost[i] = d64_coded_cost;
					lev_opt[i] = level;
				}
			}
		}

        //for (int i = 0; i < cu_height; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 0; i < 32; i++) {
			if (i < cu_height) {
				if (i < cu_width - j) {
					if      (i + j <  3) { ace_log2 = i + j; }
					else if (i + j <  4) { ace_log2 = 3;     }
					else if (i + j <  6) { ace_log2 = 4;     }
					else if (i + j < 10) { ace_log2 = 5;     }
					else if (i + j < 14) { ace_log2 = 6;     }
					else if (i + j < 21) { ace_log2 = 7;     }
					else                 { ace_log2 = 8;     }

					U4 flag;
					if (mat_prev_level[i] - 1 < 5) {
						flag = mat_prev_level[i] - 1;
					} else {
						flag = 5;
					}
					d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
				}
			}
		}

        //for (int i = 0; i < cu_height; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 0; i < 32; i++) {
			if (i < cu_height) {
				if (i < cu_width - j) {
					if (lev_opt[i]) {
						base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
					} else {
						base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
					}
				}
			}
		}

        // for (int i = 0; i < cu_height; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 0; i < 32; i++) {
			if (i < cu_height) {
				if (i < cu_width - j) {
					if      (i + j <  3) { ace_log2 = i + j; }
					else if (i + j <  4) { ace_log2 = 3;     }
					else if (i + j <  6) { ace_log2 = 4;     }
					else if (i + j < 10) { ace_log2 = 5;     }
					else if (i + j < 14) { ace_log2 = 6;     }
					else if (i + j < 21) { ace_log2 = 7;     }
					else                 { ace_log2 = 8;     }

					U24 prev_level = mat_prev_level[i];
					U4 flag;
					if (prev_level - 1 < 5) {
						flag = prev_level - 1;
					} else {
						flag = 5;
					}
					d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
				}
			}
		}

        //for (int i = 0; i < cu_height; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 0; i < 32; i++) {
			if (i < cu_height) {
				if (j == 0) {
					if (lev_opt[i]) {
						rdoq_last_x   [i] = i;
						rdoq_last_y   [i] = j;
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] = base_cost_buffer_tmp[i];
					if ((i + j) % 2 == 0) { 									// bottom - left scan for (i+j)%2 is odd case
						if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
						else            endPosCost[i] = 0;
					} else { 													// above - top scan for (i+j)%2 is even case
						if (lev_opt[i]) endPosCost[i] = 0;
						else 			endPosCost[i] = base_cost_buffer_tmp[i];
						if (i == 0) {  											// substract here is to get the actual endPosCost
							endPosCost[i] = tempCost[i] - endPosCost[i];
						}
					}
				}
				else if (i == shift_t - 1) {
					rdoq_last_x[i] = -1;
					rdoq_last_y[i] = -1;
					rdoqD64LastOne[i] = -1;
					if (lev_opt[i]) {
						last_x        [i] = i;
						last_y        [i] = j;
						rdoq_last_x   [i] = i;
						rdoq_last_y   [i] = j;
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] = base_cost_buffer_tmp[i];
					if ((i + j) % 2 == 0) { 									// bottom - left scan for (i+j)%2 is odd case
						if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
						else 			endPosCost[i] = 0;
					} else { 													// above - top scan for (i+j)%2 is even case
						if (lev_opt[i]) endPosCost[i] = 0;
						else 			endPosCost[i] = base_cost_buffer_tmp[i];
					}
				}
				else {
					if ((i + j) % 2 == 0) { 									// bottom - left scan for (i+j)%2 is odd case
						if (lev_opt[i] && rdoq_last_y[i] != -1) { 				// compare for intialized case.
							if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i]) {
								rdoq_last_x   [i] = i;
								rdoq_last_y   [i] = j;
								endPosCost    [i] = tempCost[i] + base_cost_buffer_tmp[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) { 				// cost initial. purpose.
							rdoq_last_x   [i] = i;
							rdoq_last_y   [i] = j;
							endPosCost    [i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += base_cost_buffer_tmp[i];
					} else { 													// above - top scan for (i+j)%2 is even case
						S64 curCost = base_cost_buffer_tmp[i];  				// care the bit-width. not int.
						if (lev_opt[i] && rdoq_last_y[i] != -1) { 				// the previous non-zero position
							if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) { // previous position is better
								rdoq_last_x   [i] = i;
								rdoq_last_y   [i] = j;
								endPosCost    [i] = tempCost[i];
								rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
							}
						}
						if (lev_opt[i] && rdoq_last_y[i] == -1) { 				// first non-zero position
							rdoq_last_x   [i] = i;
							rdoq_last_y   [i] = j;
							endPosCost    [i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
						tempCost[i] += curCost; 								// from the start point to current pos cost.
						if (i == 0) {  											// substract here is to get the actual endPosCost
							endPosCost[i] = tempCost[i] - endPosCost[i];
						}
					}
				}
			}
		}

		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
        if ((rdoq_last_y[0] != -1) && (temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)) {
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];

        //for (int i = 1; i < shift_t; i++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 
		for (int i = 1; i < 32; i++) {
			if (i < shift_t) {
				rdoq_last_x   [i - 1] = rdoq_last_x   [i];
				rdoq_last_y   [i - 1] = rdoq_last_y   [i];
				tempCost      [i - 1] = tempCost      [i];
				endPosCost    [i - 1] = endPosCost    [i];
				rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
			}
		}
	}
#endif

	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
}
template<int H_LOG2, int W_LOG2, int H, int W>
void rdoq_32x_all_hardware_luma(s16 src_coef[32][32], U6 qp, S32 q_bits, S16 tmp_dst_coef_out[32][32],
	int rdoq_est_cbf[3][2], int rdoq_est_run_local[24][2], int rdoq_est_level_local[24][2],
	int rdoq_est_last_local[2][6][12][2], U3 ch_type, U1 is_intra, S64 lambda, U4 bit_depth, int* final_x, int* final_y)
{
#pragma HLS ARRAY_PARTITION variable=src_coef               dim=1 complete
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef_out       dim=1 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_est_run_local     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_est_level_local   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local    dim=2 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_est_last_local    dim=3 complete

	const U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	const U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };

	// U8 cu_width  = 1 << cu_width_log2;
	// U8 cu_height = 1 << cu_height_log2;
	
	U14 scale = quant_scale[qp];
	int ns_shift  = ((W_LOG2 + H_LOG2) & 1) ?   7 : 0;
	int ns_scale  = ((W_LOG2 + H_LOG2) & 1) ? 181 : 1;
	int ns_offset = ((W_LOG2 + H_LOG2) & 1) ? (1 << (ns_shift - 1)) : 0;
	int q_value   = (scale * ns_scale + ns_offset) >> ns_shift;
	int log2_size = (W_LOG2 + H_LOG2) >> 1;
#if 0
    int tr_shift = get_transform_shift(bit_depth, log2_size);
#else
    int tr_shift = 15 - bit_depth - log2_size;
#endif
	int ctx_last = (ch_type == Y_C) ? 0 : 1;
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	S16 tmp_dst_coef      [32];
	U36 tmp_level_double  [32];
	S16 tmp_coef          [32];
	U24 lev_opt           [32];
	S64 mat_coded_cost    [32];
	S64 mat_uncoded_cost  [32];
	S64 tempCost          [32];   	// all scan line cost
	S64 endPosCost        [32]; 	// as the last position cost.
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef       dim=0 complete
#pragma HLS ARRAY_PARTITION variable=tmp_level_double   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=tmp_coef           dim=0 complete
#pragma HLS ARRAY_PARTITION variable=lev_opt            dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=tempCost           dim=0 complete
#pragma HLS ARRAY_PARTITION variable=endPosCost         dim=0 complete

	U4 ace_log2           = 0;
	U32 scan_pos          = 0;
	S64 d64_best_cost     = 0;
	S64 d64_best_cost_tmp = 0;
	s64 d64_uncoded_cost  = 0;
	s64 d64_coded_cost    = 0;
	S64 finalRdoqCost     = 0;
	s8 final_last_x       = -1, final_last_y      = -1;
	s8 final_rdoq_last_x  = -1, final_rdoq_last_y = -1;

	//S64 d64_base_cost   [1024] = { 0 };	// NOT used
	//S64 base_cost_buffer[1024] = { 0 };	// NOT used
	S64 base_cost_buffer_tmp [32]; // = { 0 };
	U24 mat_prev_level       [32]; // = { 0 };
	U1 mat_run               [32]; // = { 0 };
	S64 d64_cost_last_one_tmp[32]; // = { 0 };
	S64 d64_cost_last_zero   [32]; // = { 0 };	// d64_cost_last_zero[0] = 0;
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_zero     dim=0 complete
#pragma HLS ARRAY_PARTITION variable=base_cost_buffer_tmp   dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_prev_level         dim=0 complete
#pragma HLS ARRAY_PARTITION variable=mat_run                dim=0 complete
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp  dim=0 complete	
    for (int i=0; i<32; i++) {
#pragma HLS UNROLL
        d64_cost_last_zero   [i] = 0;
        base_cost_buffer_tmp [i] = 0;
        mat_prev_level       [i] = 0;
        mat_run              [i] = 0;
        d64_cost_last_one_tmp[i] = 0;
    }

	S64 rdoqD64LastOne[32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	s8 last_x         [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 last_y         [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_x    [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_y    [32]; // = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
#pragma HLS ARRAY_PARTITION variable=rdoqD64LastOne dim=0 complete
#pragma HLS ARRAY_PARTITION variable=last_x         dim=0 complete
#pragma HLS ARRAY_PARTITION variable=last_y         dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_last_x    dim=0 complete
#pragma HLS ARRAY_PARTITION variable=rdoq_last_y    dim=0 complete
    for (int i=0; i<32; i++) {
#pragma HLS UNROLL
        rdoqD64LastOne[i] = -1;
        last_x        [i] = -1;
        last_y        [i] = -1;
        rdoq_last_x   [i] = -1;
        rdoq_last_y   [i] = -1;
    }

	int shift_t = (W == H) ? 32 : 16;

    if ((!is_intra) && (ch_type == Y_C)) {
		d64_best_cost     = 0;
		d64_best_cost_tmp = 0;
    } else {
		d64_best_cost     = rdoq_est_cbf[ch_type][0] * lambda;
		S64 cbf_cost      = rdoq_est_cbf[ch_type][1] * lambda;
		d64_best_cost     = d64_best_cost - cbf_cost;
		d64_best_cost_tmp = d64_best_cost;
	}

#if 1
    LOOP_RDOQ_32x_LUMA_1: for (int j = 0; j < W; j++) {
#pragma HLS PIPELINE
		for (int i = 0; i < H; i++) {
			if (i < W - j) {
				U36 level_double = src_coef[i][j];
				S25 max_abs_level;
				U1 lower_int;
				U36 temp_level;
				temp_level   = (U36)abs(src_coef[i][j]) * q_value;
				level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
				tmp_level_double[i] = level_double;
				max_abs_level = (S32)(level_double >> q_bits);
				lower_int = ((level_double - (max_abs_level << q_bits)) < (1 << (q_bits - 1))) ? 1 : 0;
				if (!lower_int) {
					max_abs_level++;
				}
				tmp_coef[i] = (src_coef[i][j] > 0) ? (S16)max_abs_level : (S16)(-max_abs_level);
			}
		}

		for (int i = 0; i < H; i++) {
			if (i < W - j) {
				if (tmp_coef[i]) {
					mat_prev_level[i] = abs(tmp_coef[i]);
					mat_run[i] = 0;
				} else {
					mat_prev_level[i] = 1;
					mat_run[i] = 1;
				}
			}
		}

		for (int i = 0; i < H; i++) {
			if (i < W - j) {
				U24 level;
				U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
				level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], abs(tmp_coef[i]),
					mat_run[i], ctx_run, ctx_run, q_bits, err_scale, lambda, 0, rdoq_est_run_local, rdoq_est_level_local);
				S17 level_cbf = level;
				tmp_dst_coef[i] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				//tmp_dst_coef_out[i * W + j] = tmp_dst_coef[i];
				tmp_dst_coef_out[i][j] = tmp_dst_coef[i];
				mat_uncoded_cost[i] = d64_uncoded_cost;
				mat_coded_cost[i] = d64_coded_cost;
				lev_opt[i] = level;
			}
		}

		for (int i = 0; i < H; i++) {
			if (i < W - j) {
				if      (i + j <  3) { ace_log2 = i + j; }
				else if (i + j <  4) { ace_log2 = 3;     }
				else if (i + j <  6) { ace_log2 = 4;     }
				else if (i + j < 10) { ace_log2 = 5;     }
				else if (i + j < 14) { ace_log2 = 6;     }
				else if (i + j < 21) { ace_log2 = 7;     }
				else                 { ace_log2 = 8;     }

				U4 flag;
				if (mat_prev_level[i] - 1 < 5) {
					flag = mat_prev_level[i] - 1;
				} else {
					flag = 5;
				}
				d64_cost_last_zero[i] = rdoq_est_last_local[ctx_last][flag][ace_log2][0] * lambda;
			}
		}

		for (int i = 0; i < H; i++) {
			if (i < W - j) {
				if (lev_opt[i]) {
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				} else {
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
				}
			}
		}

		for (int i = 0; i < H; i++) {
			if (i < W - j) {
				if      (i + j <  3) { ace_log2 = i + j; }
				else if (i + j <  4) { ace_log2 = 3;     }
				else if (i + j <  6) { ace_log2 = 4;     }
				else if (i + j < 10) { ace_log2 = 5;     }
				else if (i + j < 14) { ace_log2 = 6;     }
				else if (i + j < 21) { ace_log2 = 7;     }
				else                 { ace_log2 = 8;     }

				U24 prev_level = mat_prev_level[i];
				U4 flag;
				if (prev_level - 1 < 5) {
					flag = prev_level - 1;
				} else {
					flag = 5;
				}
				d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[ctx_last][flag][ace_log2][1], lambda); // block scan order
			}
		}

		for (int i = 0; i < H; i++) {
			if (j == 0) {
				if (lev_opt[i]) {
					rdoq_last_x   [i] = i;
					rdoq_last_y   [i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) { 									// bottom - left scan for (i+j)%2 is odd case
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else            endPosCost[i] = 0;
				} else { 													// above - top scan for (i+j)%2 is even case
					if (lev_opt[i]) endPosCost[i] = 0;
					else 			endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0) {  											// substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else if (i == shift_t - 1) {
				rdoq_last_x[i] = -1;
				rdoq_last_y[i] = -1;
				rdoqD64LastOne[i] = -1;
				if (lev_opt[i]) {
					last_x        [i] = i;
					last_y        [i] = j;
					rdoq_last_x   [i] = i;
					rdoq_last_y   [i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) { 									// bottom - left scan for (i+j)%2 is odd case
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else 			endPosCost[i] = 0;
				} else { 													// above - top scan for (i+j)%2 is even case
					if (lev_opt[i]) endPosCost[i] = 0;
					else 			endPosCost[i] = base_cost_buffer_tmp[i];
				}
			}
			else {
				if ((i + j) % 2 == 0) { 									// bottom - left scan for (i+j)%2 is odd case
					if (lev_opt[i] && rdoq_last_y[i] != -1) { 				// compare for intialized case.
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i]) {
							rdoq_last_x   [i] = i;
							rdoq_last_y   [i] = j;
							endPosCost    [i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) { 				// cost initial. purpose.
						rdoq_last_x   [i] = i;
						rdoq_last_y   [i] = j;
						endPosCost    [i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				} else { 													// above - top scan for (i+j)%2 is even case
					S64 curCost = base_cost_buffer_tmp[i];  				// care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) { 				// the previous non-zero position
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) { // previous position is better
							rdoq_last_x   [i] = i;
							rdoq_last_y   [i] = j;
							endPosCost    [i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) { 				// first non-zero position
						rdoq_last_x   [i] = i;
						rdoq_last_y   [i] = j;
						endPosCost    [i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; 								// from the start point to current pos cost.
					if (i == 0) {  											// substract here is to get the actual endPosCost
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}

		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
        if ((rdoq_last_y[0] != -1) && (temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)) {
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];

		for (int i = 1; i < ((W==H) ? 32 : 16); i++) {
			rdoq_last_x   [i - 1] = rdoq_last_x   [i];
			rdoq_last_y   [i - 1] = rdoq_last_y   [i];
			tempCost      [i - 1] = tempCost      [i];
			endPosCost    [i - 1] = endPosCost    [i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
		}
	}
#endif

	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
}

void rdoq_32_all_hardware_chroma(U3 cu_width_log2, U3 cu_height_log2, s16 src_coef[32][32], U6 qp,  S16 tmp_dst_coef_out[32][32],
	s32 rdoq_est_cbf[3][2], s32 rdoq_est_run_local[24][2], s32 rdoq_est_level_local[24][2],
	s32 rdoq_est_last_local[2][6][12][2],  S64 d_lambda, U4 bit_depth, int* final_x, int* final_y, U1 uv, int rdo_idx, int all_rdo_num)
{
#pragma HLS ARRAY_PARTITION variable=src_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef_out complete dim=1
	U8 cu_width = 1 << cu_width_log2;
	U8 cu_height = 1 << cu_height_log2;
	U16 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
	U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const U14 scale = quant_scale[qp];
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	const int q_bits = 14 + tr_shift;
	const s64 lambda = (d_lambda * (1 << 15) + 500) >> 10;
	const int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	const int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	const int ns_offset = ((cu_width_log2 + cu_height_log2) & 1) ? (1 << (ns_shift - 1)) : 0;
	const int q_value = (scale * ns_scale + ns_offset) >> ns_shift;


	U2 ch_type = uv + 1;

	U36 tmp_level_double[32];
	S16 tmp_coef[32];
	S64 d64_cost_last_zero[32];// = { 0 };
	U24 lev_opt[32];
	S64 mat_coded_cost[32];
	S64 mat_uncoded_cost[32];
	S64 base_cost_buffer_tmp[32];// = { 0 };
	U24 mat_prev_level[32];// = { 0 };
	U1 mat_run[32];// = { 0 };


	S64 finalRdoqCost = 0;
	S64 tempCost[32];   // all scan line cost
	S64 endPosCost[32]; // as the last position cost.


	S64 d64_cost_last_one_tmp[32];// = { 0 };
	S64 rdoqD64LastOne[32];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }; // shifter buffer the d64_cost_last_one_tmp
	s8 rdoq_last_x[32];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 rdoq_last_y[32];// = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 };
	s8 final_rdoq_last_x = -1, final_rdoq_last_y = -1;
#pragma HLS ARRAY_PARTITION variable=tmp_level_double complete dim=1
#pragma HLS ARRAY_PARTITION variable=tmp_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_zero complete dim=1
#pragma HLS ARRAY_PARTITION variable=lev_opt complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_coded_cost complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_uncoded_cost complete dim=1
#pragma HLS ARRAY_PARTITION variable=base_cost_buffer_tmp complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_prev_level complete dim=1
#pragma HLS ARRAY_PARTITION variable=mat_run complete dim=1
#pragma HLS ARRAY_PARTITION variable=tempCost complete dim=1
#pragma HLS ARRAY_PARTITION variable=endPosCost complete dim=1
#pragma HLS ARRAY_PARTITION variable=d64_cost_last_one_tmp complete dim=1
#pragma HLS ARRAY_PARTITION variable=rdoqD64LastOne complete dim=1
#pragma HLS ARRAY_PARTITION variable=rdoq_last_x complete dim=1
#pragma HLS ARRAY_PARTITION variable=rdoq_last_y complete dim=1
	for (int i = 0; i < 32; i++)
	{
#pragma HLS UNROLL
		d64_cost_last_one_tmp[i] = 0;
		rdoqD64LastOne[i] = -1;
		rdoq_last_x[i] = -1;
		rdoq_last_y[i] = -1;
	}
	int shift_t;
	if (cu_width == 4 || cu_height == 4) {
		shift_t = 4;
	}
	else if (cu_width == 8 || cu_height == 8) {
		shift_t = 8;
	}
	else if (cu_width == 16 || cu_height == 16) {
		shift_t = 16;
	}
	else {
		shift_t = 32;
	}

	

	S64 d64_best_cost_tmp = rdoq_est_cbf[ch_type][0] * lambda - rdoq_est_cbf[ch_type][1] * lambda;

	

	if (rdo_idx >= all_rdo_num) {
	}
	else {
	for (int j = 0; j < 32; j++) // vertical
	{
#pragma HLS PIPELINE II=1
		if (j < cu_width) {
			for (int i = 0; i < 32; i++)
		{
				if ((i < cu_width - j) && (i < cu_height)) {
				U36 level_double = src_coef[i][j];
				S25 max_abs_level;
				U1 lower_int;
				U36 temp_level;
				temp_level = (U36)abs(src_coef[i][j]) * q_value;
				level_double = (U36)COM_MIN((temp_level), (U36)(COM_INT32_MAX - (1 << (q_bits - 1))));
				tmp_level_double[i] = level_double;
				max_abs_level = (S32)(level_double >> q_bits);
				lower_int = ((level_double - (max_abs_level << q_bits)) < (1 << (q_bits - 1))) ? 1 : 0;
				if (!lower_int)
				{
					max_abs_level++;
				}
				tmp_coef[i] = src_coef[i][j] > 0 ? (S16)max_abs_level : (S16)(-max_abs_level);
			}
		}
			for (int i = 0; i < 32; i++)
		{
				if ((i < cu_width - j)&&(i < cu_height)) {
				if (tmp_coef[i])
				{
					mat_prev_level[i] = abs(tmp_coef[i]);
					mat_run[i] = 0;
				}
				else
				{
					mat_prev_level[i] = 1;
					mat_run[i] = 1;
				}
			}
		}
			for (int i = 0; i < 32; i++)
		{
				s64 d64_uncoded_cost;
				s64 d64_coded_cost;
				if ((i < cu_width - j) && (i < cu_height)) {
				U24 level;
				U5 ctx_run = ((COM_MIN((U24)(mat_prev_level[i] - 1), (U24)(5))) << 1) + (ch_type == Y_C ? 0 : 12);
				level = get_coded_level_rl(&d64_uncoded_cost, &d64_coded_cost, tmp_level_double[i], abs(tmp_coef[i]),
					mat_run[i], ctx_run, ctx_run, q_bits, err_scale, lambda, 0, rdoq_est_run_local, rdoq_est_level_local);
				S17 level_cbf = level;
					tmp_dst_coef_out[i][j] = (S16)(tmp_coef[i] < 0 ? (S16)(-level_cbf) : (S16)level_cbf);
				mat_uncoded_cost[i] = d64_uncoded_cost;
				mat_coded_cost[i] = d64_coded_cost;
				lev_opt[i] = level;
			}
		}

			for (int i = 0; i < 32; i++)
		{
				int ace_log2;
				if ((i < cu_width - j) && (i < cu_height)) {
				if (i + j < 3) {
					ace_log2 = i + j;
				}
				else if (i + j < 4) {
					ace_log2 = 3;
				}
				else if (i + j < 6) {
					ace_log2 = 4;
				}
				else if (i + j < 10) {
					ace_log2 = 5;
				}
				else if (i + j < 14) {
					ace_log2 = 6;
				}
				else if (i + j < 21) {
					ace_log2 = 7;
				}
				else {
					ace_log2 = 8;
				}
				U4 flag = 0;
				if (mat_prev_level[i] - 1 < 5)
				{
					flag = mat_prev_level[i] - 1;
				}
				else
				{
					flag = 5;
				}
					d64_cost_last_zero[i] = rdoq_est_last_local[1][flag][ace_log2][0] * lambda;
			}
		}
			for (int i = 0; i < 32; i++)
		{
				if ((i < cu_width - j) && (i < cu_height)) {
				if (lev_opt[i])
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i] + d64_cost_last_zero[i];
				}
				else
				{
					base_cost_buffer_tmp[i] = mat_coded_cost[i] - mat_uncoded_cost[i];
				}
			}
		}
			for (int i = 0; i < 32; i++)
		{
				int ace_log2;
				if ((i < cu_width - j) && (i < cu_height)) {
				if (i + j < 3) {
					ace_log2 = i + j;
				}
				else if (i + j < 4) {
					ace_log2 = 3;
				}
				else if (i + j < 6) {
					ace_log2 = 4;
				}
				else if (i + j < 10) {
					ace_log2 = 5;
				}
				else if (i + j < 14) {
					ace_log2 = 6;
				}
				else if (i + j < 21) {
					ace_log2 = 7;
				}
				else {
					ace_log2 = 8;
				}
				U24 prev_level = mat_prev_level[i];
				U4 flag = 0;
				if (prev_level - 1 < 5)
				{
					flag = prev_level - 1;
				}
				else
				{
					flag = 5;
				}
					d64_cost_last_one_tmp[i] = GET_I_COST(rdoq_est_last_local[1][flag][ace_log2][1], lambda); // block scan order
			}
		}
			for (int i = 0; i < 32; i++) // horizontal
		{
				if (i < cu_height) {
			if (j == 0)
			{
				if (lev_opt[i])
				{
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
			else if (i == shift_t - 1)
			{
				rdoq_last_x[i] = -1;
				rdoq_last_y[i] = -1;
				rdoqD64LastOne[i] = -1;
				if (lev_opt[i])
				{
							//last_x[i] = i;
							//last_y[i] = j;
					rdoq_last_x[i] = i;
					rdoq_last_y[i] = j;
					rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
				}
				tempCost[i] = base_cost_buffer_tmp[i];
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i]) endPosCost[i] = base_cost_buffer_tmp[i];
					else endPosCost[i] = 0;
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (lev_opt[i]) endPosCost[i] = 0;
					else endPosCost[i] = base_cost_buffer_tmp[i];
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // bottom - left scan for (i+j)%2 is odd case
				{
					if (lev_opt[i] && rdoq_last_y[i] != -1) // compare for intialized case.
					{
						if (tempCost[i] + base_cost_buffer_tmp[i] + d64_cost_last_one_tmp[i] < endPosCost[i] + rdoqD64LastOne[i])
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // cost initial. purpose.
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i] + base_cost_buffer_tmp[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += base_cost_buffer_tmp[i];
				}
				else // above - top scan for (i+j)%2 is even case
				{
					S64 curCost = base_cost_buffer_tmp[i];  // care the bit-width. not int.
					if (lev_opt[i] && rdoq_last_y[i] != -1) // the previous non-zero position
					{
						if (tempCost[i] - endPosCost[i] + rdoqD64LastOne[i] - d64_cost_last_one_tmp[i] > 0) // previous position is better
						{
							rdoq_last_x[i] = i;
							rdoq_last_y[i] = j;
							endPosCost[i] = tempCost[i];
							rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
						}
					}
					if (lev_opt[i] && rdoq_last_y[i] == -1) // first non-zero position
					{
						rdoq_last_x[i] = i;
						rdoq_last_y[i] = j;
						endPosCost[i] = tempCost[i];
						rdoqD64LastOne[i] = d64_cost_last_one_tmp[i];
					}
					tempCost[i] += curCost; // from the start point to current pos cost.
					if (i == 0)  // substract here is to get the actual endPosCost
					{
						endPosCost[i] = tempCost[i] - endPosCost[i];
					}
				}
			}
		}
			}
		S64 temp_RdoqCost = finalRdoqCost + endPosCost[0];
		if (rdoq_last_y[0] != -1 && temp_RdoqCost + rdoqD64LastOne[0] < d64_best_cost_tmp)
		{
			d64_best_cost_tmp = temp_RdoqCost + rdoqD64LastOne[0];
			final_rdoq_last_x = rdoq_last_x[0];
			final_rdoq_last_y = rdoq_last_y[0];
		}
		finalRdoqCost += tempCost[0];
			for (int i = 1; i < 32; i++)
		{
				if (i < shift_t) {
			rdoq_last_x[i - 1] = rdoq_last_x[i];
			rdoq_last_y[i - 1] = rdoq_last_y[i];
			tempCost[i - 1] = tempCost[i];
			endPosCost[i - 1] = endPosCost[i];
			rdoqD64LastOne[i - 1] = rdoqD64LastOne[i];
				}
			}
		}
	}

	*final_x = final_rdoq_last_x;
	*final_y = final_rdoq_last_y;
	}
}

void CleanNz_32_all(int cu_width, int cu_height, int* num_nz_coef, s16 dst_tmp[32][32], S16 tmp_dst_coef[1024], int final_x, int final_y)
{
	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < 32; j++) {
				S16 temp;
				if ((i < cu_height)&&(j < cu_width)) {
				if (i + j < final_x + final_y) {
					temp = tmp_dst_coef[i * cu_width + j];
				}
				else if (i + j == final_x + final_y) {
					if ((final_x + final_y) % 2 == 1) {
						if (i > final_x && j < final_y) {
							temp = 0;
							}
							else {
							temp = tmp_dst_coef[i * cu_width + j];
							}
						}
						else {
						if (i < final_x && j > final_y) {
							temp = 0;
							}
							else {
							temp = tmp_dst_coef[i * cu_width + j];
						}
					}
				}
				else {
					temp = 0;
					}
				}
				else {
					temp = 0;
				}
				dst_tmp[i][j] = temp;
				*num_nz_coef += !!(temp);
		}
	}
}

void CleanNz_32_all_cp(int cu_width, int cu_height, int* num_nz_coef, s16 dst_tmp[32][32], s16 dst_tmp_2[32][32], s16 dst_tmp_3[32][32], S16 tmp_dst_coef[1024], int final_x, int final_y)
{
	
	for (int i = 0; i < cu_height; i++) {
#pragma HLS PIPELINE
		//for (int j = 0; j < cu_width; j++) {
//#pragma HLS LOOP_TRIPCOUNT max=32 min=16 avr=32
		for (int j = 0; j < 32; j++) {
			if (j < cu_width) {
				S16 temp;
				if (i + j < final_x + final_y) {
					temp = tmp_dst_coef[i * cu_width + j];
				} else if (i + j == final_x + final_y) {
					if ((final_x + final_y) % 2 == 1) {
						if (i > final_x && j < final_y) {
							temp = 0;
						} else {
							temp = tmp_dst_coef[i * cu_width + j];
						}
					} else {
						if (i < final_x && j > final_y) {
							temp = 0;
						} else {
							temp = tmp_dst_coef[i * cu_width + j];
						}
					}
				} else {
					temp = 0;
				}

				dst_tmp  [i][j] = temp;
				dst_tmp_2[i][j] = temp;
				dst_tmp_3[(i+j) & 0x1f][j] = temp;
				*num_nz_coef += !!(temp);
			}
		}
	}
}
template<int H, int W>
void CleanNz_32x_all_cp(int* num_nz_coef, s16 dst_tmp[32][32], s16 dst_tmp_2[32][32], s16 dst_tmp_3[32][32], S16 tmp_dst_coef[32][32], int final_x, int final_y)
{
#pragma HLS ARRAY_PARTITION variable=dst_tmp 		dim=1 complete
#pragma HLS ARRAY_PARTITION variable=dst_tmp_2 		dim=1 complete
#pragma HLS ARRAY_PARTITION variable=dst_tmp_3 		dim=1 complete
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef 	dim=1 complete

	for (int j = 0; j < W; j++) {
#pragma HLS PIPELINE
		for (int i = 0; i < H; i++) {
			S16 dst_temp;
			//S16 src_temp = tmp_dst_coef[i * W + j];
			S16 src_temp = tmp_dst_coef[i][j];
			if (i + j < final_x + final_y) {
				dst_temp = src_temp;
			} else if (i + j == final_x + final_y) {
				if ((final_x + final_y) % 2 == 1) {
					if (i > final_x && j < final_y) {
						dst_temp = 0;
					} else {
						dst_temp = src_temp;
					}
				} else {
					if (i < final_x && j > final_y) {
						dst_temp = 0;
					} else {
						dst_temp = src_temp;
					}
				}
			} else {
				dst_temp = 0;
			}

			dst_tmp  [i][j] = dst_temp;
			dst_tmp_2[i][j] = dst_temp;
			//dst_tmp_3[i][j] = dst_temp;
			dst_tmp_3[(i+j)& 0x1f][j] = dst_temp;
		
			*num_nz_coef += !!(dst_temp);
		}
	}
}
#if 0
void CleanNz_32x32_all_cp(int* num_nz_coef, S16 dst_tmp[32][32], S16 dst_tmp_2[32][32], S16 tmp_dst_coef[1024], int final_x, int final_y)
{
	for (int j = 0; j < 32; j++) {
#pragma HLS PIPELINE
		for (int i = 0; i < 32; i++) {
			S16 dst_temp;
			S16 src_temp = tmp_dst_coef[i * 32 + j];

			if (i + j < final_x + final_y) {
				dst_temp = src_temp;
			} else if (i + j == final_x + final_y) {
				if ((final_x + final_y) % 2 == 1) {
					if (i > final_x && j < final_y) {
						dst_temp = 0;
					} else {
						dst_temp = src_temp;
					}
				} else {
					if (i < final_x && j > final_y) {
						dst_temp = 0;
					} else {
						dst_temp = src_temp;
					}
				}
			} else {
				dst_temp = 0;
			}

			dst_tmp  [i][j] = dst_temp;
			dst_tmp_2[i][j] = dst_temp;
			*num_nz_coef += !!(dst_temp);
		}
	}
}
#endif //0

void rdoq_32x16_luma(s16 src_coef[32][32], U6 qp, int q_bits, RDOQ_ARRAY* rdoq_array, U2 ch_type, U1 is_intra, s64 lambda, U4 bit_depth, int* num_nz_coef, s16 dst_tmp[32][32], s16 dst_tmp_2[32][32], s16 dst_tmp_3[32][32])
{
#pragma HLS INLINE off
#pragma HLS ARRAY_PARTITION variable=src_coef 	dim=1 complete
#pragma HLS ARRAY_PARTITION variable=dst_tmp 	dim=1 complete
#pragma HLS ARRAY_PARTITION variable=dst_tmp_2 	dim=1 complete
#pragma HLS ARRAY_PARTITION variable=dst_tmp_3 	dim=1 complete

	int final_x;
	int final_y;
	S16 tmp_dst_coef[32][32];
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef dim=1 complete

	rdoq_32x_all_hardware_luma<5, 4, 32, 16>(src_coef, qp, q_bits, tmp_dst_coef, rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
	CleanNz_32x_all_cp<32, 16>(num_nz_coef, dst_tmp, dst_tmp_2, dst_tmp_3, tmp_dst_coef, final_x, final_y);
}

int rdoq_top_32_all(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[32][32], s16 dst_tmp[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{
	const int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	const int tr_shift = get_transform_shift(bit_depth, log2_size);
	const s64 lambda = (d_lambda * (1 << 15) + 500) >> 10;
	U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	const int q_bits = 14 + tr_shift;
	int num_nz_coef = 0;
	int best_last_idx_p1 = 0;
	S16 tmp_coef[1024] = { 0 };
	U36 tmp_level_double[1024] = { 0 };
	S16 tmp_dst_coef[1024] = { 0 };
	U24 mat_prev_level[1024] = { 0 };
	U1 mat_run[1024] = { 0 };
	S64 mat_uncoded_cost[1024] = { 0 };
	S64 mat_coded_cost[1024] = { 0 };
	U24 lev_opt[1024] = { 0 };
	int final_x = 0;
	int final_y = 0;
	rdoq_32_all_hardware(cu_width_log2, cu_height_log2, src_coef, qp, q_bits, tmp_dst_coef, model_cnt->last1, model_cnt->last2, model_cnt->run_rdoq, model_cnt->level,
		rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
		rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
	CleanNz_32_all(cu_width, cu_height, &num_nz_coef, dst_tmp, tmp_dst_coef, final_x, final_y);
	return num_nz_coef;
}

int rdoq_top_32_all_luma(U8 cu_width, U8 cu_height, U6 qp, s64 d_lambda, U1 is_intra, s16 src_coef[32][32], s16 dst_tmp[32][32], s16 dst_tmp_2[32][32], s16 dst_tmp_3[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U4 bit_depth, RDOQ_ARRAY* rdoq_array)
{
	const U30 err_scale_tbl[80][6] = { 32932, 65865, 131731, 263462, 526925, 1053850, 35734, 71468, 142936, 285873, 571747, 1143495, 38968, 77937, 155874, 311749, 623498, 1246996, 42494, 84988, 169976, 339953, 679906, 1359812, 46178, 92356, 184713, 369427, 738855, 1477711, 50533, 101067, 202135, 404270, 808540, 1617081, 55108, 110217, 220435, 440871, 881742, 1763484, 59932, 119864, 239728, 479456, 958912, 1917824, 65536, 131072, 262144, 524288, 1048576, 2097152, 71468, 142936, 285873, 571747, 1143495, 2286990, 77931, 155863, 311726, 623452, 1246905, 2493811, 85150, 170300, 340600, 681200, 1362400, 2724800, 92675, 185351, 370703, 741406, 1482812, 2965625, 101239, 202478, 404956, 809912, 1619825, 3239650, 110059, 220119, 440238, 880477, 1760954, 3521908, 120186, 240372, 480744, 961488, 1922976, 3845952, 131232, 262464, 524928, 1049857, 2099715, 4199430, 142936, 285873, 571747, 1143495, 2286990, 4573980, 155885, 311771, 623543, 1247086, 2494173, 4988347, 169842, 339684, 679368, 1358736, 2717473, 5434947, 185511, 371023, 742046, 1484093, 2968187, 5936374, 202287, 404574, 809149, 1618299, 3236599, 6473198, 220480, 440961, 881923, 1763846, 3527693, 7055387, 240210, 480421, 960842, 1921685, 3843371, 7686742, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 285873, 571747, 1143495, 2286990, 4573980, 9147960, 311771, 623543, 1247086, 2494173, 4988347, 9976695, 340006, 680013, 1360027, 2720055, 5440110, 10880221, 370511, 741022, 1482045, 2964090, 5928181, 11856362, 403966, 807932, 1615864, 3231728, 6463457, 12926914, 440780, 881561, 1763122, 3526245, 7052491, 14104982, 480636, 961272, 1922545, 3845091, 7690183, 15380366, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 571747, 1143495, 2286990, 4573980, 9147960, 18295920, 623543, 1247086, 2494173, 4988347, 9976695, 19953390, 679583, 1359166, 2718333, 5436667, 10873334, 21746669, 741534, 1483068, 2966137, 5932275, 11864550, 23729101, 808540, 1617081, 3234162, 6468324, 12936648, 25873296, 881561, 1763122, 3526245, 7052491, 14104982, 28209965, 962134, 1924268, 3848537, 7697074, 15394148, 30788296, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 1142278, 2284557, 4569114, 9138228, 18276456, 36552913, 1248537, 2497074, 4994148, 9988296, 19976592, 39953184, 1359166, 2718333, 5436667, 10873334, 21746669, 43493339, 1483068, 2966137, 5932275, 11864550, 23729101, 47458202, 1617081, 3234162, 6468324, 12936648, 25873296, 51746593, 1766022, 3532045, 7064090, 14128181, 28256363, 56512727, 1924268, 3848537, 7697074, 15394148, 30788296, 61576592, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 2284557, 4569114, 9138228, 18276456, 36552913, 73105826, 2497074, 4994148, 9988296, 19976592, 39953184, 79906368, 2725233, 5450466, 10900932, 21801864, 43603728, 87207457, 2966137, 5932275, 11864550, 23729101, 47458202, 94916404, 3234162, 6468324, 12936648, 25873296, 51746593, 103493187, 3532045, 7064090, 14128181, 28256363, 56512727, 113025455, 3834792, 7669584, 15339168, 30678337, 61356675, 122713351, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 4628197, 9256395, 18512790, 37025580, 74051160, 148102320, 4971026, 9942053, 19884107, 39768215, 79536431, 159072862, 5422938, 10845877, 21691754, 43383508, 86767016, 173534032, 5899680, 11799360, 23598721, 47197442, 94394885, 188789771, 6468324, 12936648, 25873296, 51746593, 103493187, 206986375, 7064090, 14128181, 28256363, 56512727, 113025455, 226050910, 7780737, 15561475, 31122951, 62245902, 124491805, 248983611, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 9099506, 18199013, 36398027, 72796055, 145592111, 291184223, 9942053, 19884107, 39768215, 79536431, 159072862, 318145725, 10956549, 21913098, 43826196, 87652393, 175304787, 350609575, 11930464, 23860929, 47721858, 95443717, 190887435, 381774870, 13094412, 26188824, 52377649, 104755299, 209510599, 419021199, 14128181, 28256363, 56512727, 113025455, 226050910, 452101820, 15339168, 30678337, 61356675, 122713351, 245426702, 490853405, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 17895697, 35791394, 71582788, 143165576, 286331153, 572662306, 19884107, 39768215, 79536431, 159072862, 318145725, 636291451, 21474836, 42949672, 85899345, 171798691, 343597383, 687194767, 23342213, 46684427, 93368854, 186737708, 373475417, 746950834, 25565281, 51130563, 102261126, 204522252, 409044504, 818089008, 28256363, 56512727, 113025455, 226050910, 452101820, 904203641, 29826161, 59652323, 119304647, 238609294, 477218588, 954437176 };
	int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
#if 0
	int tr_shift = get_transform_shift(bit_depth, log2_size);
#else
    int tr_shift = 15 - bit_depth - log2_size;
#endif
	s64 lambda = (d_lambda * (1 << 15) + 500) >> 10;
	
	s64 err_scale = err_scale_tbl[qp][log2_size - 1];
	int q_bits = 14 + tr_shift;
	int num_nz_coef = 0;
	int best_last_idx_p1 = 0;
	int final_x = 0;
	int final_y = 0;
	//S16 tmp_coef        [1024] = { 0 };
	//U36 tmp_level_double[1024] = { 0 };
	//U24 mat_prev_level  [1024] = { 0 };
	//U1 mat_run          [1024] = { 0 };
	//S64 mat_uncoded_cost[1024] = { 0 };
	//S64 mat_coded_cost  [1024] = { 0 };
	//U24 lev_opt         [1024] = { 0 };
#if 0
    for (int j=0; j<32; j++) {
        for (int i=0; i<32; i++) {
            tmp_dst_coef[i*32 +j] = 0;
        }
    }
#endif

#ifndef _BLOCK_MD_32x32_
	if ((cu_width == 32) && (cu_height == 32)) {
		S16 tmp_dst_coef[32][32];
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef dim=1 complete
		//rdoq_32x32_all_hardware_luma(src_coef, qp, q_bits, tmp_dst_coef, rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
		// CleanNz_32x32_all_cp(&num_nz_coef, dst_tmp, dst_tmp_2, tmp_dst_coef, final_x, final_y);
		rdoq_32x_all_hardware_luma<5, 5, 32, 32>(src_coef, qp, q_bits, tmp_dst_coef, rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
		CleanNz_32x_all_cp<32, 32>(&num_nz_coef, dst_tmp, dst_tmp_2, dst_tmp_3, tmp_dst_coef, final_x, final_y);
	} else 
#endif //_BLOCK_MD_32x32_
#ifndef _BLOCK_MD_32x16_
	if ((cu_width == 16) && (cu_height == 32)) {
		//rdoq_32x_all_hardware_luma<5, 4, 32, 16>(src_coef, qp, q_bits, tmp_dst_coef, rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
		//CleanNz_32x_all_cp<32, 16>(&num_nz_coef, dst_tmp, dst_tmp_2, dst_tmp_3, tmp_dst_coef, final_x, final_y);
		rdoq_32x16_luma(src_coef, qp, q_bits, rdoq_array, ch_type, is_intra, lambda, bit_depth, &num_nz_coef, dst_tmp, dst_tmp_2, dst_tmp_3);
	} else 
#endif //_BLOCK_MD_32x16_
#ifndef _BLOCK_MD_16x32_
	if ((cu_width == 32) && (cu_height == 16)) {
		S16 tmp_dst_coef[32][32];
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef dim=1 complete
		//rdoq_32_all_hardware_luma(cu_width_log2, cu_height_log2, src_coef, qp, q_bits, tmp_dst_coef, rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
		rdoq_32x_all_hardware_luma<4, 5, 16, 32>(src_coef, qp, q_bits, tmp_dst_coef, rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, ch_type, is_intra, lambda, bit_depth, &final_x, &final_y);
		CleanNz_32x_all_cp<16, 32>(&num_nz_coef, dst_tmp, dst_tmp_2, dst_tmp_3, tmp_dst_coef, final_x, final_y);
		//CleanNz_32_all_cp(cu_width, cu_height, &num_nz_coef, dst_tmp, dst_tmp_2, dst_tmp_3, tmp_dst_coef, final_x, final_y);
	}
#endif //_BLOCK_MD_16x32_

	return num_nz_coef;
}

void CleanNz_32_all_Chroma32(int cu_width, int cu_height, int* num_nz_coef,  S16 tmp_dst_coef[32][32], int final_x, int final_y
	, s16 coef_uv[32][32], s16 coefVer_q[32][32], int rdo_idx, int all_rdo_num
	)
{
#pragma HLS ARRAY_PARTITION variable=tmp_dst_coef complete dim=1
#pragma HLS ARRAY_PARTITION variable=coefVer_q complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_uv complete dim=1
	int  num_nz_coef_tmp =0;
	if (rdo_idx < all_rdo_num) {
	for (int j = 0; j < 32; j++) {
#pragma HLS PIPELINE
		for (int i = 0; i < 32; i++) {
			S16 temp;
			if ((i < cu_height) && (j < cu_width)) {
				if (i + j < final_x + final_y) {
					temp = tmp_dst_coef[i][j];
				}
				else if (i + j == final_x + final_y) {
					if ((final_x + final_y) % 2 == 1) {
						if (i > final_x && j < final_y) {
							temp = 0;
						}
						else {
							temp = tmp_dst_coef[i][j];
						}
					}
					else {
						if (i < final_x && j > final_y) {
							temp = 0;
						}
						else {
							temp = tmp_dst_coef[i][j];
						}
					}
				}
				else {
					temp = 0;
				}
			}
			else {
				temp = 0;
			}
			coef_uv[i][j] = temp;
			coefVer_q[i][j] = temp;
			num_nz_coef_tmp += !!(temp);
		}
	}

	*num_nz_coef = num_nz_coef_tmp;
	}
}



static void memcpy_rewrintra_2d_to_1d_32(s16* des, s16 src[32][32], U3 cu_width_log2, U3 cu_height_log2)
{
	int w = 1 << cu_width_log2;
	int h = 1 << cu_height_log2;

    for (int i = 0; i < h; i++) {
#pragma HLS LOOP_TRIPCOUNT max=32
        for (int j = 0; j < w; j++) {
#pragma HLS LOOP_TRIPCOUNT max=32
			des[(i << cu_width_log2) + j] = src[i][j];
		}

	}
}

static int quant_32(U7 w, U7 h, U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth, s16 coef[32][32], s16 coef_out[32][32], s16 coef_out1[32][32], s16 coef_out2[32][32], U2 slice_type, U14 scale)
{
	int offset;
	int i, j;
	int shift;
	int sign;
	s16 lev;
	int tr_shift;
	int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	int num_nz_coef = 0;
	int scale_x_ns_scale = scale * ns_scale;

	tr_shift = get_transform_shift(bit_depth, log2_size - ns_shift);
	shift = QUANT_SHIFT + tr_shift;
	offset = (s64)((slice_type == SLICE_I) ? 171 : 85) << (s64)(shift - 9);

	for (i = 0; i < h; i++)
	{
		for (j = 0; j < w; j++)
		{
			sign = COM_SIGN_GET(coef[i][j]);
			lev = ((int)(COM_ABS(coef[i][j]) * scale_x_ns_scale + offset) >> shift);
			coef_out[i][j] = COM_SIGN_SET(lev, sign);
			coef_out1[i][j] = COM_SIGN_SET(lev, sign);
			coef_out2[(i + j) & 0x1f][j] = COM_SIGN_SET(lev, sign);
			//bug fix for rate estimation
			//if ((i + j) >= w)
			//{
			//	coef[i][j] = 0;
			//}

			num_nz_coef += !!(coef_out[i][j]);
		}
	}
	return num_nz_coef;
}

//static int quant_nnz_32(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, RDOQ_ARRAY* rdoq_array, U4 bit_depth, U6 qp, s64 lambda, U1 is_intra, s16 coef[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U2 slice_type, s16 coef_y_pb_part[SIZE_32], s16 coef_u[SIZE_32], s16 coef_v[SIZE_32])
//{
//	int i;
//	int num_nz_coef = 0;
//	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };
//
//	U14 scale = quant_scale[qp];
//	int width = cu_width;
//	int height = cu_height;
//
//	for (i = 0; i < SIZE_32; i++) {
//		coef_y_pb_part[i] = 0;
//	}
//
//#if RDOQ_OPEN
//	num_nz_coef = rdoq_top_32(cu_width, cu_height, model_cnt, qp, lambda, is_intra, coef, coef, cu_width_log2, cu_height_log2, ch_type, bit_depth, rdoq_array);
//#else
//	num_nz_coef = quant_32(cu_width, cu_height, cu_width_log2, cu_height_log2, bit_depth, coef, coef, slice_type, scale);
//#endif
//
//	memcpy_rewrintra_2d_to_1d_32(coef_y_pb_part, coef, cu_width_log2, cu_height_log2);
//	if (ch_type == 1)memcpy_rewrintra_2d_to_1d_32(coef_u, coef, cu_width_log2, cu_height_log2);
//	else if (ch_type == 2)memcpy_rewrintra_2d_to_1d_32(coef_v, coef, cu_width_log2, cu_height_log2);
//
//	return num_nz_coef;
//}

static int quant_chroma32(U7 w, U7 h, U3 cu_width_log2, U3 cu_height_log2, U4 bit_depth, s16 coef[32][32], s16 coef_out[32][32], U2 slice_type,
	U14 scale, int* num_nz_q)
{
	int offset;
	int i, j;
	int shift;
	int sign;
	s16 lev;
	int tr_shift;
	int log2_size = (cu_width_log2 + cu_height_log2) >> 1;
	int ns_shift = ((cu_width_log2 + cu_height_log2) & 1) ? 7 : 0;
	int ns_scale = ((cu_width_log2 + cu_height_log2) & 1) ? 181 : 1;
	int num_nz_coef = 0;
	int scale_x_ns_scale = scale * ns_scale;

	tr_shift = get_transform_shift(bit_depth, log2_size - ns_shift);
	shift = QUANT_SHIFT + tr_shift;
	offset = (s64)((slice_type == SLICE_I) ? 171 : 85) << (s64)(shift - 9);

	for (i = 0; i < h; i++)
	{
		for (j = 0; j < w; j++)
		{
			sign = COM_SIGN_GET(coef[i][j]);
			lev = ((int)(COM_ABS(coef[i][j]) * scale_x_ns_scale + offset) >> shift);
			coef_out[i][j] = COM_SIGN_SET(lev, sign);

	

			num_nz_coef += !!(coef_out[i][j]);
		}
	}
	*num_nz_q = num_nz_coef;
}



static int quant_nnz_32_luma(U8 cu_width, U8 cu_height, RDOQ_MODEL* model_cnt, RDOQ_ARRAY* rdoq_array, U4 bit_depth, U6 qp, s64 lambda, U1 is_intra, s16 coef[32][32], U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U2 slice_type, s16 coef_y_pb_part[SIZE_32], s16 coef_u[SIZE_32], s16 coef_v[SIZE_32])
{
	int i;
	int num_nz_coef = 0;
	static U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	U14 scale = quant_scale[qp];
	int width = cu_width;
	int height = cu_height;

	for (i = 0; i < SIZE_32; i++) {
		coef_y_pb_part[i] = 0;
	}


	num_nz_coef = rdoq_top_32(cu_width, cu_height, model_cnt, qp, lambda, is_intra, coef, coef, cu_width_log2, cu_height_log2, ch_type, bit_depth, rdoq_array);


	memcpy_rewrintra_2d_to_1d_32(coef_y_pb_part, coef, cu_width_log2, cu_height_log2);
	if (ch_type == 1)memcpy_rewrintra_2d_to_1d_32(coef_u, coef, cu_width_log2, cu_height_log2);
	else if (ch_type == 2)memcpy_rewrintra_2d_to_1d_32(coef_v, coef, cu_width_log2, cu_height_log2);

	return num_nz_coef;
}

// MD_KERNEL_32 QUANT TOP
static void quant_nnz_32_lite(int num_nz_rate[MAX_NUM_TB][N_C], int* num_nz_itv, U8 cu_width, U8 cu_height, RDOQ_ARRAY* rdoq_array, U4 bit_depth, U6 qp, s64 lambda, U1 is_intra_quant, U1* is_intra_rate, s16 coef[32][32], 
    U3 cu_width_log2, U3 cu_height_log2, U2 ch_type, U2 slice_type, s16 coef_y_pb_part[32][32], s16 coef_tmp_v_to_it[32][32], s16 coef_y_pb_part_update[32][32])
{
#pragma HLS INLINE off

//#pragma HLS ARRAY_PARTITION variable=coef                   dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part         dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_v_to_it       dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part_update  dim=1 complete
	
	const U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	// STREAM BUFFER
	U1 is_intra_read = is_intra_quant;
	int num_nz_write;
	
	U14 scale  = quant_scale[qp];
	int width  = cu_width;
	int height = cu_height;

	//int num_nz_coef = 0;
	//s16 coef_to_it2[32][32];

	if (ch_type == 0) {
#if 0
		cu_nz_cln(num_nz_rate);
		cu_nz_cln(num_nz_update);
#else
        for (U3 i = 0; i < 4; i++) {
        #pragma HLS UNROLL
            for (U3 j= 0; j < 3; j++) {
            #pragma HLS UNROLL
                num_nz_rate  [i][j] = 0;
		    }
	    }
#endif
	}

	/*for (i = 0; i < SIZE_32; i++) {
		coef_y_pb_part[i] = 0;
	}*/
	/*for (int j = 0; j < 32; j++) {
		for (int k = 0; k < 32; k++) {
			coef_to_it2[j][k] = coef[j][k];
		}
	}*/

//    s16 coef_tmp_v_to_it_local[32][32];
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_v_to_it_local dim=1 complete

#if RDOQ_OPEN
	num_nz_write = rdoq_top_32_all_luma(cu_width, cu_height, qp, lambda, is_intra_read, coef, coef_tmp_v_to_it, coef_y_pb_part, coef_y_pb_part_update, cu_width_log2, cu_height_log2, ch_type, bit_depth, rdoq_array);
#else
	num_nz_write = quant_32(cu_width, cu_height, cu_width_log2, cu_height_log2, bit_depth, coef, coef_tmp_v_to_it, coef_y_pb_part, coef_y_pb_part_update, slice_type, scale);
#endif

#if 0 // Move into rdoq_top_32_all_luma

	for (int j = 0; j < width; j++) {
#pragma HLS LOOP_TRIPCOUNT max=32 min=16 avg=32
#pragma HLS PIPELINE
		// for (int i = 0; i < height; i++) {
		for (int i = 0; i < 32; i++) {
			if (i < height) {
				coef_y_pb_part       [i][j] = coef_tmp_v_to_it_local[i][j];
				coef_y_pb_part_update[(i+j)&0x1f][j] = coef_tmp_v_to_it_local[i][j];
			}
		}
	}
#endif 

	// WRITE STREAMS
	*is_intra_rate = is_intra_read;
	*num_nz_itv    = num_nz_write;
	num_nz_rate[0][ch_type] = num_nz_write;
	
	//return num_nz_coef;
}


/////////////////////update rdo luma
static int encode_umve_idx_est(u8 umve_idx)
{
	U3 enc_est;
	enc_est = 0;
	if (umve_idx < 20) {
		enc_est++;
	} else {
		enc_est += 2;
	}

	if (umve_idx < 4 || (umve_idx >= 20 && umve_idx < 24)) {
		enc_est++;
	} else {
		enc_est += 2;
	}

	enc_est += 2;
	return enc_est;
}
static int encode_skip_idx_cu_est(u8  skip_idx, u8 num_hmvp_cands, U2 slice_type)
{

	U8 enc_est = 0;
	U8 val;
	U8 max_skip_num;
	// for P slice, change 3, 4, ..., 13 to 1, 2, ..., 11
	if ((slice_type == 2) && (skip_idx > 0)) {
		skip_idx -= 2;
	}
	val = skip_idx;
	max_skip_num = (((slice_type) == 2 ? 2 : (PRED_DIR_NUM)+1)) + num_hmvp_cands;
	enc_est += val;
	if (skip_idx != max_skip_num - 1) {
		enc_est++;
	}
	return enc_est;
}
static int enc_eco_abs_mvd_est(U16 sym)
{
	U5 enc_est = 0;
	U5 exp_golomb_order = 0;
	// 0, 1, 2
	if (sym < (3)) {
		if (sym == (0)) {
			enc_est++;
		}
		else if (sym == (1)) {
			enc_est += 2;
		}
		else if (sym == (2)) {
			enc_est += 3;
		}
	}
	else {
		U1 offset;
		sym -= (3);
		offset = ((sym & (1)));
		enc_est += 3;
		enc_est++;
		sym = (sym - (offset)) >> 1;
		// exp_golomb part
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 16;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 18;
		}
		else //if (sym >= (1023) && sym < (2047)) 
		{
			exp_golomb_order = 20;
		}
		//else if (sym >= (2047) && sym < (4095)) {
		//	exp_golomb_order = 22;
		//}
		enc_est += exp_golomb_order;
		//enc_est+=sbac_write_unary_sym_ep_est(exp_golomb_order);
		//enc_est+=sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}
static int encode_affine_flag_est(U1 flag, u8 affine_enable_flag, U3 cu_width_log2, U3 cu_height_log2)
{
	//COM_MODE *mod_info_curr = &core->mod_info_curr;
	U1 enc_est = 0;
	if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
		enc_est++;
	}
	return enc_est;
}
static int sbac_write_truncate_unary_sym_est(U8 sym, U8 max_num)
{

	U8 enc_est;
	enc_est = (max_num - (1) > sym + (1) ? sym + (1) : max_num - (1));
	return enc_est;
}
static int encode_intra_dir_est(u8 ipm, u8 mpm[2])
{
	U3 enc_est;
	S8 ipm_code = (ipm) == (mpm[0]) ? -2 : (((mpm[1]) == (ipm) ? -1 : (((ipm) < (mpm[0]) ? (ipm) : (((ipm) < (mpm[1]) ? (ipm)-1 : (ipm)-2))))));
	if (ipm_code < 0) {
		enc_est = 2;
	} else {
		enc_est = 6;
	}

	return enc_est;
}
static int encode_mvd_est(S16 mvd[2])
{
	U16 mv;
	U5 enc_est = 0;

	mv = (mvd[0]);
	if ((mvd[0]) < 0) {

		mv = ((-(mvd[0])));
	}
	enc_est += enc_eco_abs_mvd_est(mv);
	if (mv) {
		enc_est++;
	}

	mv = (mvd[1]);
	if ((mvd[1]) < 0) {

		mv = ((-(mvd[1])));
	}
	enc_est += enc_eco_abs_mvd_est(mv);
	if (mv) {
		enc_est++;
	}
	return enc_est;
}


static int enc_eco_level_est_2(u16 sym)
{

	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0)
		enc_est = 0;
	else if (sym < (9)) {
		enc_est = sym;
		enc_est += 2;
	}
	else {
		sym -= (9);
		//enc_est += sbac_write_truncate_unary_sym_est(8, 9);
		enc_est = 10;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 16;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 18;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 20;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 22;
		}
		enc_est += exp_golomb_order;
		//sbac_write_unary_sym_ep_est(exp_golomb_order);
		//sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}
static int enc_eco_run_est_2(U10 sym, u16 level)
{

	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0) {
		if (level == 0) {
			enc_est = 0;
		}
		else {
			enc_est = 1;
		}
	}
	else if (sym < (16)) {
		enc_est += sym + 1;
	}
	else {
		sym -= (16);
		enc_est += 16;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 16;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 18;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 20;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 22;
		}
		enc_est += exp_golomb_order;
	}
	return enc_est;
}

static int rate_coef_est_32(s16 coef[32], U10 run[32], u8 w)
{
	U12 enc_est = 0;
	U6 i;

	for (i = 0; i < 32; i++)
	{
		if (i < w)
		{
			u16  level;
			level = abs(coef[i]);
			//level = ((((coef[i]) ^ (coef[i]) >> 15) - ((coef[i]) >> 15)));
			//level = (coef[i]) ^ ((coef[i]) >> 15) - ((coef[i]) >> 15);
			enc_est += enc_eco_run_est_2(run[i], level);
			enc_est += enc_eco_level_est_2(level);
		}
	}
	return enc_est;
}

static int rate_coef_est_32_coef_0(u8 w)
{
	U12 enc_est = 0;
	U6 i;

	for (i = 0; i < 32; i++)
	{
		if (i < w)
		{
			enc_est += enc_eco_run_est_2(0, 0);
			enc_est += enc_eco_level_est_2(0);
		}
	}
	return enc_est;
}




static int enc_eco_run_est_3(U10 run)
{

	U4 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (run < (16)) {
		enc_est += run + 1;
	}
	else {
		run -= (16);
		enc_est += 16;
		if (run == (0)) {
			exp_golomb_order = 0;
		}
		else if (run >= (1) && run < (3)) {
			exp_golomb_order = 1;
		}
		else if (run >= (3) && run < (7)) {
			exp_golomb_order = 2;
		}
		else if (run >= (7) && run < (15)) {
			exp_golomb_order = 3;
		}
		else if (run >= (15) && run < (31)) {
			exp_golomb_order = 4;
		}
		else if (run >= (31) && run < (63)) {
			exp_golomb_order = 5;
		}
		else if (run >= (63) && run < (127)) {
			exp_golomb_order = 6;
		}
		else if (run >= (127) && run < (255)) {
			exp_golomb_order = 7;
		}
		else /*if (run >= (255) && run < (511))*/ {
			exp_golomb_order = 8;
		}/*
		 else if (run >= (512) && run < (1023)) {
		 exp_golomb_order = 9;
		 }
		 else if (run >= (1023) && run < (2047)) {
		 exp_golomb_order = 10;
		 }
		 else if (run >= (2047) && run < (4095)) {
		 exp_golomb_order = 11;
		 }*/
		enc_est += 2 * exp_golomb_order;
	}
	return enc_est;
}
static int enc_eco_level_est_3(U16 sym)
{

	U4 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0)
		enc_est = 0;
	else if (sym < (9)) {
		enc_est = sym;
		//enc_est += 2;
	}
	else {
		sym -= (9);
		enc_est = 8;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 1;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 3;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 5;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 7;
		}
		else /*if (sym >= ( 255) && sym < ( 511)) */ {
			exp_golomb_order = 8;
		}/*
		 else if (sym >= ( 512) && sym < ( 1023)) {
		 exp_golomb_order = 9;
		 }
		 else if (sym >= ( 1023) && sym < ( 2047)) {
		 exp_golomb_order = 10;
		 }
		 else if (sym >= ( 2047) && sym < ( 4095)) {
		 exp_golomb_order = 11;
		 }*/
		enc_est += 2 * exp_golomb_order;
	}
	return enc_est;
}
static int enc_eco_cbf_est_32(int num_nz[4][3], u8 pred_mode,
	S8 ipm[4][2], U2 tree_status, U3 cu_width_log2, U3 cu_height_log2)
{
	U4 enc_est = 0;
	//COM_MODE *mod_info_curr = &core->mod_info_curr;
	U1 ctp_zero_flag = !is_cu_nz(num_nz);
	/* code allcbf */
	if ((pred_mode) != 0) {
		if (!((pred_mode) == 3)) {
			if (tree_status == TREE_LC) {
				enc_est++;
				if (ctp_zero_flag) {
					return 0;
				}
			}
		}

		if (tree_status == TREE_LC) {
			enc_est += 2;
			
		}
		if (num_nz[0][1] + num_nz[0][2] == 0 && tree_status == TREE_LC) {
		} else {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);

			enc_est += 1;
		
		}
	}
	else {
		if (!((ipm[0][0]) == 33)) {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);

			enc_est += 1;
			

		}
		if (tree_status == TREE_LC) {
			if (!((ipm[0][0]) == 33 && (ipm[0][1]) == 0)) {
				enc_est += 2;
				
			}
		}
	}
	return enc_est;
}

static int enc_bit_est_flag_32(U2 slice_type, u8 curr_mvr, U2 tree_status, U2 cons_pred_mode, U2 cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, 
	S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], U3 cu_width_log2, U3 cu_height_log2, int num_nz[MAX_NUM_TB][N_C], 
	S8 ipm[MAX_NUM_PB][2], int cur_ptr, int ref_ptr, u8 num_of_hmvp_cand, u8 mpm[4][2], U1 intra)
{
	U8 enc_est = 0;
	if (intra) {
		if (slice_type != 1) {
			if ((cons_pred_mode) != (ONLY_INTRA)) {
				enc_est += 2;
			}
			if (cons_pred_mode == NO_MODE_CONS) {
				enc_est++;
			}
		}
		enc_est += encode_intra_dir_est(ipm[0][0], mpm[0]);
		enc_est++;
	}
	else {
		U2 skip_flag = (cu_mode == 2);
		U2 dir_flag = (cu_mode == 3);
		U1 umve_enable_flag = 1;
		U4 num_of_hmvp_cand = 8;
		U1 amvr_enable_flag = 1;
		U1 emvr_enable_flag = 1;
		U1 smvd_enable_flag = 1;
		enc_est++;
		if (!skip_flag) {
			enc_est++;
		}
		if (skip_flag || dir_flag) {
			if (umve_enable_flag) {
				enc_est++;
			}
			if (umve_flag) {
				enc_est += encode_umve_idx_est((umve_idx));
			} else {
				if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
					enc_est++;
				}
				if (affine_flag) {
					enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
				} else {
					enc_est += encode_skip_idx_cu_est((skip_idx), num_of_hmvp_cand, slice_type);
				}
			}
		}
		else {
			if (((cons_pred_mode)) == (NO_MODE_CONS)) {
				enc_est++;
			}
			enc_est += encode_affine_flag_est(((affine_flag)) != 0, 1, cu_width_log2, cu_height_log2);
			if (amvr_enable_flag) {
				// also imply ctx->info.sqh.num_of_hmvp_cand is not zero
				if (emvr_enable_flag && !affine_flag) {
					enc_est++;
				}
				if (affine_flag) {
					enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 3);
				}
				else {
					enc_est += sbac_write_truncate_unary_sym_est(curr_mvr, 5);
				}
			}
			{
				S8 refi0 = refi[0];
				S8 refi1 = refi[1];

				if ((smvd_enable_flag) && refi0 >= 0 && refi1 >= 0 && cur_ptr - 0 == 0 - cur_ptr && (affine_flag) == 0 && !(mvp_from_hmvp_flag)) {
					enc_est++;
				}
				if ((slice_type == 2 || slice_type == 3) && refi0 >= 0) {
					if ((smvd_flag) == 0) {
						/*if ((num_refp) > 1) {
							enc_est += sbac_write_truncate_unary_sym_est(refi0, num_refp);
						}*/
					}
					if (affine_flag) {
						S16 affine_mvd_real[2];
						U3 amvr_shift = ((curr_mvr) == 0 ? 2 : (((curr_mvr) == 1 ? 4 : 0)));
						affine_mvd_real[0] = (((affine_mvd[0][0][0]) >> (amvr_shift)));
						affine_mvd_real[1] = (((affine_mvd[0][0][1]) >> (amvr_shift)));
						enc_est += encode_mvd_est(affine_mvd_real);
						S16 affine_mvd_real_1[2];
						affine_mvd_real_1[0] = (((affine_mvd[0][1][0]) >> (amvr_shift)));
						affine_mvd_real_1[1] = (((affine_mvd[0][1][1]) >> (amvr_shift)));
						enc_est += encode_mvd_est(affine_mvd_real_1);
					}
					else {
						S16 a_mvd[2];
						a_mvd[0] = (((mvd[0][0]) >> (curr_mvr)));
						a_mvd[1] = (((mvd[0][1]) >> (curr_mvr)));
						enc_est += encode_mvd_est(a_mvd);
					}
				}
			}
		}


		if (tree_status != TREE_C) {
			enc_est += enc_eco_cbf_est_32(num_nz, cu_mode, ipm, tree_status, cu_width_log2, cu_height_log2);
		}
		else if (!((cu_mode == 0) && (ipm[0][0] == 33) && (ipm[0][1] == 0))) {
			enc_est += 2;
		}
	}

	return enc_est;
}
static int  enc_eco_coef_32_wh(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	static s16 coef_out[32];
	//s16 coef[H][W];
	static U10 run[32];

	//	FUNC_NAME(ready_coef, W, H)(coef_in, coef);
	for (U7 z = 0; z < 32; z++) {
		run[z] = 0;
		coef_out[z] = 0;
	}
	//	run_end[0] = 0;
	U10 run_num = 0;
	S7 j;
	for (U7 i = 0; i < cu_width; i++)
	{
		if (i == 0)
		{
			coef_out[0] = coef[i];
			if (coef[i]) {
				run_num = 0;
			}
			else
				run_num = 1;
		}
		else
		{
			if (i & 0x1)
			{
				for (j = 0; j < 32; j++)
				{
					if (j <= i)
					{
						coef_out[j] = coef[(j << log2_w) + i - j];
						if (coef[(j << log2_w) + i - j]) {
							run[j] = run_num;
							run_num = 0;
						}
						else
						{
							run[j] = 0;
							run_num++;
						}
					}
				}
			}
			else
			{
				for (j = 32; j >= 0; j--)
				{
					if (j <= i)
					{
						coef_out[i - j] = coef[(j << log2_w) + i - j];
						if (coef[(j << log2_w) + i - j]) {
							run[i - j] = run_num;
							run_num = 0;
						}
						else
						{
							run[i - j] = 0;
							run_num++;
						}
					}
				}
			}
		}

		enc_est += rate_coef_est_32(coef_out, run, cu_width);
	}

	return enc_est;


}

static int enc_eco_run_est_2_only(U10 sym)
{
#pragma HLS INLINE 

	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 65) {
		enc_est = 1;
	}
	else if (sym == 0) {
		enc_est = 0;
	}
	else if (sym < (16)) {
		enc_est += sym + 1;
	}
	else {
		sym -= (16);
		enc_est += 16;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 16;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 18;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 20;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 22;
		}
		enc_est += exp_golomb_order;
	}
	return enc_est;
}

static int rate_coef_run_est_32(U10 run[32], u8 w)
{
	U12 enc_est = 0;
	U6 i;

	for (i = 0; i < 32; i++)
	{
		if (i < w)
		{
			//level = ((((coef[i]) ^ (coef[i]) >> 15) - ((coef[i]) >> 15)));
			//level = (coef[i]) ^ ((coef[i]) >> 15) - ((coef[i]) >> 15);
			enc_est += enc_eco_run_est_2_only(run[i]);

		}
	}
	return enc_est;
}


static int enc_eco_coef_32_wh_run(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h) {
	U15 enc_est = 0;
	static U10 run[32];

	//	FUNC_NAME(ready_coef, W, H)(coef_in, coef);
	for (U7 z = 0; z < 32; z++) {
		run[z] = 0;
	}
	//	run_end[0] = 0;
	U10 run_num = 0;
	S7 j;
	for (U7 i = 0; i < cu_width; i++)
	{
		if (i & 0x1)
		{
			for (j = 0; j < 32; j++)
			{
				if (j <= i)
				{
					if (coef[(j << log2_w) + i - j]) {
						if (!run_num) {
							run[j] = 65;
						}
						else {
							run[j] = run_num;
						}
						run_num = 0;
					}
					else
					{
						run[j] = 0;
						run_num++;
					}
				}
			}
		}
		else
		{
			for (j = 32; j >= 0; j--)
			{
				if (j <= i)
				{
					if (coef[(j << log2_w) + i - j]) {
						if (!run_num) {
							run[i - j] = 65;
						}
						else {
							run[i - j] = run_num;
						}
						run_num = 0;
					}
					else
					{
						run[i - j] = 0;
						run_num++;
					}
				}
			}
		}

		enc_est += rate_coef_run_est_32(run, cu_width);
	}

	return enc_est;
}

static int enc_eco_level_est_2_only(u16 sym)
{
#pragma HLS INLINE

	U5 exp_golomb_order = 0;
	U6 enc_est = 0;

	if (sym == 0)
		enc_est = 0;
	else if (sym < (9)) {
		enc_est = sym;
		enc_est += 2;
	}
	else {
		sym -= (9);
		//enc_est += sbac_write_truncate_unary_sym_est(8, 9);
		enc_est = 10;
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 12;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 14;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 16;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 18;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 20;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 22;
		}
		enc_est += exp_golomb_order;
		//sbac_write_unary_sym_ep_est(exp_golomb_order);
		//sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}


static int rate_coef_level_est_32(s16 coef[32], u8 w)
{
#pragma HLS INLINE 

	U12 enc_est = 0;
	U12 enc_est_tmp[32];
#pragma HLS ARRAY_PARTITION variable=enc_est_tmp complete dim=1

	for (U6 i = 0; i < 32; i++) {
#pragma HLS UNROLL 
		if (i < w) {
			u16  level;
			level = abs(coef[i]);
			//level = ((((coef[i]) ^ (coef[i]) >> 15) - ((coef[i]) >> 15)));
			//level = (coef[i]) ^ ((coef[i]) >> 15) - ((coef[i]) >> 15);
			enc_est_tmp[i] = enc_eco_level_est_2_only(level);
		} else {
			enc_est_tmp[i] = 0;
		}
	}
	for (U6 i=0; i<32; i++) {
#pragma HLS UNROLL 
        enc_est += enc_est_tmp[i];	
	}
	
	return enc_est;
}


static int  enc_eco_coef_32_wh_level(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	static s16 coef_out[32];
	//s16 coef[H][W];

	//	FUNC_NAME(ready_coef, W, H)(coef_in, coef);
	for (U7 z = 0; z < 32; z++) {
		coef_out[z] = 0;
	}
	//	run_end[0] = 0;
	U10 run_num = 0;
	S7 j;
	for (U7 i = 0; i < cu_width; i++)
	{
		if (i & 0x1)
		{
			for (j = 0; j < 32; j++)
			{
				if (j <= i)
				{
					coef_out[j] = coef[(j << log2_w) + i - j];
				}
			}
		}
		else
		{
			for (j = 32; j >= 0; j--)
			{
				if (j <= i)
				{
					coef_out[i - j] = coef[(j << log2_w) + i - j];
				}
			}
		}

		enc_est += rate_coef_level_est_32(coef_out, cu_width);
	}

	return enc_est;
}

static int enc_eco_coef_32_32_run(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h) {


	int final_rate = 0;
	int last_x[32];  // the last non-zero position of scan-line.
	int last_y[32];

	int first_x[32]; // the first non-zero position of scan-line.
	int first_y[32];

	int sumRate[32] = { 0, };

	int final_last_x = -1, final_last_y = -1;
	int final_zig_zag = 0;

	memset(last_x, -1, sizeof(int) * 32);
	memset(last_y, -1, sizeof(int) * 32);

	memset(first_x, -1, sizeof(int) * 32);
	memset(first_y, -1, sizeof(int) * 32);

	for (int j = 0; j < 32; j++) // vertical
	{
		int zzz = 0;
		for (int i = 0; i < 32; i++) // horizontal
		{
			if (j == 0) // first input row data.
			{
				if (coef[i * 32 + j])
				{
					last_x[i] = i;
					last_y[i] = j;

					first_x[i] = i;
					first_y[i] = j;
				}
			}
			else
			{
				if ((i + j) % 2 == 0) // above-right-scan
				{
					if (first_x[i] == -1 && coef[i * 32 + j])
					{
						first_x[i] = i;
						first_y[i] = j;
					}

					if (coef[i * 32 + j])
					{
						if (last_x[i] != -1)
						{
							int offset = last_x[i] - i;
							if (offset == 1) // previou is non-zero coeff. 
							{
								sumRate[i] += 1;
							}
							else
							{
								sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
							}
						}
						last_x[i] = i;
						last_y[i] = j;
					}
				}
				else // above - top scan for (i+j)%2 is even case
				{
					if (coef[i * 32 + j] && last_x[i] == -1) // first non-zero position
					{
						last_x[i] = i;
						last_y[i] = j;
					}

					if (coef[i * 32 + j] && first_x[i] != -1)
					{
						int offset = first_x[i] - i;
						if (offset == 1) // previou is non-zero coeff. 
						{
							sumRate[i] += 1;
						}
						else
						{
							// should change here.
							sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
						}
					}

					if (coef[i * 32 + j])
					{
						first_x[i] = i;
						first_y[i] = j;
					}
				}
			}
		}

		// calculate the rate of the last coeff.
		int cur_zig_zag_num;
		if (last_x[0] == -1) // all zeros for current scan-line.
		{
			cur_zig_zag_num = j + 1;
			final_zig_zag += cur_zig_zag_num;
		}
		else
		{
			if (j % 2 == 1) // bottom -left scan
			{
				cur_zig_zag_num = first_x[0];
			}
			else
			{
				cur_zig_zag_num = j - first_x[0];
			}

			final_zig_zag += cur_zig_zag_num;

			// rate _cal:
			// get(final_zig_zag); 
			if (final_zig_zag == 0) // only one non-zero coeff.
			{
				final_rate += 1;
			}
			else
			{
				final_rate += enc_eco_run_est_2_only(final_zig_zag);
			}

			if (j % 2 == 1) // bottom -left scan
			{
				final_zig_zag = j - last_x[0]; // update
			}
			else
			{
				final_zig_zag = j - last_y[0]; // update
			}
			final_rate += sumRate[0];
		}


		// shift register.
		for (int i = 1; i < 32; i++)
		{
			last_x[i - 1] = last_x[i];
			last_y[i - 1] = last_y[i];

			first_x[i - 1] = first_x[i];
			first_y[i - 1] = first_y[i];

			sumRate[i - 1] = sumRate[i];
		}
	}
	return final_rate;
}

static int  enc_eco_coef_32_32_level(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	static s16 coef_out[32];


	for (U7 z = 0; z < 32; z++) {
		coef_out[z] = 0;
	}
	for (int j = 0; j < 32; j++)
	{
		for (int i = 0; i < 32; i++)
		{
			if (i < 32 - j) {
				coef_out[i] = coef[i * 32 + j];
			}
		}
		enc_est += rate_coef_level_est_32(coef_out, 32 - j);
	}

	return enc_est;


}



static int  enc_eco_coef_32_32(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	enc_est += enc_eco_coef_32_32_run(cu_width, cu_height, coef, log2_w, log2_h);
	enc_est += enc_eco_coef_32_32_level(cu_width, cu_height, coef, log2_w, log2_h);
	return enc_est;


}

static int enc_eco_coef_32_run(U8 cu_width, U8 cu_height, s16 coef[32][32], U3 log2_w, U3 log2_h) 
{
#pragma HLS INLINE off
//#pragma HLS ARRAY_PARTITION variable=coef dim=1 complete

	int final_rate = 0;
	int last_x [32];  // the last non-zero position of scan-line.
	int last_y [32];
	int first_x[32]; // the first non-zero position of scan-line.
	int first_y[32];
	int sumRate[32];
#pragma HLS ARRAY_PARTITION variable=last_x     dim=1 complete
#pragma HLS ARRAY_PARTITION variable=last_y     dim=1 complete
#pragma HLS ARRAY_PARTITION variable=first_x    dim=1 complete
#pragma HLS ARRAY_PARTITION variable=first_y    dim=1 complete
#pragma HLS ARRAY_PARTITION variable=sumRate    dim=1 complete

	int final_last_x = -1, final_last_y = -1;
	int final_zig_zag = 0;

#ifndef __SYNTHESIS__
	memset(last_x,  -1, sizeof(int) * 32);
	memset(last_y,  -1, sizeof(int) * 32);
	memset(first_x, -1, sizeof(int) * 32);
	memset(first_y, -1, sizeof(int) * 32);
	memset(sumRate,  0, sizeof(int) * 32);
#else
    for (int i=0; i<32; i++) {
#pragma HLS UNROLL
        last_x [i] = -1;
        last_y [i] = -1;
        first_x[i] = -1;
        first_y[i] = -1;
        sumRate[i] =  0;
    }
#endif 
	int shift_t = (cu_width <= cu_height ? cu_width : cu_height);
	for (int j = 0; j < cu_width; j++) { // vertical
//#pragma HLS LOOP_TRIPCOUNT max=32
#pragma HLS PIPELINE II=1
		{
			// int zzz = 0;
			// for (int i = 0; i < cu_height; i++) { // horizontal
			for (int i = 0; i < 32; i++) { // horizontal
#pragma HLS UNROLL
				if (i < cu_height) {
					s16 coef_temp = coef[i][j];

					if (j == 0) { // first input row data.
						if (coef_temp) {
							last_x [i] = i;
							last_y [i] = j;
							first_x[i] = i;
							first_y[i] = j;
						}
					} 
					else if (i == shift_t - 1) {
						last_x [i] = -1;
						last_y [i] = -1;
						first_x[i] = -1;
						first_y[i] = -1;

						if (coef_temp) {
							last_x [i] = i;
							last_y [i] = j;
							first_x[i] = i;
							first_y[i] = j;
						}
					} 
					else {
						if ((i + j) % 2 == 0) { // above-right-scan
							if (first_x[i] == -1 && coef_temp) {
								first_x[i] = i;
								first_y[i] = j;
							}

							if (coef_temp) {
								if (last_x[i] != -1) {
									int offset = last_x[i] - i;
									if (offset == 1) { // previou is non-zero coeff. 
										sumRate[i] += 1;
									} else {
										sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
									}
								}
								last_x[i] = i;
								last_y[i] = j;
							}
						} else { // above - top scan for (i+j)%2 is even case
							if (coef_temp && last_x[i] == -1) { // first non-zero position
								last_x[i] = i;
								last_y[i] = j;
							}

							if (coef_temp && first_x[i] != -1) {
								int offset = first_x[i] - i;
								if (offset == 1) { // previou is non-zero coeff. 
									sumRate[i] += 1;
								} else {
									// should change here.
									sumRate[i] += enc_eco_run_est_2_only(offset - 1); // rate_coef_run_est_32(offset, cu_width);
								}
							}

							if (coef_temp) {
								first_x[i] = i;
								first_y[i] = j;
							}
						}
					}
				}
			}

			// calculate the rate of the last coeff.
			int cur_zig_zag_num;
			if (last_x[0] == -1) { // all zeros for current scan-line.
				if (j < shift_t) {
					cur_zig_zag_num = j + 1;
				} else {
					cur_zig_zag_num = shift_t;
				}
				final_zig_zag += cur_zig_zag_num;
			} else {
				if (j % 2 == 1) { // bottom -left scan
					cur_zig_zag_num = first_x[0];
				} else {
					if (j < shift_t) {
						cur_zig_zag_num = j - first_x[0];
					} else {
						cur_zig_zag_num = shift_t - 1 - first_x[0];
					}
				}

				final_zig_zag += cur_zig_zag_num;

				// rate _cal:
				// get(final_zig_zag); 
				if (final_zig_zag == 0) { // only one non-zero coeff.
					final_rate += 1;
				} else {
					final_rate += enc_eco_run_est_2_only(final_zig_zag);
				}

				if (j % 2 == 1) { // bottom -left scan
					if (j < shift_t) {
						final_zig_zag = j - last_x[0]; // update
					} else {
						final_zig_zag = shift_t - 1 - last_x[0];
					}
				} else {
					final_zig_zag = j - last_y[0]; // update
				}
				final_rate += sumRate[0];
			}

			// shift register.
			for (int i = 1; i < 32; i++) {
#pragma HLS UNROLL
				if (i < shift_t) {
					last_x [i - 1] = last_x [i];
					last_y [i - 1] = last_y [i];
					first_x[i - 1] = first_x[i];
					first_y[i - 1] = first_y[i];
					sumRate[i - 1] = sumRate[i];
				}
			}
		}
	}
	return final_rate;
}

static int  enc_eco_coef_32_level(U8 cu_width, U8 cu_height, s16 coef[32][32], U3 log2_w, U3 log2_h)
{
#pragma HLS INLINE off

	U15 enc_est = 0;
#ifndef __SYNTHESIS__
	static s16 coef_out[32];
#else
	s16 coef_out[32];
#endif
#pragma HLS ARRAY_PARTITION variable=coef_out dim=1 complete

	int max_num = 0;

	for (U7 z = 0; z < 32; z++) {
#pragma HLS UNROLL
		coef_out[z] = 0;
	}
	for (int j = 0; j < cu_width; j++) {
//#pragma HLS LOOP_TRIPCOUNT max=32
#pragma HLS PIPELINE II=1
		if (cu_width <= cu_height) {
			max_num = cu_width - j;
		} else {
			max_num = (j < cu_height ? (int)cu_height : (int)cu_width - j);
		}
		//for (int i = 0; i < cu_height; i++) {
		for (int i = 0; i < 32; i++) {
#pragma HLS UNROLL
			if (i < cu_height) {
				if (i < max_num) {
					coef_out[i] = coef[i][j];
				}
			}
		}
		enc_est += rate_coef_level_est_32(coef_out, max_num);
	}

	return enc_est;
}



static int  enc_eco_coef_32(U8 cu_width, U8 cu_height, s16 coef[32][32], U3 log2_w, U3 log2_h)
{
#pragma HLS INLINE

	U15 enc_est, enc_est_run, enc_est_level;
	enc_est_run   = enc_eco_coef_32_run  (cu_width, cu_height, coef, log2_w, log2_h);
	enc_est_level = enc_eco_coef_32_level(cu_width, cu_height, coef, log2_w, log2_h);
	enc_est = enc_est_run + enc_est_level;
	return enc_est;
}

static int  enc_eco_coef_32_wh_new(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	enc_est += enc_eco_coef_32_wh_run(cu_width, cu_height, coef, log2_w, log2_h);
	enc_est += enc_eco_coef_32_wh_level(cu_width, cu_height, coef, log2_w, log2_h);
	return enc_est;


}

static int  enc_eco_coef_32_wh_1(U8 cu_width, U8 cu_height, s16 coef[SIZE_32], U3 log2_w, U3 log2_h)
{
	int i;
	u8 scan_tab_index = 0;
	static u16 scan[9][64] = { {0,1,32,64,33,2,3,34,65,96,128,97,66,35,4,5,36,67,98,129,160,192,161,130,99,68,37,6,7,38,69,100,131,162,193,224,256,225,194,163,132,101,70,39,8,9,40,71,102,133,164,195,226,257,288,320,289,258,227,196,165,134,103,72},
	{41,10,11,42,73,104,135,166,197,228,259,290,321,352,384,353,322,291,260,229,198,167,136,105,74,43,12,13,44,75,106,137,168,199,230,261,292,323,354,385,416,448,417,386,355,324,293,262,231,200,169,138,107,76,45,14,15,46,77,108,139,170,201,232},
	{263,294,325,356,387,418,449,480,512,481,450,419,388,357,326,295,264,233,202,171,140,109,78,47,16,17,48,79,110,141,172,203,234,265,296,327,358,389,420,451,482,513,544,576,545,514,483,452,421,390,359,328,297,266,235,204,173,142,111,80,49,18,19,50},
	{81,112,143,174,205,236,267,298,329,360,391,422,453,484,515,546,577,608,640,609,578,547,516,485,454,423,392,361,330,299,268,237,206,175,144,113,82,51,20,21,52,83,114,145,176,207,238,269,300,331,362,393,424,455,486,517,548,579,610,641,672,704,673,642},
	{611,580,549,518,487,456,425,394,363,332,301,270,239,208,177,146,115,84,53,22,23,54,85,116,147,178,209,240,271,302,333,364,395,426,457,488,519,550,581,612,643,674,705,736,768,737,706,675,644,613,582,551,520,489,458,427,396,365,334,303,272,241,210,179},
	{148,117,86,55,24,25,56,87,118,149,180,211,242,273,304,335,366,397,428,459,490,521,552,583,614,645,676,707,738,769,800,832,801,770,739,708,677,646,615,584,553,522,491,460,429,398,367,336,305,274,243,212,181,150,119,88,57,26,27,58,89,120,151,182},
	{213,244,275,306,337,368,399,430,461,492,523,554,585,616,647,678,709,740,771,802,833,864,896,865,834,803,772,741,710,679,648,617,586,555,524,493,462,431,400,369,338,307,276,245,214,183,152,121,90,59,28,29,60,91,122,153,184,215,246,277,308,339,370,401},
	{432,463,494,525,556,587,618,649,680,711,742,773,804,835,866,897,928,960,929,898,867,836,805,774,743,712,681,650,619,588,557,526,495,464,433,402,371,340,309,278,247,216,185,154,123,92,61,30,31,62,93,124,155,186,217,248,279,310,341,372,403,434,465,496},
	{527, 558, 589, 620, 651, 682, 713, 744, 775, 806, 837, 868, 899, 930, 961, 992} };
	U15 enc_est1 = 0;
	U15 enc_est2 = 0;
	U15 enc_est3 = 0;
	U15 enc_est4 = 0;
	U15 enc_est5 = 0;
	U15 enc_est6 = 0;
	U15 enc_est7 = 0;
	U15 enc_est8 = 0;
	//U8 run = 0;
	U10 run1 = 0;
	U10 run2 = 0;
	U10 run3 = 0;
	U10 run4 = 0;
	U10 run5 = 0;
	U10 run6 = 0;
	U10 run7 = 0;
	U10 run8 = 0;
	U8 runflag1 = 0;
	U8 runflag2 = 0;
	U8 runflag3 = 0;
	U8 runflag4 = 0;
	U8 runflag5 = 0;
	U8 runflag6 = 0;
	U8 runflag7 = 0;
	U15 enc_est = 0;
	s16 coef_out[32];
	//s16 coef[H][W];
	U10 run[32];

	//	FUNC_NAME(ready_coef, W, H)(coef_in, coef);
	if (cu_width == 32 && cu_height == 32) {
		for (int j = 0; j < 9; j++)
		{
			U15 enc_est1 = 0;
			U15 enc_est2 = 0;
			U15 enc_est3 = 0;
			U15 enc_est4 = 0;
			U15 enc_est5 = 0;
			U15 enc_est6 = 0;
			U15 enc_est7 = 0;
			U15 enc_est8 = 0;
			U10 run = 0;
			U10 run1 = 0;
			U10 run2 = 0;
			U10 run3 = 0;
			U10 run4 = 0;
			U10 run5 = 0;
			U10 run6 = 0;
			U10 run7 = 0;
			U10 run8 = 0;
			U10 runflag1 = 0;
			U10 runflag2 = 0;
			U10 runflag3 = 0;
			U10 runflag4 = 0;
			U10 runflag5 = 0;
			U10 runflag6 = 0;
			U10 runflag7 = 0;
			if (j == 0) {
				scan_tab_index = 0;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 1) {
				scan_tab_index = 1;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 2) {
				scan_tab_index = 2;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 3) {
				scan_tab_index = 3;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 4) {
				scan_tab_index = 4;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 5) {
				scan_tab_index = 5;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 6) {
				scan_tab_index = 6;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 7) {
				scan_tab_index = 7;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run3 = 0;
					}
					else {
						run3++;
					}
					if (i == 23) {
						runflag3 = run3;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run4 = 0;
					}
					else {
						run4++;
					}
					if (i == 31) {
						runflag4 = run4;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run5 = 0;
					}
					else {
						run5++;
					}
					if (i == 39) {
						runflag5 = run5;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run6 = 0;
					}
					else {
						run6++;
					}
					if (i == 47) {
						runflag6 = run6;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run7 = 0;
					}
					else {
						run7++;
					}
					if (i == 55) {
						runflag7 = run7;
					}

				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				for (i = 16; i < 24; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 16) {
						if (runflag2 == 8) {
							run = runflag1 + runflag2;
						}
						else {
							run = runflag2;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est3 += enc_eco_run_est_3(run);
						enc_est3 += enc_eco_level_est_3(level);
						enc_est3++;
						run = 0;
						enc_est3++;
					}
					else {
						run++;
					}
				}
				for (i = 24; i < 32; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 24) {
						if (runflag3 == 8) {
							if (runflag2 == 8) {
								run = runflag1 + runflag2 + runflag3;
							}
							else {
								run = runflag2 + runflag3;
							}
						}
						else {
							run = runflag3;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est4 += enc_eco_run_est_3(run);
						enc_est4 += enc_eco_level_est_3(level);
						enc_est4++;
						run = 0;
						enc_est4++;
					}
					else {
						run++;
					}
				}
				for (i = 32; i < 40; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag4 == 8) {
							if (runflag3 == 8) {
								if (runflag2 == 8) {
									run = runflag1 + runflag2 + runflag3 + runflag4;
								}
								else {
									run = runflag2 + runflag3 + runflag4;
								}
							}
							else {
								run = runflag3 + runflag4;
							}
						}
						else {
							run = runflag4;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est5 += enc_eco_run_est_3(run);
						enc_est5 += enc_eco_level_est_3(level);
						enc_est5++;
						run = 0;
						enc_est5++;
					}
					else {
						run++;
					}
				}
				for (i = 40; i < 48; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 40) {
						if (runflag5 == 8) {
							if (runflag4 == 8) {
								if (runflag3 == 8) {
									if (runflag2 == 8) {
										run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5;
									}
									else {
										run = runflag2 + runflag3 + runflag4 + runflag5;
									}
								}
								else {
									run = runflag3 + runflag4 + runflag5;
								}

							}
							else {
								run = runflag4 + runflag5;
							}
						}
						else {
							run = runflag5;
						}
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est6 += enc_eco_run_est_3(run);
						enc_est6 += enc_eco_level_est_3(level);
						enc_est6++;
						run = 0;
						enc_est6++;
					}
					else {
						run++;
					}
				}
				for (i = 48; i < 56; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 48) {
						if (runflag6 == 8) {
							if (runflag5 == 8) {
								if (runflag4 == 8) {
									if (runflag3 == 8) {
										if (runflag2 == 8) {
											run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
										else {
											run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6;
										}
									}
									else {
										run = runflag3 + runflag4 + runflag5 + runflag6;
									}
								}
								else {
									run = runflag4 + runflag5 + runflag6;
								}
							}
							else {
								run = runflag5 + runflag6;
							}
						}
						else {
							run = runflag6;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est7 += enc_eco_run_est_3(run);
						enc_est7 += enc_eco_level_est_3(level);
						enc_est7++;
						run = 0;
						enc_est7++;
					}
					else {
						run++;
					}
				}
				for (i = 56; i < 64; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					//coef_cur = coef[scan[scan_tab_index][scan_pos]];
					if (i == 56) {
						if (runflag7 == 8) {
							if (runflag6 == 8) {
								if (runflag5 == 8) {
									if (runflag4 == 8) {
										if (runflag3 == 8) {
											if (runflag2 == 8) {
												run = runflag1 + runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
											else {
												run = runflag2 + runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
											}
										}
										else {
											run = runflag3 + runflag4 + runflag5 + runflag6 + runflag7;
										}
									}
									else {
										run = runflag4 + runflag5 + runflag6 + runflag7;
									}
								}
								else {
									run = runflag5 + runflag6 + runflag7;
								}
							}
							else {
								run = runflag6 + runflag7;
							}
						}
						else {
							run = runflag7;
						}

					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est8 += enc_eco_run_est_3(run);
						enc_est8 += enc_eco_level_est_3(level);
						enc_est8++;
						if (i == 64 - 1) {
							break;
						}
						run = 0;
						enc_est8++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2 + enc_est3 + enc_est4 + enc_est5 + enc_est6 + enc_est7 + enc_est8;

			}
			else if (j == 8) {
				scan_tab_index = 8;
				for (i = 0; i < 8; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est1 += enc_eco_run_est_3(run1);
						enc_est1 += enc_eco_level_est_3(level);
						enc_est1++;
						run1 = 0;
						enc_est1++;
					}
					else {
						run1++;
					}
					if (i == 7) {
						runflag1 = run1;
					}
				}
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (coef_cur) {
						run2 = 0;
					}
					else {
						run2++;
					}
					if (i == 15) {
						runflag2 = run2;
					}
				}
				//////////////////////////////////
				for (i = 8; i < 16; i++) {
					s16 coef_cur;
					u16 level;
					coef_cur = coef[scan[scan_tab_index][i]];
					if (i == 8) {
						run = runflag1;
					}
					if (coef_cur) {
						level = abs(coef_cur);
						//	level = ((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15));
						enc_est2 += enc_eco_run_est_3(run);
						enc_est2 += enc_eco_level_est_3(level);
						enc_est2++;
						run = 0;
						enc_est2++;
					}
					else {
						run++;
					}
				}
				enc_est += enc_est1 + enc_est2;

			}

		}
	/*	FILE* file;
		file = fopen("32enc_est_new.txt", "a+");
		fprintf(file, "32enc_est1=%d\n", enc_est);
		fclose(file);*/
		//printf("32enc_est1=%d\n", enc_est);
		return enc_est;
	}
	else {
		for (U7 z = 0; z < 32; z++) {
			run[z] = 0;
			coef_out[z] = 0;
		}
		//	run_end[0] = 0;
		U10 run_num = 0;
		S7 j;
		for (U7 i = 0; i < cu_width; i++)
		{
			if (i == 0)
			{
				coef_out[0] = coef[i];
				if (coef[i]) {
					run_num = 0;
				}
				else
					run_num = 1;
			}
			else
			{
				if (i & 0x1)
				{
					for (j = 0; j < 32; j++)
					{
						if (j <= i)
						{
							coef_out[j] = coef[(j << log2_w) + i - j];
							if (coef[(j << log2_w) + i - j]) {
								run[j] = run_num;
								run_num = 0;
							}
							else
							{
								run[j] = 0;
								run_num++;
							}
						}
					}
				}
				else
				{
					for (j = 32; j >= 0; j--)
					{
						if (j <= i)
						{
							coef_out[i - j] = coef[(j << log2_w) + i - j];
							if (coef[(j << log2_w) + i - j]) {
								run[i - j] = run_num;
								run_num = 0;
							}
							else
							{
								run[i - j] = 0;
								run_num++;
							}
						}
					}
				}
			}

			enc_est += rate_coef_est_32(coef_out, run, cu_width);
		}
	}
	return enc_est;


}

static int  enc_eco_coef_32_wh_coef_0(U8 cu_width, U8 cu_height)
{
	U15 enc_est = 0;
	for (U7 i = 0; i < cu_width; i++)
	{
		enc_est += rate_coef_est_32_coef_0(cu_width);
	}

	return enc_est;
}

static int  enc_eco_coef_32_hw_run(U8 cu_width, U8 cu_height, s16 coef[32 * 32], U3 log2_w, U3 log2_h) {

	U15 enc_est = 0;

	U10 run[32];

	//coef_ready_16x16(coef_in, coef);
	//FUNC_NAME(ready_coef, W, H)(coef_in, coef);
	for (U7 z = 0; z < 32; z++) {
		run[z] = 0;
	}
	U10 run_num = 0;
	S7 j;
	U7 max_cnt = 0;
	for (U7 i = 0; i < cu_width; i++)
	{

		if (i < cu_height)
			max_cnt = i;

		if (i & 1)
		{
			for (j = 0; j <= 32; j++)
			{
				if (j <= max_cnt)
				{
					if (coef[(j << log2_w) + i - j]) {
						if (!run_num) {
							run[j] = 65;
						}
						else {
							run[j] = run_num;
						}
						run_num = 0;
					}
					else
					{
						run[j] = 0;
						run_num++;
					}
				}
			}
		}
		else
		{
			for (j = 32; j >= 0; j--)
			{
				if (j <= max_cnt)
				{
					if (coef[(j << log2_w) + i - j]) {
						if (!run_num) {
							run[max_cnt - j] = 65;
						}
						else {
							run[max_cnt - j] = run_num;
						}
						run_num = 0;
					}
					else
					{
						run[max_cnt - j] = 0;
						run_num++;
					}
				}
			}
		}


		enc_est += rate_coef_run_est_32(run, cu_height);
	}




	return enc_est;
}

static int  enc_eco_coef_32_hw_level(U8 cu_width, U8 cu_height, s16 coef[32 * 32], U3 log2_w, U3 log2_h) {
	U15 enc_est = 0;
	s16 coef_out[32];


	//coef_ready_16x16(coef_in, coef);
	//FUNC_NAME(ready_coef, W, H)(coef_in, coef);
	for (U7 z = 0; z < 32; z++) {
		coef_out[z] = 0;
	}
	U10 run_num = 0;
	S7 j;
	U7 max_cnt = 0;
	for (U7 i = 0; i < cu_width; i++)
	{

		if (i < cu_height)
			max_cnt = i;

		if (i & 1)
		{
			for (j = 0; j <= 32; j++)
			{
				if (j <= max_cnt)
				{
					coef_out[j] = coef[(j << log2_w) + i - j];
				}
			}
		}
		else
		{
			for (j = 32; j >= 0; j--)
			{
				if (j <= max_cnt)
				{
					coef_out[max_cnt - j] = coef[(j << log2_w) + i - j];
				}
			}
		}


		enc_est += rate_coef_level_est_32(coef_out, cu_height);
	}




	return enc_est;
}


static int  enc_eco_coef_32_hw_new(U8 cu_width, U8 cu_height, s16 coef[32 * 32], U3 log2_w, U3 log2_h) {
	/*U7 cu_width = 1 << log2_w;
	U7 cu_height = 1 << log2_h;*/
	U15 enc_est = 0;
	enc_est += enc_eco_coef_32_hw_run(cu_width, cu_height, coef, log2_w, log2_h);
	enc_est += enc_eco_coef_32_hw_level(cu_width, cu_height, coef, log2_w, log2_h);
	return enc_est;
}
static int  enc_eco_coef_32_hw(U8 cu_width, U8 cu_height, s16 coef[32 * 32], U3 log2_w, U3 log2_h) {
	/*U7 cu_width = 1 << log2_w;
	U7 cu_height = 1 << log2_h;*/
	U15 enc_est = 0;
	static s16 coef_out[32];
	//s16 coef[H][W];
	static U10 run[32];

	//coef_ready_16x16(coef_in, coef);
	//FUNC_NAME(ready_coef, W, H)(coef_in, coef);
	for (U7 z = 0; z < 32; z++) {
		run[z] = 0;
		coef_out[z] = 0;
	}
	U10 run_num = 0;
	S7 j;
	U7 max_cnt = 0;
	for (U7 i = 0; i < cu_width; i++)
	{

		if (i < cu_height)
			max_cnt = i;

		if (i & 1)
		{
			for (j = 0; j <= 32; j++)
			{
				if (j <= max_cnt)
				{
					coef_out[j] = coef[(j << log2_w) + i - j];
					if (coef[(j << log2_w) + i - j]) {
						run[j] = run_num;
						run_num = 0;
					}
					else
					{
						run[j] = 0;
						run_num++;
					}
				}
			}
		}
		else
		{
			for (j = 32; j >= 0; j--)
			{
				if (j <= max_cnt)
				{
					coef_out[max_cnt - j] = coef[(j << log2_w) + i - j];
					if (coef[(j << log2_w) + i - j]) {
						run[max_cnt - j] = run_num;
						run_num = 0;
					}
					else
					{
						run[max_cnt - j] = 0;
						run_num++;
					}
				}
			}
		}


		enc_est += rate_coef_est_32(coef_out, run, cu_height);
	}




	return enc_est;
}

static int  enc_eco_coef_32_hw_coef_0(U8 cu_width, U8 cu_height) {
	/*U7 cu_width = 1 << log2_w;
	U7 cu_height = 1 << log2_h;*/
	U15 enc_est = 0;
	for (U7 i = 0; i < cu_width; i++)
	{
		enc_est += rate_coef_est_32_coef_0(cu_height);
	}

	return enc_est;
}

static int enc_eco_cbf_est_skip_32(U1 tb_avaliable, u8 pred_mode, S8 ipm[4][2], U2 tree_status, U3 cu_width_log2, U3 cu_height_log2)
{
	U4 enc_est = 0;
	if ((pred_mode) != 0) {
		if (!((pred_mode) == 3)) {
			if (tree_status == TREE_LC) {
				if (cu_width_log2 > 6 || cu_height_log2 > 6) {
					enc_est++;
				}
				else {
					enc_est++;
				}

				return 0;

			}
		}
		if (tb_avaliable) {
			enc_est++;
		}

		if (tree_status == TREE_LC) {
			enc_est += 2;
			
		}
		else {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);

			enc_est += 1;
			
		}
	}
	else {
		if (!((ipm[0][0]) == 33)) {
			//int part_num = get_part_num((PART_SIZE)tb_part_size);
			enc_est += 1;
			

		}
		if (tree_status == TREE_LC) {
			if (!((ipm[0][0]) == 33 && (ipm[0][1]) == 0)) {
				enc_est += 2;
				
			}
		}
	}
	return enc_est;
}


static int enc_bit_est_flag_skip_32(U2 slice_type, U2 tree_status, u8 umve_flag, u8 umve_idx, u8 affine_flag, u8 skip_idx, U3 cu_width_log2, U3 cu_height_log2, S8   ipm[MAX_NUM_PB][2], u8 num_of_hmvp_cand)
{
#pragma HLS INLINE off
	int enc_est = 0;
	int umve_enable_flag = 1;
	enc_est++;
	if (umve_enable_flag) {
		enc_est++;
	}
	if (umve_flag) {
		enc_est += encode_umve_idx_est(umve_idx);
	}
	else {
		if (cu_width_log2 >= 4 && cu_height_log2 >= 4) {
			enc_est++;
		}
		if (affine_flag) {
			enc_est += sbac_write_truncate_unary_sym_est((skip_idx), 5);
		} else {
			enc_est += encode_skip_idx_cu_est(skip_idx, num_of_hmvp_cand, slice_type);
		}
	}

	if (tree_status != TREE_C) {
		enc_est += enc_eco_cbf_est_skip_32(0, 2, ipm, tree_status, cu_width_log2, cu_height_log2);
	}
	else if (!((2) == 0 && (ipm[0][0]) == 33 && (ipm[0][1]) == 0)) {
		enc_est += 2;
	}
	return enc_est;
}

static int enc_eco_run_length_cc_est_2(s16* coef, int log2_w, int log2_h, int num_sig);

void rate_est_32_flag_2(U1 is_intra_read, u8 mode_type_read, u8 curr_mvr_read, s64 lambda_y, u8 tree_status, u8 cons_pred_mode, MD_KERNEL_MODE_32* mod_info_curr_ptr, MD_KERNEL_INPUT_32* md_kernel_input_32, s64* flag_cost)
{
#pragma HLS INLINE off

	if (is_intra_read == 0) {
		if (mode_type_read == 1 || mode_type_read == 0) {
			
			int num_nz_fz[MAX_NUM_TB][N_C];
			cu_nz_cln(num_nz_fz);

			mod_info_curr_ptr->tb_part = (int)SIZE_2Nx2N;
			
			if (mode_type_read == 0) { 
				mod_info_curr_ptr->cu_mode = 3;
			} else {
				int bit_cnt = enc_bit_est_flag_32(2, curr_mvr_read, tree_status, cons_pred_mode, 
					mod_info_curr_ptr->cu_mode, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx,
					mod_info_curr_ptr->affine_flag, 1, mod_info_curr_ptr->skip_idx, mod_info_curr_ptr->refi,
					0, mod_info_curr_ptr->smvd_flag, mod_info_curr_ptr->affine_mvd,
					mod_info_curr_ptr->mvd, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2,
					num_nz_fz, mod_info_curr_ptr->ipm, 1, 0, 8, mod_info_curr_ptr->mpm, is_intra_read);

				/*flag_cost[2]*/*flag_cost = (bit_cnt * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
			}
		}
	}
}

void rate_est_32_flag_0(U1 is_intra_read, u8 mode_type_read, u8 curr_mvr_read, U8 cu_width, U8 cu_height, s64 lambda_y, U2 slice_type, u8 tree_status, u8 cons_pred_mode, s16 coef_y_pb_part[32][32], int num_nz_rate[MAX_NUM_TB][N_C], MD_KERNEL_MODE_32* mod_info_curr_ptr, MD_KERNEL_INPUT_32* md_kernel_input_32, s64* flag_cost)
{
#pragma HLS INLINE off

	if ((is_intra_read == 0) && (mode_type_read == 0)) {
        mod_info_curr_ptr->cu_mode = 3;
    }

	U16 flag_est = enc_bit_est_flag_32(slice_type, curr_mvr_read, tree_status, cons_pred_mode, mod_info_curr_ptr->cu_mode, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx, mod_info_curr_ptr->affine_flag, 
	    1, mod_info_curr_ptr->skip_idx, mod_info_curr_ptr->refi, 0, mod_info_curr_ptr->smvd_flag, mod_info_curr_ptr->affine_mvd, mod_info_curr_ptr->mvd, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, 
	    num_nz_rate, mod_info_curr_ptr->ipm, 1, 0, 8, mod_info_curr_ptr->mpm, is_intra_read);

	U16 coef_est;
#if RATE_EST_SWITCH
	/*if (cu_width == 32 && cu_height == 32) {
		coef_est = enc_eco_coef_32_32(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2);
	} else if (cu_width <= cu_height) {
		coef_est = enc_eco_coef_32_wh_new(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2);
	} else {
		coef_est = enc_eco_coef_32_hw_new(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2); }*/
	coef_est = enc_eco_coef_32(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2);
#else
	static s16 coef_tmp[1024];
	for (int i = 0; i < cu_height; i++)
	{
		for (int j = 0; j < cu_width; j++)
		{
			coef_tmp[i * cu_width + j] = coef_y_pb_part[i][j];
		}
	}
	coef_est = enc_eco_run_length_cc_est_2(coef_tmp, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, num_nz_rate[0][0]);
#endif
	U16 bit_cnt = flag_est + coef_est;
	/*flag_cost[0]*/*flag_cost = (bit_cnt * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
}

void rate_est_32_flag_1(U1 is_intra_read, u8 mode_type_read, s64 lambda_y,U2 slice_type, u8 tree_status, MD_KERNEL_MODE_32* mod_info_curr_ptr, MD_KERNEL_INPUT_32* md_kernel_input_32, s64* flag_cost)
{
#pragma HLS INLINE off

	if (is_intra_read == 0) {
		if (mode_type_read == 0) {
			U16 flag_est = enc_bit_est_flag_skip_32(slice_type, tree_status, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx, mod_info_curr_ptr->affine_flag, mod_info_curr_ptr->skip_idx, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, mod_info_curr_ptr->ipm, 8);
			/*flag_cost[1]*/*flag_cost = (flag_est * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		}
	}
}


// MD_KERNEL_32 RATE_EST TOP
void rate_est_32(U8 cu_width, U8 cu_height, MD_KERNEL_MODE_32* mod_info_curr_ptr, u8 mode_type, u8* mode_type_update,
	u8 curr_mvr, u8* curr_mvr_update, u8 tree_status, u8 cons_pred_mode, s16 coef_y_pb_part[32][32], s64 lambda_y,
	int is_intra_rate, U1* is_intra_update, s64 flag_cost[3], U2 slice_type, int num_nz_rate[MAX_NUM_TB][N_C], MD_KERNEL_INPUT_32* md_kernel_input_32)
{
#pragma HLS INLINE off


	// STREAM BUFFER
	u8 mode_type_read = mode_type;
	u8 curr_mvr_read  = curr_mvr;
	U1 is_intra_read  = is_intra_rate;
#if 0
	if (is_intra_read == 0) {
		if (mode_type_read == 1 || mode_type_read == 0)
		{
			int num_nz_fz[MAX_NUM_TB][N_C];
			cu_nz_cln(num_nz_fz);
			mod_info_curr_ptr->tb_part = ((int)SIZE_2Nx2N);
			if (mode_type == 0) { 
				mod_info_curr_ptr->cu_mode = 3;
			} else {
				flag_cost[2] = 0;
				int bit_cnt = enc_bit_est_flag_32(2, curr_mvr, tree_status, cons_pred_mode, 
					mod_info_curr_ptr->cu_mode, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx,
					mod_info_curr_ptr->affine_flag, 1, mod_info_curr_ptr->skip_idx, mod_info_curr_ptr->refi,
					0, mod_info_curr_ptr->smvd_flag, mod_info_curr_ptr->affine_mvd,
					mod_info_curr_ptr->mvd, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2,
					num_nz_fz, mod_info_curr_ptr->ipm, 1, 0, 8, mod_info_curr_ptr->mpm, is_intra_read);

				flag_cost[2] += (bit_cnt * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
			}
		}
	}

	flag_cost[0] = 0;
	U16 flag_est = enc_bit_est_flag_32(slice_type, curr_mvr_read, tree_status, cons_pred_mode, mod_info_curr_ptr->cu_mode, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx, mod_info_curr_ptr->affine_flag, 1, mod_info_curr_ptr->skip_idx, mod_info_curr_ptr->refi, 0, mod_info_curr_ptr->smvd_flag, mod_info_curr_ptr->affine_mvd, mod_info_curr_ptr->mvd, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, num_nz_rate, mod_info_curr_ptr->ipm, 1, 0, 8, mod_info_curr_ptr->mpm, is_intra_read);
	//U16 flag_est;
	U16 coef_est;
#if RATE_EST_SWITCH
	/*if (cu_width == 32 && cu_height == 32) {
		coef_est = enc_eco_coef_32_32(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2);

	}
	else if (cu_width <= cu_height)
		coef_est = enc_eco_coef_32_wh_new(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2);
	else
		coef_est = enc_eco_coef_32_hw_new(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2);*/
	coef_est = enc_eco_coef_32(cu_width, cu_height, coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2);
#else
	coef_est = enc_eco_run_length_cc_est_2(coef_y_pb_part, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, num_nz_rate[0][0]);
#endif
	U16 bit_cnt = flag_est + coef_est;
	flag_cost[0] += (bit_cnt * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;

	if (is_intra_read == 0) {
		if (mode_type_read == 0) {
			flag_cost[1] = 0;
			flag_est = enc_bit_est_flag_skip_32(slice_type, tree_status, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx, mod_info_curr_ptr->affine_flag, mod_info_curr_ptr->skip_idx, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, mod_info_curr_ptr->ipm, 8);
			flag_cost[1] += (flag_est * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		}
	}
#else
	rate_est_32_flag_2(is_intra_read, mode_type_read, curr_mvr_read, lambda_y, tree_status, cons_pred_mode, mod_info_curr_ptr, md_kernel_input_32, &flag_cost[2]);

	rate_est_32_flag_0(is_intra_read, mode_type_read, curr_mvr_read, cu_width, cu_height, lambda_y, slice_type, tree_status, cons_pred_mode, coef_y_pb_part, num_nz_rate, mod_info_curr_ptr, md_kernel_input_32, &flag_cost[0]);

	rate_est_32_flag_1(is_intra_read, mode_type_read, lambda_y, slice_type, tree_status, mod_info_curr_ptr, md_kernel_input_32, &flag_cost[1]);
#endif

	// WRITE STREAMS
	*curr_mvr_update  = curr_mvr_read;
	*mode_type_update = mode_type_read;
	*is_intra_update  = is_intra_read;
}

// copy of rate_est_32 except coef rate is 0.
void rate_est_azb_32(U8 cu_width, U8 cu_height, MD_KERNEL_MODE_32* mod_info_curr_ptr, u8 mode_type, u8* mode_type_update,
	u8 curr_mvr, u8* curr_mvr_update, u8 tree_status, u8 cons_pred_mode, s16 coef_y_pb_part[1024], s64 lambda_y,
	int is_intra_rate, U1* is_intra_update, s64 flag_cost[3], U2 slice_type, int num_nz_rate[MAX_NUM_TB][N_C], MD_KERNEL_INPUT_32* md_kernel_input_32)
{

	// STREAM BUFFER
	u8 mode_type_read = mode_type;
	u8 curr_mvr_read = curr_mvr;
	U1 is_intra_read = is_intra_rate;

	if (is_intra_read == 0) {
		if (mode_type_read == 1 || mode_type_read == 0)
		{
			int num_nz_fz[MAX_NUM_TB][N_C];
			cu_nz_cln(num_nz_fz);
			mod_info_curr_ptr->tb_part = ((int)SIZE_2Nx2N);
			if (mode_type == 0)
				mod_info_curr_ptr->cu_mode = 3;
			else {
				flag_cost[2] = 0;
				int bit_cnt = enc_bit_est_flag_32(2, curr_mvr, tree_status, cons_pred_mode,
					mod_info_curr_ptr->cu_mode, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx,
					mod_info_curr_ptr->affine_flag, 1, mod_info_curr_ptr->skip_idx, mod_info_curr_ptr->refi,
					0, mod_info_curr_ptr->smvd_flag, mod_info_curr_ptr->affine_mvd,
					mod_info_curr_ptr->mvd, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2,
					num_nz_fz, mod_info_curr_ptr->ipm, 1, 0, 8, mod_info_curr_ptr->mpm, is_intra_read);

				flag_cost[2] += (bit_cnt * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
			}
		}
	}

	flag_cost[0] = 0;
	U16 flag_est = enc_bit_est_flag_32(slice_type, curr_mvr_read, tree_status, cons_pred_mode, mod_info_curr_ptr->cu_mode, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx, mod_info_curr_ptr->affine_flag, 1, mod_info_curr_ptr->skip_idx, mod_info_curr_ptr->refi, 0, mod_info_curr_ptr->smvd_flag, mod_info_curr_ptr->affine_mvd, mod_info_curr_ptr->mvd, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, num_nz_rate, mod_info_curr_ptr->ipm, 1, 0, 8, mod_info_curr_ptr->mpm, is_intra_read);
	//U16 flag_est;
	U16 coef_est = 0;
	U16 bit_cnt = flag_est + coef_est;
	flag_cost[0] += (bit_cnt * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;

	if (is_intra_read == 0) {
		if (mode_type_read == 0) {
			flag_cost[1] = 0;
			flag_est = enc_bit_est_flag_skip_32(slice_type, tree_status, mod_info_curr_ptr->umve_flag, mod_info_curr_ptr->umve_idx, mod_info_curr_ptr->affine_flag, mod_info_curr_ptr->skip_idx, md_kernel_input_32->cu_width_log2, md_kernel_input_32->cu_height_log2, mod_info_curr_ptr->ipm, 8);
			flag_cost[1] += (flag_est * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		}
	}

	// WRITE STREAMS
	*curr_mvr_update = curr_mvr_read;
	*mode_type_update = mode_type_read;
	*is_intra_update = is_intra_read;
}

void memcpy_1d_2_1d_32(s16 des[64 * 64], s16 src[32 * 32], int n, int flag)
{
	int z;
	if (flag) {
		if (n == 128)
			for (z = 0; z < 128; z++)
				des[z] = src[z];
		else if (n == 256)
			for (z = 0; z < 256; z++)
				des[z] = src[z];
		else if (n == 512)
			for (z = 0; z < 512; z++)
				des[z] = src[z];
		else if (n == 1024)
			for (z = 0; z < 1024; z++)
				des[z] = src[z];
	}
	else {
		if (n == 128)
			for (z = 0; z < 128; z++)
				des[z] = 0;
		else if (n == 256)
			for (z = 0; z < 256; z++)
				des[z] = 0;
		else if (n == 512)
			for (z = 0; z < 512; z++)
				des[z] = 0;
		else if (n == 1024)
			for (z = 0; z < 1024; z++)
				des[z] = 0;
	}
}
void memcpy_2d_2_1d_32(s16 des[64 * 64], s16 src[32][32], int w, int h)
{
	if (w == 4 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 4; j++)
				des[i * 4 + j] = src[i][j];
	}
	else if (w == 32 && h == 4) {
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
	else if (w == 8 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 8; j++)
				des[i * 8 + j] = src[i][j];
	}
	else if (w == 32 && h == 8) {
		for (int i = 0; i < 8; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
	else if (w == 16 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 16; j++)
				des[i * 16 + j] = src[i][j];
	}
	else if (w == 32 && h == 16) {
		for (int i = 0; i < 16; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
	else if (w == 32 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
}
void memcpy_2d_2_1d_32(u8 des[64 * 64], s16 src[32][32], int w, int h)
{
	if (w == 4 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 4; j++)
				des[i * 4 + j] = src[i][j];
	}
	else if (w == 32 && h == 4) {
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
	else if (w == 8 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 8; j++)
				des[i * 8 + j] = src[i][j];
	}
	else if (w == 32 && h == 8) {
		for (int i = 0; i < 8; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
	else if (w == 16 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 16; j++)
				des[i * 16 + j] = src[i][j];
	}
	else if (w == 32 && h == 16) {
		for (int i = 0; i < 16; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
	else if (w == 32 && h == 32) {
		for (int i = 0; i < 32; i++)
			for (int j = 0; j < 32; j++)
				des[i * 32 + j] = src[i][j];
	}
}
void updateMode_coef_mux(int i, s16 coef_buf_tmp[32], s16 coef_buf[32][32])
{
	//#pragma HLS INLINE
	if (i == 0) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 1) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 2) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 3) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 4) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 5) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 6) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 7) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 8) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 9) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 10) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 11) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 12) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 13) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 14) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 15) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 16) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 17) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 18) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 19) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 20) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 21) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 22) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 23) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 24) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 25) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 26) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 27) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 28) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 29) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 30) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
	else if (i == 31) {
		for (U8 j = 0; j < 32; j++) { coef_buf_tmp[j] = coef_buf[(j + i) & 31][j]; }
	}
}
// MD_KERNEL_32 UPDATE TOP
void update_rdo_luma_32(U1 valid_flag, U8 cu_width, U8 cu_height, 
	ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr,
	MD_KERNEL_MODE_32* mod_info_curr_ptr, u8 mode_type, s64 dist_pred[1],
	s64* cost_best_temp, MD_COM_MODE_BEST* best_info_ptr,
	s64* cost_best, u8 curr_mvr,  pel rec_y_pb_part[32][32], pel pred_cache[32][32], s16 coef_y_pb_part[32][32], s32* dist,
	U1 is_intra, s64* cost_pb_best, s64 flag_cost[3], int num_nz_update[MAX_NUM_TB][N_C], MD_KERNEL_INPUT_32* md_kernel_input
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
	, U1 valid_mode_config[3]
#endif
	)
{
#pragma HLS INLINE off


#pragma HLS ARRAY_PARTITION variable=cu_data_ptr->reco_y   		dim=2 complete
#pragma HLS ARRAY_PARTITION variable=rec_y_pb_part              dim=2 complete

#pragma HLS ARRAY_PARTITION variable=cu_data_ptr->coef_y  		dim=2 complete
#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part             dim=1 complete

	s64 cost = 0;
	U7 pb_w = cu_width;
	U7 pb_h = cu_height;
	s64 cost_pb_temp = 0;
	int bin_cnt_luma[1] = { 0 };
	//U13 i;
	//U13 j;
	s16 wxh = s16(cu_width) * s16(cu_height);
	U3 cu_width_log2 = md_kernel_input->cu_width_log2;

	U2 cu_mode_read = mod_info_curr_ptr->cu_mode;
	int tb_part_read = mod_info_curr_ptr->tb_part;
	
	//if (!valid_flag)
	//{
	//	for (i = 0; i < 3; i++)
	//		model_cnt->cbf[i] = model_cnt_inner->cbf[i];
	//	for (i = 0; i < 24; i++)
	//		model_cnt->run_rdoq[i] = model_cnt_inner->run_rdoq[i];
	//	for (i = 0; i < 24; i++)
	//		model_cnt->level[i] = model_cnt_inner->level[i];
	//	for (i = 0; i < 12; i++)
	//		model_cnt->last1[i] = model_cnt_inner->last1[i];
	//	for (i = 0; i < 22; i++)
	//		model_cnt->last2[i] = model_cnt_inner->last2[i];
	//	return;
	//}

	*cost_best_temp = MAX_S64;

	if (is_intra || num_nz_update[0][0]) {
		cost = *dist;
	}
	cost += flag_cost[0];

#if USE_ROI_MODE_CONFIG
	if (valid_mode_config[2] == 0 && mod_info_curr_ptr->cu_mode ==0)
		cost = MAX_S64;

	if (valid_mode_config[1] == 0 && mod_info_curr_ptr->cu_mode == 1)
		cost = MAX_S64;

	if (valid_mode_config[0] == 0 && (mod_info_curr_ptr->cu_mode == 2 || mod_info_curr_ptr->cu_mode == 3))
		cost = MAX_S64;
#endif

	if (is_intra == 0) {  // INTER
		//*cost_best_temp = mode_type == 1 ? flag_cost[2] + dist_pred[0] : MAX_S64;
		*cost_best_temp = flag_cost[2] + dist_pred[0];
		if (num_nz_update[0][0]) {
			//if (cost < *cost_best_temp) {
				*cost_best_temp = cost;
			//}
		}
		//if (mode_type == 0) {
		//	cost = dist_pred[0];
		//	cost += flag_cost[1];
		//	if (cost < *cost_best_temp) {
		//		*cost_best_temp = cost;
		//		cu_mode_read = 2;
		//		tb_part_read = (SIZE_2Nx2N);
		//		for (i = 0; i < 4; i++) {
		//			for (j = 0; j < 3; j++) {
		//				num_nz_update[i][j] = 0;
		//			}
		//		}
		//	}
		//}

		//U2 lidx;
		//U2 vertex;
		U2 vertex_num;

		// NOT used
		//static U11 skip_mode_2_thread_s64[64] = { (1000), (1002), (1004), (1005), (1007), (1009), (1010), (1012), (1014), (1016), (1017), (1019), (1020), (1022), (1024), (1026), (1027), (1029), (1030), (1032), (1034), (1036), (1037), (1039), (1040), (1042), (1044), (1046), (1047), (1049), (1050), (1052), (1054), (1056), (1057), (1059), (1060), (1062), (1064), (1066), (1067), (1069), (1070), (1072), (1074), (1076), (1077), (1079), (1080), (1082), (1084), (1086), (1087), (1089), (1090), (1092), (1094), (1096), (1097), (1099), (1100), (1102), (1104), (1106) };

#if SUB_TMVP
		BOOL isSubTMVP = cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE && mod_info_curr_ptr->cu_mode >= MODE_SKIP && mod_info_curr_ptr->skip_idx == 0 && mod_info_curr_ptr->umve_flag == 0;
		BOOL rdoRun = TRUE;
		if (isSubTMVP) {
			rdoRun = core_sbtmvp->isValid;
		}

#endif
		if (*cost_best_temp < *cost_best
#if SUB_TMVP
			&& rdoRun
#endif	
        ) {
			best_info_ptr->cu_mode = cu_mode_read;
			best_info_ptr->pb_part = mod_info_curr_ptr->pb_part;
			best_info_ptr->tb_part = tb_part_read;
			/*bst_info_pb_info->num_sub_part = mod_info_curr_pb_info->num_sub_part;
			bst_info_tb_info->num_sub_part = mod_info_curr_tb_info->num_sub_part;
			for (U1 it = 0; it < 1; it++) {
				bst_info_pb_info->sub_x[it] = mod_info_curr_pb_info->sub_x[it];
				bst_info_pb_info->sub_y[it] = mod_info_curr_pb_info->sub_y[it];
				bst_info_pb_info->sub_w[it] = mod_info_curr_pb_info->sub_w[it];
				bst_info_pb_info->sub_h[it] = mod_info_curr_pb_info->sub_h[it];
				bst_info_pb_info->sub_scup[it] = mod_info_curr_pb_info->sub_scup[it];
				bst_info_tb_info->sub_x[it] = mod_info_curr_tb_info->sub_x[it];
				bst_info_tb_info->sub_y[it] = mod_info_curr_tb_info->sub_y[it];
				bst_info_tb_info->sub_w[it] = mod_info_curr_tb_info->sub_w[it];
				bst_info_tb_info->sub_h[it] = mod_info_curr_tb_info->sub_h[it];
				bst_info_tb_info->sub_scup[it] = mod_info_curr_tb_info->sub_scup[it];
			}*/
			best_info_ptr->umve_flag = mod_info_curr_ptr->umve_flag;
			*cost_best = *cost_best_temp;

			if (best_info_ptr->cu_mode != 0) {
				if (best_info_ptr->cu_mode == 2 || best_info_ptr->cu_mode == 3) {
					best_info_ptr->mvr_idx = ((u8)0);
				} else {
					best_info_ptr->mvp_from_hmvp_flag = 0;
					best_info_ptr->mvr_idx = curr_mvr;
				}
#ifndef _DATA_CP_FOR_DATAFLOW_
				best_info_ptr->refi[0] = mod_info_curr_ptr->refi[0];
				best_info_ptr->refi[1] = mod_info_curr_ptr->refi[1];
#else
				best_info_ptr->refi[0] = mod_info_curr_ptr->refi_cp[0];
				best_info_ptr->refi[1] = mod_info_curr_ptr->refi_cp[1];
#endif //_DATA_CP_FOR_DATAFLOW_

				LOOP_UPDATE32_mv_mvd: for (U2 lidx = 0; lidx < 2; lidx++) {
#pragma HLS PIPELINE
					best_info_ptr->mv[lidx][0] = mod_info_curr_ptr->mv[lidx][0];
					best_info_ptr->mv[lidx][1] = mod_info_curr_ptr->mv[lidx][1];
#ifndef _DATA_CP_FOR_DATAFLOW_
					best_info_ptr->mvd[lidx][0] = mod_info_curr_ptr->mvd[lidx][0];
					best_info_ptr->mvd[lidx][1] = mod_info_curr_ptr->mvd[lidx][1];
#else
					best_info_ptr->mvd[lidx][0] = mod_info_curr_ptr->mvd_cp[lidx][0];
					best_info_ptr->mvd[lidx][1] = mod_info_curr_ptr->mvd_cp[lidx][1];
#endif //_DATA_CP_FOR_DATAFLOW_
				}

				best_info_ptr->smvd_flag   = mod_info_curr_ptr->smvd_flag;
				best_info_ptr->affine_flag = mod_info_curr_ptr->affine_flag;

				if (best_info_ptr->affine_flag) {
					vertex_num = (best_info_ptr->affine_flag) + 1;
					LOOP_UPDATE32_affine_mv_affine_mvd: for (U2 lidx = 0; lidx < 2; lidx++) {
#pragma HLS UNROLL
						for (U2 vertex = 0; vertex < 4; vertex++) {
#pragma HLS UNROLL
							if (vertex < vertex_num) {
								best_info_ptr->affine_mv[lidx][vertex][0] = mod_info_curr_ptr->affine_mv[lidx][vertex][0];
								best_info_ptr->affine_mv[lidx][vertex][1] = mod_info_curr_ptr->affine_mv[lidx][vertex][1];
#ifndef _DATA_CP_FOR_DATAFLOW_
								best_info_ptr->affine_mvd[lidx][vertex][0] = mod_info_curr_ptr->affine_mvd[lidx][vertex][0];
								best_info_ptr->affine_mvd[lidx][vertex][1] = mod_info_curr_ptr->affine_mvd[lidx][vertex][1];
#else
								best_info_ptr->affine_mvd[lidx][vertex][0] = mod_info_curr_ptr->affine_mvd_cp[lidx][vertex][0];
								best_info_ptr->affine_mvd[lidx][vertex][1] = mod_info_curr_ptr->affine_mvd_cp[lidx][vertex][1];
#endif //_DATA_CP_FOR_DATAFLOW_
							}
						}
					}
				}

				//memcpy_2d_2_1d_32(best_info_ptr->pred_y, pred_cache, cu_width, cu_height);

				if (best_info_ptr->cu_mode == 2) {
					if (((int)(best_info_ptr->umve_flag)) != 0) {
						best_info_ptr->umve_idx = mod_info_curr_ptr->umve_idx;
					} else {
						best_info_ptr->skip_idx = mod_info_curr_ptr->skip_idx;
					}
				} else {
					if (best_info_ptr->cu_mode == 3) {
						if (best_info_ptr->umve_flag) {
							best_info_ptr->umve_idx = mod_info_curr_ptr->umve_idx;
						} else {
							best_info_ptr->skip_idx = mod_info_curr_ptr->skip_idx;
						}
					}
				}

				LOOP_UPDATE32_INTER_num_nz: for (U3 i_numnz = 0; i_numnz < 4; i_numnz++) {
#pragma HLS UNROLL
					best_info_ptr->num_nz[i_numnz][0] = best_info_ptr->cu_mode == 2 ? 0 : num_nz_update[i_numnz][0];
				}
			}

//			if (best_info_ptr->cu_mode != 0) {
//				LOOP_UPDATE32_INTER_coef: for (int i = 0; i < cu_height; i++)
//#pragma HLS LOOP_TRIPCOUNT max=32
//#pragma HLS PIPELINE
//					// for (j = 0; j < cu_width; j++)
//					for (int j = 0; j < 32; j++)
//						if (j < cu_width)
//							cu_data_ptr->coef_y[i][j] = (best_info_ptr->cu_mode == 2) ? 0 : coef_y_pb_part[i][j];
//
//			}

			U1 b_num_nz = num_nz_update[0][0] == 0;

#if 0
			if (b_num_nz) {
				LOOP_UPDATE32_INTER_reco_0: for (int i = 0; i < cu_height; i++)
#pragma HLS LOOP_TRIPCOUNT max=32
#pragma HLS PIPELINE
					// for (int j = 0; j < cu_width; j++)
					for (int j = 0; j < 32; j++)
						if (j < cu_width)
							cu_data_ptr->reco_y[i][j] = pred_cache[i][j];
			} else {
				LOOP_UPDATE32_INTER_reco_1: for (int i = 0; i < cu_height; i++)
#pragma HLS LOOP_TRIPCOUNT max=32
#pragma HLS PIPELINE
					// for (int j = 0; j < cu_width; j++)
					for (int j = 0; j < 32; j++)
						if (j < cu_width)
							cu_data_ptr->reco_y[i][j] = rec_y_pb_part[i][j];
			}
#else
			s16 coef_buf_tmp[32];
			LOOP_UPDATE32_INTER_com: for (int i = 0; i < cu_height; i++) {
#pragma HLS LOOP_TRIPCOUNT max=32
#pragma HLS PIPELINE
				for (int j = 0; j < cu_width; j++) {
					//cu_data_ptr->reco_y[i][j] = b_num_nz ? pred_cache[i][j] : rec_y_pb_part[i][j];
					cu_data_ptr->reco_y[i][j] = rec_y_pb_part[i][j];
				}


				updateMode_coef_mux(i, coef_buf_tmp, coef_y_pb_part);
				for (int j = 0; j < cu_width; j++) {

					cu_data_ptr->coef_y[i][j] = coef_buf_tmp[j];
				}
			}
#endif //0
		}
	}

	else {	// INTRA
	//if (is_intra) {
		cost_pb_temp += cost;
		if (cost_pb_temp < *cost_pb_best) {
			*cost_pb_best = cost_pb_temp;
		}

		if (cost_pb_temp < *cost_best) {
			best_info_ptr->cu_mode = MODE_INTRA;
			best_info_ptr->affine_flag = 0;
			*cost_best = cost_pb_temp;
			//memcpy_rewrintra(best_info_ptr->coef_y, coef_y_pb_part, wxh);
			//memcpy_2d_2_1d_32(best_info_ptr->rec_y, rec_y_pb_part, cu_width, cu_height);
			s16 coef_buf_tmp[32];
			LOOP_UPDATE32_INTRA_coef_reco: for (int i = 0; i < cu_height; i++) {
#pragma HLS LOOP_TRIPCOUNT max=32
#pragma HLS PIPELINE
			for (int j = 0; j < cu_width; j++) {
				
				{
					//cu_data_ptr->coef_y[i][j] = coef_y_pb_part[(i + j) & 0x1f][j];
//						cu_data_ptr->coef_y[i][j] = coef_y_pb_part[i][j];
					cu_data_ptr->reco_y[i][j] = rec_y_pb_part[i][j];
				}
			}

			updateMode_coef_mux(i, coef_buf_tmp, coef_y_pb_part);
			for (int j = 0; j < cu_width; j++) {

				cu_data_ptr->coef_y[i][j] = coef_buf_tmp[j];
			}
			}

			LOOP_UPDATE32_mpm_ipm: for (int i = 0; i < 4; ++i) {
#pragma HLS UNROLL
				for (int j = 0; j < 2; ++j) {
#pragma HLS UNROLL
#ifndef _DATA_CP_FOR_DATAFLOW_
					best_info_ptr->mpm[i][j] = mod_info_curr_ptr->mpm[i][j];
					best_info_ptr->ipm[i][j] = mod_info_curr_ptr->ipm[i][j];
#else
					best_info_ptr->mpm[i][j] = mod_info_curr_ptr->mpm_cp[i][j];
					best_info_ptr->ipm[i][j] = mod_info_curr_ptr->ipm_cp[i][j];
#endif //_DATA_CP_FOR_DATAFLOW_
				}
			}
			
			LOOP_UPDATE32_INTRA_num_nz: for (int i = 0; i < 4; ++i) {
#pragma HLS UNROLL
				for (int j = 0; j < 3; ++j) {
#pragma HLS UNROLL
					best_info_ptr->num_nz[i][j] = num_nz_update[i][j];
				}
			}

		}
	}
}



void diff_16b_32(U7 w, U7 h, s16 src1[32][32], s16 src2[32][32], int s_src1, s16 diff[32][32])
{
	//int offset_s1 = 0;

	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
		if (i < h) {
			for (int j = 0; j < 32; j++) {
				if (j < w)
					diff[i][j] = ((s16)((src1[i][j]) - (src2[i][j])));
			}
		}
	}
}

void diff_16b_32_chroma(U7 w, U7 h, s16 src1[32][32], s16 src2[32][32], int s_src1, s16 diff[32][32])
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src1 complete dim=2
#pragma HLS ARRAY_PARTITION variable=src2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=diff complete dim=2
	int i;
	int j;
	s16 diff_tmp[32];
#pragma HLS ARRAY_PARTITION variable=diff_tmp complete dim=0
	for (i = 0; i < 32; i++) {
#pragma HLS PIPELINE
			for (j = 0; j < 32; j++) {
			if ((j < w) && (i < h)) {
				diff_tmp[j] = ((s16)(src1[i][j] - src2[i][j]));
			}
			else {
				diff_tmp[j] = 0;
			}
		}
		for (j = 0; j < 32; j++) {
			diff[i][j] = diff_tmp[j];	
		}
	}
}

void enc_diff_16b_32(U3 log2w, U3 log2h, s16 src1[32][32], s16 src2[32][32], int s_src1, s16 diff[32][32])
{

	int x = log2w;
	int y = log2h;
	int w = 1 << log2w;
	int h = 1 << log2h;

	diff_16b_32(w, h, src1, src2, s_src1, diff);
}

void enc_diff_16b_32_chroma(U3 log2w, U3 log2h, s16 src1[32][32], s16 src2[32][32], int s_src1, s16 diff[32][32])
{

	int w = 1 << log2w;
	int h = 1 << log2h;
	{
		diff_16b_32_chroma(w, h, src1, src2, s_src1, diff);
	}
}


////////////////////////////////////////////////


static int get_bitcnt_est_32_coef_0(u8 curr_mvr, u8 tree_status,
s32 slice_type, u8 cons_pred_mode, int cu_mode, u8 umve_flag, u8 umve_idx, u8 affine_flag, unsigned char affine_enable_flag, u8 skip_idx, S3 refi[REFP_NUM], u8 mvp_from_hmvp_flag, u8 smvd_flag, s16  affine_mvd[REFP_NUM][VER_NUM][MV_D], s16  mvd[REFP_NUM][MV_D], int cu_width_log2, int cu_height_log2, int num_nz[MAX_NUM_TB][N_C], S8   ipm[MAX_NUM_PB][2], int cur_ptr, int ref_ptr, u8 mpm[4][2], int is_intra)
{

	U16 enc_est;
	enc_est = enc_bit_est_flag_32(slice_type, curr_mvr, tree_status, cons_pred_mode, cu_mode, umve_flag, umve_idx, affine_flag, 1, skip_idx, refi, mvp_from_hmvp_flag, smvd_flag, affine_mvd, mvd, cu_width_log2, cu_height_log2, num_nz, ipm, 1, 0, 8, mpm, is_intra);

	return enc_est;
}

void init_inter_data_32(MD_KERNEL_MODE_32* mod_info_curr_ptr)
{

#if MD_KERNEL_32_MOD_YHY
#pragma HLS array_partition variable=mod_info_curr_ptr->mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->mvd complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mv complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->affine_mvd complete dim=0
#pragma HLS array_partition variable=mod_info_curr_ptr->refi complete dim=0
#endif

	mod_info_curr_ptr->skip_idx = 0;
	mod_info_curr_ptr->smvd_flag = 0;
	for (int i = 0; i < 2; i++) {
#if MD_INFO_NZ_FLAT
#pragma HLS UNROLL
#else
#pragma HLS PIPELINE
#endif

		for (int j = 0; j < 2; j++) {
#pragma HLS UNROLL
			mod_info_curr_ptr->mv[i][j] = 0;
			mod_info_curr_ptr->mvd[i][j] = 0;
		}
		mod_info_curr_ptr->refi[i] = 0;
		//add by xujch
	}

	/*for (int m = 0; m < 4; m++) {

		for (int n = 0; n < 3; n++) {
			mod_info_curr_ptr->num_nz[m][n] = 0;
		}
	}*/

	for (int c = 0; c < 2; c++) {
#if MD_INFO_NZ_FLAT
#pragma HLS UNROLL
#else
#pragma HLS PIPELINE
#endif

		for (int d = 0; d < 4; d++) {
#pragma HLS UNROLL
			for (int e = 0; e < 2; e++) {
#pragma HLS UNROLL
				mod_info_curr_ptr->affine_mv[c][d][e] = 0;
				mod_info_curr_ptr->affine_mvd[c][d][e] = 0;
			}
		}
		//add by xujch
	}
}

void get_pred_y_32(int w, int h, int x_refp, int y_refp, int dx, int dy, Arbitor& ref,
#if ENABLE_BFRAME
	U1 lidx,
#endif
	pel pred[32][32])
{
#pragma HLS INTERFACE m_axi port=ref->ref_0_0 offset=off name=ref_0_0
#pragma HLS INTERFACE m_axi port=ref->ref_0_1 offset=off name=ref_0_1
#pragma HLS INTERFACE m_axi port=ref->ref_1_0 offset=off name=ref_1_0
#pragma HLS INTERFACE m_axi port=ref->ref_1_1 offset=off name=ref_1_1
#pragma HLS INTERFACE m_axi port=ref->ref_2_0 offset=off name=ref_2_0
#pragma HLS INTERFACE m_axi port=ref->ref_2_1 offset=off name=ref_2_1
#pragma HLS INTERFACE m_axi port=ref->ref_3_0 offset=off name=ref_3_0
#pragma HLS INTERFACE m_axi port=ref->ref_3_1 offset=off name=ref_3_1
#pragma HLS INTERFACE m_axi port=ref->ref_4_0 offset=off name=ref_4_0
#pragma HLS INTERFACE m_axi port=ref->ref_4_1 offset=off name=ref_4_1
#pragma HLS INTERFACE m_axi port=ref->ref_5_0 offset=off name=ref_5_0
#pragma HLS INTERFACE m_axi port=ref->ref_5_1 offset=off name=ref_5_1
#pragma HLS INTERFACE m_axi port=ref->ref_6_0 offset=off name=ref_6_0
#pragma HLS INTERFACE m_axi port=ref->ref_6_1 offset=off name=ref_6_1
#pragma HLS INTERFACE m_axi port=ref->ref_7_0 offset=off name=ref_7_0
#pragma HLS INTERFACE m_axi port=ref->ref_7_1 offset=off name=ref_7_1
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_0_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_1_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_2_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_3_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_4_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_5_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_6_1 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_0 dim=2
#pragma HLS ARRAY_RESHAPE variable=ref->ref_7_1 dim=2
	int frac_idx = dy * 4 + dx;
	int gmvx_refp_int = x_refp >> 2;
	int gmvy_refp_int = y_refp >> 2;

#if 1
	pel buffer_0[5 + 5][8][2][16];

	U6 gmvxdiv32 = gmvx_refp_int & 31;
	int i, j, k, m;
	int m_tmp;

	for (m = 0; m < 10; m++) {
#pragma HLS PIPELINE
		for (k = 0; k < 16; k++) {
#pragma HLS UNROLL
#define FLAT(i, j) buffer_0[m][i][j][k] = ref.ref_##i##_##j [(gmvx_refp_int / 32 + (m & 1)) + ((gmvy_refp_int / 8 + m / 2) * 5) + 80 * frac_idx + lidx * 1280][k];
			FLAT_8_2
#undef FLAT
		}
	}



	for (int i = 0; i < 32; i++) {
		for (int j = 0; j < 32; j++) {
#if ENABLE_BFRAME
			pred[i][j] = buffer_0[((gmvy_refp_int & 7) + i) / 8 * 2 + (((gmvx_refp_int & 31) + j) >> 5)]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif
		}
	}
#else
	for (int i = 0; i < h; i++) {
#pragma HLS loop_tripcount max=32
		for (int j = 0; j < w; j++) {
#pragma HLS loop_tripcount max=32
#if ENABLE_BFRAME
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx + lidx * 1280]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#else
			pred[i][j] = refwin_mc[((gmvx_refp_int + j) >> 5) + (((gmvy_refp_int + i) >> 3) * 5) + 80 * frac_idx]
				[(gmvy_refp_int + i) & 7][((gmvx_refp_int + j) & 31) >> 4][(gmvx_refp_int + j) & 15];
#endif
		}
	}
#endif // 1

	return;
}

BOOL com_mc_cu_y_32(CU_POS* cu, U13 pic_w, U13 pic_h, S3 refi[REFP_NUM], s16 mv[REFP_NUM][2], U10 stride_luma,
	pel pred_y[32][32], U4 bit_depth, strFetch_ref_window* Fetch_Ref_window_ptr,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	Arbitor& ref
	, U2 mode_type
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int mode_idx, int umve_flag
#endif
)
{
	int scup = cu->scup;
	int x = cu->x_pos;
	int y = cu->y_pos;
	int w = cu->cu_width;
	int h = cu->cu_height;
	int cu_width  = cu->cu_width;
	int cu_height = cu->cu_height;
	s16 mv_t[2];
	int min_clip[2];
	int max_clip[2];
	int x_ext = cu->x_pos << 2;
	int y_ext = cu->y_pos << 2;
	int w_ext = cu->cu_width << 2;
	int h_ext = cu->cu_height << 2;
	int x_ext_of_ctu;
	int y_ext_of_ctu;
	int qpel_gmv_x_of_ctu;
	int qpel_gmv_y_of_ctu;
	int qpel_gmv_x_of_refp_cu;
	int qpel_gmv_y_of_refp_cu;
#if MD_KERNEL_32_MOD_YHY

#pragma HLS ARRAY_PARTITION variable=core_sbtmvp->sbTmvp complete dim=0
#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP complete dim=0
#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP_ref1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=mv_t complete dim=0
#pragma HLS ARRAY_PARTITION variable=min_clip complete dim=0
#pragma HLS ARRAY_PARTITION variable=max_clip complete dim=0
#pragma HLS ARRAY_PARTITION variable=mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=refi complete dim=0

	//int bidx = 0;
	U1 ref0_valid = 0, ref1_valid = 0;
	pel pred_ref0[32][32];

#pragma HLS ARRAY_PARTITION variable=pred_ref0 complete dim=0

	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];

	if (refi[REFP_0] >= 0)
	{
		if (x_ext + (mv[REFP_0][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_0][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_0][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_0][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

#if ENABLE_BFRAME
		S2 cur_refw_idx = get_ref_idx_y(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME

#if SUB_TMVP
		if (mode_idx == 0 && cu->cu_width >= SBTMVP_MIN_SIZE && cu->cu_height >= SBTMVP_MIN_SIZE && mode_type >= MODE_SKIP && umve_flag == 0)
		{
			if (!core_sbtmvp->isValid)
				return FALSE;
			core_sbtmvp->isValid = TRUE;
#if DEBUG_CU
			if (isProblem)
			{
				printf("CU %d,%d,%d,%d\n", cu->x_pos, cu->y_pos, cu->cu_width, cu->cu_height);
				printf("ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}\n",
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1]);
			}
#endif
			int cu_width = cu->cu_width;
			int cu_height = cu->cu_height;
			int x = cu->x_pos;
			int y = cu->y_pos;
			int sub_w = cu_width / SBTMVP_NUM_1D;
			int sub_h = cu_height / SBTMVP_NUM_1D;
			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp[32][32];

#pragma HLS ARRAY_PARTITION variable=pred_tmp complete dim=0

			for (int k = 0; k < SBTMVP_NUM; k++)
			{
#pragma HLS LOOP_TRIPCOUNT max=4
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + ((int)mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + ((int)mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}

					qpel_gmv_x = (x << 2) + ((int)mv_sbtmvp[0]);
					qpel_gmv_y = (y << 2) + ((int)mv_sbtmvp[1]);
					dx = qpel_gmv_x & 0x3;
					dy = qpel_gmv_y & 0x3;
					if (dx == 0 && dy == 0) {
						x_offset_min = 0;
						y_offset_min = 0;
					}
					else {
						x_offset_min = -3;
						y_offset_min = -3;
					}
#if ENABLE_BFRAME
					cur_refw_idx = get_ref_idx_y(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME

					if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + x_offset_max <= (160 + 4) &&
						(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + sub_h + y_offset_max <= (128 + 4)))
					{
#if MD_PRINT_ENH
						if (mode_type == MODE_SKIP)
							printf("<MODE_SKIP:SUB_TMVP> ");
						else if (mode_type == MODE_DIR)
							printf("<MODE_DIR:SUB_TMVP> ");
						printf("out of ref0 window ERROR: sub cu %d=(%d %d %d %d)", k, x, y, sub_w, sub_h);
						printf("mv=(");
						printf("%d %d", mv_sbtmvp[MV_X], mv_sbtmvp[MV_Y]);
						printf(")\n ");
#if ENABLE_BFRAME
						printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
							cur_refw_idx,
							CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
							CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
						);
						printf("\n");
#endif 
						fflush(stdout);
#endif
						core_sbtmvp->isValid = FALSE;
						return FALSE;
					}

					get_pred_y_32(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
						cur_refw_idx,
#endif // ENABLE_BFRAME
						pred_tmp);
#if DEBUG_CU
					if (isProblem)
					{
						printf("CU %d (%d,%d) (%d,%d)\n", k, mv_sbtmvp[0], mv_sbtmvp[1], qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu);
					}
#endif
					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < 16; i++)
					{
#pragma HLS UNROLL
						for (int j = 0; j < 16; j++)
						{
#pragma HLS UNROLL
							//pred_ref0[h + i][w + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							if (h == 0 && w == 0) {
								pred_ref0[0 + i][0 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
							else if (h == 16 && w == 0) {
								pred_ref0[16 + i][0 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
							else if (h == 0 && w == 16) {
								pred_ref0[0 + i][16 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
							else {
								pred_ref0[16 + i][16 + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
							}
#if DEBUG_CU
							if (isProblem)
							{
								printf("%d,", pred_tmp[i][j]);
							}
#endif
						}
#if DEBUG_CU
						if (isProblem)
						{
							printf("\n");
						}
#endif
					}

					/*FILE* sbtmvp = fopen("sbtmvp.csv", "w");
					for (int i = 0; i < 64; i++) {
						for (int j = 0; j < 64; j++) {
							pel curr = pred[i * 64 + j];
							fprintf(sbtmvp, "%d, ", (int)curr);
						}
						fprintf(sbtmvp, "\n");
					}
					fclose(sbtmvp);*/
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}

#if DEBUG_CU
			if (isProblem == 1)
				isProblem = 0;
#endif
				}
		else {
#endif
			if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
				(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
			{
#if MD_PRINT
				if (mode_type == MODE_SKIP)
					printf("<MODE_SKIP> ");
				else if (mode_type == MODE_INTER)
					printf("<MODE_INTER> ");
				else if (mode_type == MODE_DIR)
					printf("<MODE_DIR> ");
				printf("out of ref0 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
				printf("mv=(");
				printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
				printf(")\n ");
#if ENABLE_BFRAME
				printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
					cur_refw_idx,
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
					CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
				);
				printf("\n");
#endif 
				printf("\n");
#ifndef __SYNTHESIS__
				fflush(stdout);
#endif //__SYNTHESIS__
#endif
				return FALSE;
			}

			get_pred_y_32(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
				cur_refw_idx,
#endif // ENABLE_BFRAME
				pred_ref0);
#if SUB_TMVP
		}
#endif
		//++bidx;
		ref0_valid = 1;
	}
	if (ref0_valid)
	{
		for (int i = 0; i < 32; i++)
		{
#pragma HLS UNROLL
			for (int j = 0; j < 32; j++)
			{
				if(i<h&&j<w)
				{
					pred_y[i][j] = pred_ref0[i][j];
				}
			}
		}
	}
#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	static pel pred_ref1[32][32];
	if (REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred)[32] = bidx ? pred_snd : pred_y;
		//ref_pic = refp[refi[REFP_1]][REFP_1].pic;
		if (x_ext + (mv[REFP_1][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_1][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_1][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_1][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		S2 cur_refw_idx = get_ref_idx_y(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));

		//if (channel != CHANNEL_C)
		//{
		//if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < SWH)) { return FALSE; }
		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			if (mode_type == MODE_SKIP)
				printf("<MODE_SKIP> ");
			else if (mode_type == MODE_INTER)
				printf("<MODE_INTER> ");
			else if (mode_type == MODE_DIR)
				printf("<MODE_DIR> ");
			printf("out of ref1 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
			printf("mv=(");
			printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
			printf(")\n");
			printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
				cur_refw_idx,
				CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
				CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
			);
			printf("\n");
#ifndef __SYNTHESIS__
			fflush(stdout);
#endif //__SYNTHESIS__
#endif
			return FALSE;
		}

		//pel(*pred)[32] = bidx ? pred_snd : pred_y;
		get_pred_y_32(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref, cur_refw_idx, pred_ref1);

		//}

//		if (channel != CHANNEL_L)
//		{
//#if CHROMA_NOT_SPLIT
//			assert(w >= 8 && h >= 8);
//#endif
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->u, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[U_C], w >> 1, h >> 1, bit_depth);
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->v, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[V_C], w >> 1, h >> 1, bit_depth);
//		}
		//bidx++;
		ref1_valid = 1;
		}

	if (ref0_valid && ref1_valid)
	{
		//if (channel != CHANNEL_C)
		//{
#if SIMD_MC
		average_16b_no_clip_sse(pred_y[0], pred_snd[0], pred_y[0], 32, 32, 32, w, h);
#else
		//pel(*p0)[32] = pred_y;
		//pel(*p1)[32] = pred_snd;
		for (int j = 0; j < 32; j++)
		{
#pragma HLS UNROLL
			for (int i = 0; i < 32; i++)
			{
				if(i<w&&j<h)
				{
				    pred_y[j][i] = (pred_ref0[j][i] + pred_ref1[j][i] + 1) >> 1;
				}
			}
		}
#endif
		//}

//		if (channel != CHANNEL_L)
//		{
//#if SIMD_MC
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			average_16b_no_clip_sse(pred_buf[U_C], pred_snd[U_C], pred_buf[U_C], pred_stride, pred_stride, pred_stride, w, h);
//			average_16b_no_clip_sse(pred_buf[V_C], pred_snd[V_C], pred_buf[V_C], pred_stride, pred_stride, pred_stride, w, h);
//#else
//			p0 = pred_buf[U_C];
//			p1 = pred_snd[U_C];
//			p2 = pred_buf[V_C];
//			p3 = pred_snd[V_C];
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			for (j = 0; j < h; j++)
//			{
//				for (i = 0; i < w; i++)
//				{
//					p0[i] = (p0[i] + p1[i] + 1) >> 1;
//					p2[i] = (p2[i] + p3[i] + 1) >> 1;
//				}
//				p0 += pred_stride;
//				p1 += pred_stride;
//				p2 += pred_stride;
//				p3 += pred_stride;
//			}
//#endif
//		}
	}
	else
	{
		if (ref0_valid)
		{
			/////
		}
		else if (ref1_valid)
		{
			for (int j = 0; j < 32; j++)
			{
#pragma HLS UNROLL
				for (int i = 0; i < 32; i++)
				{
					if(i<w&&j<h)
					{
                        pred_y[j][i] = pred_ref1[j][i];
					}
				}
			}
		}
		else
		{
#if MD_PRINT
			printf("%s:%d:all refs are invalid\n", __FUNCTION__, 7922);
#endif
		}
	}
#endif
	return 1;
#else
	//int bidx = 0;
	U1 ref0_valid = 0, ref1_valid = 0;

	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];

	if (refi[REFP_0] >= 0)
	{
		if (x_ext + (mv[REFP_0][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_0][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_0][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_0][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

#if ENABLE_BFRAME
		S2 cur_refw_idx = get_ref_idx_y(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME

#if SUB_TMVP
		if (mode_idx == 0 && cu->cu_width >= SBTMVP_MIN_SIZE && cu->cu_height >= SBTMVP_MIN_SIZE && mode_type >= MODE_SKIP && umve_flag == 0)
		{
			if (!core_sbtmvp->isValid)
				return FALSE;
			core_sbtmvp->isValid = TRUE;
#if DEBUG_CU
			if (isProblem)
			{
				printf("CU %d,%d,%d,%d\n", cu->x_pos, cu->y_pos, cu->cu_width, cu->cu_height);
				printf("ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}\n",
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1]);
			}
#endif
			int cu_width = cu->cu_width;
			int cu_height = cu->cu_height;
			int x = cu->x_pos;
			int y = cu->y_pos;
			int sub_w = cu_width / SBTMVP_NUM_1D;
			int sub_h = cu_height / SBTMVP_NUM_1D;
			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp[32][32];
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + ((int)mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + ((int)mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}

					qpel_gmv_x = (x << 2) + ((int)mv_sbtmvp[0]);
					qpel_gmv_y = (y << 2) + ((int)mv_sbtmvp[1]);
					dx = qpel_gmv_x & 0x3;
					dy = qpel_gmv_y & 0x3;
					if (dx == 0 && dy == 0) {
						x_offset_min = 0;
						y_offset_min = 0;
					}
					else {
						x_offset_min = -3;
						y_offset_min = -3;
					}
#if ENABLE_BFRAME
					cur_refw_idx = get_ref_idx_y(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));
#else
					qpel_gmv_x_of_refp_cu = qpel_gmv_x - ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2));
					qpel_gmv_y_of_refp_cu = qpel_gmv_y - ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2));
#endif // ENABLE_BFRAME

					if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + x_offset_max <= (160 + 4) &&
						(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + sub_h + y_offset_max <= (128 + 4)))
					{
#if MD_PRINT_ENH
						if (mode_type == MODE_SKIP)
							printf("<MODE_SKIP:SUB_TMVP> ");
						else if (mode_type == MODE_DIR)
							printf("<MODE_DIR:SUB_TMVP> ");
						printf("out of ref0 window ERROR: sub cu %d=(%d %d %d %d)", k, x, y, sub_w, sub_h);
						printf("mv=(");
						printf("%d %d", mv_sbtmvp[MV_X], mv_sbtmvp[MV_Y]);
						printf(")\n ");
#if ENABLE_BFRAME
						printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
							cur_refw_idx,
							CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
							CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
						);
						printf("\n");
#endif 
						fflush(stdout);
#endif
						core_sbtmvp->isValid = FALSE;
						return FALSE;
					}

					get_pred_y_32(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
						cur_refw_idx,
#endif // ENABLE_BFRAME
						pred_tmp);
#if DEBUG_CU
					if (isProblem)
					{
						printf("CU %d (%d,%d) (%d,%d)\n", k, mv_sbtmvp[0], mv_sbtmvp[1], qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu);
					}
#endif
					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < sub_h; i++)
					{
						for (int j = 0; j < sub_w; j++)
						{
							pred_y[h + i][w + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]
#if DEBUG_CU
							if (isProblem)
							{
								printf("%d,", pred_tmp[i][j]);
							}
#endif
						}
#if DEBUG_CU
						if (isProblem)
						{
							printf("\n");
						}
#endif
					}

					/*FILE* sbtmvp = fopen("sbtmvp.csv", "w");
					for (int i = 0; i < 64; i++) {
						for (int j = 0; j < 64; j++) {
							pel curr = pred[i * 64 + j];
							fprintf(sbtmvp, "%d, ", (int)curr);
						}
						fprintf(sbtmvp, "\n");
					}
					fclose(sbtmvp);*/
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}

#if DEBUG_CU
			if (isProblem == 1)
				isProblem = 0;
#endif
				}
		else {
#endif
			if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
				(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
			{
#if MD_PRINT
				if (mode_type == MODE_SKIP)
					printf("<MODE_SKIP> ");
				else if (mode_type == MODE_INTER)
					printf("<MODE_INTER> ");
				else if (mode_type == MODE_DIR)
					printf("<MODE_DIR> ");
				printf("out of ref0 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
				printf("mv=(");
				printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
				printf(")\n ");
#if ENABLE_BFRAME
				printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
					cur_refw_idx,
					CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
					CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
				);
				printf("\n");
#endif 
				printf("\n");
#ifndef __SYNTHESIS__
				fflush(stdout);
#endif //__SYNTHESIS__
#endif
				return FALSE;
			}

			get_pred_y_32(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
				cur_refw_idx,
#endif // ENABLE_BFRAME
				pred_y);
#if SUB_TMVP
		}
#endif
		//++bidx;
		ref0_valid = 1;
				}
#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	static pel pred_ref1[32][32];
	if (REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred)[32] = bidx ? pred_snd : pred_y;
		//ref_pic = refp[refi[REFP_1]][REFP_1].pic;
		if (x_ext + (mv[REFP_1][0]) < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + (mv[REFP_1][1]) < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + (mv[REFP_1][0]) + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + (mv[REFP_1][1]) + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[1]);
		int dx = qpel_gmv_x & 0x3;
		int dy = qpel_gmv_y & 0x3;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		S2 cur_refw_idx = get_ref_idx_y(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][0][0]) << 2) + (((int)CtrPosSKIP_ref1[0][0][1]) << 2)));
		qpel_gmv_y_of_refp_cu = qpel_gmv_y - (cur_refw_idx == 0 ? ((((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2)) : ((((int)CtrPosSKIP_ref1[0][1][0]) << 2) + (((int)CtrPosSKIP_ref1[0][1][1]) << 2)));

		//if (channel != CHANNEL_C)
		//{
		//if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < SWH)) { return FALSE; }
		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + w + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + h + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			if (mode_type == MODE_SKIP)
				printf("<MODE_SKIP> ");
			else if (mode_type == MODE_INTER)
				printf("<MODE_INTER> ");
			else if (mode_type == MODE_DIR)
				printf("<MODE_DIR> ");
			printf("out of ref1 window ERROR: cu=(%d %d %d %d)", x, y, w, h);
			printf("mv=(");
			printf("%d %d", mv_t[MV_X], mv_t[MV_Y]);
			printf(")\n");
			printf("cur_refw_idx is %d, ctrpos_skip_ref0={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}, ctrpos_skip_ref1={PIC_DIM:[(%d, %d),(%d, %d)], RW_DIM:[(%d, %d),(%d, %d)]}",
				cur_refw_idx,
				CtrPosSKIP[0][0][0], CtrPosSKIP[0][1][0], CtrPosSKIP[1][0][0], CtrPosSKIP[1][1][0], CtrPosSKIP[0][0][1], CtrPosSKIP[0][1][1], CtrPosSKIP[1][0][1], CtrPosSKIP[1][1][1],
				CtrPosSKIP_ref1[0][0][0], CtrPosSKIP_ref1[0][1][0], CtrPosSKIP_ref1[1][0][0], CtrPosSKIP_ref1[1][1][0], CtrPosSKIP_ref1[0][0][1], CtrPosSKIP_ref1[0][1][1], CtrPosSKIP_ref1[1][0][1], CtrPosSKIP_ref1[1][1][1]
			);
			printf("\n");
#ifndef __SYNTHESIS__
			fflush(stdout);
#endif //__SYNTHESIS__
#endif
			return FALSE;
		}

		//pel(*pred)[32] = bidx ? pred_snd : pred_y;
		get_pred_y_32(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref, cur_refw_idx, pred_ref1);

		//}

//		if (channel != CHANNEL_L)
//		{
//#if CHROMA_NOT_SPLIT
//			assert(w >= 8 && h >= 8);
//#endif
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->u, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[U_C], w >> 1, h >> 1, bit_depth);
//			com_mc_c(mv[REFP_1][0], mv[REFP_1][1], ref_pic->v, qpel_gmv_x, qpel_gmv_y, ref_pic->stride_chroma, pred_stride >> 1, pred[V_C], w >> 1, h >> 1, bit_depth);
//		}
		//bidx++;
		ref1_valid = 1;
		}

	if (ref0_valid && ref1_valid)
	{
		//if (channel != CHANNEL_C)
		//{
#if SIMD_MC
		average_16b_no_clip_sse(pred_y[0], pred_snd[0], pred_y[0], 32, 32, 32, w, h);
#else
		//pel(*p0)[32] = pred_y;
		//pel(*p1)[32] = pred_snd;
		for (int j = 0; j < h; j++)
		{
			for (int i = 0; i < w; i++)
			{
				pred_y[j][i] = (pred_y[j][i] + pred_ref1[j][i] + 1) >> 1;
			}
		}
#endif
		//}

//		if (channel != CHANNEL_L)
//		{
//#if SIMD_MC
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			average_16b_no_clip_sse(pred_buf[U_C], pred_snd[U_C], pred_buf[U_C], pred_stride, pred_stride, pred_stride, w, h);
//			average_16b_no_clip_sse(pred_buf[V_C], pred_snd[V_C], pred_buf[V_C], pred_stride, pred_stride, pred_stride, w, h);
//#else
//			p0 = pred_buf[U_C];
//			p1 = pred_snd[U_C];
//			p2 = pred_buf[V_C];
//			p3 = pred_snd[V_C];
//			w >>= 1;
//			h >>= 1;
//			pred_stride >>= 1;
//			for (j = 0; j < h; j++)
//			{
//				for (i = 0; i < w; i++)
//				{
//					p0[i] = (p0[i] + p1[i] + 1) >> 1;
//					p2[i] = (p2[i] + p3[i] + 1) >> 1;
//				}
//				p0 += pred_stride;
//				p1 += pred_stride;
//				p2 += pred_stride;
//				p3 += pred_stride;
//			}
//#endif
//		}
	}
	else
	{
		if (ref0_valid)
		{
			/////
		}
		else if (ref1_valid)
		{
			for (int j = 0; j < h; j++)
			{
				for (int i = 0; i < w; i++)
				{
					pred_y[j][i] = pred_ref1[j][i];
				}
			}
		}
		else
		{
#if MD_PRINT
			printf("%s:%d:all refs are invalid\n", __FUNCTION__, 7922);
#endif
		}
	}
#endif
	return 1;
#endif//MD_KERNEL_32_YHY
}

BOOL rdo_mc_y_32(u8 mode_type,
	S14 CtrPosSKIP[2][2][2], Arbitor& ref,
	int x_pos, int y_pos, int cu_width, int cu_height,
	s16 mv[2][2], s16 mv_t[2][2], U11 stride, U4 bit_depth, U2 channel,
#if ENABLE_BFRAME
	U1 lidx,
#endif
	pel pred_y[32][32]
#if SUB_TMVP
	, U13 pic_w, U13 pic_h, u8 rdo_idx, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	int x = x_pos;
	int y = y_pos;
	int w = cu_width;
	int h = cu_height;

	if (mode_type == 0)
	{
		int dx;
		int dy;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;

		int qpel_gmv_x;
		int qpel_gmv_y;
		qpel_gmv_x = (x << 2) + ((int)mv_t[0][0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[0][1]);
		int qpel_gmv_x_of_refp_cu = qpel_gmv_x - (((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2);
		int qpel_gmv_y_of_refp_cu = qpel_gmv_y - (((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2);
		dx = qpel_gmv_x & 0x3;
		dy = qpel_gmv_y & 0x3;

		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			y_offset_min = 0;
		}
		else {
			x_offset_min = -3;
			y_offset_min = -3;
		}
		x_offset_max = 4;
		y_offset_max = 4;

		if (!((qpel_gmv_x_of_refp_cu >> 2) + x_offset_min >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu_width + x_offset_max <= (160 + 4) &&
			(qpel_gmv_y_of_refp_cu >> 2) + y_offset_min >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu_height + y_offset_max <= (128 + 4)))
		{
#if MD_PRINT
			printf("Error: cu=(%d %d %d %d)",
				x_pos,
				y_pos,
				cu_width,
				cu_height
			);
			printf("mv=(");
			printf("%d %d", mv_t[REFP_0][MV_X], mv_t[REFP_0][MV_Y]);
			printf(") ");
			printf("\n");
			fflush(stdout);
#endif

			return FALSE;
		}
#if SUB_TMVP

		int min_clip[2];
		int max_clip[2];
		min_clip[0] = (-(1 << 7) - 4) << 2;
		min_clip[1] = (-(1 << 7) - 4) << 2;
		max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
		max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;

		if (rdo_idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE)
		{
			int x = x_pos;
			int y = y_pos;
			int sub_w = cu_width / SBTMVP_NUM_1D;
			int sub_h = cu_height / SBTMVP_NUM_1D;
			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp[32][32];
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + w;
					y = tmp_y + h;

					int x_ext = x << 2;
					int y_ext = y << 2;
					int w_ext = sub_w << 2;
					int h_ext = sub_h << 2;

					int mv_sbtmvp[2];
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];
					int x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
					int y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);

					if (x_ext + (mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + (mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + (mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + (mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}

					int qpel_gmv_x_of_ctu = x_ext_of_ctu + (mv_sbtmvp[0]);
					int qpel_gmv_y_of_ctu = y_ext_of_ctu + (mv_sbtmvp[1]);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
					qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);
					if (!((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + sub_w + 4 <= SWW && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 &&
						(qpel_gmv_y_of_refp_cu >> 2) + sub_h + 4 <= SWH)) {
						return FALSE;
					}

					get_pred_y_32(sub_w, sub_h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref,
#if ENABLE_BFRAME
						0,
#endif // ENABLE_BFRAME
						pred_tmp);

					//copy pred_tmp to pred output
					//int offset = h * 64 + w;
					for (int i = 0; i < sub_h; i++)
					{
						for (int j = 0; j < sub_w; j++)
						{
							pred_y[h + i][w + j] = pred_tmp[i][j];//[offset + i * 64 + j]  [i * 64 + j]

						}

					}

				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}

			}

		}
		else {
#endif
		get_pred_y_32(w, h, qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, dx, dy, ref, 
#if ENABLE_BFRAME
			0,
#endif // ENABLE_BFRAME
			pred_y);
#if SUB_TMVP
		}
#endif
	}
	else if (mode_type == 1)
	{
		int qpel_gmv_x;
		int qpel_gmv_y;
		int fme = 0;
		int out = 0;
		int dx;
		int dy;
		int x_offset_min = 0;
		int x_offset_max = 0;
		int y_offset_min = 0;
		int y_offset_max = 0;
		/* forward */
#if ENABLE_BFRAME
		qpel_gmv_x = (x << 2) + ((int)mv_t[lidx][0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[lidx][1]);
#else
		qpel_gmv_x = (x << 2) + ((int)mv_t[0][0]);
		qpel_gmv_y = (y << 2) + ((int)mv_t[0][1]);
#endif
		int qpel_gmv_x_of_refp_cu_32 = qpel_gmv_x - (((int)CtrPosSKIP[0][0][0]) << 2) + (((int)CtrPosSKIP[0][0][1]) << 2);
		int qpel_gmv_y_of_refp_cu_32 = qpel_gmv_y - (((int)CtrPosSKIP[0][1][0]) << 2) + (((int)CtrPosSKIP[0][1][1]) << 2);
		dx = qpel_gmv_x & 0x3;
		dy = qpel_gmv_y & 0x3;
		if (dx == 0 && dy == 0) {
			x_offset_min = 0;
			x_offset_max = 0;
			y_offset_min = 0;
			y_offset_max = 0;
			fme = 0;
		}
		else if (dx != 0 && dy == 0) {
			x_offset_min = -3;
			x_offset_max = 4;
			y_offset_min = 0;
			y_offset_max = 0;
			fme = 1;
		}
		else if (dx == 0 && dy != 0) {
			x_offset_min = 0;
			x_offset_max = 0;
			y_offset_min = -3;
			y_offset_max = 4;
			fme = 1;
		}
		else {
			x_offset_min = -3;
			x_offset_max = 4;
			y_offset_min = -3;
			y_offset_max = 4;
			fme = 1;
		}
#if MD_PRINT
#endif

#if ENABLE_BFRAME
		get_pred_y_32(w, h, qpel_gmv_x_of_refp_cu_32, qpel_gmv_y_of_refp_cu_32, dx, dy, ref, lidx, pred_y);
#else
		get_pred_y_32(w, h, qpel_gmv_x_of_refp_cu_32, qpel_gmv_y_of_refp_cu_32, dx, dy, fme2mdrefbuf, pred_y);
#endif
	}

	return 1;
}

void array_cp_pred(pel src[32][32], pel dst1[32][32], pel dst2[32][32])
{
	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < 32; j++) {
#pragma HLS UNROLL
			dst1[i][j] = src[i][j];
			dst2[i][j] = src[i][j];
		}
	}
}

BOOL com_mc_y_32(u8 mode_type, CU_POS* cu, U13 pic_w, U13 pic_h, S3 refi[2], s16 mv[2][2], U10 stride_luma, 
	pel pred_y[32][32], U4 bit_depth, U2 channel, 
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS], Arbitor& ref
#if ENABLE_BFRAME
	, U1 lidx
#endif
#if SUB_TMVP
	, u8 rdo_idx, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	int scup = cu->scup;
	int x = cu->x_pos;
	int y = cu->y_pos;
	int w = cu->cu_width;
	int h = cu->cu_height;
	s16 mv_t[2][2];
	int mc_flag = 1;
	int qpel_gmv_x_of_refp_cu = 0;
	int qpel_gmv_y_of_refp_cu = 0;

	mv_clip_1(x, y, pic_w, pic_h, w, h, refi, mv, mv_t);

	if ((mode_type == 0 || mode_type == 1) && ((refi[0]) >= 0)) {
		if (!rdo_mc_y_32(mode_type, 
			CtrPosSKIP, ref,
			x, y, w, h, mv, mv_t, stride_luma, bit_depth, channel, 
#if ENABLE_BFRAME
			lidx,
#endif // ENABLE_BFRAME
			pred_y
#if SUB_TMVP
			, pic_w, pic_h, rdo_idx, core_sbtmvp
#endif
		))
			return FALSE;
	}
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3213);
#endif
	}
	return 1;
}

BOOL mc_skip_y_32(MD_COM_MODE* mod_info_curr, 
	U13 pic_width, U13 pic_height, pel pred_cache[32][32], U4 bit_depth, strFetch_ref_window* Fetch_Ref_window_ptr,
	S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], 
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	Arbitor& ref
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int mode_idx
#endif
)
{
	{
		CU_POS cu = { (int)mod_info_curr->scup, mod_info_curr->x_pos, mod_info_curr->y_pos, mod_info_curr->cu_width, mod_info_curr->cu_height };
		if (!com_mc_cu_y_32(&cu, pic_width, pic_height, mod_info_curr->refi, mod_info_curr->mv,
			SWW, pred_cache, bit_depth, Fetch_Ref_window_ptr,
			CtrPos2MD, 
#if ENABLE_BFRAME
			CtrPosSKIP_ref1,
#endif // ENABLE_BFRAME
			ref
			, MODE_SKIP
#if SUB_TMVP
			, core_sbtmvp, mode_idx, mod_info_curr->umve_flag
#endif		
		))
		{
			return FALSE;
		}
	}
	return 1;
}

BOOL derive_mode_info_32(int idx, SKIP_RDO* skip, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge, MD_KERNEL_MODE_32* mod_info_curr)
{

	if (idx < skip->num_rdo) {
		int skip_idx = idx;
		mod_info_curr->umve_flag = skip_rdo_mode[skip_idx].umve_flag;
		mod_info_curr->umve_idx = skip_rdo_mode[skip_idx].umve_idx;
		mod_info_curr->affine_flag = skip_rdo_mode[skip_idx].affine_flag;
		mod_info_curr->skip_idx = skip_rdo_mode[skip_idx].skip_idx;
		mod_info_curr->mv[0][0] = skip_rdo_mode[skip_idx].mvp[REFP_0][MV_X];
		mod_info_curr->mv[0][1] = skip_rdo_mode[skip_idx].mvp[REFP_0][MV_Y];
		mod_info_curr->refi[0] = skip_rdo_mode[skip_idx].refi[REFP_0];
#if ENABLE_BFRAME
		mod_info_curr->mv[1][0] = skip_rdo_mode[skip_idx].mvp[REFP_1][MV_X];
		mod_info_curr->mv[1][1] = skip_rdo_mode[skip_idx].mvp[REFP_1][MV_Y];
		mod_info_curr->refi[1] = skip_rdo_mode[skip_idx].refi[REFP_1];
#else
		mod_info_curr->mv[1][0] = 0;
		mod_info_curr->mv[1][1] = 0;
		mod_info_curr->refi[1] = -1;
#endif
		mod_info_curr->cu_mode = 3;
		// skip index 1 and 2 for P slice
	}
	return 1;
}


BOOL make_skip_resi_32(U5 idx, SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo, MD_KERNEL_MODE_32* mod_info_curr)
{
	if (!derive_mode_info_32(idx, skip_rdo, skip_rdo_mode, merge_rdo, mod_info_curr)) {
		return 0;
	}
	return 1;
}

void fme_set_mv_refi_32(s16* mv, s16* mvd, s16 mv_all[2][5][2], s16 mvp_all[2][5][2],
	MD_KERNEL_MODE_32* mod_info_curr, int best_refi, u8 curr_mvr, int lidx)
{
	s8 t0, t1;
	// best_refi is fixed to 0.
	mv[0] = mv_all[best_refi][curr_mvr][0];
	mv[1] = mv_all[best_refi][curr_mvr][1];
	//mvp = mvp_scale[lidx][best_refi];
	t0 = (lidx == 0) ? best_refi : -1;
	t1 = (lidx == 1) ? best_refi : -1;
	mod_info_curr->refi[0] = t0;
	mod_info_curr->refi[1] = t1;
	//refi_L0L1[lidx] = best_refi;
	mv[0] = mv[0] >> curr_mvr << curr_mvr;
	mv[1] = mv[1] >> curr_mvr << curr_mvr;
	mvd[0] = mv[0] - mvp_all[best_refi][curr_mvr][0];
	mvd[1] = mv[1] - mvp_all[best_refi][curr_mvr][1];

	int amvr_shift = curr_mvr;
	mvd[0] = mvd[0] >> amvr_shift << amvr_shift;
	mvd[1] = mvd[1] >> amvr_shift << amvr_shift;
	int mv_x = mvd[0] + mvp_all[best_refi][curr_mvr][0];
	int mv_y = mvd[1] + mvp_all[best_refi][curr_mvr][1];
	mv[0] = (-32768) > (32767 < mv_x ? 32767 : mv_x) ? (-32768) : (32767 < mv_x ? 32767 : mv_x);
	mv[1] = (-32768) > (32767 < mv_y ? 32767 : mv_y) ? (-32768) : (32767 < mv_y ? 32767 : mv_y);

}

void derive_mv_range_com_32(s16 mv_com, S14 ctrpos[2][2][2], s16 mv_clip_range[RANGE_NUM], int cu_size_dir, int pos_father, int pos, BOOL chroma_motion, int cur_mvr, u8 mv_dir)
{


	int mv_x = mv_com + (pos << 2);

	int offset_min, offset_max;

	int pattern = mv_x & 0x3;

	if (pattern == 0 || cur_mvr >= 2) {
		offset_min = 0;
		offset_max = 0;
	}
	else {
		offset_min = -3;
		offset_max = 4;
	}

	mv_clip_range[RANGE_MIN] = ctrpos[RANGE_MIN][mv_dir][PIC_DIM] - offset_min - pos;

	mv_clip_range[RANGE_MAX] = ctrpos[RANGE_MAX][mv_dir][PIC_DIM] - cu_size_dir - offset_min - pos;
}


int mv_inbound_clip_mvr_32(s16 mv[MV_D], s16 mv_clip[MV_D], s16 mvp[MV_D], S14 ctrpos[2][2][2], int cu_width, int cu_height, int x_father, int y_father, int x_pos, int y_pos, BOOL chroma_motion, int cur_mvr, int bits = 2) {


	s16 mv_clip_range[MV_D][RANGE_NUM];
	s16 mv_temp[MV_D];
	u8 mv_dir;
	int cu_size[MV_D] = { cu_width, cu_height };
	int pos[MV_D] = { x_pos, y_pos };
	int father_pos[MV_D] = { x_father, y_father };


	for (mv_dir = 0; mv_dir < MV_D; mv_dir++)
	{
		derive_mv_range_com_32(mv[mv_dir], ctrpos, mv_clip_range[mv_dir], cu_size[mv_dir], father_pos[mv_dir], pos[mv_dir], chroma_motion, cur_mvr, mv_dir);

		mv_temp[mv_dir] = COM_CLIP3(mv_clip_range[mv_dir][RANGE_MIN], mv_clip_range[mv_dir][RANGE_MAX], mv[mv_dir]);

		derive_mv_range_com_32(mv_temp[mv_dir], ctrpos, mv_clip_range[mv_dir], cu_size[mv_dir], father_pos[mv_dir], pos[mv_dir], chroma_motion, cur_mvr, mv_dir);

		mv_clip[mv_dir] = mv_temp[mv_dir];
	}
	return 1;
}

int pinter_fme_all_cu_pred_32(int x_pos, int y_pos, U12 x_chroma, U12 y_chroma, BOOL chroma_motion, s8 refi_cur,
	int curr_mvr, int lidx, int cu_width, int cu_height, s16 mvp_all[REFP_NUM][MAX_NUM_MVR][MV_D],
	s16 mv_all[REFP_NUM][MAX_NUM_MVR][MV_D], int me_level, int best_mv_uni_inner[REFP_NUM][MAX_NUM_ACTIVE_REF_FRAME][MV_D],
	S14 sub_pel_mv[MV_D]
#if ENABLE_BFRAME
	, u8 num_refp_cnt
#endif
	)
{

#if ENABLE_BFRAME
	for (refi_cur = 0; refi_cur < num_refp_cnt; refi_cur++)
#else
	for (refi_cur = 0; refi_cur < 1; refi_cur++)
#endif
	
	{
#pragma HLS LOOP_TRIPCOUNT max=2
		if (me_level > 1 && (curr_mvr == 0 || curr_mvr == 1)) {
			mv_all[refi_cur][curr_mvr][MV_X] = sub_pel_mv[MV_X];
			mv_all[refi_cur][curr_mvr][MV_Y] = sub_pel_mv[MV_Y];
		}

		if (curr_mvr < MAX_NUM_AFFINE_MVR) {
			best_mv_uni_inner[lidx][refi_cur][MV_X] = mv_all[refi_cur][curr_mvr][MV_X];
			best_mv_uni_inner[lidx][refi_cur][MV_Y] = mv_all[refi_cur][curr_mvr][MV_Y];
		}
	}

	return 0;
}

BOOL analyze_me_uni_pred_32(MD_KERNEL_MODE_32* mod_info_curr, MD_INPUT* md_input_ptr,
	u8 curr_mvr, U7 cu_width, U7 cu_height, s16 mvp_all[2][5][2], s16 mv_all[2][5][2],
	int best_mv_uni_inner[2][4][2],
	U7 stride_org,
	s8 refi_cur, U2 tree_status, U2 ctx_cons_pred_mode,
	S14 sub_pel_mv[MV_D],
	MD_KERNEL_INPUT_32* md_kernel_input, U4 bit_depthpel
#if ENABLE_BFRAME
	, MV_DIR* mv_dir, u8 num_refp_cnt
#endif
	)
{

#if ENABLE_BFRAME
	int lidx = mv_dir->lidx;
	int best_refi = mv_dir->cur_refi;
#else
	int lidx = 0;
	int best_refi = 0;
#endif
	int me_level = 3;
	int is_intra = 0;
	mod_info_curr->cu_mode = 1;
	mod_info_curr->affine_flag = 0;
	//S14* mv;
	//s16* mvd;
	//mv = mod_info_curr->mv[lidx];
	//mvd = mod_info_curr->mvd[lidx];

	init_inter_data_32(mod_info_curr);

#if ENABLE_BFRAME
	if (best_refi != 0 || lidx != 0)
	{
		best_refi = pinter_fme_all_cu_pred_32(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv, num_refp_cnt);
		if (best_refi < 0) { return FALSE; }
		best_refi = mv_dir->cur_refi;
	}
	else
#endif
	{
		best_refi = pinter_fme_all_cu_pred_32(md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->x_chroma, md_kernel_input->y_chroma, md_kernel_input->chroma_motion,
			refi_cur, curr_mvr, lidx, cu_width, cu_height, mvp_all, mv_all, me_level,
			best_mv_uni_inner, sub_pel_mv
#if ENABLE_BFRAME
			, num_refp_cnt
#endif
		);
		if (best_refi < 0) { return FALSE; }
	}

	fme_set_mv_refi_32(mod_info_curr->mv[lidx], mod_info_curr->mvd[lidx], mv_all, mvp_all, mod_info_curr, best_refi, curr_mvr, lidx);

#if MD_PRINT && !ENABLE_BFRAME
	((int)mod_info_curr->refi[0]) >= 0
		&& !(((int)mod_info_curr->refi[1]) >= 0) ? ((void)0) :
		__assert_HLS("((mod_info_curr->refi[0]) >= 0) && !((mod_info_curr->refi[1]) >= 0)", "../separate/enc_pinter.c",
			(unsigned int)1053, __FUNCTION__);
#endif

	return TRUE;
}

#if 0
static void limit_inter_rdo_num_32(RDOQ_MODEL* model_cnt, U3 max_rdo_num, U5 all_inter_mode_num, MD_FW* md_fw_ptr, ENC_ME_LINE_MAP* me_line_map_ptr,
	ENC_ME_NEB_INFO inner_nebs[2][SCU_IN_LCU_NUMS_LEN][SCU_IN_LCU_NUMS_LEN], ENC_ME_NEB_INFO above_nebs_line[ABOVE_LINE_LEN],
	s64 cost_best_temp[1 + 17],
	MD_INPUT* md_input_ptr, u8 num_refp_cnt, U7 cu_width, U7 cu_height, s16 mvp_all[2][5][2],
	s16 mv_all[2][5][2], u32 mecost_all[2][5], pel RefWindowLCU[SWW * SWH], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS],
	MD_COM_MODE mod_info_curr_ptr[17 + 1], COM_PART_INFO mod_info_curr_pb_info[17 + 1], COM_PART_INFO mod_info_curr_tb_info[17 + 1], s64 dist_pred[17 + 1], pel* org_y, U7 stride_org, int bit_cnt, s8 refi_cur, pel p_fenc_LCU_Y[MAX_CU_SIZE_FETCH][MAX_CU_SIZE_FETCH],
	SKIP_RDO skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo,
	U3 cu_width_log2, U3 cu_height_log2, s16 resi_t[17 + 1][32][32], U2 tree_status, U2 ctx_cons_pred_mode, U1 valid_flag[1], U1 valid_mode[17], S14 sub_pel_mv[MV_D], pel pred_cache[17 + 1][32][32])
{
	int best_mv_uni_inner[2][4][2];
	s64 dist_pred_all[30] = { 0 };
	for (U5 mode_idx = 0; mode_idx < all_inter_mode_num; mode_idx++) {

		analyze_uni_pred_32(model_cnt, md_fw_ptr, me_line_map_ptr, inner_nebs, above_nebs_line, &cost_best_temp[1 + mode_idx], md_input_ptr,
			cu_width, cu_height, mvp_all, mv_all, mecost_all, best_mv_uni_inner, RefWindowLCU, CtrPos, &mod_info_curr_ptr[0],
			&dist_pred[1 + mode_idx], org_y, stride_org, bit_cnt, (int)refi_cur, p_fenc_LCU_Y,
			mode_idx, skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2, resi_t[1 + mode_idx], tree_status, ctx_cons_pred_mode, valid_flag, valid_mode, sub_pel_mv, pred_cache[1 + mode_idx]);

		if (valid_flag[0])
		{
			copy_md_com_mode_info(&mod_info_curr_ptr[0], &mod_info_curr_ptr[1 + mode_idx]);
			copy_md_com_part_info(&mod_info_curr_pb_info[0], &mod_info_curr_pb_info[1 + mode_idx]);
			copy_md_com_part_info(&mod_info_curr_tb_info[0], &mod_info_curr_tb_info[1 + mode_idx]);
		}

		if (valid_flag[0] == 1)
		{
			dist_pred_all[mode_idx] = dist_pred[1 + mode_idx];
			valid_mode[mode_idx] = 1;

		}
		else
		{
			dist_pred_all[mode_idx] = MAX_S64;
			valid_mode[mode_idx] = 0;
		}
	}

	choose_inter_rdo_mode(max_rdo_num, all_inter_mode_num, dist_pred_all, valid_mode);
}
#endif

static int get_md_rdo_num_32(U3 qt_depth)
{
	int max_rdo_num = 5;

	if (qt_depth == 2)
	{
		max_rdo_num = 3;
	}

	return max_rdo_num;
}

static void get_IP_pixel_32(U8 w, U8 h, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, U2 ch_type, pel left[2 * 32 + 3], pel up[2 * 32 + 3], U14 x, U14 y,
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16,
	IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16)
{
	int i;
	int j;
	int width_in_scu = ch_type == 0 ? w >> 2 : w >> (2 - 1);
	int height_in_scu = ch_type == 0 ? h >> 2 : h >> (2 - 1);
	//4
	U4 unit_size = ch_type == 0 ? 1 << 2 : 1 << 2 >> 1;
	U2 unit_size_bit = ch_type == 0 ? 2 : 1;
	//x/4
	int x_scu = ((ch_type == 0 ? x : x << 1)) >> 2;
	//y/4
	int y_scu = ((ch_type == 0 ? y : y << 1)) >> 2;
	//number of padding pixel in the left column   64
	int pad_le = h;
	//number of padding pixel in the upper row     64
	int pad_up = w;
	//16
	int pad_le_in_scu = height_in_scu;
	//16
	int pad_up_in_scu = width_in_scu;
	int pic_x = x % 64;
	int pic_y = y % 64;
	s16 pic_x_scu = (pic_x >> 2);
	s16 pic_y_scu = (pic_y >> 2);
	int flag;

	S7 ip_array_size_idx = get_ip_array_size_idx(w, h);
#if MD_PRINT
	assert(ip_array_size_idx != -1);
#endif

	if (w == 32 && h == 32)
	{
		IP_buffer_ptr_32x32->const_up(up, IP_map_scu_ptr_32x32, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_32x32->const_left(left, IP_map_scu_ptr_32x32, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_32x32->const_top_left(up, left, avail_cu);
	}
	else if (w == 32 && h == 16)
	{
		IP_buffer_ptr_32x16->const_up(up, IP_map_scu_ptr_32x16, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_32x16->const_left(left, IP_map_scu_ptr_32x16, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_32x16->const_top_left(up, left, avail_cu);
	}
	else if (w == 16 && h == 32)
	{
		IP_buffer_ptr_16x32->const_up(up, IP_map_scu_ptr_16x32, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_16x32->const_left(left, IP_map_scu_ptr_16x32, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_16x32->const_top_left(up, left, avail_cu);
	}

#if CDEBUG
	if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		if (pic_y == 0) {
			for (i = 0; i < w; i++) {
				assert(up[i + 3] == IP_buffer_ptr->up_temp_size[ip_array_size_idx][pic_x + i]);
			}
			for (i = 0; i < pad_up_in_scu; i++) {

				if (x_scu + width_in_scu + i < pic_width_in_scu) {
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_above_line[MAP_SCU_IP_ptr->above_line_idx][x_scu + width_in_scu + i] >> 31 & ((
						unsigned int)1)));
				}
				else {
					flag = 0;
				}
				if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
					for (j = 0; j < unit_size; j++) {

						assert(up[w + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->up_temp_size[ip_array_size_idx][pic_x + w + (i << unit_size_bit) + j]);
					}
				}
				else {
					for (j = 0; j < unit_size; j++) {

						assert(up[w + (i << unit_size_bit) + j + 3] == up[w + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
		else {
			for (i = 0; i < w; i++) {

				assert(up[i + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + i]);

			}
			for (i = 0; i < pad_up_in_scu; i++) {

				if (pic_x_scu + width_in_scu + i < 16) {
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu + width_in_scu + i][pic_y_scu - 1]
						>> 31 & ((unsigned int)1)));
				}
				else {
					flag = 0;
				}
				if (x_scu + width_in_scu + i < pic_width_in_scu && flag) {
					for (j = 0; j < unit_size; j++) {


						assert(up[w + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x + w + (i << unit_size_bit) + j]);
					}
				}
				else {
					for (j = 0; j < unit_size; j++) {

						assert(up[w + (i << unit_size_bit) + j + 3] == up[w + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
	}
	if ((((int)avail_cu) & 1 << 1) == 1 << 1)
	{
		if (pic_x == 0)
		{
			for (i = 0; i < h; i++)
			{

				assert(left[i + 3] == IP_buffer_ptr->left_size[ip_array_size_idx][pic_y + i]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{

				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[1 - MAP_SCU_IP_ptr->curr_ctu_idx][15][pic_y_scu + height_in_scu + i] >> 31
						& ((unsigned int)1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{

						assert(left[h + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->left_size[ip_array_size_idx][pic_y + h + (i << unit_size_bit) + j]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{

						assert(left[h + (i << unit_size_bit) + j + 3] == left[h + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
		else
		{
			for (i = 0; i < h; i++)
			{

				assert(left[i + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][pic_y + i][(pic_x >> 2) - 1]);
			}
			for (i = 0; i < pad_le_in_scu; i++)
			{

				if (pic_y_scu + height_in_scu + i < 16)
				{
					flag = ((int)(MAP_SCU_IP_ptr->map_scu_inner[MAP_SCU_IP_ptr->curr_ctu_idx][pic_x_scu - 1][pic_y_scu + height_in_scu + i]
						>> 31 & ((unsigned int)1)));
				}
				else
				{
					flag = 0;
				}
				if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
				{
					for (j = 0; j < unit_size; j++)
					{

						assert(left[h + (i << unit_size_bit) + j + 3] == IP_buffer_ptr->left_innerLB_size[ip_array_size_idx][h + (i << unit_size_bit) + j + pic_y][(pic_x >> 2) - 1]);
					}
				}
				else
				{
					for (j = 0; j < unit_size; j++)
					{

						assert(left[h + (i << unit_size_bit) + j + 3] == left[h + (i << unit_size_bit) + 2]);
					}
				}
			}
		}
	}
	if ((((int)avail_cu) & 1 << 2) == 1 << 2)
	{
		if (pic_y == 0 && pic_x == 0)
		{
			assert(up[2]  == ((pel)(IP_buffer_ptr->top_left)));
		}
		else if (pic_y == 0)
		{
			assert(up[2] == IP_buffer_ptr->up_temp_size[ip_array_size_idx][pic_x - 1]);
		}
		else if (pic_x == 0)
		{
			assert(up[2] == IP_buffer_ptr->left_size[ip_array_size_idx][pic_y - 1]);
		}
		else
		{
			assert(up[2] == IP_buffer_ptr->up_innerLB_size[ip_array_size_idx][(pic_y >> 2) - 1][pic_x - 1]);
		}
	}
#endif // CDEBUG

	up[1] = left[3];
	left[1] = up[3];
	up[0] = left[4];
	left[0] = up[4];
}


static int get_rmd_result_32(U3 cu_width_log2, U3 cu_heght_log2, U13 x, U13 y, u8 ipred_list[], 
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE]
	, U8 speed_level
#else
	u8 rmd_mode[IPD_RDO_CNT]
#endif
#if EIPM
	, int eipm_enable_flag
#endif
)
{
	int i;
	int w = cu_width_log2 - 2;
	int h = cu_heght_log2 - 2;
	int x0 = x >> 2;
	int y0 = y >> 2;
	int idx = get_g_map_idx(w, h, x0, y0);
	//int cnt = ((((cu_width_log2 - cu_heght_log2) >= 2) || ((cu_heght_log2 - cu_width_log2) >= 2)) ? (IPD_RDO_CNT - 1) : IPD_RDO_CNT);
#if USE_SPEED_LEVEL
	int cnt = IPD_RDO_CNT;
	if (speed_level == 1)
		cnt = IPD_RDO_CNT; //5
	else if (speed_level == 2)
		cnt = EXTRA_RDO_MODE;//10
	else
		cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
	int cnt = IPD_RDO_CNT;
#endif
#if EIPM && !USE_EIPM_RMD
	if (eipm_enable_flag)
	{
		for (int i = 0; i < IPD_RDO_CNT; i++)
		{
			if (rmd_mode[i] >= 3 && rmd_mode[i] <= 31)
			{
				if (rmd_mode[i] == 3)
				{
					ipred_list[5] = 34;
				}
				else if (rmd_mode[i] > 3 && rmd_mode[i] <= 11)
				{
					ipred_list[5] = rmd_mode[i] + 30;
					ipred_list[6] = rmd_mode[i] + 31;
				}
				else if (rmd_mode[i] == 12)
				{
					ipred_list[5] = 43;
					ipred_list[6] = 44;
				}
				else if (rmd_mode[i] > 12 && rmd_mode[i] <= 23)
				{
					ipred_list[5] = rmd_mode[i] + 32;
					ipred_list[6] = rmd_mode[i] + 33;
				}
				else if (rmd_mode[i] == 24)
				{
					ipred_list[5] = 57;
					ipred_list[6] = 58;
				}
				else if (rmd_mode[i] > 24 && rmd_mode[i] <= 30)
				{
					ipred_list[5] = rmd_mode[i] + 34;
					ipred_list[6] = rmd_mode[i] + 35;
				}
				else
				{
					ipred_list[5] = 65;
				}
				break;
			}
		}
	}
#endif
	for (i = 0; i < cnt; i++) {
		ipred_list[i] = rmd_mode[i];
	}

	return cnt;
}

u16 com_get_avail_intra_ip_32x32(IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, U11 x_scu, U11 y_scu)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_32x32->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_32x32->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_32x32->map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x32->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}
u16 com_get_avail_intra_ip_16x32(IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, U11 x_scu, U11 y_scu)
{

#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_16x32->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_16x32->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_16x32->map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x32->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}
u16 com_get_avail_intra_ip_32x16(IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16, U11 x_scu, U11 y_scu)
{

#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16->map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_32x16->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_32x16->map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_32x16->map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x16->map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

void com_get_mpm_32x32(int x_scu, int y_scu, u8 mpm[2], MPM_ARRAY_SIZE<32, 32>* MPM_buffer_ptr_32x32, ENC_ME_LINE_MAP_SIZE<32>* me_line_ptr_32)
{
#pragma HLS INLINE off
	u8 ipm_l = 0;
	u8 ipm_u = 0;
	int valid_l = 0;
	int valid_u = 0;
	int mpm_x = x_scu % 16;
	int mpm_y = y_scu % 16;
	int pic_x_scu = mpm_x;
	int pic_y_scu = mpm_y;
	assert(pic_x_scu == mpm_x);
	assert(pic_y_scu == mpm_y);
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_32x32->left;
			valid_l = 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_32x32->left;
			valid_l = 1;
		}
	}
	if (pic_y_scu == 0) {
		if (y_scu > 0
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_32x32->up;
			valid_u = 1;
		}
	}
	else {
		if (y_scu > 0
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_32x32->up;
			valid_u = 1;
		}
	}
	mpm[0] = (ipm_l < ipm_u ? ipm_l : ipm_u);
	mpm[1] = (ipm_l > ipm_u ? ipm_l : ipm_u);
	if (mpm[0] == mpm[1]) {
		mpm[0] = 0;
		mpm[1] = ((u8)(((mpm[1]) == 0 ? 2 : (mpm[1]))));
	}
}
void com_get_mpm_16x32(int x_scu, int y_scu, u8 mpm[2], MPM_ARRAY_SIZE<16, 32>* MPM_buffer_ptr_16x32, ENC_ME_LINE_MAP_SIZE<32>* me_line_ptr_32)
{
#pragma HLS INLINE off
	u8 ipm_l = 0;
	u8 ipm_u = 0;
	int valid_l = 0;
	int valid_u = 0;
	int mpm_x = x_scu % 16;
	int mpm_y = y_scu % 16;
	int pic_x_scu = mpm_x;
	int pic_y_scu = mpm_y;
	assert(pic_x_scu == mpm_x);
	assert(pic_y_scu == mpm_y);
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_16x32->left;
			valid_l = 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_16x32->left;
			valid_l = 1;
		}
	}
	if (pic_y_scu == 0) {
		if (y_scu > 0
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_16x32->up;
			valid_u = 1;
		}
	}
	else {
		if (y_scu > 0
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_16x32->up;
			valid_u = 1;
		}
	}
	mpm[0] = (ipm_l < ipm_u ? ipm_l : ipm_u);
	mpm[1] = (ipm_l > ipm_u ? ipm_l : ipm_u);
	if (mpm[0] == mpm[1]) {
		mpm[0] = 0;
		mpm[1] = ((u8)(((mpm[1]) == 0 ? 2 : (mpm[1]))));
	}
}
void com_get_mpm_32x16(int x_scu, int y_scu, u8 mpm[2], MPM_ARRAY_SIZE<32, 16>* MPM_buffer_ptr_32x16, ENC_ME_LINE_MAP_SIZE<32>* me_line_ptr_32)
{
#pragma HLS INLINE off
	u8 ipm_l = 0;
	u8 ipm_u = 0;
	int valid_l = 0;
	int valid_u = 0;
	int mpm_x = x_scu % 16;
	int mpm_y = y_scu % 16;
	int pic_x_scu = mpm_x;
	int pic_y_scu = mpm_y;
	assert(pic_x_scu == mpm_x);
	assert(pic_y_scu == mpm_y);
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_32x16->left;
			valid_l = 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((me_line_ptr_32->map_scu_left_line[0] >> 31 & (1)))) {
			ipm_l = MPM_buffer_ptr_32x16->left;
			valid_l = 1;
		}
	}
	if (pic_y_scu == 0) {
		if (y_scu > 0
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_32x16->up;
			valid_u = 1;
		}
	}
	else {
		if (y_scu > 0
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 15 & (1)))
			&& ((me_line_ptr_32->map_scu_up_line[1] >> 31 & (1)))) {
			ipm_u = MPM_buffer_ptr_32x16->up;
			valid_u = 1;
		}
	}
	mpm[0] = (ipm_l < ipm_u ? ipm_l : ipm_u);
	mpm[1] = (ipm_l > ipm_u ? ipm_l : ipm_u);
	if (mpm[0] == mpm[1]) {
		mpm[0] = 0;
		mpm[1] = ((u8)(((mpm[1]) == 0 ? 2 : (mpm[1]))));
	}
}

void prepare_intra_info_32(U8 w, U8 h, MD_FW* md_fw_ptr, 
	ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32,
	MD_COM_MODE* mod_info_curr_ptr,
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16,
	MPM_ARRAY_SIZE<32, 32>* MPM_buffer_ptr_32x32, MPM_ARRAY_SIZE<16, 32>* MPM_buffer_ptr_16x32, MPM_ARRAY_SIZE<32, 16>* MPM_buffer_ptr_32x16,
	IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16,
	U3 cu_width_log2, U3 cu_height_log2,
	U13 pix_x, U13 pix_y, U14 sub_x, U14 sub_y, u8 ipred_list[IPRED_LIST_NUM], int* pred_cnt, pel src_le_temp[2 * 32 + 3], pel src_up_temp[2 * 32 + 3],
	u16* avail_tb, 
#if USE_SPEED_LEVEL
	u8 rmd_mode[IPD_RDO_CNT + EXTRA_RDO_MODE]
	, U8 speed_level
#else
	u8 rmd_mode[IPD_RDO_CNT]
#endif
)
{
	int pb_x_scu = mod_info_curr_ptr->x_pos >> 2;
	int pb_y_scu = mod_info_curr_ptr->y_pos >> 2;
	int tb_x_scu;
	int tb_y_scu;
	int i;
	int bit_depth;
	if (w == 32 && h == 32)
	{
		com_get_mpm_32x32(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr_32x32, me_line_map_ptr_32);
	}
	else if (w == 16 && h == 32)
	{
		com_get_mpm_16x32(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr_16x32, me_line_map_ptr_32);
	}
	else if (w == 32 && h == 16)
	{
		com_get_mpm_32x16(pb_x_scu, pb_y_scu, mod_info_curr_ptr->mpm[0], MPM_buffer_ptr_32x16, me_line_map_ptr_32);
	}
	*pred_cnt = get_rmd_result_32(cu_width_log2, cu_height_log2, pix_x, pix_y, ipred_list, rmd_mode
#if USE_SPEED_LEVEL
	, speed_level
#endif
#if EIPM
	, md_fw_ptr->eipm_enable_flag
#endif
	);

	bit_depth = md_fw_ptr->bit_depth_internal;
	tb_x_scu = sub_x >> 2;
	tb_y_scu = sub_y >> 2;
	if (w == 32 && h == 32)
	{
		*avail_tb = com_get_avail_intra_ip_32x32(IP_map_scu_ptr_32x32, tb_x_scu, tb_y_scu);
	}
	else if (w == 16 && h == 32)
	{
		*avail_tb = com_get_avail_intra_ip_16x32(IP_map_scu_ptr_16x32, tb_x_scu, tb_y_scu);
	}
	else if (w == 32 && h == 16)
	{
		*avail_tb = com_get_avail_intra_ip_32x16(IP_map_scu_ptr_32x16, tb_x_scu, tb_y_scu);
	}

	for (i = 0; i < (2 * h + 3); i++) {
		src_le_temp[i] = (1 << (bit_depth - 1));
	}
	for (i = 0; i < (2 * w + 3); i++) {
		src_up_temp[i] = (1 << (bit_depth - 1));
	}

	get_IP_pixel_32(w, h, *avail_tb, md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu, bit_depth, 0, src_le_temp, src_up_temp, sub_x, sub_y, 
		IP_buffer_ptr_32x32, IP_buffer_ptr_16x32, IP_buffer_ptr_32x16,
		IP_map_scu_ptr_32x32, IP_map_scu_ptr_16x32, IP_map_scu_ptr_32x16);
}

void derive_neb_cu_32(const U10 pic_width_in_scu, const U10 x_scu, const U10 y_scu, const U7 cu_width, const U7 cu_height,
	NEB_CU neb[NUM_SKIP_SPATIAL_MV], SKIP_MERGE_MAP_SCU neb_map[NUM_SKIP_SPATIAL_MV],
	const U32 map_scu_up_line[10], const U32 map_cu_mode_up_line[10],
	const U32 map_scu_left_line[8], const U32 map_cu_mode_left_line[8],
	const U1 curr_ctu_idx,
	const ENC_ME_NEB_INFO* up_nebs, const ENC_ME_NEB_INFO* left_nebs)
{
#pragma HLS INLINE OFF

	U5 cu_width_in_scu = cu_width >> MIN_CU_LOG2;
	U5 cu_height_in_scu = cu_height >> MIN_CU_LOG2;

	U5 x_scu_of_ctu = x_scu & (MAX_CU_IN_SCU - 1);
	U5 y_scu_of_ctu = y_scu & (MAX_CU_IN_SCU - 1);

	neb[0].x_scu_of_ctu = x_scu_of_ctu - 1;
	neb[0].y_scu_of_ctu = y_scu_of_ctu + cu_height_in_scu - 1;
	neb[1].x_scu_of_ctu = x_scu_of_ctu + cu_width_in_scu - 1;
	neb[1].y_scu_of_ctu = y_scu_of_ctu - 1;
	neb[2].x_scu_of_ctu = x_scu_of_ctu + cu_width_in_scu;
	neb[2].y_scu_of_ctu = y_scu_of_ctu - 1;
	neb[3].x_scu_of_ctu = x_scu_of_ctu - 1;
	neb[3].y_scu_of_ctu = y_scu_of_ctu;
	neb[4].x_scu_of_ctu = x_scu_of_ctu;
	neb[4].y_scu_of_ctu = y_scu_of_ctu - 1;
	neb[5].x_scu_of_ctu = x_scu_of_ctu - 1;
	neb[5].y_scu_of_ctu = y_scu_of_ctu - 1;


	for (int i = 0; i < NUM_SKIP_SPATIAL_MV; i++) {
#pragma HLS UNROLL
		S6 x = neb[i].x_scu_of_ctu;
		S6 y = neb[i].y_scu_of_ctu;
#if MD_PRINT
		assert(x >= -1 && x <= MAX_CU_IN_SCU && y >= -1 && y < MAX_CU_IN_SCU);
#endif
		if (neb[i].y_scu_of_ctu == -1) { // top, top left, top right
			neb_map[i].map_mv[REFP_0][MV_X] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_0][MV_X];
			neb_map[i].map_mv[REFP_0][MV_Y] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_0][MV_Y];
			neb_map[i].map_refi[REFP_0] = up_nebs[x - x_scu_of_ctu + 1].refi[REFP_0];
			neb_map[i].map_mv[REFP_1][MV_X] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_1][MV_X];
			neb_map[i].map_mv[REFP_1][MV_Y] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_1][MV_Y];
			neb_map[i].map_refi[REFP_1] = up_nebs[x - x_scu_of_ctu + 1].refi[REFP_1];
			neb_map[i].map_scu = map_scu_up_line[x - x_scu_of_ctu + 1];
			neb_map[i].map_cu_mode = map_cu_mode_up_line[x - x_scu_of_ctu + 1];
		}
		else if (x == MAX_CU_IN_SCU) { // right
			neb_map[i].map_mv[REFP_0][MV_X] = 0;
			neb_map[i].map_mv[REFP_0][MV_Y] = 0;
			neb_map[i].map_refi[REFP_0] = REFI_INVALID;
			neb_map[i].map_mv[REFP_1][MV_X] = 0;
			neb_map[i].map_mv[REFP_1][MV_Y] = 0;
			neb_map[i].map_refi[REFP_1] = REFI_INVALID;
			neb_map[i].map_scu = 0;
			neb_map[i].map_cu_mode = 0;
		}
		else if (x == -1) { // left
			if (i == 5)
			{
				neb_map[i].map_mv[REFP_0][MV_X] = up_nebs[0].mv[REFP_0][MV_X];
				neb_map[i].map_mv[REFP_0][MV_Y] = up_nebs[0].mv[REFP_0][MV_Y];
				neb_map[i].map_refi[REFP_0] = up_nebs[0].refi[REFP_0];
				neb_map[i].map_mv[REFP_1][MV_X] = up_nebs[0].mv[REFP_1][MV_X];
				neb_map[i].map_mv[REFP_1][MV_Y] = up_nebs[0].mv[REFP_1][MV_Y];
				neb_map[i].map_refi[REFP_1] = up_nebs[0].refi[REFP_1];
				neb_map[i].map_scu = map_scu_up_line[0];
				neb_map[i].map_cu_mode = map_cu_mode_up_line[0];
			}
			else
			{
				neb_map[i].map_mv[REFP_0][MV_X] = left_nebs[y - y_scu_of_ctu].mv[REFP_0][MV_X];
				neb_map[i].map_mv[REFP_0][MV_Y] = left_nebs[y - y_scu_of_ctu].mv[REFP_0][MV_Y];
				neb_map[i].map_refi[REFP_0] = left_nebs[y - y_scu_of_ctu].refi[REFP_0];
				neb_map[i].map_mv[REFP_1][MV_X] = left_nebs[y - y_scu_of_ctu].mv[REFP_1][MV_X];
				neb_map[i].map_mv[REFP_1][MV_Y] = left_nebs[y - y_scu_of_ctu].mv[REFP_1][MV_Y];
				neb_map[i].map_refi[REFP_1] = left_nebs[y - y_scu_of_ctu].refi[REFP_1];
				neb_map[i].map_scu = map_scu_left_line[y - y_scu_of_ctu];
				neb_map[i].map_cu_mode = map_cu_mode_left_line[y - y_scu_of_ctu];
			}
		}
		else {
			if (i == 0 || i == 3)
			{
				neb_map[i].map_mv[REFP_0][MV_X] = left_nebs[y - y_scu_of_ctu].mv[REFP_0][MV_X];
				neb_map[i].map_mv[REFP_0][MV_Y] = left_nebs[y - y_scu_of_ctu].mv[REFP_0][MV_Y];
				neb_map[i].map_refi[REFP_0] = left_nebs[y - y_scu_of_ctu].refi[REFP_0];
				neb_map[i].map_mv[REFP_1][MV_X] = left_nebs[y - y_scu_of_ctu].mv[REFP_1][MV_X];
				neb_map[i].map_mv[REFP_1][MV_Y] = left_nebs[y - y_scu_of_ctu].mv[REFP_1][MV_Y];
				neb_map[i].map_refi[REFP_1] = left_nebs[y - y_scu_of_ctu].refi[REFP_1];
				neb_map[i].map_scu = map_scu_left_line[y - y_scu_of_ctu];
				neb_map[i].map_cu_mode = map_cu_mode_left_line[y - y_scu_of_ctu];
			}
			else
			{
				neb_map[i].map_mv[REFP_0][MV_X] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_0][MV_X];
				neb_map[i].map_mv[REFP_0][MV_Y] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_0][MV_Y];
				neb_map[i].map_refi[REFP_0] = up_nebs[x - x_scu_of_ctu + 1].refi[REFP_0];
				neb_map[i].map_mv[REFP_1][MV_X] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_1][MV_X];
				neb_map[i].map_mv[REFP_1][MV_Y] = up_nebs[x - x_scu_of_ctu + 1].mv[REFP_1][MV_Y];
				neb_map[i].map_refi[REFP_1] = up_nebs[x - x_scu_of_ctu + 1].refi[REFP_1];
				neb_map[i].map_scu = map_scu_up_line[x - x_scu_of_ctu + 1];
				neb_map[i].map_cu_mode = map_cu_mode_up_line[x - x_scu_of_ctu + 1];
			}
		}
	}

	neb[0].valid_flag = x_scu > 0 && MCU_GET_CODED_FLAG(neb_map[0].map_scu) && !MCU_GET_INTRA_FLAG(neb_map[0].map_scu);
	neb[1].valid_flag = y_scu > 0 && MCU_GET_CODED_FLAG(neb_map[1].map_scu) && !MCU_GET_INTRA_FLAG(neb_map[1].map_scu);
	neb[2].valid_flag = y_scu > 0 && x_scu + cu_width_in_scu < pic_width_in_scu&& MCU_GET_CODED_FLAG(neb_map[2].map_scu) && !MCU_GET_INTRA_FLAG(neb_map[2].map_scu);
	neb[3].valid_flag = x_scu > 0 && MCU_GET_CODED_FLAG(neb_map[3].map_scu) && !MCU_GET_INTRA_FLAG(neb_map[3].map_scu);
	neb[4].valid_flag = y_scu > 0 && MCU_GET_CODED_FLAG(neb_map[4].map_scu) && !MCU_GET_INTRA_FLAG(neb_map[4].map_scu);
	neb[5].valid_flag = x_scu > 0 && y_scu > 0 && MCU_GET_CODED_FLAG(neb_map[5].map_scu) && !MCU_GET_INTRA_FLAG(neb_map[5].map_scu);
}

static void get_mvp_default_line_32(MD_FW* md_fw_ptr,
	ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32, 
	MD_COM_MODE* mod_info_curr, int refp_ptr[17][2],
	int ptr_cur, int lidx, s8 cur_refi, u8 amvr_idx, s16 mvp[2],
	ENC_ME_NEB_INFO up_nebs[1 + (32 >> 2) + 1], ENC_ME_NEB_INFO left_nebs[(32 >> 2)])
{
#pragma HLS inline off
	U23 scup = mod_info_curr->scup;
	U7 cu_width = mod_info_curr->cu_width;
	U7 cu_height = mod_info_curr->cu_height;
	U13 pic_w = md_fw_ptr->pic_width;
	U13 pic_h = md_fw_ptr->pic_height;
	U11 pic_width_in_scu = md_fw_ptr->pic_width_in_scu;
	U11 h_scu = md_fw_ptr->pic_height_in_scu;
	//s16(*map_mv)[REFP_NUM][MV_D] = pic_map->map_mv;
	//s8(*map_refi)[REFP_NUM] = pic_map->map_refi;
	//u32* map_scu = pic_map->map_scu;
	int x_scu_left = 0;
	int cnt;
	int hv;
	int ptr_cur_ref;
	int mvPredType = 3;
	s8 rFrameL;
	s8 rFrameU;
	s8 rFrameUR;
	int neb_addr[3 + 1];
	int valid_flag[3 + 1];
	s32 refi[3];
	s32 MVPs[3][2];
	int x_scu = mod_info_curr->x_scu;
	int y_scu = mod_info_curr->y_scu;
	int cu_width_in_scu = cu_width >> 2;
	int offset_in_line = 0;
	//check_mvp_motion_availability(info, mod_info_curr, pic_map, neb_addr, valid_flag, lidx);
	int i = 0;
	int use_line = 0;
	int debug = 0;
	s16 x_scu_line[5 - 1];
	s16 y_scu_line[5 - 1];
	int d_inner = 1;
	S2 refi_nebs[NEB_NUMS];
	//u32 scu_nebs[NEB_NUMS];
	s32 mv_nebs[NEB_NUMS][MV_D];

	// A
	neb_addr[0] = scup - 1;
	// B
	neb_addr[1] = scup - pic_width_in_scu;
	// C
	neb_addr[2] = scup - pic_width_in_scu + cu_width_in_scu;
	// D
	neb_addr[3] = scup - pic_width_in_scu - 1;
	valid_flag[0] = x_scu > 0;
	valid_flag[1] = y_scu > 0;
	valid_flag[2] = y_scu > 0 && x_scu + cu_width_in_scu < pic_width_in_scu;
	valid_flag[3] = x_scu > 0 && y_scu > 0;
	x_scu_line[0] = x_scu - me_line_map_ptr_32->min_scu_x - 1;
	y_scu_line[0] = y_scu - me_line_map_ptr_32->min_scu_y;
	x_scu_line[1] = x_scu - me_line_map_ptr_32->min_scu_x;
	y_scu_line[1] = y_scu - me_line_map_ptr_32->min_scu_y - 1;
	x_scu_line[2] = x_scu - me_line_map_ptr_32->min_scu_x + cu_width_in_scu;
	y_scu_line[2] = y_scu - me_line_map_ptr_32->min_scu_y - 1;
	x_scu_line[3] = x_scu - me_line_map_ptr_32->min_scu_x - 1;
	y_scu_line[3] = y_scu - me_line_map_ptr_32->min_scu_y - 1;
	if (x_scu == me_line_map_ptr_32->min_scu_x) {
		offset_in_line = y_scu - me_line_map_ptr_32->min_scu_y;
		x_scu_left = (1 << 7 >> 1 >> 2) - 1;
		// A
		neb_addr[0] = offset_in_line;
		if (valid_flag[0]) {
			refi_nebs[0] = left_nebs[0].refi[lidx];
			valid_flag[0] = ((int)(me_line_map_ptr_32->map_scu_left_line[0] >> 31 & ((
				unsigned int)1)))
				&& !((int)(me_line_map_ptr_32->map_scu_left_line[0] >> 15 & ((
					unsigned int)1)))
				&& ((int)left_nebs[0].refi[lidx]) >= 0;
			//valid_flag[0] = valid_flag[0] && MCU_GET_CODED_FLAG(me_line_ptr->map_scu_left[neb_addr[0]]) && !MCU_GET_INTRA_FLAG(me_line_ptr->map_scu_left[neb_addr[0]]) && REFI_IS_VALID(me_line_ptr->left_nebs[neb_addr[0]].refi[lidx]);
		}
		if (valid_flag[0]) {
			mv_nebs[0][0] = left_nebs[0].mv[lidx][0];
			mv_nebs[0][1] = left_nebs[0].mv[lidx][1];
		}
		//D
		if (y_scu != me_line_map_ptr_32->min_scu_y) {
			offset_in_line = y_scu - me_line_map_ptr_32->min_scu_y - 1;
			neb_addr[3] = offset_in_line;
			if (valid_flag[3]) {
				refi_nebs[3] = up_nebs[0].refi[lidx];
				valid_flag[3] = valid_flag[3]
					&& ((int)(me_line_map_ptr_32->map_scu_up_line[0] >> 31 & ((
						unsigned int)1)))
					&& !((int)(me_line_map_ptr_32->map_scu_up_line[0] >> 15 & ((
						unsigned int)1)))
					&& ((int)up_nebs[0].refi[lidx]) >= 0;
			}
			if (valid_flag[3]) {
				mv_nebs[3][0] = up_nebs[0].mv[lidx][0];
				mv_nebs[3][1] = up_nebs[0].mv[lidx][1];
			}
			d_inner = 0;
		}
	}
	else {
		if (valid_flag[0]) {
			refi_nebs[0] = left_nebs[0].refi[lidx];
			//valid_flag[0] = valid_flag[0] && MCU_GET_CODED_FLAG(map_scu[neb_addr[0]]) && !MCU_GET_INTRA_FLAG(map_scu[neb_addr[0]]) && REFI_IS_VALID(me_line_ptr->refi_nebs[0]);
			valid_flag[0] = ((int)(me_line_map_ptr_32->map_scu_left_line[0] >> 31 & ((
				unsigned int)1)))
				&& !((int)(me_line_map_ptr_32->map_scu_left_line[0] >> 15 & ((
					unsigned int)1))) && ((int)refi_nebs[0]) >= 0;
		}
		if (valid_flag[0]) {
			mv_nebs[0][0] =
				left_nebs[0].mv[lidx][0];
			mv_nebs[0][1] =
				left_nebs[0].mv[lidx][1];
		}
	}
	if (y_scu == me_line_map_ptr_32->min_scu_y) {
		offset_in_line = x_scu;
		// B
		neb_addr[1] = offset_in_line;
		// C
		neb_addr[2] = offset_in_line + cu_width_in_scu;
		// D
		neb_addr[3] = offset_in_line - 1;
		for (i = 1; i < 3 + d_inner; i++) {
#pragma HLS loop_tripcount max = 3
#pragma HLS PIPELINE
			if (valid_flag[i]) {
				refi_nebs[i] = up_nebs[neb_addr[i] - offset_in_line + 1].refi[lidx];
				valid_flag[i] = valid_flag[i]
					&& ((int)(me_line_map_ptr_32->map_scu_up_line[neb_addr[i] - offset_in_line + 1] >> 31 & ((unsigned int)1)))
					&& !((int)(me_line_map_ptr_32->map_scu_up_line[neb_addr[i] - offset_in_line + 1] >> 15 & ((unsigned int)1)))
					&& ((int)refi_nebs[i]) >= 0;
			}
			if (valid_flag[i]) {
				mv_nebs[i][0] = up_nebs[neb_addr[i] - offset_in_line + 1].mv[lidx][0];
				mv_nebs[i][1] = up_nebs[neb_addr[i] - offset_in_line + 1].mv[lidx][1];
			}
		}
	}
	else {
		for (i = 1; i < 3 + d_inner; i++) {
#pragma HLS loop_tripcount max = 3
#pragma HLS PIPELINE II=2
			if (valid_flag[i]) {
				if (x_scu_line[i] > 15 || y_scu_line[i] > 15) {
					valid_flag[i] = 0;
				}
				if (valid_flag[i])
				{
					refi_nebs[i] = up_nebs[x_scu_line[i] - (x_scu - me_line_map_ptr_32->min_scu_x) + 1].refi[lidx];
					//valid_flag[i] = valid_flag[i] && MCU_GET_CODED_FLAG(map_scu[neb_addr[i]]) && !MCU_GET_INTRA_FLAG(map_scu[neb_addr[i]]) && REFI_IS_VALID(me_line_ptr->refi_nebs[i]);
					valid_flag[i] = valid_flag[i]
						&& ((int)(me_line_map_ptr_32->map_scu_up_line[x_scu_line[i] - (x_scu - me_line_map_ptr_32->min_scu_x) + 1] >> 31 & ((
							unsigned int)1)))
						&& !((int)(me_line_map_ptr_32->map_scu_up_line[x_scu_line[i] - (x_scu - me_line_map_ptr_32->min_scu_x) + 1] >> 15 & ((
							unsigned int)1))) && ((int)refi_nebs[i]) >= 0;
				}
			}
			if (valid_flag[i]) {
				mv_nebs[i][0] =
					up_nebs[x_scu_line[i] - (x_scu - me_line_map_ptr_32->min_scu_x) + 1].mv[lidx][0];
				mv_nebs[i][1] =
					up_nebs[x_scu_line[i] - (x_scu - me_line_map_ptr_32->min_scu_x) + 1].mv[lidx][1];
			}
			/*if (valid_flag[i]){
			if(me_line_ptr->mv_nebs[i][MV_X] != map_mv[neb_addr[i]][lidx][MV_X] || me_line_ptr->mv_nebs[i][MV_Y] != map_mv[neb_addr[i]][lidx][MV_Y])
			printf("Wrong");
			}*/
		}
	}
	if (!valid_flag[2]) {
		// D
		neb_addr[2] = neb_addr[3];
		valid_flag[2] = valid_flag[3];
		refi_nebs[2] = refi_nebs[3];
		mv_nebs[2][0] = mv_nebs[3][0];
		mv_nebs[2][1] = mv_nebs[3][1];
	}
	ptr_cur_ref = refp_ptr[cur_refi][lidx];
	for (cnt = 0; cnt < 3; cnt++) {
#pragma HLS PIPELINE
		if (valid_flag[cnt]) {
			refi[cnt] = refi_nebs[cnt];
#if MD_PRINT
			((int)refi[cnt]) >= 0 ? ((void)0) : __assert_HLS("((refi[cnt]) >= 0)", "../separate/com_util.c", (unsigned int)723,
				__FUNCTION__);
#endif
			int ptr_neb_ref = refp_ptr[refi[cnt]][lidx];
			//scaling_mv1(ptr_cur, ptr_cur_ref, ptr_cur, ptr_neb_ref, map_mv[neb_addr[cnt]][lidx], MVPs[cnt]);
			scaling_mv1(ptr_cur, ptr_cur_ref, ptr_cur, ptr_neb_ref, mv_nebs[cnt], MVPs[cnt]);
		}
		else {
			refi[cnt] = -1;
			MVPs[cnt][0] = 0;
			MVPs[cnt][1] = 0;
		}
	}
	rFrameL = refi[0];
	rFrameU = refi[1];
	rFrameUR = refi[2];
	if (rFrameL != -1 && rFrameU == -1 && rFrameUR == -1) {
		mvPredType = 0;
	}
	else if (rFrameL == -1 && rFrameU != -1 && rFrameUR == -1) {
		mvPredType = 1;
	}
	else if (rFrameL == -1 && rFrameU == -1 && rFrameUR != -1) {
		mvPredType = 2;
	}
	for (hv = 0; hv < 2; hv++) {
#pragma HLS PIPELINE II=2
		s16 mva = MVPs[0][hv];
		s16 mvb = MVPs[1][hv];
		s16 mvc = MVPs[2][hv];
		switch (mvPredType) {
		case 3:
			if ((mva < 0 && mvb > 0 && mvc > 0) || (mva > 0 && mvb < 0 && mvc < 0)) {
				mvp[hv] = (mvb + mvc) / 2;
			}
			else if ((mvb < 0 && mva > 0 && mvc > 0) || (mvb > 0 && mva < 0 && mvc < 0)) {
				mvp[hv] = (mvc + mva) / 2;
			}
			else if ((mvc < 0 && mva > 0 && mvb > 0) || (mvc > 0 && mva < 0 && mvb < 0)) {
				mvp[hv] = (mva + mvb) / 2;
			}
			else {
				s16 mva_ext = abs(mva - mvb);
				s16 mvb_ext = abs(mvb - mvc);
				s16 mvc_ext = abs(mvc - mva);
				s16 pred_vec = mva_ext < ((mvb_ext < mvc_ext ? mvb_ext : mvc_ext)) ? mva_ext : ((mvb_ext < mvc_ext ? mvb_ext :
					mvc_ext));
				if (pred_vec == mva_ext) {
					mvp[hv] = (mva + mvb) / 2;
				}
				else if (pred_vec == mvb_ext) {
					mvp[hv] = (mvb + mvc) / 2;
				}
				else {
					mvp[hv] = (mvc + mva) / 2;
				}
			}
			break;
		case 0:
			mvp[hv] = mva;
			break;
		case 1:
			mvp[hv] = mvb;
			break;
		case 2:
			mvp[hv] = mvc;
			break;
		default:
#if MD_PRINT
			0 ? ((void)0) : __assert_HLS("0", "../separate/com_util.c", (unsigned int)800, __FUNCTION__);
#endif
			break;
		}
	}
	// clip MVP after rounding (rounding process might result in 32768)
	CPMV mvp_x;
	CPMV mvp_y;
	com_mv_rounding_s32((s32)mvp[0], (s32)mvp[1], &mvp_x, &mvp_y, (int)amvr_idx, (int)amvr_idx);
	mvp[0] = ((s16)(((((s16)0x8000)) > (((((s16)0x7FFF)) < mvp_x ? (((s16)0x7FFF)) : (s16)mvp_x)) ? (((s16)0x8000)) : (((((s16)0x7FFF)) < mvp_x ? (((s16)0x7FFF)) : (s16)mvp_x)))));
	mvp[1] = ((s16)(((((s16)0x8000)) > (((((s16)0x7FFF)) < mvp_y ? (((s16)0x7FFF)) : (s16)mvp_y)) ? (((s16)0x8000)) : (((((s16)0x7FFF)) < mvp_y ? (((s16)0x7FFF)) : (s16)mvp_y)))));
}

void derive_mvp_line_all_32(MD_FW* md_fw_ptr, ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32,
	ENC_ME_NEB_INFO* up_nebs, ENC_ME_NEB_INFO* left_nebs,
	MD_COM_MODE* mod_info_curr, int ptr, int ref_list,
	int ref_idx, int refp_ptr[17][2], int mvr_num, s16 mvp[5][2])
{
#pragma HLS inline off
#pragma HLS ARRAY_PARTITION variable=mvp complete dim=0
	U23 scup = mod_info_curr->scup;
	U8 emvp_flag = mod_info_curr->mvp_from_hmvp_flag;
	u8 mvr_idx = 0;
	CPMV mvp_x = 0;
	CPMV mvp_y = 0;
	if (!emvp_flag) {
		get_mvp_default_line_32(md_fw_ptr, me_line_map_ptr_32, mod_info_curr, refp_ptr, ptr, ref_list, (s8)ref_idx, mvr_idx, mvp[mvr_idx], up_nebs, left_nebs);
		for (mvr_idx = 1; mvr_idx < 4; mvr_idx++) {
#pragma HLS UNROLL
			if (mvr_idx < mvr_num) {
				com_mv_rounding_s32(mvp[0][0], mvp[0][1], &mvp_x, &mvp_y, mvr_idx, mvr_idx);

				mvp[mvr_idx][0] = ((s16)(((((s16)0x8000)) > (((((s16)0x7FFF)) < mvp_x ? (((s16)0x7FFF)) : (s16)mvp_x)) ? (((s16)0x8000)) : (((((s16)0x7FFF)) < mvp_x ? (((s16)0x7FFF)) : (s16)mvp_x)))));
				mvp[mvr_idx][1] = ((s16)(((((s16)0x8000)) > (((((s16)0x7FFF)) < mvp_y ? (((s16)0x7FFF)) : (s16)mvp_y)) ? (((s16)0x8000)) : (((((s16)0x7FFF)) < mvp_y ? (((s16)0x7FFF)) : (s16)mvp_y)))));
			}
		}
	}
	else {
		for (mvr_idx = 0; mvr_idx < 5; mvr_idx++) {
#pragma HLS UNROLL
			if (mvr_idx < mvr_num) {
				mvp[mvr_idx][0] = 0;
				mvp[mvr_idx][1] = 0;
			}
		}
	}
}

void prepare_luma_inter_32(U8 w, U8 h, MD_FW* md_fw_ptr, 
	ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32,
	ENC_ME_NEB_INFO* up_nebs, ENC_ME_NEB_INFO* left_nebs,
	SKIP_MERGE_INPUT* in, MD_COM_MODE* mod_info_curr,
	SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO* merge_rdo, MD_INPUT* md_input_ptr,
	int num_amvr, u32 lambda_mv,
#if ENABLE_BFRAME
	s8 num_refp_cnt[2],
#else
	s8 num_refp_cnt,
#endif
	int ptr, int refp_ptr[17][2], s16 mvp_all[2][5][2],
	U1 valid_mode[17], int amvr_enable_flag, ENC_FME_INFO_ALL* fme_mv_info, 
#if ENABLE_BFRAME
	ME_MV_DIR* me_mv_dir, MV_DIR* mv_dir,
#endif
	S14 sub_pel_mv[MV_D], SKIP_ELEMENT mode[SKIP_MODE_NUM], strFetch_ref_window* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	s8 refi_cur = 0;
	U13 x_pos = mod_info_curr->x_pos;
	U13 y_pos = mod_info_curr->y_pos;
	U7 cu_width = mod_info_curr->cu_width;
	U7 cu_height = mod_info_curr->cu_height;
	U10 x_scu = x_pos >> 2;
	U10 y_scu = y_pos >> 2;

	U3 cu_width_log2 = mod_info_curr->cu_width_log2;
	U3 cu_height_log2 = mod_info_curr->cu_height_log2;
	U11 x0_scu;
	U11 y0_scu;
	x0_scu = PEL2SCU(x_pos - md_input_ptr->pix_x);
	y0_scu = PEL2SCU(y_pos - md_input_ptr->pix_y);

	U1 curr_ctu_idx = me_line_map_ptr_32->curr_ctu_idx;
	U1 above_line_idx = me_line_map_ptr_32->above_line_idx;
	U12 pix_x_scu = in->pix_x >> MIN_CU_LOG2;
	//SKIP_ELEMENT mode[SKIP_MODE_NUM];
	for (int i = 0; i < SKIP_MODE_NUM; ++i)
	{
		mode[i].valid = 0;
		mode[i].skip_flag = 0;
		mode[i].skip_idx = 0;
		mode[i].umve_flag = 0;
		mode[i].umve_idx = 0;
		mode[i].affine_flag = 0;
		mode[i].mvp[REFP_0][0] = 0;
		mode[i].mvp[REFP_0][1] = 0;
		mode[i].refi[REFP_0] = -1;
		mode[i].mvp[REFP_1][0] = 0;
		mode[i].mvp[REFP_1][1] = 0;
		mode[i].refi[REFP_1] = -1;
	}
	U6 num_cands_all = 0;
	U11 pic_width_in_scu = md_fw_ptr->pic_width_in_scu;
	U11 pic_height_in_scu = md_fw_ptr->pic_height_in_scu;
	U1 allow_affine = 0;
	U1 run_direct_skip = 1/*cu_width * cu_height >= 64*/;
	U1 run_affine_merge = allow_affine && cu_width >= 16 && cu_height >= 16;
	NEB_CU neb[NUM_SKIP_SPATIAL_MV];
	for (int i = 0; i < 6; ++i)
	{
		neb[i].x_scu_of_ctu = 0;
		neb[i].y_scu_of_ctu = 0;
		neb[i].valid_flag = 0;
	}
	static SKIP_MERGE_MAP_SCU neb_map[NUM_SKIP_SPATIAL_MV];
	for (int i = 0; i < 6; ++i)
	{
		neb_map[i].map_mv[REFP_0][0] = 0;
		neb_map[i].map_mv[REFP_0][1] = 0;
		neb_map[i].map_refi[REFP_0] = REFI_INVALID;
		neb_map[i].map_mv[REFP_1][0] = 0;
		neb_map[i].map_mv[REFP_1][1] = 0;
		neb_map[i].map_refi[REFP_1] = REFI_INVALID;
		neb_map[i].map_scu = 0;
		neb_map[i].map_cu_mode = 0;
	}
	S7 mode_list[MAX_INTER_SKIP_RDO];

	init_skip_merge_rdo(skip_rdo, merge_rdo, mode_list);
	derive_neb_cu_32(pic_width_in_scu, x_scu, y_scu, cu_width, cu_height, 
		neb, neb_map, 
		me_line_map_ptr_32->map_scu_up_line, me_line_map_ptr_32->map_cu_mode_up_line,
		me_line_map_ptr_32->map_scu_left_line, me_line_map_ptr_32->map_cu_mode_left_line,
		curr_ctu_idx,
		up_nebs, left_nebs);
	derive_inter_cands(in, (U4*)&skip_rdo->num_rdo, neb, neb_map, x_scu, y_scu, pic_width_in_scu, pic_height_in_scu, mode, run_direct_skip, Fetch_Ref_window_ptr
#if SUB_TMVP
		, mod_info_curr->cu_width, mod_info_curr->cu_height, core_sbtmvp
#endif
	);
	if (core_sbtmvp->isValid && md_fw_ptr->num_refp[REFP_0] > 1)
	{
		core_sbtmvp->isValid = FALSE;
	}
#if SKIP_RESTRI
	check_skip_mv_inbound(mode, x_pos, y_pos, md_input_ptr->CtrPos2MD, cu_width, cu_height, mod_info_curr
#if ENABLE_BFRAME
		, md_input_ptr->CtrPos2MD_ref1, Fetch_Ref_window_ptr
#endif // ENABLE_BFRAME
	);
#endif
#ifndef __SYNTHESIS__
    LOOP_set_mode_list: for (int i = 0, j = 0; i < SKIP_MODE_NUM && j < 4; ++i) {
		if (mode[i].valid && (mode[i].refi[REFP_0] >= 0 || REFI_IS_VALID(mode[i].refi[REFP_1])))
		{
			mode_list[j++] = i;
		}
	}
#else
    int j;
    j = 0;
    LOOP_set_mode_list: for (int i=0; i < SKIP_MODE_NUM; i++) { // SKIP_MODE_NUM==12
        if (j < 4) {
            if (mode[i].valid && ((mode[i].refi[REFP_0] >= 0) || (REFI_IS_VALID(mode[i].refi[REFP_1])))) {
                mode_list[j] = i;
                j++;
            }
        }
    }
#endif //__SYNTHESIS__
	output_skip_mode(skip_rdo, skip_rdo_mode, mode, mode_list);

	mod_info_curr->affine_flag = 0;
	mod_info_curr->mvp_from_hmvp_flag = 0;

	if (cu_width == 32 && cu_height == 32)
	{
		sub_pel_mv[MV_X] = fme_mv_info->sadTree32x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_X];
		sub_pel_mv[MV_Y] = fme_mv_info->sadTree32x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_Y];
#if ENABLE_BFRAME
		mv_dir->cur_refi = me_mv_dir->block32x32MvDir[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2].cur_refi;
		mv_dir->lidx = me_mv_dir->block32x32MvDir[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2].lidx;
#endif
	}
	else if (cu_width == 32 && cu_height == 16)
	{
		sub_pel_mv[MV_X] = fme_mv_info->sadTree32x16Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_X];
		sub_pel_mv[MV_Y] = fme_mv_info->sadTree32x16Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_Y];
#if ENABLE_BFRAME
		mv_dir->cur_refi = me_mv_dir->block32x16MvDir[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2].cur_refi;
		mv_dir->lidx = me_mv_dir->block32x16MvDir[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2].lidx;
#endif
	}
	else if (cu_width == 16 && cu_height == 32)
	{
		sub_pel_mv[MV_X] = fme_mv_info->sadTree16x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_X];
		sub_pel_mv[MV_Y] = fme_mv_info->sadTree16x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_Y];
#if ENABLE_BFRAME
		mv_dir->cur_refi = me_mv_dir->block16x32MvDir[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2].cur_refi;
		mv_dir->lidx = me_mv_dir->block16x32MvDir[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2].lidx;
#endif
	}
#if ENABLE_BFRAME
	for (refi_cur = 0; refi_cur < num_refp_cnt[mv_dir->lidx]; refi_cur++) {
#pragma HLS LOOP_TRIPCOUNT max=2
		derive_mvp_line_all_32(md_fw_ptr, me_line_map_ptr_32, up_nebs, left_nebs, mod_info_curr, ptr, mv_dir->lidx, (int)refi_cur, refp_ptr, num_amvr, mvp_all[refi_cur]);
	}
#else
	for (refi_cur = 0; refi_cur < num_refp_cnt; refi_cur++) {
#pragma HLS LOOP_TRIPCOUNT max=2 min=1
		derive_mvp_line_all_32(md_fw_ptr, me_line_map_ptr_32, up_nebs, left_nebs, mod_info_curr, ptr, 0, (int)refi_cur, refp_ptr, num_amvr, mvp_all[refi_cur]);
	}
#endif
	


	for (int x = 0; x < 4; x++) {
		if (x < skip_rdo->num_rdo)
		{
			if (op_patch_mode_on)
				valid_mode[x] = 0;
			else
				valid_mode[x] = 1;
#if USE_INTRA_REFRESH
			if (md_input_ptr->EncRefresh &&md_fw_ptr->slice_type != SLICE_I)
			{
				if (md_input_ptr->RefreshMode == 0)
				{
					if (y_pos >= md_input_ptr->pirStartRow * 32 * md_input_ptr->RefreshSize && y_pos < md_input_ptr->pirEndRow * 32 * md_input_ptr->RefreshSize)
						valid_mode[x] = 0;
				}
				else
				{
					if (x_pos >= md_input_ptr->pirStartCol * 32 * md_input_ptr->RefreshSize && x_pos < md_input_ptr->pirEndCol * 32 * md_input_ptr->RefreshSize)
						valid_mode[x] = 0;
				}

			}
#endif
		}
		else
		{
			valid_mode[x] = 0;
		}
	}

	for (int y = 0; y < 5; y++) {
			valid_mode[y + 4] = 0;
	}

	for (int z = 0; z < 5; z++) {
		if (op_patch_mode_on)
			valid_mode[9] = 0;
		else
			valid_mode[9] = 1;
		{
			valid_mode[9] = 1;
			valid_mode[10] = 0;
			valid_mode[11] = 0;
			valid_mode[12] = 0;
			valid_mode[13] = 0;
		}
#if USE_INTRA_REFRESH
		if (md_input_ptr->EncRefresh &&md_fw_ptr->slice_type != SLICE_I)
		{
			if (md_input_ptr->RefreshMode == 0)
			{
				if (y_pos >= md_input_ptr->pirStartRow * 32 * md_input_ptr->RefreshSize && y_pos < md_input_ptr->pirEndRow * 32 * md_input_ptr->RefreshSize)
					valid_mode[9] = 0;
			}
			else
			{
				if (x_pos >= md_input_ptr->pirStartCol * 32 * md_input_ptr->RefreshSize && x_pos < md_input_ptr->pirEndCol * 32 * md_input_ptr->RefreshSize)
					valid_mode[9] = 0;
			}

		}
#endif
	}

	for (int p = 0; p < 3; p++) {
		valid_mode[p + 14] = 0;
	}


	//else if (cu_width == 32 && cu_height == 8)
	//{
	//	sub_pel_mv[MV_X] = fme_mv_info->sadTree32x8Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_X];
	//	sub_pel_mv[MV_Y] = fme_mv_info->sadTree32x8Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_Y];
	//}
	//else if (cu_width == 8 && cu_height == 32)
	//{
	//	sub_pel_mv[MV_X] = fme_mv_info->sadTree8x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_X];
	//	sub_pel_mv[MV_Y] = fme_mv_info->sadTree8x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_Y];
	//}
	//else if (cu_width == 32 && cu_height == 4)
	//{
	//	sub_pel_mv[MV_X] = fme_mv_info->sadTree32x4Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_X];
	//	sub_pel_mv[MV_Y] = fme_mv_info->sadTree32x4Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_Y];
	//}
	//else //if (cu_width == 4 && cu_height == 32)
	//{
	//	sub_pel_mv[MV_X] = fme_mv_info->sadTree4x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_X];
	//	sub_pel_mv[MV_Y] = fme_mv_info->sadTree4x32Fmv[(x0_scu << 2) >> cu_width_log2][(y0_scu << 2) >> cu_height_log2][MV_Y];
	//}

}


void rdo_prepare_32(U7 w, U7 h, MD_FW* md_fw_ptr, 
	ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32,
	ENC_ME_NEB_INFO* up_nebs, ENC_ME_NEB_INFO* left_nebs,
	SKIP_MERGE_INPUT* skip_in, MD_COM_MODE* mod_info_curr_ptr,
	MERGE_RDO* merge_rdo, MD_INPUT* md_input_ptr,
	U1 valid_mode[17], U1 amvr_enable_flag,
	ENC_FME_INFO_ALL* fme_mv_info,
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16,
	MPM_ARRAY_SIZE<32, 32>* MPM_buffer_ptr_32x32, MPM_ARRAY_SIZE<16, 32>* MPM_buffer_ptr_16x32, MPM_ARRAY_SIZE<32, 16>* MPM_buffer_ptr_32x16,
	IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16,
	U3 cu_width_log2, U3 cu_height_log2,
	u8 ipred_list[IPRED_LIST_NUM], pel src_le_temp[2 * 32 + 3], pel src_up_temp[2 * 32 + 3], u16* avail_tb, u8 rmd_mode[IPRED_LIST_NUM],
	U5 all_inter_mode_num,
#if ENABLE_BFRAME
	ME_MV_DIR* me_mv_dir, MV_DIR* mv_dir,
#endif
   	u8 curr_cons_pred_mode,
	u8 inter_num[1], u8 intra_num[1], u8 rdo_list[MD_MAX_RDO_NUM], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], SKIP_RDO* skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2], U4 bit_depth, strFetch_ref_window* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{
#pragma HLS INLINE off

	U3 max_rdo_num = MD_MAX_RDO_NUM;
	U3 max_inter = 0;
	U14 sub_x = mod_info_curr_ptr->x_pos;
	U14 sub_y = mod_info_curr_ptr->y_pos;

	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;
	s8 refi_cur = 0;
#if ENABLE_BFRAME
	s8 num_refp_cnt[REFP_NUM] = { md_fw_ptr->num_refp[0], md_fw_ptr->num_refp[1] };
#else
	u8 num_refp_cnt = md_fw_ptr->num_refp;
#endif
	int num_amvr;

	/*	if (amvr_enable_flag) {
			num_amvr = 5;
		}
		else*/ {
		num_amvr = 1;
	}

		inter_num[0] = 0;
		intra_num[0] = 0;
		//printf("pos=(%d %d) size=(%d %d) slice=%d cons_pred_mode=%d\n", mod_info_curr_ptr->x_pos, mod_info_curr_ptr->y_pos, cu_width, cu_height, md_fw_ptr->slice_type, curr_cons_pred_mode);
		if (!(md_fw_ptr->slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA)) {
			max_inter = (curr_cons_pred_mode == ONLY_INTER) ? MD_MAX_RDO_NUM : MD_MAX_RDO_NUM_INTER;

			prepare_luma_inter_32(w, h, md_fw_ptr, 
				me_line_map_ptr_32,
				up_nebs, left_nebs,
				skip_in, &mod_info_curr_ptr[0],
				skip_rdo, skip_rdo_mode, merge_rdo, md_input_ptr,
				num_amvr, md_input_ptr->lambda_mv, num_refp_cnt, md_fw_ptr->cur_ptr, md_fw_ptr->refp_ptr, mvp_all, valid_mode, amvr_enable_flag, fme_mv_info,  
#if ENABLE_BFRAME
				me_mv_dir, mv_dir,
#endif
				sub_pel_mv, skip_mode, Fetch_Ref_window_ptr
#if SUB_TMVP
				, core_sbtmvp
#endif
			);


			if (valid_mode[9])
			{
				rdo_list[inter_num[0]] = 9;
				inter_num[0]++;
			}

			//if (valid_mode[4])
			//{
			//	rdo_list[inter_num[0]] = 4;
			//	inter_num[0]++;
			//}

			for (int mode_index = 0; mode_index < 4; mode_index++)
			{
				if (inter_num[0] >= max_inter)
					break;
				if (valid_mode[mode_index] == 1)
				{
					rdo_list[inter_num[0]] = mode_index;
					inter_num[0]++;
				}
			}
		}


		if (!(IS_INTER_SLICE(md_fw_ptr->slice_type) && curr_cons_pred_mode == ONLY_INTER))
		{
			int pred_cnt[1] = {MD_MAX_RDO_NUM};

			prepare_intra_info_32(w, h, md_fw_ptr, 
				me_line_map_ptr_32,
				mod_info_curr_ptr, 
				IP_buffer_ptr_32x32, IP_buffer_ptr_16x32, IP_buffer_ptr_32x16,
				MPM_buffer_ptr_32x32, MPM_buffer_ptr_16x32, MPM_buffer_ptr_32x16,
				IP_map_scu_ptr_32x32, IP_map_scu_ptr_16x32, IP_map_scu_ptr_32x16,
				cu_width_log2, cu_height_log2, pix_x, pix_y, sub_x, sub_y, ipred_list, pred_cnt, src_le_temp, src_up_temp, avail_tb, rmd_mode
#if USE_SPEED_LEVEL
				, md_input_ptr->speed_level
#endif
			);
#if USE_SPEED_LEVEL
			if (md_input_ptr->speed_level == 1)
				max_rdo_num = IPD_RDO_CNT;
			else if (md_input_ptr->speed_level == 2)
				max_rdo_num = EXTRA_RDO_MODE;
			else
				max_rdo_num = IPD_RDO_CNT + EXTRA_RDO_MODE;

#endif
			intra_num[0] = avs3_min(*pred_cnt, (int)(max_rdo_num - inter_num[0]));
			for (int intra_index = 0; intra_index < intra_num[0]; intra_index++)
			{
				rdo_list[inter_num[0] + intra_index] = all_inter_mode_num + intra_index;
			}
		}
}

void enc_diff_16b_32x(U7 w, U7 h, s16 orgY[32][32], pel pred_y_inter[32][32], s16 coef_tmp1[32][32], pel pred_cache1[32][32], pel pred_cache_32x32_update[32][32])
{
	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
		for (int j = 0; j < 32; j++) {
			coef_tmp1              [i][j] = (s16)(orgY[i][j] - pred_y_inter[i][j]);
			pred_cache1            [i][j] = pred_y_inter[i][j];
			pred_cache_32x32_update[i][j] = pred_y_inter[i][j];
		}
	}
}

void Ipred_32x_diff(U8 w, U8 h, s16 orgY[32][32], s16 pred_y_intra_1[32][32], s16 coef_tmp1[32][32], pel pred_cache1[32][32], s16 pred_cache_32x32_update[32][32])
{
	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE 
		for (int j = 0; j < 32; j++) {
			coef_tmp1              [i][j] = orgY[i][j] - pred_y_intra_1[i][j];
			pred_cache1            [i][j] = pred_y_intra_1[i][j];
			pred_cache_32x32_update[i][j] = pred_y_intra_1[i][j];
		}
	}
}

// MD_KERNEL_32 PRED TOP
static void intra_inter_pred_32(U7 w, U7 h, u8& curr_mvr,
	MD_KERNEL_MODE_32* mod_info_nz_32, s16 orgY[32][32],
	u8& mode_type, s8& inter_mode_idx,
	s16 coef_tmp1[32][32], U1* valid_flag, U1 valid_mode[17], pel pred_cache1[32][32], pel pred_cache_32x32_update[32][32],
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[32][32], pel pred_y_inter2[2][32][32], pel pred_y_intra[5][32][32],
	U1* is_intra_quant, u8 intra_mode_list[IPRED_LIST_NUM], pel src_le_temp[32 * 2 + 3], pel src_up_temp[32 * 2 + 3], u16 avail_tb,
	u8 rdo_list[MD_MAX_RDO_NUM],
	u8 rdo_idx, u8 inter_rdo_num,
	MD_INPUT* md_input_ptr,
	int stride_org,
	SKIP_RDO* skip_rdo, SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo,
	U3 cu_width_log2, U3 cu_height_log2, U2 tree_status, u8 ctx_cons_pred_mode,
	S14 sub_pel_mv[MV_D], s16 mvp_all[2][5][2],
	U13 pic_width, U13 pic_height, MD_KERNEL_INPUT_32* md_kernel_input, u8 mpm[MAX_NUM_PB][2], U4 bit_depth,
	S14 CtrPosSKIP[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR* mv_dir, MD_FW* md_fw_ptr, strFetch_ref_window* Fetch_Ref_window_ptr
#endif
	//,pel fme2mdrefbuf[2560][8][2][16]
#if MIPF
	, int mipf_enable_flag
#endif
#if SUB_TMVP
	, u8 skip_idx, CORE_SBTMVP* core_sbtmvp
#endif
#if USE_SPEED_LEVEL
	, U8 speed_level
#endif
	)
{
#pragma HLS INLINE off

//#pragma HLS ARRAY_PARTITION variable=orgY                       dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=coef_tmp1                  dim=2 complete
#pragma HLS ARRAY_PARTITION variable=pred_cache1                dim=2 complete
#pragma HLS ARRAY_PARTITION variable=pred_cache_32x32_update    dim=2 complete
#pragma HLS ARRAY_PARTITION variable=pred_y_inter1              dim=2 complete
#pragma HLS ARRAY_PARTITION variable=pred_y_inter2              dim=3 complete
#pragma HLS ARRAY_PARTITION variable=pred_y_intra               dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mpm                        dim=0 complete

//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->mv         dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->mvd        dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->affine_mv  dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->affine_mv  dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->affine_mvd dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->affine_mvd dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->ipm        dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->mpm        dim=2 complete
#if MD_INFO_NZ_FLAT
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->mv         dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->mvd        dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->affine_mv  dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->affine_mvd dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->ipm        dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32->mpm        dim=1 complete
#endif 
//
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->mv           dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->mvd          dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->affine_mv    dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->affine_mv    dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->affine_mvd   dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->affine_mvd   dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->ipm          dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->mpm          dim=2 complete
#if MD_INFO_NZ_FLAT
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->mv           dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->mvd          dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->affine_mv    dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->affine_mvd   dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->ipm          dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_1->mpm          dim=1 complete
#endif 
//
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mv               dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mvd              dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mvd_cp           dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mv        dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mv        dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mvd       dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mvd       dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mvd_cp    dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mvd_cp    dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->ipm              dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->ipm_cp           dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mpm              dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mpm_cp           dim=2 complete
#if MD_INFO_NZ_FLAT
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mv               dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mvd              dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mvd_cp           dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mv        dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mvd       dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->affine_mvd_cp    dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->ipm              dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->ipm_cp           dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mpm              dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_nz_32_2->mpm_cp           dim=1 complete
#endif 

	inter_mode_idx = rdo_list[rdo_idx];
	s8 intra_mode_idx;
	U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
	u8 curr_mvr_table [17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };

	static MD_KERNEL_MODE_32 mode_info_write_32;
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.mv         dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.mvd        dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.affine_mv  dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.affine_mv  dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.affine_mvd dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.affine_mvd dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.ipm        dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.mpm        dim=2 complete
#if MD_INFO_NZ_FLAT
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.mv         dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.mvd        dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.affine_mv  dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.affine_mvd dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.ipm        dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=mode_info_write_32.mpm        dim=1 complete
#endif

	U1 is_intra_write;
	U1 valid_flag_write = 0;

#if USE_SPEED_LEVEL
	int extra_intra = 0;
	if (speed_level == 1)
		extra_intra = 0;
	else if (speed_level == 2)
		extra_intra = 5;
	else
		extra_intra = 10;
#else
	int extra_intra = 0;
#endif

	if (inter_mode_idx >= 17) {
		is_intra_write = 1;
		intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
		inter_mode_idx = -1;
	} else {
		is_intra_write = 0;
		intra_mode_idx = 0;
	}

	if (is_intra_write == 0) { // INTRA
		//valid_flag_write = valid_mode[inter_mode_idx];
		/*if (valid_flag_write == 1) */{
			mode_type = mode_type_table[inter_mode_idx];
			curr_mvr  = curr_mvr_table[inter_mode_idx];
		}

		if (inter_mode_idx >= 0) {
#if ENABLE_BFRAME
			u8 num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
#endif
			int refi_cur = 0;
			s16 mv_all[2][5][2];
			int best_mv_uni_inner[2][4][2];

			static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
			static u8 curr_mvr_table [17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
			U1 allowed[1] = { 1 };

			valid_flag_write = valid_mode[inter_mode_idx];
			u8 curr_mvr  = 0;
			U2 mode_type = 0;
			/*if (valid_flag_write) */{
				mode_type = mode_type_table[inter_mode_idx];
				curr_mvr  = curr_mvr_table [inter_mode_idx];

				if (mode_type == 0 || mode_type == 1) {
					if (mode_type == 1) {
						mode_info_write_32.cu_mode = 1;
						mode_info_write_32.affine_flag = 0;
						for (int i = 0; i < 2; i++) {
							for (int j = 0; j < 2; j++) {
								mode_info_write_32.mv[i][j] = 0;
								mode_info_write_32.mvd[i][j] = 0;
							}
						}
						//init_inter_data_32(&mode_info_write_32);
#if ENABLE_BFRAME
						U1 lidx = mv_dir->lidx;
#else
						U1 lidx = 0;
#endif
						mode_info_write_32.mv[lidx][0] = mv_copy[lidx][0];
						mode_info_write_32.mv[lidx][1] = mv_copy[lidx][1];
						mode_info_write_32.mvd[lidx][0] = mvd_copy[lidx][0];
						mode_info_write_32.mvd[lidx][1] = mvd_copy[lidx][1];
						mode_info_write_32.refi[0] = refi_copy[0];
						mode_info_write_32.refi[1] = refi_copy[1];
					}
					else if (mode_type == 2) {
						assert(mode_type != 2);
					}
					else {
						derive_mode_info_32(inter_mode_idx, skip_rdo, skip_rdo_mode, &merge_rdo, &mode_info_write_32);
						//make_skip_resi_32(inter_mode_idx, skip_rdo, skip_rdo_mode, &merge_rdo, &mode_info_write_32);
					}

					if (mode_type == 1) {
						//enc_diff_16b_32(cu_width_log2, cu_height_log2, orgY, pred_y_inter1, 32, coef_tmp1);
						//array_cp_pred(pred_y_inter1, pred_cache1, pred_cache_32x32_update);
						enc_diff_16b_32x(w, h, orgY, pred_y_inter1, coef_tmp1, pred_cache1, pred_cache_32x32_update);
					}
					else if (mode_type == 0) {
						//enc_diff_16b_32(cu_width_log2, cu_height_log2, orgY, pred_y_inter2[rdo_idx-1], 32, coef_tmp1);
						//array_cp_pred(pred_y_inter2[rdo_idx - 1], pred_cache1, pred_cache_32x32_update);
						enc_diff_16b_32x(w, h, orgY, pred_y_inter2[rdo_idx-1], coef_tmp1, pred_cache1, pred_cache_32x32_update);
					}
				}
			}
		}
	}
	else {	// INTER
			//Ipred_32_diff(w, h, orgY, pred_y_intra[rdo_idx], coef_tmp1);
			//array_cp_pred(pred_y_intra[rdo_idx], pred_cache1, pred_cache_32x32_update);
			Ipred_32x_diff(w, h, orgY, pred_y_intra[rdo_idx], coef_tmp1, pred_cache1, pred_cache_32x32_update);
			mode_info_write_32.cu_mode = 0;
			mode_info_write_32.ipm[0][0] = intra_mode_idx;
			mode_info_write_32.ipm[0][1] = -1;
			//valid_flag_write = 1;
	}

		*valid_flag     = valid_flag_write;
		*is_intra_quant = is_intra_write;
		mod_info_nz_32->cu_mode     = mode_info_write_32.cu_mode;
		mod_info_nz_32->affine_flag = mode_info_write_32.affine_flag;

		LOOP_INTER_INTRA_PRED_cp_1: for (int i = 0; i < REFP_NUM; ++i) {
#if MD_INFO_NZ_FLAT
#pragma HLS UNROLL
#else 
#pragma HLS PIPELINE
#endif
			for (int j = 0; j < MV_D; ++j) {
#pragma HLS UNROLL
				mod_info_nz_32->mvd[i][j] = mode_info_write_32.mvd[i][j];
				mod_info_nz_32->mv [i][j] = mode_info_write_32.mv [i][j];
#ifdef _DATA_CP_FOR_DATAFLOW_
				mod_info_nz_32->mvd_cp[i][j] = mode_info_write_32.mvd[i][j];                            	// mem cp for DATAFLOW
#endif //_DATA_CP_FOR_DATAFLOW_
				for (int k = 0; k < VER_NUM; ++k) {
#pragma HLS UNROLL
					mod_info_nz_32->affine_mv [i][k][j] = mode_info_write_32.affine_mv [i][k][j];
					mod_info_nz_32->affine_mvd[i][k][j] = mode_info_write_32.affine_mvd[i][k][j];
#ifdef _DATA_CP_FOR_DATAFLOW_					
					mod_info_nz_32->affine_mvd_cp[i][k][j] = mode_info_write_32.affine_mvd[i][k][j];    	// mem cp for DATAFLOW
#endif //_DATA_CP_FOR_DATAFLOW_
				}
			}
			mod_info_nz_32->refi[i] = mode_info_write_32.refi[i];
#ifdef _DATA_CP_FOR_DATAFLOW_	
			mod_info_nz_32->refi_cp[i] = mode_info_write_32.refi[i];                                    	// mem cp for DATAFLOW
#endif //_DATA_CP_FOR_DATAFLOW_
		}
		mod_info_nz_32->skip_idx  = mode_info_write_32.skip_idx;
		mod_info_nz_32->smvd_flag = mode_info_write_32.smvd_flag;
		mod_info_nz_32->umve_flag = mode_info_write_32.umve_flag;
		mod_info_nz_32->umve_idx  = mode_info_write_32.umve_idx;
		for (int i = 0; i < MAX_NUM_PB; ++i) {
#if MD_INFO_NZ_FLAT
#pragma HLS UNROLL
#else 
#pragma HLS PIPELINE
#endif
			for (int j = 0; j < 2; ++j) {
#pragma HLS UNROLL
				mod_info_nz_32->ipm[i][j] = mode_info_write_32.ipm[i][j];
				mod_info_nz_32->mpm[i][j] = mpm[i][j];
#ifdef _DATA_CP_FOR_DATAFLOW_
				mod_info_nz_32->ipm_cp[i][j] = mode_info_write_32.ipm[i][j];                            	// mem cp for DATAFLOW
            	mod_info_nz_32->mpm_cp[i][j] = mpm[i][j];                                               	// mem cp for DATAFLOW
#endif //_DATA_CP_FOR_DATAFLOW_
			}
		}
		mod_info_nz_32->tb_part = mode_info_write_32.tb_part;
		mod_info_nz_32->pb_part = 0;
}


void rdo_skip_32(s64* cost_best, MD_COM_MODE_BEST* best_info_ptr,
	ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr, MD_COM_MODE* mod_info_curr,
	pel org_y[32][32], SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO* merge,
	U13 pic_width, U13 pic_height, U2 slice_type, U2 tree_status, s64 lambda_y, U2 curr_cons_pred_mode, U4 bit_depth,
	strFetch_ref_window* Fetch_Ref_window_ptr,
	S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], 
#if ENABLE_BFRAME
	S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	//pel fme2mdrefbuf[2560][8][2][16]
	pel pred_y_skip[13][32][32]
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{
#pragma HLS INLINE off

	U3 cu_width_log2 = mod_info_curr->cu_width_log2;
	U3 cu_height_log2 = mod_info_curr->cu_height_log2;
	U3 cu_width = mod_info_curr->cu_width;
	U3 cu_height = mod_info_curr->cu_height;


	if (slice_type == 1 || curr_cons_pred_mode == ONLY_INTRA) { return; }

	for (int idx = 0; idx < SKIP_MODE_NUM; ++idx)
	{
		// derive mode info
			SKIP_ELEMENT* mode = skip_mode + idx;
			if (mode->valid == 0) { continue; }

			mod_info_curr->cu_mode = MODE_SKIP;
			mod_info_curr->umve_flag = mode->umve_flag;
			mod_info_curr->umve_idx = mode->umve_idx;
			mod_info_curr->affine_flag = mode->affine_flag;
			mod_info_curr->skip_idx = mode->skip_idx;
			mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
			mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
			mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
			mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
			mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
			mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
			mod_info_curr->mv[1][0] = 0;
			mod_info_curr->mv[1][1] = 0;
			mod_info_curr->refi[1] = -1;
#endif
			// skip index 1 and 2 for P slice

#if ENABLE_BFRAME
		if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
		if (mod_info_curr->refi[0] == -1) { continue; }
#endif

//		// calc pred info
		s64 cost = enc_ssd_16b_1_32(cu_width_log2, cu_height_log2, pred_y_skip[idx], org_y, 32, bit_depth);
		cu_nz_cln(mod_info_curr->num_nz);
		mod_info_curr->tb_part = ((int)SIZE_2Nx2N);

		// calc bit est
		U16 bit_est = enc_bit_est_flag_skip_32(slice_type, tree_status, mod_info_curr->umve_flag, mod_info_curr->umve_idx, mod_info_curr->affine_flag, mod_info_curr->skip_idx, cu_width_log2, cu_height_log2, mod_info_curr->ipm, 8);
		cost += ((bit_est * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE);
#if SUB_TMVP
		// if skip tmvp mode
		if (idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE) {
			core_sbtmvp->sbTmvp_flag = 1;
		}
		else {
			core_sbtmvp->sbTmvp_flag = 0;
		}
#endif
		// compare cost
		if (cost < *cost_best) {

#if SUB_TMVP
			if (idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE) {
				if (!core_sbtmvp->isValid)
					continue;
				core_sbtmvp->best_sbTmvp_flag = core_sbtmvp->sbTmvp_flag;
				if (core_sbtmvp->best_sbTmvp_flag) {
					for (int i = 0; i < SBTMVP_NUM; i++)
					{
						core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_X];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_0][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_0][MV_Y];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_X] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_X];
						core_sbtmvp->best_sbTmvp[i].mv[REFP_1][MV_Y] = core_sbtmvp->sbTmvp[i].mv[REFP_1][MV_Y];
						core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_0] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_0];
						core_sbtmvp->best_sbTmvp[i].ref_idx[REFP_1] = core_sbtmvp->sbTmvp[i].ref_idx[REFP_1];

					}
					for (int lidx = 0; lidx < 2; lidx++)
					{
						best_info_ptr->mvd[lidx][0] = 0;
						best_info_ptr->mvd[lidx][1] = 0;
					}
				}
			}
#endif
			best_info_ptr->cu_mode = mod_info_curr->cu_mode;
			best_info_ptr->pb_part = mod_info_curr->pb_part;
			best_info_ptr->tb_part = mod_info_curr->tb_part;
			//			bst_info_pb_info->num_sub_part = mod_info_curr_pb_info->num_sub_part;
			//			bst_info_tb_info->num_sub_part = mod_info_curr_tb_info->num_sub_part;
			//			for (U1 it = 0; it < 1; it++) {
			//				bst_info_pb_info->sub_x[it] = mod_info_curr_pb_info->sub_x[it];
			//				bst_info_pb_info->sub_y[it] = mod_info_curr_pb_info->sub_y[it];
			//				bst_info_pb_info->sub_w[it] = mod_info_curr_pb_info->sub_w[it];
			//				bst_info_pb_info->sub_h[it] = mod_info_curr_pb_info->sub_h[it];
			//				bst_info_pb_info->sub_scup[it] = mod_info_curr_pb_info->sub_scup[it];
			//				bst_info_tb_info->sub_x[it] = mod_info_curr_tb_info->sub_x[it];
			//				bst_info_tb_info->sub_y[it] = mod_info_curr_tb_info->sub_y[it];
			//				bst_info_tb_info->sub_w[it] = mod_info_curr_tb_info->sub_w[it];
			//				bst_info_tb_info->sub_h[it] = mod_info_curr_tb_info->sub_h[it];
			//				bst_info_tb_info->sub_scup[it] = mod_info_curr_tb_info->sub_scup[it];
			//			}
			best_info_ptr->umve_flag = mod_info_curr->umve_flag;
			*cost_best = cost;

			best_info_ptr->mvr_idx = ((u8)0);
			best_info_ptr->refi[0] = mod_info_curr->refi[0];
			best_info_ptr->refi[1] = mod_info_curr->refi[1];
			for (int lidx = 0; lidx < 2; lidx++) {
				best_info_ptr->mv[lidx][0] = mod_info_curr->mv[lidx][0];
				best_info_ptr->mv[lidx][1] = mod_info_curr->mv[lidx][1];
				best_info_ptr->mvd[lidx][0] = mod_info_curr->mvd[lidx][0];
				best_info_ptr->mvd[lidx][1] = mod_info_curr->mvd[lidx][1];
			}
#if SUB_TMVP
			if (idx == 0 && cu_width >= SBTMVP_MIN_SIZE && cu_height >= SBTMVP_MIN_SIZE) {
				if (core_sbtmvp->best_sbTmvp_flag) {
					for (int lidx = 0; lidx < 2; lidx++)
					{
						best_info_ptr->mvd[lidx][MV_X] = 0;
						best_info_ptr->mvd[lidx][MV_Y] = 0;
					}
				}
			}
			//core_sbtmvp->sbTmvp_flag = 0;
#endif
			best_info_ptr->smvd_flag = mod_info_curr->smvd_flag;
			best_info_ptr->affine_flag = mod_info_curr->affine_flag;
			if (best_info_ptr->affine_flag) {
				int vertex_num = (best_info_ptr->affine_flag) + 1;
				for (int lidx = 0; lidx < 2; lidx++) {
					for (int vertex = 0; vertex < 4; vertex++) {
						if (vertex < vertex_num)
						{
							best_info_ptr->affine_mv[lidx][vertex][0] = mod_info_curr->affine_mv[lidx][vertex][0];
							best_info_ptr->affine_mv[lidx][vertex][1] = mod_info_curr->affine_mv[lidx][vertex][1];
							best_info_ptr->affine_mvd[lidx][vertex][0] = mod_info_curr->affine_mvd[lidx][vertex][0];
							best_info_ptr->affine_mvd[lidx][vertex][1] = mod_info_curr->affine_mvd[lidx][vertex][1];
						}
					}
				}
			}

			for (int i = 0; i < cu_height; i++)
			{
				for (int j = 0; j < cu_width; j++)
				{
					best_info_ptr->pred_y[i][j] = pred_y_skip[idx][i][j];
				}
			}


			if (((int)(best_info_ptr->umve_flag)) != 0) {
				best_info_ptr->umve_idx = mod_info_curr->umve_idx;
			}
			else {
				best_info_ptr->skip_idx = mod_info_curr->skip_idx;
			}

			for (U3 i_numnz = 0; i_numnz < 4; i_numnz++) {
				best_info_ptr->num_nz[i_numnz][0] = 0;
			}
			for (int i = 0; i < mod_info_curr->cu_height; ++i) {
#pragma HLS loop_tripcount max = 8
				for (int j = 0; j < mod_info_curr->cu_width; ++j) {
#pragma HLS loop_tripcount max = 8
					cu_data_ptr->coef_y[i][j] = 0;
				}
			}

			for (int i = 0; i < cu_height; i++) {
				for (int j = 0; j < 32; j++) {
					if (j < cu_width)
					{
						s16 pred = pred_y_skip[idx][i][j];
						cu_data_ptr->reco_y[i][j] = 0 > pred ? 0 : (pred > ((1 << bit_depth) - 1) ? ((1 << bit_depth) - 1) : pred);
					}
				}
			}

		}

	}
}


void diff_ssd_bitcnt_32(RDOQ_MODEL* model_cnt, MD_INPUT* md_input_ptr,
	u8 mode_type, MD_KERNEL_MODE_32* mod_info_nz_32, pel pred_cache[32][32],
	pel org_y[32*32], s16 resi_t[32][32], s64* dist_pred, s64* cost_best,
	U2 tree_status, u8 cons_pred_mode, int mode_idx, U1 valid_mode[17], MD_KERNEL_INPUT_32* md_kernel_input, U4 bit_depth)
{
	static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };
	int curr_mvr = curr_mvr_table[mode_idx];
	int cu_width_log2 = md_kernel_input->cu_width_log2;
	int cu_height_log2 = md_kernel_input->cu_height_log2;
	s64 lambdaY = md_input_ptr->lambda_y;

	*cost_best = (s64)MAX_S64;
	*dist_pred = (s64)MAX_S64;
	
	U1 valid_flag = valid_mode[mode_idx];
	if (valid_flag == 1) {
		if (mode_type == 1 || mode_type == 0)
		{
			int num_nz[MAX_NUM_TB][N_C];
			cu_nz_cln(num_nz);
			mod_info_nz_32->tb_part = ((int)SIZE_2Nx2N);
			if (mode_type == 0)
			{
				mod_info_nz_32->cu_mode = 3;
			}
			else
			{
				*cost_best = 0;
				int bit_cnt = get_bitcnt_est_32_coef_0(curr_mvr, tree_status,
					 2, cons_pred_mode, mod_info_nz_32->cu_mode, mod_info_nz_32->umve_flag, mod_info_nz_32->umve_idx,
					mod_info_nz_32->affine_flag, 1, mod_info_nz_32->skip_idx, mod_info_nz_32->refi,
					0, mod_info_nz_32->smvd_flag, mod_info_nz_32->affine_mvd,
					mod_info_nz_32->mvd, md_kernel_input->cu_width_log2, md_kernel_input->cu_height_log2,
					num_nz, mod_info_nz_32->ipm, 1 , 0, mod_info_nz_32->mpm,0);
				*cost_best += (bit_cnt * lambdaY + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
			}
		}
	}

}


static void init_scan(u16* scan, int size_x, int size_y, int scan_type)
{

	int x;
	int y;
	int l;
	int pos;
	int num_line;
	pos = 0;
	num_line = size_x + size_y - 1;
	if (scan_type == 0) {
		/* starting point */
		scan[pos] = ((u16)0);
		pos++;
		/* loop */
		for (l = 1; l < num_line; l++) {

			/* decreasing loop */
			if (l % 2) {
				x = (l < size_x - 1 ? l : size_x - 1);
				y = (0 > l - (size_x - 1) ? 0 : l - (size_x - 1));
				while (x >= 0 && y < size_y) {

					scan[pos] = ((u16)(y * size_x + x));
					pos++;
					x--;
					y++;
				}
			}
			else
				/* increasing loop */
			{
				y = (l < size_y - 1 ? l : size_y - 1);
				x = (0 > l - (size_y - 1) ? 0 : l - (size_y - 1));
				while (y >= 0 && x < size_x) {

					scan[pos] = ((u16)(y * size_x + x));
					pos++;
					x++;
					y--;
				}
			}
		}
	}
}
static int enc_eco_run_est(u32 sym)
{

	int exp_golomb_order = 0;
	int enc_est = 0;
	if (sym < (16)) {
		enc_est += sbac_write_truncate_unary_sym_est(sym, (u32)17);
	}
	else {
		sym -= (16);
		enc_est += sbac_write_truncate_unary_sym_est((u32)16, (u32)17);
		if (sym == (0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= (1) && sym < (3)) {
			exp_golomb_order = 1;
		}
		else if (sym >= (3) && sym < (7)) {
			exp_golomb_order = 2;
		}
		else if (sym >= (7) && sym < (15)) {
			exp_golomb_order = 3;
		}
		else if (sym >= (15) && sym < (31)) {
			exp_golomb_order = 4;
		}
		else if (sym >= (31) && sym < (63)) {
			exp_golomb_order = 5;
		}
		else if (sym >= (63) && sym < (127)) {
			exp_golomb_order = 6;
		}
		else if (sym >= (127) && sym < (255)) {
			exp_golomb_order = 7;
		}
		else if (sym >= (255) && sym < (511)) {
			exp_golomb_order = 8;
		}
		else if (sym >= (512) && sym < (1023)) {
			exp_golomb_order = 9;
		}
		else if (sym >= (1023) && sym < (2047)) {
			exp_golomb_order = 10;
		}
		else if (sym >= (2047) && sym < (4095)) {
			exp_golomb_order = 11;
		}
		enc_est += 2 * exp_golomb_order;
		/*sbac_write_unary_sym_ep_est(exp_golomb_order);
		sbac_encode_bins_ep_msb_est(exp_golomb_order);*/
	}
	return enc_est;
}

static int enc_eco_level_est(u32 sym)
{

	int exp_golomb_order = 0;
	int enc_est = 0;
	if (sym < ((unsigned int)8)) {
		enc_est += sbac_write_truncate_unary_sym_est(sym, (u32)9);
	}
	else {
		sym -= ((unsigned int)8);
		enc_est += sbac_write_truncate_unary_sym_est((u32)8, (u32)9);
		//		while ((int)sym >= (1 << exp_golomb_order))
		//		{
		//			sym = sym - (1 << exp_golomb_order);
		//			exp_golomb_order++;
		//		}
		if (sym == ((unsigned int)0)) {
			exp_golomb_order = 0;
		}
		else if (sym >= ((unsigned int)1) && sym < ((unsigned int)3)) {
			exp_golomb_order = 1;
		}
		else if (sym >= ((unsigned int)3) && sym < ((unsigned int)7)) {
			exp_golomb_order = 2;
		}
		else if (sym >= ((unsigned int)7) && sym < ((unsigned int)15)) {
			exp_golomb_order = 3;
		}
		else if (sym >= ((unsigned int)15) && sym < ((unsigned int)31)) {
			exp_golomb_order = 4;
		}
		else if (sym >= ((unsigned int)31) && sym < ((unsigned int)63)) {
			exp_golomb_order = 5;
		}
		else if (sym >= ((unsigned int)63) && sym < ((unsigned int)127)) {
			exp_golomb_order = 6;
		}
		else if (sym >= ((unsigned int)127) && sym < ((unsigned int)255)) {
			exp_golomb_order = 7;
		}
		else if (sym >= ((unsigned int)255) && sym < ((unsigned int)511)) {
			exp_golomb_order = 8;
		}
		else if (sym >= ((unsigned int)512) && sym < ((unsigned int)1023)) {
			exp_golomb_order = 9;
		}
		else if (sym >= ((unsigned int)1023) && sym < ((unsigned int)2047)) {
			exp_golomb_order = 10;
		}
		else if (sym >= ((unsigned int)2047) && sym < ((unsigned int)4095)) {
			exp_golomb_order = 11;
		}
		enc_est += 2 * exp_golomb_order;
		//sbac_write_unary_sym_ep_est(exp_golomb_order);
		//sbac_encode_bins_ep_msb_est(exp_golomb_order);
	}
	return enc_est;
}
static int enc_eco_run_length_cc_est_2(s16* coef, int log2_w, int log2_h, int num_sig)
{
	int enc_est = 0;
	u32 num_coeff;
	u32 scan_pos;
	u32 level;
	u32 prev_level;
	u32 run;
	u32 last_flag;
	s16 coef_cur;
	num_coeff = ((u32)(1 << (log2_w + log2_h)));
	static u16 scanp[1 << 12];
	init_scan(scanp, 1 << log2_w, 1 << log2_h, 0);
	run = 0;
	prev_level = ((u32)6);
	int run_1 = 0;
	s16 coef_cur_1;
	static s16 run_num[1 << 12];
	static int num_sig_num[1 << 12];
	u32 scan_pos_1;
	for (scan_pos_1 = 0; scan_pos_1 < num_coeff; scan_pos_1++) {

		coef_cur_1 = coef[scanp[scan_pos_1]];
		if (coef_cur_1) {
			run_num[scan_pos_1] = ((s16)run_1);
			if (scan_pos_1 == num_coeff - ((unsigned int)1)) {
				break;
			}
			run_1 = 0;
			num_sig_num[scan_pos_1] = --num_sig;
			if (!num_sig) {
				break;
			}
		}
		else {
			run_1++;
			run_num[scan_pos_1] = 0;
		}
	}
	for (scan_pos = 0; scan_pos < num_coeff; scan_pos++) {

		coef_cur = coef[scanp[scan_pos]];
		if (coef_cur) {
			level = ((u32)((((int)coef_cur) ^ ((int)coef_cur) >> 15) - (((int)coef_cur) >> 15)));
			enc_est += enc_eco_run_est((u32)run_num[scan_pos]);
			enc_est += enc_eco_level_est(level - ((unsigned int)1));
			enc_est++;
			if (scan_pos == num_coeff - ((unsigned int)1)) {
				break;
			}
			last_flag = ((u32)((num_sig_num[scan_pos] == 0 ? 1 : 0)));
			enc_est++;
			if (last_flag) {
				break;
			}
		}


	}
	return enc_est;
}

void array_cp_org_y(pel orgY_32[32][32], pel orgY_32_cp[32][32], pel orgY_32_cp1[32][32])
{
    for (int y=0; y<32; y++) {
#pragma HLS PIPELINE
        for (int x=0; x<32; x++) {
            orgY_32_cp [y][x] = orgY_32[y][x];
            orgY_32_cp1[y][x] = orgY_32[y][x];
        }
    }
}



// MD_KERNEL_32 ENTITY
#if !LUMA_32_PIPELINE_DUMMY
void rdo_luma_32_pipeline(U8 w, U8 h, RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32,
#ifndef __SYNTHESIS__
	ENC_ME_NEB_INFO* up_nebs, ENC_ME_NEB_INFO* left_nebs, SKIP_MERGE_INPUT* skip_in,
#else
    ENC_ME_NEB_INFO up_nebs[10], ENC_ME_NEB_INFO left_nebs[8], SKIP_MERGE_INPUT* skip_in,
#endif //__SYNTHESIS__
	U2 tree_status, MD_COM_MODE_BEST* best_info_ptr, MD_INPUT* md_input_ptr, pel orgY_32[32][32], pel orgY_32_cp1[32][32], pel orgY_32_cp2[32][32],
#if ENABLE_BFRAME
	ME_MV_DIR* me_mv_dir,
#endif
	MD_COM_MODE* mod_info_curr_ptr, ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr, U2 curr_cons_pred_mode, U3 qt_depth,
	ENC_FME_INFO_ALL* fme_mv_info,
	u8 rmd_mode[IPRED_LIST_NUM],
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16,
	IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16,
	MD_KERNEL_INPUT_32* md_kernel_input_32,
	//pel fme2mdrefbuf[2560][8][2][16],
	S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_inter1[32][32], pel pred_y_inter2[2][32][32], pel pred_y_intra[5][32][32],
	strFetch_ref_window* Fetch_Ref_window_ptr,
#if SUB_TMVP
	CORE_SBTMVP* core_sbtmvp,
#endif
	//add new paras
	U1 valid_mode[17],
	u8 ipred_list[IPRED_LIST_NUM],
	pel src_le_temp[2 * 32 + 3],
	pel src_up_temp[2 * 32 + 3],
	u16 avail_tb,
	u8 rdo_list[MD_MAX_RDO_NUM],
	u8 inter_rdo_num,
	SKIP_RDO* skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO],
	MERGE_RDO* merge_rdo,
	S14 sub_pel_mv[MV_D],
	s16 mvp_all[2][5][2],
#if ENABLE_BFRAME
	MV_DIR* mv_dir,
#endif
	s64 *cost_best)
{
#pragma HLS INLINE off

#pragma HLS ARRAY_PARTITION variable=orgY_32                    dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=pred_y_intr                dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=pred_y_intr                dim=3 complete
//#pragma HLS ARRAY_PARTITION variable=mod_info_curr_ptr->mpm     dim=0 complete

	U4 bit_depth = md_fw_ptr->bit_depth_internal;
	u8 curr_mvr, curr_mvr_update;
	MD_KERNEL_MODE_32 md_info_nz_32;
	u8 mode_type, mode_type_update;

	s8 inter_mode_idx;
	//u8 rdo_idx;
	U1 is_intra_quant, is_intra_rate, is_intra_update;

//    pel orgY_32_cp1[32][32];                                // mem cp for DATAFLOW
//    pel orgY_32_cp2[32][32];
	static s16 coef_tmp_32x32  [32][32];
	static s16 coef_tmp_h      [32][32];
	static s16 coef_tmp_v      [32][32];
	static s16 coef_tmp_v_to_it[32][32];
	static s16 coef_tmp_h_to_it[32][32];
	static pel rec_y_pb_part   [32][32];
	static pel pred_cache_32x32[32][32], pred_cache_32x32_update[32][32];
	       s16 coef_y_pb_part  [32][32], coef_y_pb_part_update  [32][32];
	int num_nz_rate[MAX_NUM_TB][N_C], num_nz_itv, num_nz_ith, num_nz_update[MAX_NUM_TB][N_C];
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_32x32     dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_h         dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_v         dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_v_to_it   dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=coef_tmp_h_to_it   dim=1 complete
//#pragma HLS ARRAY_PARTITION variable=num_nz_rate        dim=0 complete
//#pragma HLS ARRAY_PARTITION variable=num_nz_update      dim=0 complete
//
//#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part     dim=1 block factor=32
//#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part_cp  dim=1 block factor=32
//
//#pragma HLS ARRAY_PARTITION variable=coef_y_pb_part_update      dim=1 block factor=32
//
//#pragma HLS ARRAY_PARTITION variable=rec_y_pb_part              dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=pred_cache_32x32_update    dim=2 complete

	U1 valid_flag = 0;
	s32 dist; // = 0;
	s64 cost_best_temp = MAX_S64;
	s64 dist_pred; // = 0;
	s64 lambda_y = md_input_ptr->lambda_y;

	U3 cu_width_log2  = mod_info_curr_ptr->cu_width_log2;
	U3 cu_height_log2 = mod_info_curr_ptr->cu_height_log2;

	U13 pic_height = md_fw_ptr->pic_height_in_scu << 2;
	U13 pic_width  = md_fw_ptr->pic_width_in_scu  << 2;

	U2 slice_type = md_fw_ptr->slice_type;
	s64 flag_cost[3];
	s64 cost_pb_best = MAX_S64;
#if 0
	static pel orgY[32 * 32];
	pel orgY_32[32][32];
	for (int i = 0; i < cu_height; i++) {
		for (int j = 0; j < cu_width; j++) {
			orgY_32[i][j] = p_fenc_LCU_Y[(mod_info_curr_ptr->y_pos - md_input_ptr->pix_y + i) * 64 + (mod_info_curr_ptr->x_pos - md_input_ptr->pix_x + j)];
		}
	}
#endif

//	// mem copy
//    array_cp_org_y(orgY_32, orgY_32_cp, orgY_32_cp1);	// mem cp for DATAFLOW

#if !AZB_ENABLE
#if USE_SPEED_LEVEL
		int rdo_cnt = 5;
		if (md_input_ptr->speed_level == 1)
			rdo_cnt = IPD_RDO_CNT; //5
		else if (md_input_ptr->speed_level == 2)
			rdo_cnt = EXTRA_RDO_MODE;//10
		else
			rdo_cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
		int rdo_cnt = 5;
#endif

		for (u8 rdo_idx = 0; rdo_idx < rdo_cnt; rdo_idx++) {
#pragma HLS LOOP_TRIPCOUNT max=5 min=5
#pragma HLS DATAFLOW

            pel pred_cache_cp1[32][32], pred_cache_cp2[32][32];
//#pragma HLS ARRAY_PARTITION variable=pred_cache_cp1     dim=2 complete
//#pragma HLS ARRAY_PARTITION variable=pred_cache_cp2     dim=2 complete

		// DATAFLOW step 1
		intra_inter_pred_32(w, h, curr_mvr, &md_info_nz_32, orgY_32, mode_type, inter_mode_idx, coef_tmp_32x32, &valid_flag, valid_mode, /*pred_y_intr[rdo_idx],*/pred_cache_cp1, pred_cache_32x32_update,
			mv_copy, mvd_copy, refi_copy, pred_y_inter1, pred_y_inter2, pred_y_intra,
			&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num, md_input_ptr,
			64, skip_rdo, skip_rdo_mode, *merge_rdo, cu_width_log2, cu_height_log2,
			tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all, pic_width, pic_height, md_kernel_input_32, mod_info_curr_ptr->mpm, bit_depth,
			md_input_ptr->CtrPos2MD,
#if ENABLE_BFRAME
				md_input_ptr->CtrPos2MD_ref1, mv_dir, md_fw_ptr, Fetch_Ref_window_ptr
#endif
				//,fme2mdrefbuf
#if MIPF
				, md_fw_ptr->mipf_enable_flag
#endif
#if SUB_TMVP
				, mod_info_curr_ptr->skip_idx, core_sbtmvp
#endif
#if USE_SPEED_LEVEL
				, md_input_ptr->speed_level
#endif
			);
#if DEBUG_CU
			if (isProblem)
			{
				printf("Idx=%d CurB: cu_mode=%d,umve_flag=%d,affine_flag=%d,skip_idx=%d\n", rdo_idx, md_info_nz_32.cu_mode, md_info_nz_32.umve_flag, md_info_nz_32.affine_flag, md_info_nz_32.skip_idx);
			}
#endif
			// DATAFLOW step 2
			transform_hor_32_lite(w, h, bit_depth, coef_tmp_32x32, coef_tmp_h, slice_type);

			// DATAFLOW step 3
			transform_ver_32_lite(w, h, slice_type, bit_depth, coef_tmp_h, coef_tmp_v);

			// DATAFLOW step 4
			quant_nnz_32_lite(num_nz_rate, &num_nz_itv, w, h, rdoq_array, bit_depth, md_input_ptr->qp_y, md_input_ptr->lambda_y,
				is_intra_quant, &is_intra_rate, coef_tmp_v, cu_width_log2, cu_height_log2, 0, slice_type,
				coef_y_pb_part, coef_tmp_v_to_it, coef_y_pb_part_update);

			// DATAFLOW step 5
			rate_est_32(w, h, &md_info_nz_32, mode_type, &mode_type_update, curr_mvr, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_y_pb_part, lambda_y, is_intra_rate, &is_intra_update, flag_cost, slice_type, num_nz_rate, md_kernel_input_32);

			// DATAFLOW step 6
			inv_transform_ver_32_lite(w, h, bit_depth, md_input_ptr->qp_y, num_nz_itv, &num_nz_ith, num_nz_update, coef_tmp_v_to_it, cu_width_log2, cu_height_log2, 1 << cu_width_log2, 1 << cu_height_log2, 0, coef_tmp_h_to_it);

			// DATAFLOW step 7
			inv_transform_hor_32_lite(w, h, bit_depth, num_nz_ith, cu_width_log2, cu_height_log2, /*pred_y_intr[rdo_idx],*/pred_cache_cp1, &dist, &dist_pred, rec_y_pb_part, coef_tmp_h_to_it, 0, /*orgY_32,*/orgY_32_cp1, orgY_32_cp2 /*, pred_cache_32x32_update*/);

			// DATAFLOW step 8
			update_rdo_luma_32(valid_flag, w, h, cu_data_ptr, &md_info_nz_32, mode_type_update, &dist_pred, &cost_best_temp, best_info_ptr, cost_best, curr_mvr_update,
				rec_y_pb_part, pred_cache_32x32_update, coef_y_pb_part_update, &dist, is_intra_update, &cost_pb_best, flag_cost, num_nz_update, md_kernel_input_32
#if SUB_TMVP
				, core_sbtmvp
#endif
#if USE_ROI_MODE_CONFIG
				, md_input_ptr->valid_mode_config
#endif
			);
#if SET_MD_32_MAX_COST
			*cost_best = 1 << 25;
#endif

#if DEBUG_CU
			if (isProblem)
			{
				printf("Idx=%d CurA: cu_mode=%d,umve_flag=%d,affine_flag=%d,skip_idx=%d\n", rdo_idx, md_info_nz_32.cu_mode, md_info_nz_32.umve_flag, md_info_nz_32.affine_flag, md_info_nz_32.skip_idx);
				printf("Idx=%d Best: cu_mode=%d,umve_flag=%d,affine_flag=%d,skip_idx=%d\n", rdo_idx, best_info_ptr->cu_mode, best_info_ptr->umve_flag, best_info_ptr->affine_flag, best_info_ptr->skip_idx);
			}
#endif
		}
#else
		is_intra_rate = 0;
		if (slice_type == 1) // i slice
		{
			for (u8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {
				intra_inter_pred_32(w, h, curr_mvr, &md_info_nz_32, orgY_32, mode_type, inter_mode_idx, coef_tmp_32x32, &valid_flag, valid_mode, pred_cache_32x32,
					&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
					model_cnt, md_input_ptr,
					RefWindowLCU, CtrPos,
#if ENABLE_BFRAME
					RefWindowLCU_ref1, CtrPos_ref1, &mv_dir, refwin_md_ref1, CtrPosFME_ref1, md_fw_ptr, Fetch_Ref_window_ptr,
#endif
					64, skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
					tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all, pic_width, pic_height, md_kernel_input_32, mod_info_curr_ptr->mpm, bit_depth, refwin_md, CtrPosFME);

				transform_hor_32_lite(w, h, bit_depth, coef_tmp_32x32, coef_tmp_h, slice_type);
				transform_ver_32_lite(w, h, slice_type, bit_depth, coef_tmp_h, coef_tmp_v);
				quant_nnz_32_lite(num_nz_rate, num_nz_update, &num_nz_itv, w, h, model_cnt, rdoq_array, bit_depth, md_input_ptr->qp_y, md_input_ptr->lambda_y,
					is_intra_quant, &is_intra_rate, coef_tmp_v, cu_width_log2, cu_height_log2, 0, slice_type,
					coef_y_pb_part, coef_tmp_v_to_it, coef_y_pb_part_update);

				rate_est_32(w, h, model_cnt, &md_info_nz_32, mode_type, &mode_type_update, curr_mvr, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_y_pb_part, lambda_y, is_intra_rate, &is_intra_update, flag_cost, slice_type, num_nz_rate, md_kernel_input_32);

				inv_transform_ver_32_lite(w, h, bit_depth, md_input_ptr->qp_y, num_nz_itv, &num_nz_ith, coef_tmp_v_to_it, cu_width_log2, cu_height_log2, 1 << cu_width_log2, 1 << cu_height_log2, 0, coef_tmp_h_to_it);
				inv_transform_hor_32_lite(w, h, bit_depth, num_nz_ith, cu_width_log2, cu_height_log2, pred_cache_32x32, &dist, &dist_pred, rec_y_pb_part, coef_tmp_h_to_it, 0, orgY, pred_cache_32x32_update);
				update_rdo_luma_32(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz_32, mode_type_update, &dist_pred, &cost_best_temp, best_info_ptr, &cost_best, curr_mvr_update,
					rec_y_pb_part, pred_cache_32x32_update, coef_y_pb_part_update, &dist, is_intra_update, &cost_pb_best, flag_cost, num_nz_update, md_kernel_input_32);
			}
		}
		else // p b slice
		{
			for (rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {
				intra_inter_pred_32(w, h, curr_mvr, &md_info_nz_32, orgY_32, mode_type, inter_mode_idx, coef_tmp_32x32, &valid_flag, valid_mode, pred_cache_32x32,
					&is_intra_quant, ipred_list, src_le_temp, src_up_temp, avail_tb, rdo_list, rdo_idx, inter_rdo_num,
					model_cnt, md_input_ptr,
					RefWindowLCU, CtrPos,
#if ENABLE_BFRAME
					RefWindowLCU_ref1, CtrPos_ref1, &mv_dir, refwin_md_ref1, CtrPosFME_ref1, md_fw_ptr, Fetch_Ref_window_ptr,
#endif
					64, skip_rdo, skip_rdo_mode, merge_rdo, cu_width_log2, cu_height_log2,
					tree_status, curr_cons_pred_mode, sub_pel_mv, mvp_all, pic_width, pic_height, md_kernel_input_32, mod_info_curr_ptr->mpm, bit_depth, refwin_md, CtrPosFME);

				for (int i = 0; i < 1024; ++i)
				{
					coef_y_pb_part[i] = 0;
				}
				dist = enc_ssd_16b_1_32(cu_width_log2, cu_height_log2, pred_cache_32x32, orgY_32, 32, bit_depth);
				rate_est_azb_32(w, h, model_cnt, &md_info_nz_32, mode_type, &mode_type_update, curr_mvr, &curr_mvr_update, tree_status, curr_cons_pred_mode, coef_y_pb_part, lambda_y, is_intra_rate, &is_intra_update, flag_cost, slice_type, num_nz_rate, md_kernel_input_32);
				update_rdo_luma_32(valid_flag, w, h, cu_data_temp_ptr, &md_info_nz_32, mode_type_update, &dist_pred, &cost_best_temp, best_info_ptr, &cost_best, curr_mvr_update,
					pred_cache_32x32, pred_cache_32x32, coef_y_pb_part, &dist, is_intra_update, &cost_pb_best, flag_cost, num_nz_update, md_kernel_input_32);
			}
		}
#endif
}
#endif //!LUMA_32_PIPELINE_DUMMY
#if MD_KERNEL_32_MOD_YHY

void ipred_ang_eipm_32_pred(pel src_le[67], pel src_up[67], int w, int h, int ipm
#if MIPF
    , int is_luma, int mipf_enable_flag, U4 bit_depth, s16 diff[32][32]
#endif
)
{

#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=diff complete dim=2

    pel tmp, tmp1;
    static const int com_tbl_ipred_dxdy[IPD_CNT][2] = /* {dx/dy, dy/dx} */
    {
        {0, 0},{0, 0},{0, 0},                                 //0~2
        {2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //3~6
        {744, 1408},{512, 2048},                              //7~8
        {372, 2816},                                          //9
        {256, 4096},                                          //10
        {128, 8192},{0, 0},{128, 8192},{256, 4096},           //11~14
        {372, 2816},{512, 2048},{744, 1408},{1024, 1024},     //15~18
        {1408, 744},{2048, 512},{2816, 372},                  //19~21
        {4096, 256},                                          //22
        {8192, 128},{0, 0},{8192, 128},{4096, 256},           //23~26
        {2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //27~30
        {744, 1408},{ 512, 2048 },{0, 0},{2340, 448},         //31~34
        {1640, 640},                                          //35
        {1168, 898},{898, 1168},{640, 1640},{448, 2340},      //36~39
        {320, 3276},{192, 5460},{64, 16384},{32, 32768},      //40~43
        {32, 32768},{64, 16384},{192, 5460},{320, 3276},      //44~47
        {448, 2340},                                          //48
        {640, 1640},{898, 1168},{1168, 898},{1640, 640},      //49~52
        {2340, 448},{3276, 320},{5460, 192},{16384, 64},      //53~56
        {32768, 32},{32768, 32},{16384, 64},{5460, 192},      //57~60
        {3276, 320},{2340, 448},                              //61~62
        {1640, 640},{1168, 898},{898, 1168}                   //63~65
    };
#if MIPF

    static const s16 com_tbl_ipred_adi_bilinear[32][4] =
    {
        /* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
        { 32, 64, 32,  0 },
        { 31, 63, 33,  1 },
        { 30, 62, 34,  2 },
        { 29, 61, 35,  3 },
        { 28, 60, 36,  4 },
        { 27, 59, 37,  5 },
        { 26, 58, 38,  6 },
        { 25, 57, 39,  7 },
        { 24, 56, 40,  8 },
        { 23, 55, 41,  9 },
        { 22, 54, 42, 10 },
        { 21, 53, 43, 11 },
        { 20, 52, 44, 12 },
        { 19, 51, 45, 13 },
        { 18, 50, 46, 14 },
        { 17, 49, 47, 15 },
        { 16, 48, 48, 16 },
        { 15, 47, 49, 17 },
        { 14, 46, 50, 18 },
        { 13, 45, 51, 19 },
        { 12, 44, 52, 20 },
        { 11, 43, 53, 21 },
        { 10, 42, 54, 22 },
        { 9, 41, 55, 23 },
        { 8, 40, 56, 24 },
        { 7, 39, 57, 25 },
        { 6, 38, 58, 26 },
        { 5, 37, 59, 27 },
        { 4, 36, 60, 28 },
        { 3, 35, 61, 29 },
        { 2, 34, 62, 30 },
        { 1, 33, 63, 31 },
    };

    static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
    {
        /* best for CfP extra smooth */
        { 23, 82, 21, 2 },
        { 21, 82, 23, 2 },
        { 19, 82, 25, 2 },
        { 18, 81, 27, 2 },
        { 16, 80, 30, 2 },
        { 15, 79, 32, 2 },
        { 13, 78, 35, 2 },
        { 12, 77, 37, 2 },
        { 11, 75, 40, 2 },
        { 10, 74, 42, 2 },
        { 9, 72, 45, 2 },
        { 8, 70, 47, 3 },
        { 7, 68, 50, 3 },
        { 6, 67, 52, 3 },
        { 6, 64, 54, 4 },
        { 5, 62, 57, 4 },
        { 4, 60, 60, 4 },
        { 4, 57, 62, 5 },
        { 4, 54, 64, 6 },
        { 3, 52, 67, 6 },
        { 3, 50, 68, 7 },
        { 3, 47, 70, 8 },
        { 2, 45, 72, 9 },
        { 2, 42, 74, 10 },
        { 2, 40, 75, 11 },
        { 2, 37, 77, 12 },
        { 2, 35, 78, 13 },
        { 2, 32, 79, 15 },
        { 2, 30, 80, 16 },
        { 2, 27, 81, 18 },
        { 2, 25, 82, 19 },
        { 2, 23, 82, 21 },
    };

    static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
    {
        // semi-sharp
        { 11, 106, 12, -1 },
        { 9, 105, 15, -1 },
        { 7, 105, 18, -2 },
        { 6, 103, 21, -2 },
        { 4, 102, 25, -3 },
        { 2, 100, 29, -3 },
        { 1, 99, 32, -4 },
        { 0, 96, 36, -4 },
        { -1, 94, 39, -4 },
        { -2, 92, 43, -5 },
        { -3, 89, 47, -5 },
        { -4, 86, 51, -5 },
        { -4, 83, 55, -6 },
        { -5, 80, 59, -6 },
        { -5, 77, 62, -6 },
        { -6, 74, 66, -6 },
        { -6, 70, 70, -6 },
        { -6, 66, 74, -6 },
        { -6, 62, 77, -5 },
        { -6, 59, 80, -5 },
        { -6, 55, 83, -4 },
        { -5, 51, 86, -4 },
        { -5, 47, 89, -3 },
        { -5, 43, 92, -2 },
        { -4, 39, 94, -1 },
        { -4, 36, 96, 0 },
        { -4, 32, 99, 1 },
        { -3, 29, 100, 2 },
        { -3, 25, 102, 4 },
        { -2, 21, 103, 6 },
        { -2, 18, 105, 7 },
        { -1, 15, 105, 9 },
    };

    static const s16 tbl_mc_c_coeff_hp[32][4] =
    {
        { 0, 64, 0, 0 },
        { -1, 63,  2,  0 },
        { -2, 62,  4,  0 },
        { -2, 60,  7,  -1 },
        { -2, 58, 10, -2 },
        { -3, 57, 12, -2 },
        { -4, 56, 14, -2 },
        { -4, 55, 15, -2 },
        { -4, 54, 16, -2 },
        { -5, 53, 18, -2 },
        { -6, 52, 20, -2 },
        { -6, 49, 24, -3 },
        { -6, 46, 28, -4 },
        { -5, 44, 29, -4 },
        { -4, 42, 30, -4 },
        { -4, 39, 33, -4 },
        { -4, 36, 36, -4 },
        { -4, 33, 39, -4 },
        { -4, 30, 42, -4 },
        { -4, 29, 44, -5 },
        { -4, 28, 46, -6 },
        { -3, 24, 49, -6 },
        { -2, 20, 52, -6 },
        { -2, 18, 53, -5 },
        { -2, 16, 54, -4 },
        { -2, 15, 55, -4 },
        { -2, 14, 56, -4 },
        { -2, 12, 57, -3 },
        { -2, 10, 58, -2 },
        { -1,  7, 60, -2 },
        { 0,  4, 62, -2 },
        { 0,  2, 63, -1 },
    };
#else
    static const s16 com_tbl_ipred_adi[32][4] = { { (32), (64), (32), 0 }, { (31), (63), (33), (1) }, { (30), (62), (34), (2) }, { (29), (61), (35), (3) }, { (28), (60), (36), (4) }, { (27), (59), (37), (5) }, { (26), (58), (38), (6) }, { (25), (57), (39), (7) }, { (24), (56), (40), (8) }, { (23), (55), (41), (9) }, { (22), (54), (42), (10) }, { (21), (53), (43), (11) }, { (20), (52), (44), (12) }, { (19), (51), (45), (13) }, { (18), (50), (46), (14) }, { (17), (49), (47), (15) }, { (16), (48), (48), (16) }, { (15), (47), (49), (17) }, { (14), (46), (50), (18) }, { (13), (45), (51), (19) }, { (12), (44), (52), (20) }, { (11), (43), (53), (21) }, { (10), (42), (54), (22) }, { (9), (41), (55), (23) }, { (8), (40), (56), (24) }, { (7), (39), (57), (25) }, { (6), (38), (58), (26) }, { (5), (37), (59), (27) }, { (4), (36), (60), (28) }, { (3), (35), (61), (29) }, { (2), (34), (62), (30) }, { (1), (33), (63), (31) } };
#endif

#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_adi_bilinear complete dim=2
#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_dxdy complete dim=2
#pragma HLS   ARRAY_PARTITION variable=tbl_mc_c_coeff_hp complete dim=2
#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_adi_extra_smooth complete dim=2
#pragma HLS   ARRAY_PARTITION variable=com_tbl_ipred_adi_semi_sharp complete dim=2

#if MIPF
    //const s16(*tbl_filt_list[4])[4] = { com_tbl_ipred_adi + 32, com_tbl_ipred_adi + 64, tbl_mc_c_coeff_hp, com_tbl_ipred_adi };
    const int filter_bits_list[4] = { 7, 7, 6, 7 };
    const int filter_offset_list[4] = { 64, 64 ,32, 64 };
    const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
    const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
    int filter_idx;
#else
    const s16(*tbl_filt)[4] = com_tbl_ipred_adi;
    const int filter_offset = ADI_4T_FILTER_OFFSET;
    const int filter_bits = ADI_4T_FILTER_BITS;
#endif

    const int* mt = com_tbl_ipred_dxdy[ipm];

    int offset_x[MAX_CU_SIZE], offset_y[MAX_CU_SIZE];
    int t_dx[MAX_CU_SIZE], t_dy[MAX_CU_SIZE];
    int i, j;
    int offset = 0;
    int pos_max = w + h - 1;
    int p, pn, pn_n1, pn_p2;

#if CLOSE_MD_HLS
#pragma HLS ARRAY_PARTITION variable=t_dx complete dim=0
#pragma HLS ARRAY_PARTITION variable=t_dy complete dim=0
#pragma HLS ARRAY_PARTITION variable=offset_x complete dim=0
#pragma HLS ARRAY_PARTITION variable=offset_y complete dim=0
#endif

    if (((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT)) || (((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))))
    {
        if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT))
            pos_max = w * 2 - 1;
        else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
            pos_max = h * 2 - 1;

        for (j = 0; j < 32; j++)
        {
#pragma HLS PIPELINE
            int dx;

            for (i = 0; i < 32; i++)
            {
				if(i < w && j < h)
				{
					int x;
					int src_p, src_pn, src_pn_n1, src_pn_p2;

					if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT)) {
						GET_REF_POS(mt[0], j + 1, dx, offset);
						filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;

						x = i + dx;

						pn_n1 = x - 1;
						p = x;
						pn = x + 1;
						pn_p2 = x + 2;

						pn_n1 = COM_MIN(pn_n1, pos_max);
						p = COM_MIN(p, pos_max);
						pn = COM_MIN(pn, pos_max);
						pn_p2 = COM_MIN(pn_p2, pos_max);

						src_pn_n1 = src_up[pn_n1];
						src_p = src_up[p];
						src_pn = src_up[pn];
						src_pn_p2 = src_up[pn_p2];
					}
					else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
					{
						GET_REF_POS(mt[1], i + 1, dx, offset);
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;

						x = j + dx;

						pn_n1 = x - 1;
						p = x;
						pn = x + 1;
						pn_p2 = x + 2;

						pn_n1 = COM_MIN(pn_n1, pos_max);
						p = COM_MIN(p, pos_max);
						pn = COM_MIN(pn, pos_max);
						pn_p2 = COM_MIN(pn_p2, pos_max);

						src_pn_n1 = src_le[pn_n1];
						src_p = src_le[p];
						src_pn = src_le[pn];
						src_pn_p2 = src_le[pn_p2];

					}

					s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][0] : com_tbl_ipred_adi_bilinear[offset][0];
					s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][1] : com_tbl_ipred_adi_bilinear[offset][1];
					s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][2] : com_tbl_ipred_adi_bilinear[offset][2];
					s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][3] : com_tbl_ipred_adi_bilinear[offset][3];
					s16 data5 = filter_offset_list[filter_idx];
					s16 data6 = filter_bits_list[filter_idx];
					s32 buffer1 = src_pn_n1 * data1;
					s32 buffer2 = src_p * data2;
					s32 buffer3 = src_pn * data3;
					s32 buffer4 = src_pn_p2 * data4;
					tmp = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
					tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
					diff[j][i] = tmp1;
				}
            }
        }
    }
    else
    {
        for (i = 0; i < 32; i++)
        {
#pragma HLS UNROLL
            if(i<w)
			{
                GET_REF_POS(mt[1], i + 1, t_dy[i], offset_y[i]);
                t_dy[i] = -t_dy[i];
			}
        }
        for (j = 0; j < 32; j++)
        {
#pragma HLS UNROLL
            if(j<h)
			{
                GET_REF_POS(mt[0], j + 1, t_dx[j], offset_x[j]);
            	t_dx[j] = -t_dx[j];
			}
        }

        {
            for (j = 0; j < 32; j++)
            {
#pragma HLS PIPELINE
                for (i = 0; i < 32; i++)
                {
					if (i < w && j < h)
					{
						int x = i + t_dx[j];
						int y = j + t_dy[i];
						int src_p, src_pn, src_pn_n1, src_pn_p2;

						if (y <= -1)
						{
							offset = offset_x[j];
							pos_max = w * 2 - 1;

							pn_n1 = x + 1;
							p = x;
							pn = x - 1;
							pn_p2 = x - 2;

							pn_n1 = COM_MIN(pn_n1, pos_max);
							p = COM_MIN(p, pos_max);
							pn = COM_MIN(pn, pos_max);
							pn_p2 = COM_MIN(pn_p2, pos_max);

							src_pn_n1 = src_up[pn_n1];
							src_p = src_up[p];
							src_pn = src_up[pn];
							src_pn_p2 = src_up[pn_p2];

						}
						else
						{
							offset = offset_y[i];
							pos_max = h * 2 - 1;

							pn_n1 = y + 1;
							p = y;
							pn = y - 1;
							pn_p2 = y - 2;

							pn_n1 = COM_MIN(pn_n1, pos_max);
							p = COM_MIN(p, pos_max);
							pn = COM_MIN(pn, pos_max);
							pn_p2 = COM_MIN(pn_p2, pos_max);

							src_pn_n1 = src_le[pn_n1];
							src_p = src_le[p];
							src_pn = src_le[pn];
							src_pn_p2 = src_le[pn_p2];

						}

						if (ipm < IPD_DIA_R || (ipm > IPD_VER_EXT && ipm <= IPD_DIA_R_EXT)) {
							filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
						}
						else
						{
							filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
						}

						s16 data1 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][0] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][0] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][0] : com_tbl_ipred_adi_bilinear[offset][0];
						s16 data2 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][1] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][1] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][1] : com_tbl_ipred_adi_bilinear[offset][1];
						s16 data3 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][2] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][2] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][2] : com_tbl_ipred_adi_bilinear[offset][2];
						s16 data4 = filter_idx == 0 ? com_tbl_ipred_adi_extra_smooth[offset][3] : filter_idx == 1 ? com_tbl_ipred_adi_semi_sharp[offset][3] : filter_idx == 2 ? tbl_mc_c_coeff_hp[offset][3] : com_tbl_ipred_adi_bilinear[offset][3];
						s16 data5 = filter_offset_list[filter_idx];
						s16 data6 = filter_bits_list[filter_idx];
						s32 buffer1 = src_pn_n1 * data1;
						s32 buffer2 = src_p * data2;
						s32 buffer3 = src_pn * data3;
						s32 buffer4 = src_pn_p2 * data4;
						tmp = (pel)((buffer1 + buffer2 + buffer3 + buffer4 + data5) >> data6);
						tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp);
						diff[j][i] = tmp1;
					}
                }
            }
        }
    }
}

void get_ref_inter_32_32(u8 w, u8 h,MD_FW * md_fw_ptr, u8 ctx_cons_pred_mode, SKIP_ELEMENT skip_mode[SKIP_MODE_NUM],  MD_COM_MODE * mod_info_curr,
		u8 rdo_list[5], MV_DIR * mv_dir, s16 mvp_all[2][5][2], U2 tree_status, S14 sub_pel_mv[MV_D], MD_KERNEL_INPUT_32 * md_kernel_input, SKIP_RDO * skip_rdo,
		S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_skip_inter[13][32][32], strFetch_ref_window * Fetch_Ref_window_ptr,
		S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],  Arbitor& ref, pel pred_y_inter2[2][32][32], 
		CORE_SBTMVP * core_sbtmvp,MD_INPUT* md_input_ptr,u8 intra_mode_list[IPRED_LIST_NUM],int stride_org)
{
    int pic_height = md_fw_ptr->pic_height_in_scu << 2;
	int pic_width = md_fw_ptr->pic_width_in_scu << 2;
	static MD_KERNEL_MODE_32 mode_info_write_32;

#pragma HLS ARRAY_PARTITION variable=pred_y_inter2 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_inter2 complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred_y_skip_inter complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_y_skip_inter complete dim=3
#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=intra_mode_list complete dim=0

#pragma HLS ARRAY_PARTITION variable=skip_mode complete dim=0
#pragma HLS ARRAY_PARTITION variable=skip_mode[11].refi complete dim=0
//#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP complete dim=0
#pragma HLS ARRAY_PARTITION variable=CtrPosSKIP_ref1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_curr->mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=mvd_copy complete dim=0
#pragma HLS ARRAY_PARTITION variable=refi_copy complete dim=0

	//get skip pred
	if (!(md_fw_ptr->slice_type == 1 || ctx_cons_pred_mode == ONLY_INTRA)) 
	{
		for (int idx = 0; idx < SKIP_MODE_NUM + 1; ++idx)
		{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT max=13
			if (idx < SKIP_MODE_NUM)
			{
				SKIP_ELEMENT* mode = skip_mode + idx;

				if (mode->valid == 0) 
				{ 
					continue; 
				}

#pragma HLS ARRAY_PARTITION variable=mode->mvp complete dim=0
#pragma HLS ARRAY_PARTITION variable=mode->refi complete dim=0
//#pragma HLS ARRAY_PARTITION variable=mod_info_curr->mv complete dim=0
//#pragma HLS ARRAY_PARTITION variable=mod_info_curr->refi complete dim=0

				mod_info_curr->cu_mode = MODE_SKIP;
				mod_info_curr->umve_flag = mode->umve_flag;
				mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
				mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
				mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
				mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
				mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
				mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
				mod_info_curr->mv[1][0] = 0;
				mod_info_curr->mv[1][1] = 0;
				mod_info_curr->refi[1] = -1;
#endif
				// skip index 1 and 2 for P slice
#if ENABLE_BFRAME
				if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) 
				{ 
					continue; 
				}
#else
				if (mod_info_curr->refi[0] == -1) { continue; }
#endif
			}
			else 
			{
				mod_info_curr->cu_mode = MODE_INTER;
				s8 inter_mode_idx = rdo_list[0];
#if ENABLE_BFRAME
				u8 num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
#endif
				int refi_cur = 0;
				s16 mv_all[2][5][2];
				int best_mv_uni_inner[2][4][2];

#pragma HLS ARRAY_PARTITION variable=mv_all complete dim=0
#pragma HLS ARRAY_PARTITION variable=best_mv_uni_inner complete dim=0

				u8 curr_mvr = 0;
				U2 mode_type = 0;

				if (inter_mode_idx < 17) 
				{
					static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
					static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };

					mode_type = mode_type_table[inter_mode_idx];
					curr_mvr = curr_mvr_table[inter_mode_idx];
					if (mode_type == 1) 
					{
						BOOL res = analyze_me_uni_pred_32(&mode_info_write_32, md_input_ptr, curr_mvr, w, h,
							mvp_all, mv_all, best_mv_uni_inner,
							stride_org, refi_cur, tree_status, ctx_cons_pred_mode, sub_pel_mv,
							md_kernel_input, md_fw_ptr->bit_depth_internal
#if ENABLE_BFRAME
							, mv_dir, num_refp_cnt
#endif
						);
#if ENABLE_BFRAME
						U1 lidx = mv_dir->lidx;
#else 
						U1 lidx = 0;
#endif					
						mv_copy[lidx][0] = mode_info_write_32.mv[lidx][0];
						mv_copy[lidx][1] = mode_info_write_32.mv[lidx][1];
						mvd_copy[lidx][0] = mode_info_write_32.mvd[lidx][0];
						mvd_copy[lidx][1] = mode_info_write_32.mvd[lidx][1];
						refi_copy[0] = mode_info_write_32.refi[0];
						refi_copy[1] = mode_info_write_32.refi[1];
					}
				}
			}
			// calc pred info
			if (idx < SKIP_MODE_NUM) 
			{
				CU_POS cu = { (int)mod_info_curr->scup, mod_info_curr->x_pos, mod_info_curr->y_pos, mod_info_curr->cu_width, mod_info_curr->cu_height };
				BOOL res = com_mc_cu_y_32(&cu, pic_width, pic_height, mod_info_curr->refi, mod_info_curr->mv,
					SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
					CtrPos2MD
#if ENABLE_BFRAME
					, CtrPosSKIP_ref1
#endif//ENABLE_BFRAME
					, ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
					, core_sbtmvp, idx, mod_info_curr->umve_flag
#endif	
				);
			}
			else 
			{
				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };

				BOOL res1 = com_mc_cu_y_32(&cu, pic_width, pic_height, mode_info_write_32.refi, mode_info_write_32.mv,
					SWW, pred_y_skip_inter[idx], md_fw_ptr->bit_depth_internal, Fetch_Ref_window_ptr,
					CtrPos2MD,
					CtrPosSKIP_ref1,
					ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
					, core_sbtmvp, mode_info_write_32.skip_idx, mode_info_write_32.umve_flag
#endif
				);
			}
		}
	}

	//get inter pred
	U8 mode_list[MAX_INTER_SKIP_RDO] = { 0 };

#pragma HLS ARRAY_PARTITION variable=mode_list complete dim=0

    int j = 0;
	for (int i = 0; i < 12; ++i) 
	{
#pragma HLS PIPELINE
        if(j<4)
		{
			if (skip_mode[i].valid && (skip_mode[i].refi[REFP_0] >= 0 || REFI_IS_VALID(skip_mode[i].refi[REFP_1])))
			{
				mode_list[j++] = i;
			}
		}
	}

	for (U8 rdo_idx = 1; rdo_idx < 3; rdo_idx++) 
	{
#pragma HLS PIPELINE
		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;
		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 1) {
			if (inter_mode_idx < skip_rdo->num_rdo) {
				int skip_idx = inter_mode_idx;
				if (rdo_idx == 1 || rdo_idx == 2) {
					for (int j = 0; j < 32; j++) {
						for (int k = 0; k < 32; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
				}
			}
		}
	}
}

void get_ref_intra_32_32(u8 all_rdo_num, u8 rdo_list[5], u8 intra_mode_list[IPRED_LIST_NUM], pel src_le_temp[32 * 2 + 3], pel src_up_temp[32 * 2 + 3],
		pel pred_y_intra[5][32][32], U4 bit_depth_internal, int mipf_enable_flag, U8 w, U8 h, u16 avail_tb)
{

#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=intra_mode_list complete dim=0

    //get intra_pred
	for (U8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) 
	{
#pragma HLS LOOP_TRIPCOUNT max=5
		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;

		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 0) {

			if (intra_mode_idx == 12)
				Ipred_vert_32_pred(w, h, src_up_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 24)
				Ipred_hor_32_pred(w, h, src_le_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 0)
				Ipred_dc_32_pred(w, h, src_le_temp + 3, src_up_temp + 3, bit_depth_internal, avail_tb, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 1)
				Ipred_plane_32_pred(w, h, src_le_temp + 2, src_up_temp + 2, bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 2)
				Ipred_bi_32_pred(w, h, src_le_temp + 3, src_up_temp + 3, bit_depth_internal, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
				ipred_ang1_32_pred(w, h, src_le_temp, src_up_temp, bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, mipf_enable_flag
#endif
				);
			else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
				ipred_ang2_32_pred(w, h, src_le_temp, src_up_temp, bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, mipf_enable_flag
#endif
				);
			else
			{
#if EIPM
				if (intra_mode_idx > 33)
				{
					ipred_ang_eipm_32_pred(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
#if MIPF
						, 1, mipf_enable_flag,bit_depth_internal, pred_y_intra[rdo_idx]
#endif
					);
				}
				else
#endif
					ipred_ang3_32_pred(w, h, src_le_temp, src_up_temp, bit_depth_internal, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
						, 1, mipf_enable_flag
#endif
					);
			}
		}
	}
}
#endif

void get_ref_pel_2(U8 w, U8 h, U13 pic_width, U13 pic_height, U4 bit_depth, u8 all_rdo_num, u8 rdo_list[MD_MAX_RDO_NUM], u8 intra_mode_list[IPRED_LIST_NUM], MD_COM_MODE* mod_info_curr,
	SKIP_ELEMENT skip_mode[SKIP_MODE_NUM], MERGE_RDO* merge, strFetch_ref_window* Fetch_Ref_window_ptr,
	S14 CtrPos2MD[RANGE_NUM][DIR_DIM][MAP_DIMS], MD_FW* md_fw_ptr, MD_INPUT* md_input_ptr, s16 mvp_all[2][5][2], SKIP_RDO* skip_rdo,
	SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO], MERGE_RDO merge_rdo, int stride_org, MD_KERNEL_INPUT_32* md_kernel_input,
	U2 tree_status, u8 ctx_cons_pred_mode,
	S14 sub_pel_mv[MV_D], U1 slice_type,
	pel src_le_temp[32 * 2 + 3], pel src_up_temp[32 * 2 + 3], u16 avail_tb
#if ENABLE_BFRAME
	, S14 CtrPosSKIP_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS], MV_DIR* mv_dir
#endif
#if MIPF
	, int mipf_enable_flag
#endif
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
	, S14 mv_copy[2][2], s16 mvd_copy[2][2], S3 refi_copy[2], pel pred_y_skip_inter[13][32][32], pel pred_y_intra[5][32][32], pel pred_y_inter2[2][32][32], Arbitor& ref)
{

#if MD_KERNEL_32_MOD_YHY
	U4 bit_depth_internal = md_fw_ptr->bit_depth_internal;
	u8 rdo_list_intra[5];

#pragma HLS ARRAY_PARTITION variable=rdo_list_intra complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdo_list complete dim=0

	for(int i=0;i<5;i++)
	{
#pragma HLS UNROLL
		rdo_list_intra[i] = rdo_list[i];
	}

	u8 w_cp = w;
	u8 h_cp = h;

    get_ref_inter_32_32(w,h,md_fw_ptr, ctx_cons_pred_mode, skip_mode, mod_info_curr,
			rdo_list, mv_dir, mvp_all, tree_status, sub_pel_mv, md_kernel_input, skip_rdo,
			mv_copy, mvd_copy, refi_copy, pred_y_skip_inter, Fetch_Ref_window_ptr,
			CtrPos2MD, CtrPosSKIP_ref1,  ref, pred_y_inter2, core_sbtmvp,md_input_ptr,intra_mode_list,stride_org);

    get_ref_intra_32_32(all_rdo_num, rdo_list_intra, intra_mode_list, src_le_temp, src_up_temp,
			pred_y_intra, bit_depth_internal, mipf_enable_flag, w_cp, h_cp, avail_tb);
#else
	//get skip pred
	static MD_KERNEL_MODE_32 mode_info_write_32;

	if (slice_type == 1 || ctx_cons_pred_mode == ONLY_INTRA) {

	}
	else
	{
		for (int idx = 0; idx < SKIP_MODE_NUM + 1; ++idx)
		{
			if (idx < SKIP_MODE_NUM)
			{
				SKIP_ELEMENT* mode = skip_mode + idx;

				if (mode->valid == 0) { continue; }

				mod_info_curr->cu_mode = MODE_SKIP;
				mod_info_curr->umve_flag = mode->umve_flag;
				mod_info_curr->mv[0][0] = mode->mvp[REFP_0][MV_X];
				mod_info_curr->mv[0][1] = mode->mvp[REFP_0][MV_Y];
				mod_info_curr->refi[0] = mode->refi[REFP_0];
#if ENABLE_BFRAME
				mod_info_curr->mv[1][0] = mode->mvp[REFP_1][MV_X];
				mod_info_curr->mv[1][1] = mode->mvp[REFP_1][MV_Y];
				mod_info_curr->refi[1] = mode->refi[REFP_1];
#else
				mod_info_curr->mv[1][0] = 0;
				mod_info_curr->mv[1][1] = 0;
				mod_info_curr->refi[1] = -1;
#endif
				// skip index 1 and 2 for P slice
#if ENABLE_BFRAME
				if (!REFI_IS_VALID(mod_info_curr->refi[REFP_0]) && !REFI_IS_VALID(mod_info_curr->refi[REFP_1])) { continue; }
#else
				if (mod_info_curr->refi[0] == -1) { continue; }
#endif
			}
			else {
				mod_info_curr->cu_mode = MODE_INTER;
				s8 inter_mode_idx = rdo_list[0];
#if ENABLE_BFRAME
				u8 num_refp_cnt = md_fw_ptr->num_refp[mv_dir->lidx];
#endif
				int refi_cur = 0;
				s16 mv_all[2][5][2];
				int best_mv_uni_inner[2][4][2];
				u8 curr_mvr = 0;
				U2 mode_type = 0;

				if (inter_mode_idx < 17) {
					static U2 mode_type_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2 };
					static u8 curr_mvr_table[17] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 1, 2 };

					mode_type = mode_type_table[inter_mode_idx];
					curr_mvr = curr_mvr_table[inter_mode_idx];
					if (mode_type == 1) {
						BOOL res = analyze_me_uni_pred_32(&mode_info_write_32, md_input_ptr, curr_mvr, w, h,
							mvp_all, mv_all, best_mv_uni_inner,
							stride_org, refi_cur, tree_status, ctx_cons_pred_mode, sub_pel_mv,
							md_kernel_input, bit_depth
#if ENABLE_BFRAME
							, mv_dir, num_refp_cnt
#endif
						);
#if ENABLE_BFRAME
						U1 lidx = mv_dir->lidx;
#else 
						U1 lidx = 0;
#endif					
						mv_copy[lidx][0] = mode_info_write_32.mv[lidx][0];
						mv_copy[lidx][1] = mode_info_write_32.mv[lidx][1];
						mvd_copy[lidx][0] = mode_info_write_32.mvd[lidx][0];
						mvd_copy[lidx][1] = mode_info_write_32.mvd[lidx][1];
						refi_copy[0] = mode_info_write_32.refi[0];
						refi_copy[1] = mode_info_write_32.refi[1];
					}
				}
			}
			// calc pred info
			if (idx < SKIP_MODE_NUM) {
				CU_POS cu = { (int)mod_info_curr->scup, mod_info_curr->x_pos, mod_info_curr->y_pos, mod_info_curr->cu_width, mod_info_curr->cu_height };
				BOOL res = com_mc_cu_y_32(&cu, pic_width, pic_height, mod_info_curr->refi, mod_info_curr->mv,
					SWW, pred_y_skip_inter[idx], bit_depth, Fetch_Ref_window_ptr,
					CtrPos2MD
#if ENABLE_BFRAME
					, CtrPosSKIP_ref1
#endif // ENABLE_BFRAME
					, ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
					, core_sbtmvp, idx, mod_info_curr->umve_flag
#endif	
				);
			}
			else {
				CU_POS cu = { (int)md_kernel_input->scup, md_kernel_input->x_pos, md_kernel_input->y_pos, md_kernel_input->cu_width, md_kernel_input->cu_height };

				BOOL res1 = com_mc_cu_y_32(&cu, pic_width, pic_height, mode_info_write_32.refi, mode_info_write_32.mv,
					SWW, pred_y_skip_inter[idx], bit_depth, Fetch_Ref_window_ptr,
					CtrPos2MD,
					CtrPosSKIP_ref1,
					ref
					, mod_info_curr->cu_mode
#if SUB_TMVP
					, core_sbtmvp, mode_info_write_32.skip_idx, mode_info_write_32.umve_flag
#endif
				);
			}
		}
	}

	//get inter pred
	U8 mode_list[MAX_INTER_SKIP_RDO] = { 0 };
	for (int i = 0, j = 0; i < 12 && j < 4; ++i) {
		if (skip_mode[i].valid && (skip_mode[i].refi[REFP_0] >= 0 || REFI_IS_VALID(skip_mode[i].refi[REFP_1])))
		{
			mode_list[j++] = i;
		}
	}
	for (U8 rdo_idx = 1; rdo_idx < 3; rdo_idx++) {

		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;
		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 1) {
			if (inter_mode_idx < skip_rdo->num_rdo) {
				int skip_idx = inter_mode_idx;
				if (rdo_idx == 1) {
					for (int j = 0; j < 32; j++) {
						for (int k = 0; k < 32; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
					continue;
				}
				if (rdo_idx == 2) {
					for (int j = 0; j < 32; j++) {
						for (int k = 0; k < 32; k++) {
							pred_y_inter2[rdo_idx - 1][j][k] = pred_y_skip_inter[mode_list[skip_idx]][j][k];
						}
					}
					continue;
				}
			}
		}
	}

	//get intra_pred
	for (U8 rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {

		s8 inter_mode_idx = rdo_list[rdo_idx];
		U1 is_intra_write;
		s8 intra_mode_idx;

		if (inter_mode_idx >= 17)
		{
			is_intra_write = 1;
			intra_mode_idx = intra_mode_list[inter_mode_idx - 17];
			inter_mode_idx = -1;
		}
		else
		{
			is_intra_write = 0;
			intra_mode_idx = 0;
		}

		if (is_intra_write != 0) {

			if (intra_mode_idx == 12)
				Ipred_vert_32_pred(w, h, src_up_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 24)
				Ipred_hor_32_pred(w, h, src_le_temp + 3, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 0)
				Ipred_dc_32_pred(w, h, src_le_temp + 3, src_up_temp + 3, bit_depth, avail_tb, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 1)
				Ipred_plane_32_pred(w, h, src_le_temp + 2, src_up_temp + 2, bit_depth, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx == 2)
				Ipred_bi_32_pred(w, h, src_le_temp + 3, src_up_temp + 3, bit_depth, pred_y_intra[rdo_idx]);
			else if (intra_mode_idx >= 3 && intra_mode_idx <= 11)
				ipred_ang1_32_pred(w, h, src_le_temp, src_up_temp, bit_depth, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, mipf_enable_flag
#endif
				);
			else if (intra_mode_idx >= 25 && intra_mode_idx <= 32)
				ipred_ang2_32_pred(w, h, src_le_temp, src_up_temp, bit_depth, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
					, 1, mipf_enable_flag
#endif
				);
			else
			{
#if EIPM
				if (intra_mode_idx > 33)
				{
					ipred_ang_eipm_32(src_le_temp + 3, src_up_temp + 3, w, h, intra_mode_idx
#if MIPF
						, 1, mipf_enable_flag,bit_depth, pred_y_intra[rdo_idx]
#endif
					);
//				static pel pred_1d[1024] = { 0 };
//				memset(pred_1d, 0, sizeof(pel) * 1024);
//
//				if (intra_mode_idx > 33)
//				{
//					ipred_ang_eipm(src_le_temp + 3, src_up_temp + 3, pred_1d, w, h, intra_mode_idx
//#if MIPF
//						, 1, mipf_enable_flag
//#endif
//					);
//            
//          clip_pred(pred_1d, w, h, bit_depth);
//
//					for (int i = 0; i < 32; i++)
//					{
//						if (i < h)
//						{
//							for (int j = 0; j < 32; j++)
//							{
//								if (j < w)
//								{
//									//coef_tmp1[i][j] = orgY[i][j] - pred_1d[(i * w) + j];
//									pred_y_inter[rdo_idx][i][j] = pred_1d[(i * w) + j];
//								}
//							}
//						}
//					}
				}
				else
#endif
					ipred_ang3_32_pred(w, h, src_le_temp, src_up_temp, bit_depth, intra_mode_idx, pred_y_intra[rdo_idx]
#if MIPF
						, 1, mipf_enable_flag
#endif
					);
			}
		}
	}
#endif

}

s64 rdo_luma_32_lite(U1 isNS_allow, U8 w, U8 h, RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, 
	ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32,
	ENC_ME_NEB_INFO* up_nebs, ENC_ME_NEB_INFO* left_nebs, SKIP_MERGE_INPUT* skip_in,
	U2 tree_status, MD_COM_MODE_BEST* best_info_ptr, MD_INPUT* md_input_ptr, pel orgY_32[32][32], pel orgY_32_cp1[32][32], pel orgY_32_cp2[32][32],
#if ENABLE_BFRAME
	ME_MV_DIR* me_mv_dir,
#endif
	MD_COM_MODE* mod_info_curr_ptr, 
	ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr,
	U2 curr_cons_pred_mode, U3 qt_depth,
	ENC_FME_INFO_ALL* fme_mv_info,
	u8 rmd_mode[IPRED_LIST_NUM],
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16,
	MPM_ARRAY_SIZE<32, 32>* MPM_buffer_ptr_32x32, MPM_ARRAY_SIZE<16, 32>* MPM_buffer_ptr_16x32, MPM_ARRAY_SIZE<32, 16>* MPM_buffer_ptr_32x16,
	IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16,
	MD_KERNEL_INPUT_32* md_kernel_input_32,
	Arbitor& ref,
	strFetch_ref_window* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{
	if (!isNS_allow)
		return 0;
	U4 bit_depth = md_fw_ptr->bit_depth_internal;
	s64 cost_best = MAX_S64;
	U3 cu_width_log2 = mod_info_curr_ptr->cu_width_log2;
	U3 cu_height_log2 = mod_info_curr_ptr->cu_height_log2;
	U7 cu_width = (1 << cu_width_log2);
	U7 cu_height = (1 << cu_height_log2);
	U1 emvr_enable_flag = 1;
	U1 amvr_enable_flag = 1;

	U14 sub_x = mod_info_curr_ptr->x_pos;
	U14 sub_y = mod_info_curr_ptr->y_pos;

	U13 pix_x = sub_x - md_input_ptr->pix_x;
	U13 pix_y = sub_y - md_input_ptr->pix_y;


	static U1 valid_mode[17];   //{SKIP:0,1,2,3;Skip_Merge:4,5,6,7,8;Mode1:9,10,11,12,13;Mode2:14,15,16};    //{Mode 0:(skip mode:fix 4, skip_merger:0~5), Mode1:(ME:AMVR:FIX 1/5); Mode 2(AFF_ME::FIX 1/3)

#if 0
	static pel orgY[32 * 32];
	pel orgY_32[32][32];
	for (int i = 0; i < cu_height; i++) {
		for (int j = 0; j < cu_width; j++) {
			orgY_32[i][j] = p_fenc_LCU_Y[(mod_info_curr_ptr->y_pos - md_input_ptr->pix_y + i) * 64 + (mod_info_curr_ptr->x_pos - md_input_ptr->pix_x + j)];
		}
	}
#endif
	s64 lambda_y   = md_input_ptr->lambda_y;
	U13 pic_height = md_fw_ptr->pic_height_in_scu << 2;
	U13 pic_width  = md_fw_ptr->pic_width_in_scu << 2;
	U2 slice_type  = md_fw_ptr->slice_type;

	u8 ipred_list[IPRED_LIST_NUM];
	static s16 mvp_all[2][5][2];
	static pel src_le_temp[2 * 32 + 3];//SIZE_32
	static pel src_up_temp[2 * 32 + 3];
	//pel src_le_temp[128 + 3];
	//pel src_up_temp[128 + 3];
	u16 avail_tb;

	u8 rdo_list[MD_MAX_RDO_NUM] = { 0 };
	u8 inter_rdo_num = 0;

	u8 intra_rdo_num = 0;

	static SKIP_ELEMENT skip_mode[SKIP_MODE_NUM];
	static SKIP_RDO skip_rdo;
	static SKIP_ELEMENT skip_rdo_mode[MAX_INTER_SKIP_RDO];
	S14 sub_pel_mv[MV_D];
	static MERGE_RDO merge_rdo;

#if ENABLE_BFRAME
	MV_DIR mv_dir;
#endif
	rdo_prepare_32(w, h, md_fw_ptr, me_line_map_ptr_32, up_nebs, left_nebs, skip_in, mod_info_curr_ptr,
		&merge_rdo, md_input_ptr, valid_mode, amvr_enable_flag, fme_mv_info,
		IP_buffer_ptr_32x32, IP_buffer_ptr_16x32, IP_buffer_ptr_32x16,
		MPM_buffer_ptr_32x32, MPM_buffer_ptr_16x32, MPM_buffer_ptr_32x16,
		IP_map_scu_ptr_32x32, IP_map_scu_ptr_16x32, IP_map_scu_ptr_32x16,
		cu_width_log2, cu_height_log2, ipred_list, src_le_temp, src_up_temp, &avail_tb, rmd_mode,
		17,
#if ENABLE_BFRAME
		me_mv_dir, &mv_dir,
#endif
		curr_cons_pred_mode,
		&inter_rdo_num, &intra_rdo_num, rdo_list, skip_mode, &skip_rdo, skip_rdo_mode, sub_pel_mv, mvp_all, bit_depth, Fetch_Ref_window_ptr
#if SUB_TMVP
		, core_sbtmvp
#endif
	);

#if USE_SPEED_LEVEL
	int intra_rmd_mode_cnt = 5;
	int intra_rmd_mode = IPD_RDO_CNT;
	if (md_input_ptr->speed_level == 1)
		intra_rmd_mode_cnt = IPD_RDO_CNT; //5
	else if (md_input_ptr->speed_level == 2)
		intra_rmd_mode_cnt = EXTRA_RDO_MODE;//10
	else
		intra_rmd_mode_cnt = IPD_RDO_CNT + EXTRA_RDO_MODE;//15
#else
	int intra_rmd_mode_cnt = 5;
#endif 

	//get skip and intra_inter pred 
	static pel pred_y_skip_inter[13][32][32];
	static pel pred_y_inter2[2][32][32];
	static pel pred_y_intra[IPRED_LIST_NUM][32][32];

	static S14 mv_copy[2][2];
	static s16 mvd_copy[2][2];
	static S3 refi_copy[2];
	get_ref_pel_2(w, h, pic_width, pic_height, bit_depth, intra_rmd_mode_cnt, rdo_list, ipred_list, mod_info_curr_ptr, skip_mode, &merge_rdo, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD, md_fw_ptr, md_input_ptr, mvp_all, &skip_rdo, skip_rdo_mode, merge_rdo, 64, md_kernel_input_32, tree_status,
		curr_cons_pred_mode, sub_pel_mv, slice_type,
		src_le_temp, src_up_temp, avail_tb
#if ENABLE_BFRAME
		, md_input_ptr->CtrPos2MD_ref1, &mv_dir
#endif
#if MIPF
		, md_fw_ptr->mipf_enable_flag
#endif
#if SUB_TMVP
		, core_sbtmvp
#endif
		, mv_copy, mvd_copy, refi_copy, pred_y_skip_inter, pred_y_intra, pred_y_inter2, ref
	);


#if !DISABLE_RDO_SKIP
	rdo_skip_32(&cost_best, best_info_ptr, 
		cu_data_ptr,
		mod_info_curr_ptr,
		orgY_32, skip_mode, &merge_rdo, pic_width, pic_height, slice_type, tree_status, lambda_y, curr_cons_pred_mode, bit_depth, Fetch_Ref_window_ptr,
		md_input_ptr->CtrPos2MD,
#if ENABLE_BFRAME
		md_input_ptr->CtrPos2MD_ref1,
#endif
		//fme2mdrefbuf
		pred_y_skip_inter
#if SUB_TMVP
		, core_sbtmvp
#endif
	);
#endif // DISABLE_RDO_SKIP	

	if (op_patch_mode_on)
		cost_best = MAX_S64;
#if USE_INTRA_REFRESH
	if (md_input_ptr->EncRefresh &&md_fw_ptr->slice_type != SLICE_I)
	{
		if (md_input_ptr->RefreshMode == 0)
		{
			if (mod_info_curr_ptr->y_pos >= md_input_ptr->pirStartRow * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->y_pos < md_input_ptr->pirEndRow * 32 * md_input_ptr->RefreshSize)
				cost_best = MAX_S64;
		}
		else
		{
			if (mod_info_curr_ptr->x_pos >= md_input_ptr->pirStartCol * 32 * md_input_ptr->RefreshSize && mod_info_curr_ptr->x_pos < md_input_ptr->pirEndCol * 32 * md_input_ptr->RefreshSize)
				cost_best = MAX_S64;
		}

			}
#endif
#if DEBUG_CU
	if (isProblem)
	{
		printf("AfterSkip: cu_mode=%d,umve_flag=%d,affine_flag=%d,skip_idx=%d\n", best_info_ptr->cu_mode, best_info_ptr->umve_flag, best_info_ptr->affine_flag, best_info_ptr->skip_idx);
	}
#endif
	rdo_luma_32_pipeline(w, h, rdoq_array, md_fw_ptr, me_line_map_ptr_32,
		up_nebs, left_nebs, skip_in,
		tree_status, best_info_ptr, md_input_ptr, orgY_32, orgY_32_cp1, orgY_32_cp2,
#if ENABLE_BFRAME
		me_mv_dir,
#endif
		mod_info_curr_ptr, 
		cu_data_ptr,
		curr_cons_pred_mode, qt_depth,
		fme_mv_info,
		rmd_mode,
		IP_buffer_ptr_32x32, IP_buffer_ptr_16x32, IP_buffer_ptr_32x16,
		IP_map_scu_ptr_32x32, IP_map_scu_ptr_16x32, IP_map_scu_ptr_32x16,
		md_kernel_input_32,
		//fme2mdrefbuf,
		mv_copy, mvd_copy, refi_copy, pred_y_skip_inter[12], pred_y_inter2, pred_y_intra,
		Fetch_Ref_window_ptr,
#if SUB_TMVP
		core_sbtmvp,
#endif
		//add new paras
		valid_mode,
		ipred_list,
		src_le_temp,
		src_up_temp,
		avail_tb,
		rdo_list,

		inter_rdo_num,
		&skip_rdo,
		skip_rdo_mode,
		&merge_rdo,
		sub_pel_mv,
		mvp_all,

#if ENABLE_BFRAME
		&mv_dir,
#endif
		&cost_best);
	return cost_best;
}

void copy_to_cu_data_luma_32(U1 isNS_allow, U8 w, U8 h, U6 qp_y, ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr, MD_COM_MODE_BEST* mod_info_best, U2 tree_status,
	int slice_num, int affine_subblock_size_idx, U2 *NS_luma_pred_mode
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
#if CUDQP_QP_MAP
	, int cu_dqp_enable, int cu_qp_group_pred_qp
#endif
)
{
	if (!isNS_allow)
	{
		*NS_luma_pred_mode = ONLY_INTRA;
		return;
	}

	int i;
	int j;
	int k;
	int idx;
	U3 cu_width_log2;
	U3 cu_height_log2;
	int num_coef_y = 0;
	int num_coef_u = 0;
	int num_coef_v = 0;
	int num_nnz_sum = 0;
	int num_luma_tb;
	int cu_cbf_flag = 0;
	int pb_idx_u = 0;
	int tb_idx_u = 0;
	int pb_idx_y;
	int tb_idx_y;
	cu_width_log2 = mod_info_best->cu_width_log2;
	cu_height_log2 = mod_info_best->cu_height_log2;
	int pel_x_top = (mod_info_best->x_scu * 4 - (((mod_info_best->x_scu * 4) >> 6) << 6)) >> 2;
	int pel_y_top = (mod_info_best->y_scu * 4 - (((mod_info_best->y_scu * 4) >> 6) << 6)) >> 2;
	cu_width_log2 = mod_info_best->cu_width_log2;
	cu_height_log2 = mod_info_best->cu_height_log2;

	if (tree_status != TREE_C) {
	
		num_luma_tb = get_part_num((PART_SIZE)(mod_info_best->tb_part));
		for (i = 0; i < h; i++) {
			for (j = 0; j < w; j++)
				num_coef_y += (((int)cu_data_ptr->coef_y[i][j]) != 0 ? 1 : 0);
		}

		for (i = 0; i < num_luma_tb; i++) {
#if SRCC
			num_nnz_sum += num_coef_y;
#else
			num_nnz_sum += mod_info_best->num_nz[i][0];
#endif
			
		}
	}
	if (tree_status == TREE_LC) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	else if (((int)tree_status) == ((int)TREE_L)) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	if (((int)tree_status) == ((int)TREE_C)) {
		idx = 0;
		for (j = 0; j < h >> 2; j++) {
			for (i = 0; i < w >> 2; i++) {
				if (mod_info_best->cu_mode == 0) {
					cu_data_ptr->ipm[1][idx + i] = mod_info_best->ipm[0][1];
				}
				for (k = 1; k < 3; k++) {
					cu_data_ptr->num_nz_coef[k][idx + i] = mod_info_best->num_nz[0][k];
				}
			}
			idx += w >> 2;
		}
	}
	else {
		idx = 0;
		for (j = 0; j < h >> 2; j++) {
			for (i = 0; i < w >> 2; i++) {
				pb_idx_y = get_part_idx((PART_SIZE)(mod_info_best->pb_part), i << 2, j << 2, w, h);
				tb_idx_y = get_part_idx((PART_SIZE)(mod_info_best->tb_part), i << 2, j << 2, w, h);
				pb_idx_u = 0;
				tb_idx_u = 0;
				cu_data_ptr->pred_mode[idx + i] = ((u8)(mod_info_best->cu_mode));
				cu_data_ptr->umve_flag[idx + i] = mod_info_best->umve_flag;
				cu_data_ptr->umve_idx[idx + i] = mod_info_best->umve_idx;
				cu_data_ptr->pb_part[idx + i] = mod_info_best->pb_part;
				cu_data_ptr->tb_part[idx + i] = mod_info_best->tb_part;
#if CUDQP_QP_MAP
				cu_data_ptr->cu_luma_qp[idx + i] = cu_qp_group_pred_qp;
				//cu_data_ptr->luma_pred_qp[idx + i] = qp_y;
#endif
				for (k = 0; k < 3; k++) {
#if SRCC
					//cu_data_ptr->num_nz_coef[k][idx + i] = num_coef_y;
					cu_data_ptr->num_nz_coef[k][idx + i] = mod_info_best->num_nz[(k == 0 ? tb_idx_y : tb_idx_u)][k];
#else
					cu_data_ptr->num_nz_coef[k][idx + i] = mod_info_best->num_nz[(k == 0 ? tb_idx_y : tb_idx_u)][k];
#endif			
				}
				cu_data_ptr->map_scu[idx + i] = (cu_data_ptr->map_scu[idx + i] & 0xFF807F80) | ((unsigned int)(slice_num & 0x7F)) | (((
					unsigned int)qp_y << 16)) | ((unsigned int)((mod_info_best->cu_mode == 0) << 15)) | ((unsigned int)(1 << 31));
				if (mod_info_best->cu_mode == 2) {
					cu_data_ptr->map_scu[idx + i] = cu_data_ptr->map_scu[idx + i] | ((unsigned int)(1 << 23));
				}
				else {
					cu_data_ptr->map_scu[idx + i] = cu_data_ptr->map_scu[idx + i] & ((unsigned int)(~(1 << 23)));
				}
				cu_data_ptr->depth[idx + i] = ((s8)(mod_info_best->cud));
				cu_data_ptr->affine_flag[idx + i] = mod_info_best->affine_flag;
				if (mod_info_best->affine_flag) {
					cu_data_ptr->map_scu[idx + i] = (cu_data_ptr->map_scu[idx + i] & 0xFFFFFCFF) | ((unsigned int)((((int)(
						mod_info_best->affine_flag)) & 0x03) << 8));
				}
				else {
					cu_data_ptr->map_scu[idx + i] = cu_data_ptr->map_scu[idx + i] & 0xFFFFFCFF;
				}
				if (cu_cbf_flag) {
					cu_data_ptr->map_scu[idx + i] = cu_data_ptr->map_scu[idx + i] | ((unsigned int)(1 << 24));
				}
				else {
					cu_data_ptr->map_scu[idx + i] = cu_data_ptr->map_scu[idx + i] & ((unsigned int)(~(1 << 24)));
				}
#if CUDQP_QP_MAP
				if (cu_dqp_enable && !cu_cbf_flag)
				{
					//change qp to pred_qp if no residual
					MCU_SET_QP(cu_data_ptr->map_scu[idx + i], cu_qp_group_pred_qp);
					//assert(ctx->cu_qp_group.pred_qp >= 0 && ctx->cu_qp_group.pred_qp <= MAX_QUANT_BASE + ctx->info.qp_offset_bit_depth);
				}
#endif
				cu_data_ptr->map_cu_mode[idx + i] = (cu_data_ptr->map_cu_mode[idx + i] & 0xFFFFFFF0) | ((unsigned int)((pel_x_top & 0xF) << 0));
				cu_data_ptr->map_cu_mode[idx + i] = (cu_data_ptr->map_cu_mode[idx + i] & 0xFFFFFF0F) | ((unsigned int)((pel_y_top & 0xF) << 4));
				cu_data_ptr->map_cu_mode[idx + i] = (cu_data_ptr->map_cu_mode[idx + i] & 0xFFFF00FF) | ((unsigned int)((i & 0xFF) << 8));
				cu_data_ptr->map_cu_mode[idx + i] = (cu_data_ptr->map_cu_mode[idx + i] & 0xFF00FFFF) | ((unsigned int)((j & 0xFF) << 16));
				cu_data_ptr->map_cu_mode[idx + i] = (cu_data_ptr->map_cu_mode[idx + i] & 0xF0FFFFFF) | ((unsigned int)((
					cu_width_log2 & 0x0F) << 24));
				cu_data_ptr->map_cu_mode[idx + i] = (cu_data_ptr->map_cu_mode[idx + i] & 0x0FFFFFFF) | ((unsigned int)((
					cu_height_log2 & 0x0F) << 28));
				cu_data_ptr->map_pb_tb_part[idx + i] = (cu_data_ptr->map_pb_tb_part[idx + i] & 0xFFFFFF00) | ((unsigned int)((
					mod_info_best->tb_part & 0xFF) << 0));
				if (mod_info_best->cu_mode == 0) {
					cu_data_ptr->mpm[0][idx + i] = mod_info_best->mpm[pb_idx_y][0];
					cu_data_ptr->mpm[1][idx + i] = mod_info_best->mpm[pb_idx_y][1];
					cu_data_ptr->ipm[0][idx + i] = mod_info_best->ipm[pb_idx_y][0];
					cu_data_ptr->ipm[1][idx + i] = mod_info_best->ipm[pb_idx_u][1];
					cu_data_ptr->ipf_flag[idx + i] = mod_info_best->ipf_flag;
					cu_data_ptr->mv[idx + i][0][0] = ((s16)0);
					cu_data_ptr->mv[idx + i][0][1] = ((s16)0);
					cu_data_ptr->mv[idx + i][1][0] = ((s16)0);
					cu_data_ptr->mv[idx + i][1][1] = ((s16)0);
					cu_data_ptr->mvd[idx + i][0][0] = ((s16)0);
					cu_data_ptr->mvd[idx + i][0][1] = ((s16)0);
					cu_data_ptr->mvd[idx + i][1][0] = ((s16)0);
					cu_data_ptr->mvd[idx + i][1][1] = ((s16)0);
					cu_data_ptr->refi[idx + i][0] = ((s8)(-1));
					cu_data_ptr->refi[idx + i][1] = ((s8)(-1));
					cu_data_ptr->skip_idx[idx + i] = 0;
					cu_data_ptr->smvd_flag[idx + i] = 0;
				}
				else {
					cu_data_ptr->mpm[0][idx + i] = 0;
					cu_data_ptr->mpm[1][idx + i] = 0;
					cu_data_ptr->ipm[0][idx + i] = 0;
					cu_data_ptr->ipm[1][idx + i] = 0;
					cu_data_ptr->refi[idx + i][0] = mod_info_best->refi[0];
					cu_data_ptr->refi[idx + i][1] = mod_info_best->refi[1];
					cu_data_ptr->mvr_idx[idx + i] = mod_info_best->mvr_idx;
					cu_data_ptr->mvp_from_hmvp_flag[idx + i] = mod_info_best->mvp_from_hmvp_flag;
					cu_data_ptr->smvd_flag[idx + i] = mod_info_best->smvd_flag;
					cu_data_ptr->skip_idx[idx + i] = mod_info_best->skip_idx;
					cu_data_ptr->mv[idx + i][0][0] = mod_info_best->mv[0][0];
					cu_data_ptr->mv[idx + i][0][1] = mod_info_best->mv[0][1];
					cu_data_ptr->mv[idx + i][1][0] = mod_info_best->mv[1][0];
					cu_data_ptr->mv[idx + i][1][1] = mod_info_best->mv[1][1];
					cu_data_ptr->mvd[idx + i][0][0] = mod_info_best->mvd[0][0];
					cu_data_ptr->mvd[idx + i][0][1] = mod_info_best->mvd[0][1];
					cu_data_ptr->mvd[idx + i][1][0] = mod_info_best->mvd[1][0];
					cu_data_ptr->mvd[idx + i][1][1] = mod_info_best->mvd[1][1];
#if SUB_TMVP
					if (core_sbtmvp != 0) {
						if (mod_info_best->umve_flag == 0 && mod_info_best->cu_mode >= MODE_SKIP && mod_info_best->skip_idx == 0 && mod_info_best->cu_width >= SBTMVP_MIN_SIZE && mod_info_best->cu_height >= SBTMVP_MIN_SIZE)
						{
							// sub block position
							int blk = ((i >= (mod_info_best->cu_width >> MIN_CU_LOG2) / SBTMVP_NUM_1D) ? 1 : 0) + ((j >= (mod_info_best->cu_height >> MIN_CU_LOG2) / SBTMVP_NUM_1D) ? SBTMVP_NUM_1D : 0);
							cu_data_ptr->refi[idx + i][0] = core_sbtmvp->best_sbTmvp[blk].ref_idx[0];
							cu_data_ptr->refi[idx + i][1] = core_sbtmvp->best_sbTmvp[blk].ref_idx[1];

							cu_data_ptr->mv[idx + i][0][0] = core_sbtmvp->best_sbTmvp[blk].mv[0][0];
							cu_data_ptr->mv[idx + i][0][1] = core_sbtmvp->best_sbTmvp[blk].mv[0][1];
							cu_data_ptr->mv[idx + i][1][0] = core_sbtmvp->best_sbTmvp[blk].mv[1][0];
							cu_data_ptr->mv[idx + i][1][1] = core_sbtmvp->best_sbTmvp[blk].mv[1][1];

							cu_data_ptr->mvd[idx + i][0][0] = 0;
							cu_data_ptr->mvd[idx + i][0][1] = 0;
							cu_data_ptr->mvd[idx + i][1][0] = 0;
							cu_data_ptr->mvd[idx + i][1][1] = 0;

						}
					}
#endif
				}
			}
			idx += w >> 2;
		}
		//if (mod_info_best->affine_flag) {
		//	enc_set_affine_mvf(affine_subblock_size_idx, cu_data, mod_info_best);
		//}
	}

	*NS_luma_pred_mode = cu_data_ptr->pred_mode[0];

}

void init_md_kernel_input_32(MD_KERNEL_INPUT_32* md_kernel_input, ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr, U13 x0, U13 y0, U3 cu_width_log2, U3 cu_height_log2, U11 pic_width_in_scu, U2 tree_status)
{
	md_kernel_input->x_chroma = cu_data_ptr->x_chroma;
	md_kernel_input->y_chroma = cu_data_ptr->y_chroma;
	md_kernel_input->x_pos = x0;
	md_kernel_input->y_pos = y0;
	md_kernel_input->chroma_motion = (cu_data_ptr->last_child && tree_status == TREE_L);
	md_kernel_input->scup = (y0 >> 2) * pic_width_in_scu + (x0 >> 2);
	md_kernel_input->cu_width = (1 << cu_width_log2);
	md_kernel_input->cu_height = (1 << cu_height_log2);
	md_kernel_input->cu_width_log2 = cu_width_log2;
	md_kernel_input->cu_height_log2 = cu_height_log2;

}

int mode_cu_init_32(RDOQ_MODEL* rdoq_model, RDOQ_MODEL* model_cnt, RDOQ_ARRAY* rdoq_array, MD_COM_MODE* mod_info_curr_ptr, MD_COM_MODE_BEST* bst_info_ptr,
	/*COM_PART_INFO *mod_info_curr_pb_info, COM_PART_INFO *mod_info_curr_tb_info, COM_PART_INFO *bst_info_pb_info, COM_PART_INFO *bst_info_tb_info,*/
	U13 x, U13 y, U3 cu_width_log2,
	U3 cu_height_log2, U4 cud, U11 pic_width_in_scu, U2 tree_status,
	U2* cons_pred_mode, ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr)
{
	MD_COM_MODE* mod_info_curr = mod_info_curr_ptr;
	MD_COM_MODE_BEST* bst_info = bst_info_ptr;
	bst_info->x_luma = mod_info_curr->x_luma = x;
	bst_info->y_luma = mod_info_curr->y_luma = y;
	bst_info->x_pos = mod_info_curr->x_pos = x;
	bst_info->y_pos = mod_info_curr->y_pos = y;
	bst_info->cu_width = mod_info_curr->cu_width = (1 << cu_width_log2);
	bst_info->cu_height = mod_info_curr->cu_height = (1 << cu_height_log2);
	bst_info->cu_width_log2 = mod_info_curr->cu_width_log2 = cu_width_log2;
	bst_info->cu_height_log2 = mod_info_curr->cu_height_log2 = cu_height_log2;
	bst_info->x_scu = mod_info_curr->x_scu = x >> 2;
	bst_info->y_scu = mod_info_curr->y_scu = y >> 2;
	bst_info->scup = mod_info_curr->scup = mod_info_curr->y_scu * pic_width_in_scu + mod_info_curr->x_scu;///////////////////////////////
	bst_info->cud = mod_info_curr->cud = cud;
	bst_info->chroma_motion = 0;
	mod_info_curr->chroma_motion = /*0*/ mod_info_curr->last_child && tree_status == TREE_L;
	U5 cuw_scu = 1 << (cu_width_log2 - 2);
	U5 cuh_scu = 1 << (cu_height_log2 - 2);
	int m;
	cu_nz_cln(mod_info_curr->num_nz);
	cu_nz_cln(bst_info->num_nz);

	if (tree_status != TREE_C) {
		for (m = 0; m < cuw_scu * cuh_scu; m++) {
#pragma HLS LOOP_TRIPCOUNT max=256
			cu_data_ptr->ipm[0][m] = 0;
			cu_data_ptr->ipm[1][m] = 0;
		}
	}

	int i;
	bst_info->cu_mode = 0;
	mod_info_curr->cu_mode = 0;
	mod_info_curr->pb_part = 0;
	mod_info_curr->tb_part = 0;
	bst_info->pb_part = 0;
	bst_info->tb_part = 0;
	bst_info->ipf_flag = 0;
	mod_info_curr->ipf_flag = 0;

	bst_info->mvr_idx = 0;
	bst_info->skip_idx = 0;
	bst_info->umve_flag = 0;
	bst_info->umve_idx = ((-1));
	bst_info->mvp_from_hmvp_flag = 0;
	bst_info->affine_flag = 0;
	mod_info_curr->mvr_idx = 0;
	mod_info_curr->skip_idx = 0;
	mod_info_curr->umve_flag = 0;
	mod_info_curr->umve_idx = ((-1));
	mod_info_curr->mvp_from_hmvp_flag = 0;
	mod_info_curr->affine_flag = 0;

	mod_info_curr->smvd_flag = 0;
	bst_info->smvd_flag = 0;

	enc_rdoq_bit_est(rdoq_model, model_cnt, rdoq_array);
	U8 cu_width = (1 << cu_width_log2);
	U8 cu_height = (1 << cu_height_log2);
	u8 luma_pred_mode;

	return 0;
}

s64 init_basic_leaf_32(U1 isNS_allow, RDOQ_MODEL* rdoq_model, RDOQ_MODEL* model_cnt, RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, s64 lambdaY, U3 cu_width_log2,
	U3 cu_height_log2, U4 cud, MD_COM_MODE_BEST* bst_info_ptr,
	U3 qt_depth, U3 bet_depth, U13 x0, U13 y0, U9 cup, U2 tree_status,
	U2* cons_pred_mode, MD_COM_MODE* mod_info_curr_temp_ptr,/* COM_PART_INFO *mod_info_curr_pb_info, COM_PART_INFO *mod_info_curr_tb_info,
	COM_PART_INFO *bst_info_pb_info, COM_PART_INFO *bst_info_tb_info,*/
	ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr)
{
	if (!isNS_allow)
		return MAX_S64;

	U8 cu_width = (1 << cu_width_log2);
	U8 cu_height = (1 << cu_height_log2);
	int bit_cnt;
	s64 cost_temp = 0;
	int pos = 0 + ((cu_height >> 1 >> 2) * (cu_width >> 2) + (cu_width >> 1 >> 2));
	int shape = (SQUARE)+(com_tbl_log2[cu_width] - com_tbl_log2[cu_height]);
	int bit_rate = 0;
	cu_data_ptr->split_mode[cud][shape][pos] = NO_SPLIT;
	bit_rate += enc_eco_split_mode_est(md_fw_ptr, cu_data_ptr->split_mode, cud, 0, cu_width, cu_height, cu_width, qt_depth, bet_depth, x0, y0);
	bit_cnt = bit_rate;
	cost_temp += (bit_cnt * lambdaY + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
	mode_cu_init_32(rdoq_model, model_cnt, rdoq_array, mod_info_curr_temp_ptr, bst_info_ptr, x0, y0, cu_width_log2, cu_height_log2, cud, md_fw_ptr->pic_width_in_scu,
		tree_status, cons_pred_mode, cu_data_ptr);
	return cost_temp;
}

#if !MD_KERNEL_32_DUMMY
//only 32x32 32x16_16x32
s64 md_kernel_32_lite(U8 width, U8 height, 
	MD_FW* md_fw_ptr, MD_INPUT* md_input_ptr, u8 rmd_mode[IPRED_LIST_NUM],
#if ENABLE_BFRAME
	ME_MV_DIR* me_mv_dir,
#endif
	pel p_fenc_LCU_Y[MAX_CU_SIZE_FETCH][MAX_CU_SIZE_FETCH],
	ENC_ME_LINE_MAP_SIZE<32>* me_line_map_ptr_32,
	ENC_ME_NEB_INFO* up_nebs, ENC_ME_NEB_INFO* left_nebs,
	SKIP_MERGE_INPUT* skip_in, 
	U1 boundary, U1 isNS_allow, U2* NS_luma_pred_mode, U13 x0, U13 y0, U12 cup, U3 cu_width_log2, U3 cu_height_log2, U4 cud, U3 qt_depth, U3 bet_depth, U2 cons_pred_mode, U2 tree_status, 
	ENC_CU_DATA_ARRAY_SIZE<32>* cu_data_ptr,
	ENC_FME_INFO_ALL* fme_mv_info,
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_32x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_16x32, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_32x16,
	MPM_ARRAY_SIZE<32, 32>* MPM_buffer_ptr_32x32, MPM_ARRAY_SIZE<16, 32>* MPM_buffer_ptr_16x32, MPM_ARRAY_SIZE<32, 16>* MPM_buffer_ptr_32x16,
	IP_MAP_SCU_SIZE<32, 32>* IP_map_scu_ptr_32x32, IP_MAP_SCU_SIZE<16, 32>* IP_map_scu_ptr_16x32, IP_MAP_SCU_SIZE<32, 16>* IP_map_scu_ptr_32x16,
	Arbitor& ref,
	strFetch_ref_window* Fetch_Ref_window_ptr)
{
#if DISABLE_CU_32
	return MAX_S64;
#endif
	s64 ns_cost = (s64)MAX_S64;
	static MD_COM_MODE mod_info_curr_temp;
	static MD_COM_MODE_BEST mod_info_best;
	static MD_KERNEL_INPUT_32 md_kernel_input_32;
	//COM_PART_INFO mod_info_curr_pb_info;
	//COM_PART_INFO mod_info_curr_tb_info;
	//COM_PART_INFO bst_info_pb_info;
	//COM_PART_INFO bst_info_tb_info;
	s8 coef_rec_write_flag = 0;
	s8* coef_rec_write_flag_ptr = &coef_rec_write_flag;
	static RDOQ_ARRAY rdoq_array;
	static RDOQ_MODEL rdoq_model_t;
	static RDOQ_MODEL model_cnt_t;
	for (int i = 0; i < 24; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			rdoq_array.rdoq_est_run[i][j] = 0;
		}
	}
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			rdoq_array.rdoq_est_cbf[i][j] = 0;
		}
	}
	for (int i = 0; i < 24; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			rdoq_array.rdoq_est_level[i][j] = 0;
		}
	}
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 6; j++)
		{
			for (int k = 0; k < 12; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					rdoq_array.rdoq_est_last[i][j][k][l] = 0;
				}
			}
		}
	}
int i;
	for (i = 0; i < 12; i++) {
		rdoq_model_t.last1[i] = PROB_INIT;
		model_cnt_t.last1[i] = 0;
	}
	for (i = 0; i < 22; i++) {
		rdoq_model_t.last2[i] = PROB_INIT;
		model_cnt_t.last2[i] = 0;
	}
	for (i = 0; i < 24; i++) {
		rdoq_model_t.run_rdoq[i] = PROB_INIT;
		model_cnt_t.run_rdoq[i] = 0;
		rdoq_model_t.level[i] = PROB_INIT;
		model_cnt_t.level[i] = 0;
	}
	for (i = 0; i < 3; i++) {
		rdoq_model_t.cbf[i] = PROB_INIT;
		model_cnt_t.cbf[i] = 0;
	}

	mod_info_curr_temp.x_chroma = cu_data_ptr->x_chroma;
	mod_info_curr_temp.y_chroma = cu_data_ptr->y_chroma;
	mod_info_curr_temp.last_child = cu_data_ptr->last_child;
#if SUB_TMVP
	static CORE_SBTMVP core_sbtmvp;
	CORE_SBTMVP* core_sbtmvp_ptr = &core_sbtmvp;
	core_sbtmvp.sbTmvp_flag = 0;
	core_sbtmvp.best_sbTmvp_flag = 0;
	for (int k = 0; k < SBTMVP_NUM; k++)
	{
		for (int i = 0; i < REFP_NUM; i++)
		{
			core_sbtmvp.sbTmvp[k].ref_idx[i] = -1;
			core_sbtmvp.best_sbTmvp[k].ref_idx[i] = -1;
			for (int j = 0; j < MV_D; j++)
			{
				core_sbtmvp.sbTmvp[k].mv[i][j] = 0;
				core_sbtmvp.best_sbTmvp[k].mv[i][j] = 0;
			}
		}
	}
#endif

	if (!boundary) {
#if CUDQP_QP_MAP
		if (md_input_ptr->cu_dqp_enable) {
			u32 luma_map_scu;
			int scu_stride = 16;
			int x_scu_in_LCU = (x0 % 64) >> 2;
			int y_scu_in_LCU = (y0 % 64) >> 2;
			int luma_cup;
			U6 cu_w_scu = width >> 2;
			U6 cu_h_scu = height >> 2;
			luma_cup = (y_scu_in_LCU + (cu_h_scu - 1)) * scu_stride + (x_scu_in_LCU + (cu_w_scu - 1));
			md_input_ptr->qp_y = md_input_ptr->CuQPMap[luma_cup];

			md_input_ptr->cu_qp_group_pred_qp = md_input_ptr->qp_y;
		}
#endif
		ns_cost = init_basic_leaf_32(isNS_allow, &rdoq_model_t, &model_cnt_t, &rdoq_array, md_fw_ptr, md_input_ptr->lambda_y, cu_width_log2,
			cu_height_log2, cud, &mod_info_best, qt_depth, bet_depth, x0, y0, cup, tree_status, &cons_pred_mode,
			&mod_info_curr_temp, cu_data_ptr);

		init_md_kernel_input_32(&md_kernel_input_32, cu_data_ptr, x0, y0, cu_width_log2, cu_height_log2, md_fw_ptr->pic_width_in_scu, tree_status);

	  pel orgY_32[32][32];
	  pel orgY_32_cp1[32][32], orgY_32_cp2[32][32];		// mem copy for DATAFLOW
	  for (int i = 0; i < 32; i++) {
	  	for (int j = 0; j < 32; j++) {
	  		orgY_32    [i][j] = p_fenc_LCU_Y[(mod_info_curr_temp.y_pos - md_input_ptr->pix_y + i)][(mod_info_curr_temp.x_pos - md_input_ptr->pix_x + j)];
			orgY_32_cp1[i][j] = p_fenc_LCU_Y[(mod_info_curr_temp.y_pos - md_input_ptr->pix_y + i)][(mod_info_curr_temp.x_pos - md_input_ptr->pix_x + j)];
			orgY_32_cp2[i][j] = p_fenc_LCU_Y[(mod_info_curr_temp.y_pos - md_input_ptr->pix_y + i)][(mod_info_curr_temp.x_pos - md_input_ptr->pix_x + j)];
		}
	  }
		ns_cost += rdo_luma_32_lite(isNS_allow, width, height, &rdoq_array, md_fw_ptr, 
			me_line_map_ptr_32,
			up_nebs, left_nebs,
			skip_in, tree_status, &mod_info_best, md_input_ptr, orgY_32, orgY_32_cp1, orgY_32_cp2,
#if ENABLE_BFRAME
			me_mv_dir,
#endif
			& mod_info_curr_temp, 
			cu_data_ptr, 
			cons_pred_mode,
			qt_depth, fme_mv_info, rmd_mode, 
			IP_buffer_ptr_32x32, IP_buffer_ptr_16x32, IP_buffer_ptr_32x16,
			MPM_buffer_ptr_32x32, MPM_buffer_ptr_16x32, MPM_buffer_ptr_32x16, 
			IP_map_scu_ptr_32x32, IP_map_scu_ptr_16x32, IP_map_scu_ptr_32x16,
			&md_kernel_input_32,
			ref,
			Fetch_Ref_window_ptr
#if SUB_TMVP
			, core_sbtmvp_ptr
#endif
		);

		copy_to_cu_data_luma_32(isNS_allow, width, height, md_input_ptr->qp_y, cu_data_ptr, &mod_info_best, tree_status, 0, 0, NS_luma_pred_mode
#if SUB_TMVP
			, core_sbtmvp_ptr
#endif
#if CUDQP_QP_MAP
			, md_input_ptr->cu_dqp_enable, md_input_ptr->cu_qp_group_pred_qp
#endif
		);
		//NS_luma_pred_mode[0] = cu_data_temp_ptr->pred_mode[0];
	}
	//printf("pos=(%d %d) size=(%d %d) cost=%lld\n", x0, y0, 1 << cu_width_log2, 1 << cu_height_log2, ns_cost);
	return ns_cost;
}
#endif //!MD_KERNEL_32_DUMMY

static void ipred_vert_Chroma32(pel src_up[67], pel dst[32][32], pel dst0[32][32], int w, int h)
{
#pragma HLS ARRAY_PARTITION variable = src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable = dst complete dim=2
#pragma HLS ARRAY_PARTITION variable = dst0 complete dim=2
	int i;
	int j;
	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
		for (j = 0; j < 32; j++) {
			if (j < w) {
			dst[i][j] = src_up[j];
				dst0[i][j] = src_up[j];
			}
		}
	}
}

static void ipred_hor_Chroma32(pel src_le[67], pel dst[32][32], pel dst0[32][32], int w, int h)
{
#pragma HLS ARRAY_PARTITION variable = src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = dst complete dim=2
#pragma HLS ARRAY_PARTITION variable = dst0 complete dim=2
	int i;
	int j;
	{
		for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (j = 0; j < 32; j++) {
				if (j < w) {
					dst[i][j] = src_le[i];
					dst0[i][j] = src_le[i];
				}
			}
			//src_le++;
		}
	}
}

static void ipred_dc_Chroma32(int cu_width_log2_chroma, int cu_height_log2_chroma, pel src_le[67], pel src_up[67], pel dst[32][32], pel dst0[32][32], int w, int h, int bit_depth, u16 avail_cu)
{
#pragma HLS ARRAY_PARTITION variable = src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable = dst complete dim=2
#pragma HLS ARRAY_PARTITION variable = dst0 complete dim=2
	static const s8 com_tbl_log2[257] = {
		/* 0, 1 */
		-1, -1,
		/* 2, 3 */
		1, -1,
		/* 4 ~ 7 */
		2, -1, -1, -1,
		/* 8 ~ 15 */
		3, -1, -1, -1, -1, -1, -1, -1,
		/* 16 ~ 31 */
		4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 31 ~ 63 */
		5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 64 ~ 127 */
		6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 128 ~ 255 */
		7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 256 */
		8
	};
#if MD_PRINT
	((int)com_tbl_log2[w]) >= 2 ? ((void)0) : __assert_HLS("com_tbl_log2[w] >= 2", "../separate/com_ipred.c",
		(unsigned int)1489, __FUNCTION__);
	((int)com_tbl_log2[h]) >= 2 ? ((void)0) : __assert_HLS("com_tbl_log2[h] >= 2", "../separate/com_ipred.c",
		(unsigned int)1490, __FUNCTION__);
#endif
	int dc = 0;
	int wh;
	int i;
	int j;
	if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		for (i = 0; i < 32; i++) {
#pragma HLS UNROLL
			if (i < h) {
			dc += ((int)src_le[i]);
			}
		}
		if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
			for (j = 0; j < 32; j++) {
#pragma HLS UNROLL
				if (j < w) {
				dc += ((int)src_up[j]);
				}
			}

			if ((w + h) == 64) {
				dc = ((dc + ((w + h) >> 1)) * 64) >> 12;
			}
			else if ((w + h) == 48) {
				dc = ((dc + ((w + h) >> 1)) * 85) >> 12;
			}
			else if ((w + h) == 40) {
				dc = ((dc + ((w + h) >> 1)) * 102) >> 12;
			}
			else if ((w + h) == 36) {
				dc = ((dc + ((w + h) >> 1)) * 113) >> 12;
			}
			//dc = ((dc + ((w + h) >> 1)) * (4096 / (w + h))) >> 12;

		}
		else {
			dc = (dc + (h >> 1)) >> cu_height_log2_chroma;// ((int)com_tbl_log2[h]);
		}
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		for (j = 0; j < 32; j++) {
#pragma HLS UNROLL
			if (j < w) {
			dc += ((int)src_up[j]);
			}
		}
		dc = (dc + (w >> 1)) >> cu_width_log2_chroma;// ((int)com_tbl_log2[w]);
	}
	else {
		dc = 1 << (bit_depth - 1);
	}
	//wh = w * h;
	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
		for (j = 0; j < 32; j++)
		{
			if (j < w) {
			dst[i][j] = ((pel)dc);
				dst0[i][j] = ((pel)dc);
			}
		}
	}
}

static void ipred_plane_Chroma32(int cu_width_log2_chroma, int cu_height_log2_chroma, pel src_le[67], pel src_up[67], pel dst[32][32], pel dst0[32][32], U4 bit_depth, U7 w, U7 h)
{
#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=dst complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst0 complete dim=2
	static const s8 com_tbl_log2[257] = {
		/* 0, 1 */
		-1, -1,
		/* 2, 3 */
		1, -1,
		/* 4 ~ 7 */
		2, -1, -1, -1,
		/* 8 ~ 15 */
		3, -1, -1, -1, -1, -1, -1, -1,
		/* 16 ~ 31 */
		4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 31 ~ 63 */
		5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 64 ~ 127 */
		6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 128 ~ 255 */
		7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 256 */
		8
	};
#if MD_PRINT
	((int)com_tbl_log2[w]) >= 2 ? ((void)0) : __assert_HLS("com_tbl_log2[w] >= 2", "../separate/com_ipred.c",
		(unsigned int)1539, __FUNCTION__);
	((int)com_tbl_log2[h]) >= 2 ? ((void)0) : __assert_HLS("com_tbl_log2[h] >= 2", "../separate/com_ipred.c",
		(unsigned int)1540, __FUNCTION__);
#endif
	//pel* rsrc;
	int coef_h = 0;
	int coef_v = 0;
	int a;
	int b;
	int c;
	int x;
	int y;
	U6 w2 = w >> 1;
	U6 h2 = h >> 1;
	int ib_mult[5] = { (13), (17), (5), (11), (23) };
	int ib_shift[5] = { (7), (10), (11), (15), (19) };
#pragma HLS ARRAY_PARTITION variable=ib_mult complete dim=0
#pragma HLS ARRAY_PARTITION variable=ib_shift complete dim=0
	int idx_w = cu_width_log2_chroma - 2;// ((int)com_tbl_log2[w]) - 2;
	int idx_h = cu_height_log2_chroma - 2;// ((int)com_tbl_log2[h]) - 2;
	int im_h;
	int is_h;
	int im_v;
	int is_v;
	int temp;
	int temp2;
	im_h = ib_mult[idx_w];
	is_h = ib_shift[idx_w];
	im_v = ib_mult[idx_h];
	is_v = ib_shift[idx_h];
	//rsrc = src_up + (w2 - 1);
	//rsrc = src_up;
	for (x = 1; x < 16 + 1; x++) {
#pragma HLS UNROLL
		if (x < w2 + 1) {
		coef_h += x * (((int)src_up[w2 + x]) - ((int)src_up[w2 - x]));
		}		
	}
	//rsrc = src_le + (h2 - 1);
	//rsrc = src_le;
	for (y = 1; y < 16 + 1; y++) {
#pragma HLS UNROLL
		if (y < h2 + 1) {
		coef_v += y * (((int)src_le[h2 + y]) - ((int)src_le[h2 - y]));
		}
	}
	a = (((int)src_le[h]) + ((int)src_up[w])) << 4;
	b = ((coef_h << 5) * im_h + (1 << (is_h - 1))) >> is_h;
	c = ((coef_v << 5) * im_v + (1 << (is_v - 1))) >> is_v;
	temp = a - (h2 - 1) * c - (w2 - 1) * b + 16;
	pel tmp_a_buf[32];
#pragma HLS ARRAY_PARTITION variable=tmp_a_buf complete dim=0
	for (y = 0; y < h; y++) {
#pragma HLS PIPELINE II=1
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
		temp2 = temp;
		for (x = 0; x < 32; x++) {
			if (x < w) {
				tmp_a_buf[x] = ((pel)(temp2 >> 5));
				temp2 += b;
			}
			else {
				tmp_a_buf[x] = 0;
			}
		}
		for (x = 0; x < 32; x++) {
			pel tmp_a = tmp_a_buf[x];
			dst[y][x] = ((pel)((0 > (((1 << bit_depth) - 1 < ((int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))) ? 0 : (((1 << bit_depth) - 1 < ((
				int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))))));
				dst0[y][x] = ((pel)((0 > (((1 << bit_depth) - 1 < ((int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))) ? 0 : (((1 << bit_depth) - 1 < ((
					int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))))));
			}

		temp += c;
	}
}

void ipred_bi_Chroma32(int cu_width_log2_chroma, int cu_height_log2_chroma,pel src_le[67], pel src_up[67], pel dst[32][32], pel dst0[32][32], U4 bit_depth, int w, int h)
{
#pragma HLS ARRAY_PARTITION variable = src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable = dst complete dim=2
#pragma HLS ARRAY_PARTITION variable = dst0 complete dim=2
	static const s8 com_tbl_log2[257] = {
		/* 0, 1 */
		-1, -1,
		/* 2, 3 */
		1, -1,
		/* 4 ~ 7 */
		2, -1, -1, -1,
		/* 8 ~ 15 */
		3, -1, -1, -1, -1, -1, -1, -1,
		/* 16 ~ 31 */
		4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 31 ~ 63 */
		5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 64 ~ 127 */
		6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 128 ~ 255 */
		7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		/* 256 */
		8
	};
#if MD_PRINT
	((int)com_tbl_log2[w]) >= 2 ? ((void)0) : __assert_HLS("com_tbl_log2[w] >= 2", "../separate/com_ipred.c",
		(unsigned int)1593, __FUNCTION__);
	((int)com_tbl_log2[h]) >= 2 ? ((void)0) : __assert_HLS("com_tbl_log2[h] >= 2", "../separate/com_ipred.c",
		(unsigned int)1594, __FUNCTION__);
#endif
	int x;
	int y;
	int ishift_x = cu_width_log2_chroma;// (int)com_tbl_log2[w];
	int ishift_y = cu_height_log2_chroma;// (int)com_tbl_log2[h];
	int ishift = ishift_x < ishift_y ? ishift_x : ishift_y;
	int ishift_xy = ishift_x + ishift_y + 1;
	int offset = 1 << (ishift_x + ishift_y);
	int a;
	int b;
	int c;
	int wt;
	int wxy;
	int tmp;
	int predx;
	static int ref_up[32];
	static int ref_le[32];
	static int up[32];
	static int le[32];
	static int wy[32];
	int wc;
	int tbl_wc[6] = { (-1), (21), (13), (7), (4), (2) };
#pragma HLS ARRAY_PARTITION variable = ref_up complete dim=0
#pragma HLS ARRAY_PARTITION variable = ref_le complete dim=0
#pragma HLS ARRAY_PARTITION variable = up complete dim=0
#pragma HLS ARRAY_PARTITION variable = le complete dim=0
#pragma HLS ARRAY_PARTITION variable = wy complete dim=0
	pel tmp_a, tmp_a_buf[32];
#pragma HLS ARRAY_PARTITION variable = tmp_a_buf complete dim=0
	wc = (ishift_x > ishift_y ? ishift_x - ishift_y : ishift_y - ishift_x);
	{
#if MD_PRINT
		wc <= 5 ? ((void)0) : __assert_HLS("wc <= 5", "../separate/com_ipred.c", (unsigned int)1607, __FUNCTION__);
#endif
	}
	;
	wc = tbl_wc[wc];
	for (x = 0; x < 32; x++) {
#pragma HLS UNROLL
		if (x < w) {
		ref_up[x] = ((int)src_up[x]);
		}
	}
	for (y = 0; y < 32; y++) {
#pragma HLS UNROLL
		if (y < h) {
		ref_le[y] = ((int)src_le[y]);
		}
	}
	a = ((int)src_up[w - 1]);
	b = ((int)src_le[h - 1]);
	c = (w == h ? (a + b + 1) >> 1 : (((a << ishift_x) + (b << ishift_y)) * wc + (1 << (ishift + 5))) >> (ishift + 6));
	wt = (c << 1) - a - b;
	for (x = 0; x < 32; x++) {
#pragma HLS UNROLL
		if (x < w) {
		up[x] = b - ref_up[x];
		ref_up[x] <<= ishift_y;
		}
	}
	tmp = 0;
	for (y = 0; y < 32; y++) {
#pragma HLS UNROLL
		if (y < h) {
		le[y] = a - ref_le[y];
		ref_le[y] <<= ishift_x;
		wy[y] = tmp;
		tmp += wt;
		}
	}
	for (y = 0; y < h; y++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
		predx = ref_le[y];
		wxy = 0;
		for (x = 0; x < 32; x++) {
			if (x < w) {
			predx += le[y];
			ref_up[x] += up[x];
			tmp_a_buf[x] = ((pel)(((predx << ishift_y) + (ref_up[x] << ishift_x) + wxy + offset) >> ishift_xy));
			wxy += wy[y];
			}
			else {
				tmp_a_buf[x] = 0;
			}
		}
		for (x = 0; x < 32; x++) {
			tmp_a = tmp_a_buf[x];
			dst[y][x] = ((pel)((0 > (((1 << bit_depth) - 1 < ((int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))) ? 0 : (((1 << bit_depth) - 1 < ((
				int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))))));
				dst0[y][x] = ((pel)((0 > (((1 << bit_depth) - 1 < ((int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))) ? 0 : (((1 << bit_depth) - 1 < ((
					int)tmp_a) ? (1 << bit_depth) - 1 : ((int)tmp_a))))));
			}

	}
}

void ipred_ang_val_Chroma32(pel dst[32][32], pel dst0[32][32], pel src_up[67], pel src_le[67], int ipm, U4 bit_depth, int m, int n, int w, int h
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=dst complete dim=2
#pragma HLS ARRAY_PARTITION variable=dst0 complete dim=2
	int i;
	int j;

	static const int com_tbl_ipred_dxdy[33][2] = { { 0, 0 }, { 0, 0 }, { 0, 0 }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) }, { (372), (2816) }, { (256), (4096) }, { (128), (8192) }, { 0, 0 }, { (128), (8192) }, { (256), (4096) }, { (372), (2816) }, { (512), (2048) }, { (744), (1408) }, { (1024), (1024) }, { (1408), (744) }, { (2048), (512) }, { (2816), (372) }, { (4096), (256) }, { (8192), (128) }, { 0, 0 }, { (8192), (128) }, { (4096), (256) }, { (2816), (372) }, { (2048), (512) }, { (1408), (744) }, { (1024), (1024) }, { (744), (1408) }, { (512), (2048) } };
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		/* AVS-2 design == bilinear interpolation + {1,2,1} ref smoothing */
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};

	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		/* best for CfP extra smooth */
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};

	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		// semi-sharp
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};

	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};

#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_dxdy complete dim=2
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_bilinear complete dim=0
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_extra_smooth complete dim=0
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_semi_sharp complete dim=0
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_hp complete dim=0
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
#pragma HLS ARRAY_PARTITION variable=filter_bits_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=filter_offset_list complete dim=0
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	const int* mt = com_tbl_ipred_dxdy[ipm];
	const int dxy = ipm > 24 || ipm < 12 ? -1 : 1;




			int offset;
			int offset_x;
			int offset_y;
			int t_dx;
			int t_dy;
			int xx;
			int xy;
			int yx;
			int yy;
			int x;
			int y;
			int xn;
			int yn;
			int xn_n1;
			int yn_n1;
			int xn_p2;
			int yn_p2;			

			int num_selections = 0;
			int use_x = -1;
			int p;
			int pn;
			int pn_n1;
			int pn_p2;
			int pos_max = w + h - 1;
			pel temp_pel = (pel)0;
			x = 2147483647;
			xn = 2147483647;
			xn_n1 = 2147483647;
			xn_p2 = 2147483647;
			y = 2147483647;
			yn = 2147483647;
			yn_n1 = 2147483647;
			yn_p2 = 2147483647;
			xx = 2147483647;
			yy = 2147483647;


	pel tmp_a[32];
#pragma HLS ARRAY_PARTITION variable=tmp_a complete dim=0

	for (j = 0; j < h; j++) {

#pragma HLS PIPELINE II=1
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32

			if (ipm == 12) {
			for (i = 0; i < 32; i++) {
				if (i < w) {
					tmp_a[i] = src_up[i + 3];
				}
			}
		}
			else if (ipm == 24) {
			for (i = 0; i < 32; i++) {
				if (i < w) {
					tmp_a[i] = src_le[j + 3];
				}
			}
		}
		else {
			for (i = 0; i < 32; i++) {
				if (i < w) {
					int filter_idx;
					if ((ipm < 12) || ((ipm >= 13) && (ipm <= 17)) || ((ipm >= 34) && (ipm <= 50))) {
						filter_idx = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;// MIPF
					}
					else if (((ipm >= 18) && (ipm <= 23)) || ((ipm >= 25) && (ipm <= 32)) || ((ipm >= 51) && (ipm <= 65))) {
						filter_idx = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;// MIPF
			}
			if (ipm < 12) {
				/* case x-line */
				t_dx = (j + 1) * mt[0] >> 10;
				offset = ((j + 1) * mt[0] << 5 >> 10) - (t_dx << 5);
				;
				x = i + t_dx;
				y = -1;
			}
			else if (ipm > 24) {
				t_dy = (i + 1) * mt[1] >> 10;
				offset = ((i + 1) * mt[1] << 5 >> 10) - (t_dy << 5);
				;
				x = -1;
				y = j + t_dy;
			}
			else {
				t_dx = (j + 1) * mt[0] >> 10;
				offset_x = ((j + 1) * mt[0] << 5 >> 10) - (t_dx << 5);
				;
				t_dx = -t_dx;
				xx = i + t_dx;
				yx = -1;
				t_dy = (i + 1) * mt[1] >> 10;
				offset_y = ((i + 1) * mt[1] << 5 >> 10) - (t_dy << 5);
				;
				t_dy = -t_dy;
				xy = -1;
				yy = j + t_dy;
				if (yy <= -1) {
					x = xx;
					y = yx;
					offset = offset_x;
				}
				else {
					x = xy;
					y = yy;
					offset = offset_y;
				}
			}
			//com_assert(x != INT_MAX);
			//com_assert(y != INT_MAX);
			if (y == -1) {
				if (dxy < 0) {
					xn_n1 = x - 1;
					xn = x + 1;
					xn_p2 = x + 2;
				}
				else {
					xn_n1 = x + 1;
					xn = x - 1;
					xn_p2 = x - 2;
				}
				use_x = 1;
				++num_selections;
				//src_ch = src_up;
				pos_max = w * 2 - 1;
			}
			else if (x == -1) {
				if (dxy < 0) {
					yn_n1 = y - 1;
					yn = y + 1;
					yn_p2 = y + 2;
				}
				else {
					yn_n1 = y + 1;
					yn = y - 1;
					yn_p2 = y - 2;
				}
				use_x = 0;
				++num_selections;
				//src_ch = src_le;
				pos_max = h * 2 - 1;
			}
			//com_assert(num_selections == 1);
			//com_assert(src_ch != NULL);
			if (use_x == 1) {
				pn_n1 = xn_n1;
				p = x;
				pn = xn;
				pn_p2 = xn_p2;
			}
			else {
				pn_n1 = yn_n1;
				p = y;
				pn = yn;
				pn_p2 = yn_p2;
			}
			pn_n1 = (pn_n1 < pos_max ? pn_n1 : pos_max);
			p = (p < pos_max ? p : pos_max);
			pn = (pn < pos_max ? pn : pos_max);
			pn_p2 = (pn_p2 < pos_max ? pn_p2 : pos_max);

			pn_n1 += 3;
			p += 3;
			pn += 3;
			pn_p2 += 3;

			int src_p, src_pn, src_pn_n1, src_pn_p2;

			if (y == -1) {
				src_pn_n1 = src_up[pn_n1];
				src_p = src_up[p];
				src_pn = src_up[pn];
				src_pn_p2 = src_up[pn_p2];
			}
			else if (x == -1) {
				src_pn_n1 = src_le[pn_n1];
				src_p = src_le[p];
				src_pn = src_le[pn];
				src_pn_p2 = src_le[pn_p2];
			}
			else {
				src_pn_n1 = 0;
				src_p = 0;
				src_pn = 0;
				src_pn_p2 = 0;
			}

			if (filter_idx == 0)
						tmp_a[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_extra_smooth[offset][0] + src_p * com_tbl_ipred_adi_extra_smooth[offset][1] +
					src_pn * com_tbl_ipred_adi_extra_smooth[offset][2] + src_pn_p2 * com_tbl_ipred_adi_extra_smooth[offset][3] +
					filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
			else if (filter_idx == 1)
						tmp_a[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_semi_sharp[offset][0] + src_p * com_tbl_ipred_adi_semi_sharp[offset][1] +
					src_pn * com_tbl_ipred_adi_semi_sharp[offset][2] + src_pn_p2 * com_tbl_ipred_adi_semi_sharp[offset][3] +
					filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
			else if (filter_idx == 2)
						tmp_a[i] = (pel)((src_pn_n1 * tbl_mc_c_coeff_hp[offset][0] + src_p * tbl_mc_c_coeff_hp[offset][1] +
					src_pn * tbl_mc_c_coeff_hp[offset][2] + src_pn_p2 * tbl_mc_c_coeff_hp[offset][3] +
					filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF
			else if (filter_idx == 3)
						tmp_a[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_bilinear[offset][0] + src_p * com_tbl_ipred_adi_bilinear[offset][1] +
					src_pn * com_tbl_ipred_adi_bilinear[offset][2] + src_pn_p2 * com_tbl_ipred_adi_bilinear[offset][3] +
					filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);// MIPF

				}
			}
			for (i = 0; i < 32; i++) {
				if (i < w) {
					temp_pel = tmp_a[i];
			dst[j][i] = ((pel)((0 > (((1 << bit_depth) - 1 < ((int)temp_pel) ? (1 << bit_depth) - 1 : ((int)temp_pel))) ? 0 : (((1 << bit_depth) - 1 < ((
				int)temp_pel) ? (1 << bit_depth) - 1 : ((int)temp_pel))))));
					dst0[j][i] = ((pel)((0 > (((1 << bit_depth) - 1 < ((int)temp_pel) ? (1 << bit_depth) - 1 : ((int)temp_pel))) ? 0 : (((1 << bit_depth) - 1 < ((
						int)temp_pel) ? (1 << bit_depth) - 1 : ((int)temp_pel))))));
				}
			}
		}
	}
}

void ipred_ang_Chroma32(pel src_le[67], pel src_up[67], pel dst[32][32], pel dst0[32][32], U4 bit_depth, U7 w, U7 h, S8 ipm, U2 type
#if MIPF
	, int is_luma, int mipf_enable_flag
#endif
)
{

			ipred_ang_val_Chroma32(dst, dst0, src_up, src_le, ipm, bit_depth, 0, 0, w, h
#if MIPF
				, is_luma, mipf_enable_flag
#endif
			);
}


void ipred_ang_eipm_Chroma32(pel src_le[67], pel src_up[67], int w, int h, int ipm
#if MIPF
	, int is_luma, int mipf_enable_flag, U4 bit_depth, s16 diff[32][32], s16 diff0[32][32]
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=src_le complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_up complete dim=0
#pragma HLS ARRAY_PARTITION variable=diff complete dim=2
#pragma HLS ARRAY_PARTITION variable=diff0 complete dim=2
	pel tmp[32], tmp1;
#pragma HLS ARRAY_PARTITION variable=tmp complete dim=0
	static const int com_tbl_ipred_dxdy[IPD_CNT][2] = /* {dx/dy, dy/dx} */
	{
		{0, 0},{0, 0},{0, 0},                                 //0~2
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //3~6
		{744, 1408},{512, 2048},                              //7~8
		{372, 2816},                                          //9
		{256, 4096},                                          //10
		{128, 8192},{0, 0},{128, 8192},{256, 4096},           //11~14
		{372, 2816},{512, 2048},{744, 1408},{1024, 1024},     //15~18
		{1408, 744},{2048, 512},{2816, 372},                  //19~21
		{4096, 256},                                          //22
		{8192, 128},{0, 0},{8192, 128},{4096, 256},           //23~26
		{2816, 372},{2048, 512},{1408, 744},{1024, 1024},     //27~30
		{744, 1408},{ 512, 2048 },{0, 0},{2340, 448},         //31~34
		{1640, 640},                                          //35
		{1168, 898},{898, 1168},{640, 1640},{448, 2340},      //36~39
		{320, 3276},{192, 5460},{64, 16384},{32, 32768},      //40~43
		{32, 32768},{64, 16384},{192, 5460},{320, 3276},      //44~47
		{448, 2340},                                          //48
		{640, 1640},{898, 1168},{1168, 898},{1640, 640},      //49~52
		{2340, 448},{3276, 320},{5460, 192},{16384, 64},      //53~56
		{32768, 32},{32768, 32},{16384, 64},{5460, 192},      //57~60
		{3276, 320},{2340, 448},                              //61~62
		{1640, 640},{1168, 898},{898, 1168}                   //63~65
	};
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_dxdy complete dim=2
#if MIPF
	static const s16 com_tbl_ipred_adi_bilinear[32][4] =
	{
		{ 32, 64, 32,  0 },
		{ 31, 63, 33,  1 },
		{ 30, 62, 34,  2 },
		{ 29, 61, 35,  3 },
		{ 28, 60, 36,  4 },
		{ 27, 59, 37,  5 },
		{ 26, 58, 38,  6 },
		{ 25, 57, 39,  7 },
		{ 24, 56, 40,  8 },
		{ 23, 55, 41,  9 },
		{ 22, 54, 42, 10 },
		{ 21, 53, 43, 11 },
		{ 20, 52, 44, 12 },
		{ 19, 51, 45, 13 },
		{ 18, 50, 46, 14 },
		{ 17, 49, 47, 15 },
		{ 16, 48, 48, 16 },
		{ 15, 47, 49, 17 },
		{ 14, 46, 50, 18 },
		{ 13, 45, 51, 19 },
		{ 12, 44, 52, 20 },
		{ 11, 43, 53, 21 },
		{ 10, 42, 54, 22 },
		{ 9, 41, 55, 23 },
		{ 8, 40, 56, 24 },
		{ 7, 39, 57, 25 },
		{ 6, 38, 58, 26 },
		{ 5, 37, 59, 27 },
		{ 4, 36, 60, 28 },
		{ 3, 35, 61, 29 },
		{ 2, 34, 62, 30 },
		{ 1, 33, 63, 31 },
	};
	static const s16 com_tbl_ipred_adi_extra_smooth[32][4] =
	{
		{ 23, 82, 21, 2 },
		{ 21, 82, 23, 2 },
		{ 19, 82, 25, 2 },
		{ 18, 81, 27, 2 },
		{ 16, 80, 30, 2 },
		{ 15, 79, 32, 2 },
		{ 13, 78, 35, 2 },
		{ 12, 77, 37, 2 },
		{ 11, 75, 40, 2 },
		{ 10, 74, 42, 2 },
		{ 9, 72, 45, 2 },
		{ 8, 70, 47, 3 },
		{ 7, 68, 50, 3 },
		{ 6, 67, 52, 3 },
		{ 6, 64, 54, 4 },
		{ 5, 62, 57, 4 },
		{ 4, 60, 60, 4 },
		{ 4, 57, 62, 5 },
		{ 4, 54, 64, 6 },
		{ 3, 52, 67, 6 },
		{ 3, 50, 68, 7 },
		{ 3, 47, 70, 8 },
		{ 2, 45, 72, 9 },
		{ 2, 42, 74, 10 },
		{ 2, 40, 75, 11 },
		{ 2, 37, 77, 12 },
		{ 2, 35, 78, 13 },
		{ 2, 32, 79, 15 },
		{ 2, 30, 80, 16 },
		{ 2, 27, 81, 18 },
		{ 2, 25, 82, 19 },
		{ 2, 23, 82, 21 },
	};
	static const s16 com_tbl_ipred_adi_semi_sharp[32][4] =
	{
		{ 11, 106, 12, -1 },
		{ 9, 105, 15, -1 },
		{ 7, 105, 18, -2 },
		{ 6, 103, 21, -2 },
		{ 4, 102, 25, -3 },
		{ 2, 100, 29, -3 },
		{ 1, 99, 32, -4 },
		{ 0, 96, 36, -4 },
		{ -1, 94, 39, -4 },
		{ -2, 92, 43, -5 },
		{ -3, 89, 47, -5 },
		{ -4, 86, 51, -5 },
		{ -4, 83, 55, -6 },
		{ -5, 80, 59, -6 },
		{ -5, 77, 62, -6 },
		{ -6, 74, 66, -6 },
		{ -6, 70, 70, -6 },
		{ -6, 66, 74, -6 },
		{ -6, 62, 77, -5 },
		{ -6, 59, 80, -5 },
		{ -6, 55, 83, -4 },
		{ -5, 51, 86, -4 },
		{ -5, 47, 89, -3 },
		{ -5, 43, 92, -2 },
		{ -4, 39, 94, -1 },
		{ -4, 36, 96, 0 },
		{ -4, 32, 99, 1 },
		{ -3, 29, 100, 2 },
		{ -3, 25, 102, 4 },
		{ -2, 21, 103, 6 },
		{ -2, 18, 105, 7 },
		{ -1, 15, 105, 9 },
	};
	static const s16 tbl_mc_c_coeff_hp[32][4] =
	{
		{ 0, 64, 0, 0 },
		{ -1, 63,  2,  0 },
		{ -2, 62,  4,  0 },
		{ -2, 60,  7,  -1 },
		{ -2, 58, 10, -2 },
		{ -3, 57, 12, -2 },
		{ -4, 56, 14, -2 },
		{ -4, 55, 15, -2 },
		{ -4, 54, 16, -2 },
		{ -5, 53, 18, -2 },
		{ -6, 52, 20, -2 },
		{ -6, 49, 24, -3 },
		{ -6, 46, 28, -4 },
		{ -5, 44, 29, -4 },
		{ -4, 42, 30, -4 },
		{ -4, 39, 33, -4 },
		{ -4, 36, 36, -4 },
		{ -4, 33, 39, -4 },
		{ -4, 30, 42, -4 },
		{ -4, 29, 44, -5 },
		{ -4, 28, 46, -6 },
		{ -3, 24, 49, -6 },
		{ -2, 20, 52, -6 },
		{ -2, 18, 53, -5 },
		{ -2, 16, 54, -4 },
		{ -2, 15, 55, -4 },
		{ -2, 14, 56, -4 },
		{ -2, 12, 57, -3 },
		{ -2, 10, 58, -2 },
		{ -1,  7, 60, -2 },
		{ 0,  4, 62, -2 },
		{ 0,  2, 63, -1 },
	};
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_bilinear complete dim=0
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_extra_smooth complete dim=0
#pragma HLS ARRAY_PARTITION variable=com_tbl_ipred_adi_semi_sharp complete dim=0
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_hp complete dim=0
#else
	static const s16 com_tbl_ipred_adi[32][4] = { { (32), (64), (32), 0 }, { (31), (63), (33), (1) }, { (30), (62), (34), (2) }, { (29), (61), (35), (3) }, { (28), (60), (36), (4) }, { (27), (59), (37), (5) }, { (26), (58), (38), (6) }, { (25), (57), (39), (7) }, { (24), (56), (40), (8) }, { (23), (55), (41), (9) }, { (22), (54), (42), (10) }, { (21), (53), (43), (11) }, { (20), (52), (44), (12) }, { (19), (51), (45), (13) }, { (18), (50), (46), (14) }, { (17), (49), (47), (15) }, { (16), (48), (48), (16) }, { (15), (47), (49), (17) }, { (14), (46), (50), (18) }, { (13), (45), (51), (19) }, { (12), (44), (52), (20) }, { (11), (43), (53), (21) }, { (10), (42), (54), (22) }, { (9), (41), (55), (23) }, { (8), (40), (56), (24) }, { (7), (39), (57), (25) }, { (6), (38), (58), (26) }, { (5), (37), (59), (27) }, { (4), (36), (60), (28) }, { (3), (35), (61), (29) }, { (2), (34), (62), (30) }, { (1), (33), (63), (31) } };
#endif
#if MIPF
	const int filter_bits_list[4] = { 7, 7, 6, 7 };
	const int filter_offset_list[4] = { 64, 64 ,32, 64 };
#pragma HLS ARRAY_PARTITION variable=filter_bits_list complete dim=0
#pragma HLS ARRAY_PARTITION variable=filter_offset_list complete dim=0
	const int is_small = w * h <= (is_luma ? MIPF_TH_SIZE : MIPF_TH_SIZE_CHROMA);
	const int td = is_luma ? MIPF_TH_DIST : MIPF_TH_DIST_CHROMA;
	int filter_idx;
#else
	const s16(*tbl_filt)[4] = com_tbl_ipred_adi;
	const int filter_offset = ADI_4T_FILTER_OFFSET;
	const int filter_bits = ADI_4T_FILTER_BITS;
#endif
	const int* mt = com_tbl_ipred_dxdy[ipm];
	int offset_x[32], offset_y[32];
	int t_dx[32], t_dy[32];
	int i, j;
	int offset;
	int pos_max = w + h - 1;
	int p, pn, pn_n1, pn_p2;
	int src_p, src_pn, src_pn_n1, src_pn_p2;
	int src_p_tmp[32], src_pn_tmp[32], src_pn_n1_tmp[32], src_pn_p2_tmp[32];
	int filter_idx_tmp[32];
	int offset_tmp[32];
#pragma HLS ARRAY_PARTITION variable=offset_x complete dim=0
#pragma HLS ARRAY_PARTITION variable=offset_y complete dim=0
#pragma HLS ARRAY_PARTITION variable=t_dx complete dim=0
#pragma HLS ARRAY_PARTITION variable=t_dy complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_p_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_pn_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_pn_n1_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_pn_p2_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=filter_idx_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=offset_tmp complete dim=0
	if (((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT)) || (((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))))
	{
		if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT))
			pos_max = w * 2 - 1;
		else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
			pos_max = h * 2 - 1;
	}
	else {
		for (i = 0; i < 32; i++)
		{
#pragma HLS UNROLL
			if (i < w) {
				GET_REF_POS(mt[1], i + 1, t_dy[i], offset_y[i]);
				t_dy[i] = -t_dy[i];
			}
		}
		for (j = 0; j < 32; j++)
		{
#pragma HLS UNROLL
			if (j < h) {
				GET_REF_POS(mt[0], j + 1, t_dx[j], offset_x[j]);
				t_dx[j] = -t_dx[j];
			}
		}
	}
	for (j = 0; j < h; j++)
	{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
		for (i = 0; i < 32; i++)
		{
			if (i < w) {
				if (((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT)) || (((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))))
				{
					int dx;
					int x;
					if ((ipm < IPD_VER) || (ipm >= IPD_DIA_L_EXT && ipm <= IPD_VER_EXT)) {
						GET_REF_POS(mt[0], j + 1, dx, offset_tmp[i]);
						filter_idx_tmp[i] = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
						x = i + dx;
						pn_n1 = x - 1;
						p = x;
						pn = x + 1;
						pn_p2 = x + 2;
						pn_n1 = COM_MIN(pn_n1, pos_max);
						p = COM_MIN(p, pos_max);
						pn = COM_MIN(pn, pos_max);
						pn_p2 = COM_MIN(pn_p2, pos_max);
						src_pn_n1_tmp[i] = src_up[pn_n1];
						src_p_tmp[i] = src_up[p];
						src_pn_tmp[i] = src_up[pn];
						src_pn_p2_tmp[i] = src_up[pn_p2];
					}
					else if ((ipm > IPD_HOR && ipm < IPD_IPCM) || (ipm >= IPD_HOR_EXT && ipm < IPD_CNT))
					{
						GET_REF_POS(mt[1], i + 1, dx, offset_tmp[i]);
						filter_idx_tmp[i] = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
						x = j + dx;
						pn_n1 = x - 1;
						p = x;
						pn = x + 1;
						pn_p2 = x + 2;
						pn_n1 = COM_MIN(pn_n1, pos_max);
						p = COM_MIN(p, pos_max);
						pn = COM_MIN(pn, pos_max);
						pn_p2 = COM_MIN(pn_p2, pos_max);
						src_pn_n1_tmp[i] = src_le[pn_n1];
						src_p_tmp[i] = src_le[p];
						src_pn_tmp[i] = src_le[pn];
						src_pn_p2_tmp[i] = src_le[pn_p2];
					}
				}
				else
				{
					int x = i + t_dx[j];
					int y = j + t_dy[i];
					if (y <= -1)
					{
						offset_tmp[i] = offset_x[j];
						pos_max = w * 2 - 1;
						pn_n1 = x + 1;
						p = x;
						pn = x - 1;
						pn_p2 = x - 2;
						pn_n1 = COM_MIN(pn_n1, pos_max);
						p = COM_MIN(p, pos_max);
						pn = COM_MIN(pn, pos_max);
						pn_p2 = COM_MIN(pn_p2, pos_max);
						src_pn_n1_tmp[i] = src_up[pn_n1];
						src_p_tmp[i] = src_up[p];
						src_pn_tmp[i] = src_up[pn];
						src_pn_p2_tmp[i] = src_up[pn_p2];
					}
					else
					{
						offset_tmp[i] = offset_y[i];
						pos_max = h * 2 - 1;
						pn_n1 = y + 1;
						p = y;
						pn = y - 1;
						pn_p2 = y - 2;
						pn_n1 = COM_MIN(pn_n1, pos_max);
						p = COM_MIN(p, pos_max);
						pn = COM_MIN(pn, pos_max);
						pn_p2 = COM_MIN(pn_p2, pos_max);
						src_pn_n1_tmp[i] = src_le[pn_n1];
						src_p_tmp[i] = src_le[p];
						src_pn_tmp[i] = src_le[pn];
						src_pn_p2_tmp[i] = src_le[pn_p2];
					}
					if (ipm < IPD_DIA_R || (ipm > IPD_VER_EXT && ipm <= IPD_DIA_R_EXT)) {
						filter_idx_tmp[i] = mipf_enable_flag ? (j < td ? is_small + 1 : is_small) : 3;
					}
					else
					{
						filter_idx_tmp[i] = mipf_enable_flag ? (i < td ? is_small + 1 : is_small) : 3;
					}
				}
			}
		}
		for (i = 0; i < 32; i++)
		{
			if (i < w) {
				filter_idx = filter_idx_tmp[i];
				offset = offset_tmp[i];
				src_pn_n1 = src_pn_n1_tmp[i];
				src_p = src_p_tmp[i];
				src_pn = src_pn_tmp[i];
				src_pn_p2 = src_pn_p2_tmp[i];
				//s16 data1 ;
				//s16 data2;
				//s16 data3;
				//s16 data4;
				if (filter_idx == 0) {
					//data1 = com_tbl_ipred_adi_extra_smooth[offset][0];
					//data2 = com_tbl_ipred_adi_extra_smooth[offset][1];
					//data3 = com_tbl_ipred_adi_extra_smooth[offset][2];
					//data4 = com_tbl_ipred_adi_extra_smooth[offset][3];
					tmp[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_extra_smooth[offset][0] + src_p * com_tbl_ipred_adi_extra_smooth[offset][1] +
						src_pn * com_tbl_ipred_adi_extra_smooth[offset][2] + src_pn_p2 * com_tbl_ipred_adi_extra_smooth[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				}
				else if (filter_idx == 1) {
					//data1 = com_tbl_ipred_adi_semi_sharp[offset][0];
					//data2 = com_tbl_ipred_adi_semi_sharp[offset][1];
					//data3 = com_tbl_ipred_adi_semi_sharp[offset][2];
					//data4 = com_tbl_ipred_adi_semi_sharp[offset][3];

					tmp[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_semi_sharp[offset][0] + src_p * com_tbl_ipred_adi_semi_sharp[offset][1] +
						src_pn * com_tbl_ipred_adi_semi_sharp[offset][2] + src_pn_p2 * com_tbl_ipred_adi_semi_sharp[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				}
				else if (filter_idx == 2) {
					//data1 = tbl_mc_c_coeff_hp[offset][0];
					//data2 = tbl_mc_c_coeff_hp[offset][1];
					//data3 = tbl_mc_c_coeff_hp[offset][2];
					//data4 = tbl_mc_c_coeff_hp[offset][3];

					tmp[i] = (pel)((src_pn_n1 * tbl_mc_c_coeff_hp[offset][0] + src_p * tbl_mc_c_coeff_hp[offset][1] +
						src_pn * tbl_mc_c_coeff_hp[offset][2] + src_pn_p2 * tbl_mc_c_coeff_hp[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				}
				else if (filter_idx == 3) {
					//data1 = com_tbl_ipred_adi_bilinear[offset][0];
					//data2 = com_tbl_ipred_adi_bilinear[offset][1];
					//data3 = com_tbl_ipred_adi_bilinear[offset][2];
					//data4 = com_tbl_ipred_adi_bilinear[offset][3];

					tmp[i] = (pel)((src_pn_n1 * com_tbl_ipred_adi_bilinear[offset][0] + src_p * com_tbl_ipred_adi_bilinear[offset][1] +
						src_pn * com_tbl_ipred_adi_bilinear[offset][2] + src_pn_p2 * com_tbl_ipred_adi_bilinear[offset][3] +
						filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
				}
				//tmp[i] = (pel)((src_pn_n1 * data1 + src_p * data2 + src_pn * data3 + src_pn_p2 * data4 + filter_offset_list[filter_idx]) >> filter_bits_list[filter_idx]);
			}
		}
		for (i = 0; i < 32; i++)
		{
			if (i < w) {
				tmp1 = COM_CLIP3(0, ((1 << bit_depth) - 1), tmp[i]);
				diff[j][i] = tmp1;
				diff0[j][i] = tmp1;
			}
		}
	}
}
void com_ipred_uv_32(int cu_width_log2_chroma, int cu_height_log2_chroma, pel src_le[67], pel src_up[67], pel dst[32][32],pel dst0[32][32], S8 ipm_c, S8 ipm, U7 w, U7 h, U4 bit_depth,
	u16 avail_cu, pel piRecoY[64][64], pel nb_y[2][2 * 64 + 3]
#if MIPF
	, int mipf_enable_flag
#endif
)
{
#if USE_TSCPM
	int bAbove = IS_AVAIL(avail_cu, AVAIL_UP);
	int bLeft = IS_AVAIL(avail_cu, AVAIL_LE);
#endif

	if (ipm_c == 0 && (ipm == 12 || ipm == 24 || ipm == 0 || ipm == 2)) {
		ipm_c = (ipm == 12 ? 3 : ((ipm == 24 ? 2 : ((ipm == 0 ? 1 : 4)))));
	}



		if ((ipm_c == 0) && (ipm == 1)) {
		ipred_plane_Chroma32( cu_width_log2_chroma,  cu_height_log2_chroma, src_le + 2, src_up + 2, dst, dst0, bit_depth, w, h);
		}


#if EIPM

		if ((ipm_c == 0) && (ipm > 33)){
		ipred_ang_eipm_Chroma32(src_le + 3, src_up + 3, w, h, ipm
#if MIPF
			, 0, mipf_enable_flag, bit_depth, dst, dst0
#endif
				);

			}

#endif
		if((ipm_c == 0) && (ipm < 34)&&(!((ipm == 1)))) {
		ipred_ang_Chroma32(src_le, src_up, dst, dst0, bit_depth, w, h, ipm, 1
#if MIPF
					, 0, mipf_enable_flag
#endif
				);
			//clip_pred(dst, w, h, bit_depth);
		}
		// Clip
		if (ipm_c == 1) {
		ipred_dc_Chroma32( cu_width_log2_chroma,  cu_height_log2_chroma, src_le + 3, src_up + 3, dst, dst0, w, h, bit_depth, avail_cu);
		}
		if (ipm_c == 2) {
		ipred_hor_Chroma32(src_le + 3, dst, dst0, w, h);
		}
		if (ipm_c == 3) {
		ipred_vert_Chroma32(src_up + 3, dst, dst0, w, h);
		}
		if (ipm_c == 4) {
		ipred_bi_Chroma32( cu_width_log2_chroma,  cu_height_log2_chroma,src_le + 3, src_up + 3, dst, dst0, bit_depth, w, h);
		// Clip
		//clip_pred(dst, w, h, bit_depth);
		}

#if USE_TSCPM
		if (ipm_c == 5) {
		ipred_tscpm_Chroma32(dst, dst0, piRecoY, 64, w, h, bAbove, bLeft, bit_depth, src_le + 3, src_up + 3, nb_y[0], nb_y[1]);
		}
#endif


	
}

void get_ref_u_wsc32(strFetch_ref_window* Fetch_Ref_window_ptr, s8 refi, int lidx, U2* U_ref0)
{
#pragma HLS INLINE 
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->lidx complete dim=0
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->cur_refi complete dim=0
	* U_ref0 = 0;
#if ENABLE_BFRAME
	if (Fetch_Ref_window_ptr->code_stru == RA)
	{
		if (lidx == Fetch_Ref_window_ptr->lidx[REFP_0] && refi == Fetch_Ref_window_ptr->cur_refi[REFP_0])
		{
			*U_ref0 = 1;
		}
		if (lidx == Fetch_Ref_window_ptr->lidx[REFP_1] && refi == Fetch_Ref_window_ptr->cur_refi[REFP_1])
		{
			*U_ref0 = 2;
		}
	}
	else
	{
		if (refi == Fetch_Ref_window_ptr->cur_refi[REFP_0])
		{
#endif
			* U_ref0 = 1;
#if ENABLE_BFRAME
		}
		else if (refi == Fetch_Ref_window_ptr->cur_refi[REFP_1])
		{
			*U_ref0 = 2;
		}
	}
#endif
}
 void com_mc_c_00_uv32( int gmv_x, int gmv_y,  s16 pred_u[32][32], s16 pred_v[32][32], int w, int h, int bit_depth , pel UP_tmp_mc[35][35], pel VP_tmp_mc[35][35])
{
	int i;
	int j;
		for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (j = 0; j < w; j++) {
				pred_u[i][j] = UP_tmp_mc[i+1][j+1];// ref_u[j + offset_ref];
				pred_v[i][j] = VP_tmp_mc[i+1][j+1];// ref_v[j + offset_ref];
			}
		}
}
 void com_mc_c_0n_uv32(int gmv_x, int gmv_y, s16 pred_u[32][32], s16 pred_v[32][32], int w, int h, int bit_depth , pel UP_tmp_mc[35][35], pel VP_tmp_mc[35][35], s16 tbl_mc_c_coeff_all_dy[4])
{
		int i;
		int j;
		s32 pt;
		for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (j = 0; j < w; j++) {
				pt = (
					((int)tbl_mc_c_coeff_all_dy[0]) * ((int)UP_tmp_mc[i][j + 1]) +
					((int)tbl_mc_c_coeff_all_dy[1]) * ((int)UP_tmp_mc[i + 1][j + 1]) +
					((int)tbl_mc_c_coeff_all_dy[2]) * ((int)UP_tmp_mc[i + 2][j + 1]) +
					((int)tbl_mc_c_coeff_all_dy[3]) * ((int)UP_tmp_mc[i + 3][j + 1]) + (1 << 5)) >> 6;
				pred_u[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
					1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
				pt = (
					((int)tbl_mc_c_coeff_all_dy[0]) * ((int)VP_tmp_mc[i][j + 1]) +
					((int)tbl_mc_c_coeff_all_dy[1]) * ((int)VP_tmp_mc[i + 1][j + 1]) +
					((int)tbl_mc_c_coeff_all_dy[2]) * ((int)VP_tmp_mc[i + 2][j + 1]) +
					((int)tbl_mc_c_coeff_all_dy[3]) * ((int)VP_tmp_mc[i + 3][j + 1]) + (1 << 5)) >> 6;
				pred_v[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
					1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
			}
		}
}
 void com_mc_c_n0_uv32(int gmv_x, int gmv_y, s16 pred_u[32][32], s16 pred_v[32][32], int w, int h, int bit_depth, pel UP_tmp_mc[35][35], pel VP_tmp_mc[35][35],s16 tbl_mc_c_coeff_all_dx[4])
{
		int i;
		int j;
		s32 pt;
		for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (j = 0; j < w; j++) {
				pt = (
					((int)tbl_mc_c_coeff_all_dx[0]) * ((int)UP_tmp_mc[i + 1][j]) +
					((int)tbl_mc_c_coeff_all_dx[1]) * ((int)UP_tmp_mc[i + 1][j + 1]) +
					((int)tbl_mc_c_coeff_all_dx[2]) * ((int)UP_tmp_mc[i + 1][j + 2]) +
					((int)tbl_mc_c_coeff_all_dx[3]) * ((int)UP_tmp_mc[i + 1][j + 3]) + (1 << 5)) >> 6;
				pred_u[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
					1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
				pt = (
					((int)tbl_mc_c_coeff_all_dx[0]) * ((int)VP_tmp_mc[i + 1][j]) +
					((int)tbl_mc_c_coeff_all_dx[1]) * ((int)VP_tmp_mc[i + 1][j + 1]) +
					((int)tbl_mc_c_coeff_all_dx[2]) * ((int)VP_tmp_mc[i + 1][j + 2]) +
					((int)tbl_mc_c_coeff_all_dx[3]) * ((int)VP_tmp_mc[i + 1][j + 3]) + (1 << 5)) >> 6;
				pred_v[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)) ? 0 : (((
					1 << bit_depth) - 1 < pt ? (1 << bit_depth) - 1 : pt)))));
			}
		}
}
 void com_mc_c_nn_uv32( int gmv_x, int gmv_y,  s16 pred_u[32][32], s16 pred_v[32][32], int w, int h, int bit_depth ,
	 pel UP_tmp_mc[35][35], pel VP_tmp_mc[35][35],s16 tbl_mc_c_coeff_all_dx[4], s16 tbl_mc_c_coeff_all_dy[4])
{
	static  s16 buf_u[35][32];
	static  s16 buf_v[35][32];
	static  s16 buf_u1[35][32];
	static  s16 buf_v1[35][32];
#pragma HLS ARRAY_PARTITION variable=buf_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=buf_v complete dim=2
#pragma HLS ARRAY_PARTITION variable=buf_u1 complete dim=2
#pragma HLS ARRAY_PARTITION variable=buf_v1 complete dim=2
	const int shift1 = bit_depth - 8;
	const int shift2 = 20 - bit_depth;
	const int add1 = 1 << shift1 >> 1;
	const int add2 = 1 << (shift2 - 1);
		int i;
		int j;
		s32 pt_u[32];
		s32 pt_v[32];
#pragma HLS ARRAY_PARTITION variable=pt_u complete dim=0
#pragma HLS ARRAY_PARTITION variable=pt_v complete dim=0
		s16 buf_u_tmp;
		s16 buf_v_tmp;
		for (i = 0; i < h + 3; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=35 max=35 avg=35
			for (j = 0; j < w; j++) {
				buf_u_tmp = ((s16)((
					((int)tbl_mc_c_coeff_all_dx[0]) * ((int)UP_tmp_mc[i][j]) +
					((int)tbl_mc_c_coeff_all_dx[1]) * ((int)UP_tmp_mc[i][j + 1]) +
					((int)tbl_mc_c_coeff_all_dx[2]) * ((int)UP_tmp_mc[i][j + 2]) +
					((int)tbl_mc_c_coeff_all_dx[3]) * ((int)UP_tmp_mc[i][j + 3]) + add1) >> shift1));
				buf_u[i][j] = buf_u_tmp;
				buf_u1[i][j] = buf_u_tmp;
				buf_v_tmp = ((s16)((
					((int)tbl_mc_c_coeff_all_dx[0]) * ((int)VP_tmp_mc[i][j]) +
					((int)tbl_mc_c_coeff_all_dx[1]) * ((int)VP_tmp_mc[i][j + 1]) +
					((int)tbl_mc_c_coeff_all_dx[2]) * ((int)VP_tmp_mc[i][j + 2]) +
					((int)tbl_mc_c_coeff_all_dx[3]) * ((int)VP_tmp_mc[i][j + 3]) + add1) >> shift1));
				buf_v[i][j] = buf_v_tmp;
				buf_v1[i][j] = buf_v_tmp;
			}
		}
		for (i = 0; i < h; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (j = 0; j < w; j++) {
				pt_u[j] = (
					((int)tbl_mc_c_coeff_all_dy[0]) * ((int)buf_u[i][j]) +
					((int)tbl_mc_c_coeff_all_dy[1]) * ((int)buf_u[i + 1][j]) +
					((int)tbl_mc_c_coeff_all_dy[2]) * ((int)buf_u1[i + 2][j]) +
					((int)tbl_mc_c_coeff_all_dy[3]) * ((int)buf_u1[i + 3][j]) + add2) >> shift2;
				pt_v[j] = (
					((int)tbl_mc_c_coeff_all_dy[0]) * ((int)buf_v[i][j]) +
					((int)tbl_mc_c_coeff_all_dy[1]) * ((int)buf_v[i + 1][j]) +
					((int)tbl_mc_c_coeff_all_dy[2]) * ((int)buf_v1[i + 2][j]) +
					((int)tbl_mc_c_coeff_all_dy[3]) * ((int)buf_v1[i + 3][j]) + add2) >> shift2;
			}
			for (j = 0; j < w; j++) {
				pred_u[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt_u[j] ? (1 << bit_depth) - 1 : pt_u[j])) ? 0 : (((
					1 << bit_depth) - 1 < pt_u[j] ? (1 << bit_depth) - 1 : pt_u[j])))));
				pred_v[i][j] = ((s16)((0 > (((1 << bit_depth) - 1 < pt_v[j] ? (1 << bit_depth) - 1 : pt_v[j])) ? 0 : (((
					1 << bit_depth) - 1 < pt_v[j] ? (1 << bit_depth) - 1 : pt_v[j])))));
			}
		}
}
void com_tbl_mc_c_1_uv_wsc(int ori_mv_x, int ori_mv_y,  int gmv_x, int gmv_y, s16 pred_u[32][32], s16 pred_v[32][32],int w, int h, int bit_depth,
	strFetch_ref_window* Fetch_Ref_window_ptr, U2 UV_flag
	)
{
#pragma HLS INLINE OFF
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_UP cyclic factor=128 dim=1
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_VP cyclic factor=128 dim=1
#if ENABLE_BFRAME
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_UP_ref1 cyclic factor=128 dim=1
#pragma HLS ARRAY_RESHAPE variable = Fetch_Ref_window_ptr->RefWindowLCU_VP_ref1 cyclic factor=128 dim=1
#endif
#pragma HLS ARRAY_PARTITION variable=pred_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v complete dim=2
	pel UP_tmp[128];
	pel VP_tmp[128];
	pel UP_tmp_mc[35][35];
	pel VP_tmp_mc[35][35];
#pragma HLS ARRAY_PARTITION variable=UP_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=VP_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=UP_tmp_mc complete dim=2
#pragma HLS ARRAY_PARTITION variable=VP_tmp_mc complete dim=2
	for (int i = 0; i < h + 3; i++) {
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=35 max=35 avg=35
		for (int j = 0; j < 128; j++) {
			if (UV_flag == 1) {
				UP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_UP[j + (((gmv_y >> 3) - 1) + i) * 128];
				VP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_VP[j + (((gmv_y >> 3) - 1) + i) * 128];
			}
#if ENABLE_BFRAME
			else if (UV_flag == 2) {
				UP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_UP_ref1[j + (((gmv_y >> 3) - 1) + i) * 128];
				VP_tmp[j] = Fetch_Ref_window_ptr->RefWindowLCU_VP_ref1[j + (((gmv_y >> 3) - 1) + i) * 128];
			}
#endif
		}
		for (int j = 0; j < 32 + 3; j++) {
			UP_tmp_mc[i][j] = UP_tmp[j + (gmv_x >> 3) - 1];
			VP_tmp_mc[i][j] = VP_tmp[j + (gmv_x >> 3) - 1];
		}
	}
	int coeff_dx;
	int coeff_dy;
	coeff_dx = gmv_x & 0x7;
	coeff_dy = gmv_y & 0x7;
	const s16 tbl_mc_c_coeff_all_0[32][4] = {
		{ 0, (64), 0, 0 }, { ((s16)(-4)), (62), (6), 0 }, { ((s16)(-6)), (56), (15), ((s16)(-1)) }, { ((s16)(-5)), (47), (25), ((s16)(-3)) },
		{ ((s16)(-4)), (36), (36), ((s16)(-4)) }, { ((s16)(-3)), (25), (47), ((s16)(-5)) }, { ((s16)(-1)), (15), (56), ((s16)(-6)) }, { 0, (6), (62), ((s16)(-4)) },
		{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };
	s16 tbl_mc_c_coeff_all_dx[4];
	s16 tbl_mc_c_coeff_all_dy[4];
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_all_0 complete dim=2
#pragma HLS RESOURCE variable=tbl_mc_c_coeff_all_0 core=ROM_1P
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_all_dx complete dim=0
#pragma HLS ARRAY_PARTITION variable=tbl_mc_c_coeff_all_dy complete dim=0
	for (int i = 0; i < 4; i++) {
#pragma HLS UNROLL
		tbl_mc_c_coeff_all_dx[i] = tbl_mc_c_coeff_all_0[coeff_dx][i];
	}
	for (int i = 0; i < 4; i++) {
#pragma HLS UNROLL
		tbl_mc_c_coeff_all_dy[i] = tbl_mc_c_coeff_all_0[coeff_dy][i];
	}
	int dx;
	int dy;
	dx = ori_mv_x & 0x7;
	dy = ori_mv_y & 0x7;
	if (dx == 0) {
		if (dy == 0) {
			com_mc_c_00_uv32( gmv_x, gmv_y,  pred_u, pred_v, 32/*w*/, h, bit_depth,  UP_tmp_mc, VP_tmp_mc);
		}
		else {
			com_mc_c_0n_uv32( gmv_x, gmv_y,  pred_u, pred_v, 32/*w*/, h, bit_depth, UP_tmp_mc, VP_tmp_mc, tbl_mc_c_coeff_all_dy);
		}
	}
	else {
		if (dy == 0) {
			com_mc_c_n0_uv32( gmv_x, gmv_y,  pred_u, pred_v, 32/*w*/, h, bit_depth, UP_tmp_mc, VP_tmp_mc, tbl_mc_c_coeff_all_dx);
		}
		else {
			com_mc_c_nn_uv32( gmv_x, gmv_y,  pred_u, pred_v, 32/*w*/, h, bit_depth, UP_tmp_mc, VP_tmp_mc, tbl_mc_c_coeff_all_dx, tbl_mc_c_coeff_all_dy);
		}
	}
}
BOOL com_mc_cu_uv_32(MD_COM_MODE_BEST* mod_info_curr, int pic_w, int pic_h, S3 refi[REFP_NUM], s16 mv[REFP_NUM][2], 
	pel pred_u[32][32], pel pred_v[32][32], pel pred0_u[32][32], pel pred0_v[32][32], int bit_depth, strFetch_ref_window* Fetch_Ref_window_ptr
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp, int skip_idx, int cu_mode
#endif
)
{
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->refp_pic_ptr complete dim=0
#pragma HLS ARRAY_PARTITION variable=Fetch_Ref_window_ptr->refp_is_library_picture complete dim=0
#pragma HLS ARRAY_PARTITION variable=refi complete dim=0
#pragma HLS ARRAY_PARTITION variable=mv complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred0_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred0_v complete dim=2
	int scup = mod_info_curr->scup;
	int x = mod_info_curr->x_pos;
	int y = mod_info_curr->y_pos;
	int w = mod_info_curr->cu_width;
	int h = mod_info_curr->cu_height;
	int	w1 = w >> 1;
	int	h1 = h >> 1;
	s16 mv_t[2];
	int min_clip[2];
	int max_clip[2];
#pragma HLS ARRAY_PARTITION variable=mv_t complete dim=0
#pragma HLS ARRAY_PARTITION variable=min_clip complete dim=0
#pragma HLS ARRAY_PARTITION variable=max_clip complete dim=0
	int x_ext = mod_info_curr->x_pos << 2;
	int y_ext = mod_info_curr->y_pos << 2;
	int w_ext = mod_info_curr->cu_width << 2;
	int h_ext = mod_info_curr->cu_height << 2;
	int x_ext_of_ctu;
	int y_ext_of_ctu;
	int qpel_gmv_x_of_ctu;
	int qpel_gmv_y_of_ctu;
	int qpel_gmv_x_of_refp_cu;
	int qpel_gmv_y_of_refp_cu;
	int dx;
	int dy;

	int bidx = 0;
	static pel pred_u0[32][32];
	static pel pred_v0[32][32];
	static pel pred_u1[32][32];
	static pel pred_v1[32][32];
#pragma HLS ARRAY_PARTITION variable=pred_u0 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v0 complete dim=2
#pragma HLS DEPENDENCE variable=pred_u0 inter false
#pragma HLS DEPENDENCE variable=pred_v0 inter false
#pragma HLS ARRAY_PARTITION variable=pred_u1 complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_v1 complete dim=2
#pragma HLS RESOURCE variable=pred_u0 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred_v0 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred_u1 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred_v1 core=RAM_S2P_BRAM
	U1 flag_u0 = 0;
	U1 flag_u1 = 0;

	min_clip[0] = (-(1 << 7) - 4) << 2;
	min_clip[1] = (-(1 << 7) - 4) << 2;
	max_clip[0] = (pic_w - 1 + (1 << 7) + 4) << 2;
	max_clip[1] = (pic_h - 1 + (1 << 7) + 4) << 2;
	mv_t[0] = mv[REFP_0][0];
	mv_t[1] = mv[REFP_0][1];
	if (refi[REFP_0] >= 0)
	{
		if (x_ext + mv[REFP_0][0] < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + mv[REFP_0][1] < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + mv[REFP_0][0] + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + mv[REFP_0][1] + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
		y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);
		qpel_gmv_x_of_ctu = x_ext_of_ctu + ((int)mv_t[0]);
		qpel_gmv_y_of_ctu = y_ext_of_ctu + ((int)mv_t[1]);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
		qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);
		//		assert((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < REFP_CU_SIZE && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < REFP_CU_SIZE);
		dx = qpel_gmv_x_of_refp_cu & 3;
		dy = qpel_gmv_y_of_refp_cu & 3;
		//assert((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + (dx ? 4 : 0) < SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + (dy ? 4 : 0) < SWH);
		if (!((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + mod_info_curr->cu_width + (dx ? 4 : 0) <= SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + mod_info_curr->cu_height + (dy ? 4 : 0) <= SWH)) { return FALSE; }

		w >= 8 && h >= 8 ? ((void)0) : __assert_HLS("w >= 8 && h >= 8", "../separate/com_mc.c", (unsigned int)3258,
			__FUNCTION__);
		//add by luke

		U2 UV_flag;
		get_ref_u_wsc32(Fetch_Ref_window_ptr, refi[REFP_0], REFP_0, &UV_flag);

#if SUB_TMVP
#pragma HLS ARRAY_PARTITION variable=core_sbtmvp->sbTmvp complete dim=0
		if (core_sbtmvp->sbTmvp_flag == 1 && cu_mode >= MODE_SKIP && skip_idx == 0 && mod_info_curr->cu_width >= SBTMVP_MIN_SIZE && mod_info_curr->cu_height >= SBTMVP_MIN_SIZE)
		{
			int cu_width = mod_info_curr->cu_width;
			int cu_height = mod_info_curr->cu_height;
			int sub_w = cu_width >> 2;
			int sub_h = cu_height >> 2;

			int h = 0;
			int w = 0;
			int tmp_x = x;
			int tmp_y = y;
			pel pred_tmp_u[32][32];
			pel pred_tmp_v[32][32];
#pragma HLS ARRAY_PARTITION variable=pred_tmp_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=pred_tmp_v complete dim=2
			for (int k = 0; k < SBTMVP_NUM; k++)
			{
				if (core_sbtmvp->sbTmvp[k].ref_idx[0] >= 0) {
					w = (k % 2) * sub_w;
					h = (k / 2) * sub_h;
					x = tmp_x + (w << 1);
					y = tmp_y + (h << 1);

					/*x_ext = cu->x_pos << 2;
					y_ext = cu->y_pos << 2;
					w_ext = cu->cu_width << 2;
					h_ext = cu->cu_height << 2;*/

					x_ext = x << 2;
					y_ext = y << 2;
					w_ext = sub_w << 2;
					h_ext = sub_h << 2;

					int mv_sbtmvp[2];
#pragma HLS ARRAY_PARTITION variable=mv_sbtmvp complete dim=0
					mv_sbtmvp[0] = core_sbtmvp->sbTmvp[k].mv[0][0];
					mv_sbtmvp[1] = core_sbtmvp->sbTmvp[k].mv[0][1];

					if (x_ext + ((int)mv_sbtmvp[0]) < min_clip[0]) {
						mv_sbtmvp[0] = ((min_clip[0] - x_ext));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) < min_clip[1]) {
						mv_sbtmvp[1] = ((min_clip[1] - y_ext));
					}
					if (x_ext + ((int)mv_sbtmvp[0]) + w_ext - 4 > max_clip[0]) {
						mv_sbtmvp[0] = ((max_clip[0] - x_ext - w_ext + 4));
					}
					if (y_ext + ((int)mv_sbtmvp[1]) + h_ext - 4 > max_clip[1]) {
						mv_sbtmvp[1] = ((max_clip[1] - y_ext - h_ext + 4));
					}

					x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
					y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);
					qpel_gmv_x_of_ctu = x_ext_of_ctu + (mv_sbtmvp[0]);
					qpel_gmv_y_of_ctu = y_ext_of_ctu + (mv_sbtmvp[1]);
					qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
					qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);

					dx = qpel_gmv_x_of_refp_cu & 3;
					dy = qpel_gmv_y_of_refp_cu & 3;
					//assert((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + (dx ? 4 : 0) < SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + (dy ? 4 : 0) < SWH);
					if (!((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + (mod_info_curr->cu_width >> 1) + (dx ? 4 : 0) <= SWW &&
						(qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + (mod_info_curr->cu_height >> 1) + (dy ? 4 : 0) <= SWH))
					{
						return FALSE;
					}


					com_tbl_mc_c_1_uv_wsc(mv_sbtmvp[0], mv_sbtmvp[1], qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu,pred_tmp_u,pred_tmp_v,
						mod_info_curr->cu_width >> 2, mod_info_curr->cu_height >> 2, bit_depth,Fetch_Ref_window_ptr, UV_flag);
					//copy pred_tmp to pred output
					pel pred_u0_tmp[32];
					pel pred_v0_tmp[32];
					pel pred_tmp_u_tmp[32];
					pel pred_tmp_v_tmp[32];
#pragma HLS ARRAY_PARTITION variable=pred_u0_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_v0_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_tmp_u_tmp complete dim=0
#pragma HLS ARRAY_PARTITION variable=pred_tmp_v_tmp complete dim=0
					//int offset = h * 64 + w;
					for (int i = 0; i < sub_h; i++)
					{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=16 max=16 avg=16
						for (int j = 0; j < 32; j++) {
							pred_u0_tmp[j] = pred_u0[h + i][j];
							pred_v0_tmp[j] = pred_v0[h + i][j];
						}
						for (int j = 0; j < 32; j++) {
							pred_tmp_u_tmp[j] = pred_tmp_u[i][j];
							pred_tmp_v_tmp[j] = pred_tmp_v[i][j];
						}
						for (int j = 0; j < 16; j++)
						{
							if (j < sub_w) {
								pred_u0_tmp[w + j] = pred_tmp_u_tmp[j];
								pred_v0_tmp[w + j] = pred_tmp_v_tmp[j];
						}
					}

						for (int j = 0; j < 32; j++)

						{
							pred_u0[h + i][j] = pred_u0_tmp[j];
							pred_v0[h + i][j] = pred_v0_tmp[j];
						}

					}
				}
				else {
#if MD_PRINT
					printf("%s:%d:sbtmvp refi is invalid\n", __FUNCTION__, 3267);
#endif
				}
			}



		}
		else {
#endif	

		com_tbl_mc_c_1_uv_wsc(mv[REFP_0][0], mv[REFP_0][1],  qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, pred_u0, pred_v0, 
			mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth,Fetch_Ref_window_ptr, UV_flag);

#if SUB_TMVP
		}
#endif
		++bidx;
		flag_u0 = 1;
	}
#if !ENABLE_BFRAME
	else {
#if MD_PRINT
		printf("%s:%d:refi is invalid\n", __FUNCTION__, 3267);
#endif
	}
#else
	/* check identical motion */
	if (REFI_IS_VALID(refi[REFP_0]) && REFI_IS_VALID(refi[REFP_1]))
	{
#if LIBVC_ON
		if (Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_pic_ptr[refi[REFP_1]][REFP_1] &&
			mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y] &&
			Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_0]][REFP_0] == Fetch_Ref_window_ptr->refp_is_library_picture[refi[REFP_1]][REFP_1])
#else
		if (refp[refi[REFP_0]][REFP_0].pic->ptr == refp[refi[REFP_1]][REFP_1].pic->ptr && mv[REFP_0][MV_X] == mv[REFP_1][MV_X] && mv[REFP_0][MV_Y] == mv[REFP_1][MV_Y])
#endif
		{
			if (flag_u0 == 1) {
				for (int j = 0; j < h1; j++)
				{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
					for (int i = 0; i < 32; i++)
					{
						//if (i < w1) {
						pred_u[j][i] = pred_u0[j][i];
						pred_v[j][i] = pred_v0[j][i];
						pred0_u[j][i] = pred_u0[j][i];
						pred0_v[j][i] = pred_v0[j][i];
						//}
					}
				}
			}
			return 1;
		}
	}

	mv_t[0] = mv[REFP_1][0];
	mv_t[1] = mv[REFP_1][1];
	//static pel pred_snd_u[32][32], pred_snd_v[32][32];
	if (REFI_IS_VALID(refi[REFP_1]))
	{
		/* backward */
		//pel(*pred_buf_u)[32] = bidx ? pred_snd_u : pred_u;
		//pel(*pred_buf_v)[32] = bidx ? pred_snd_v : pred_v;
		if (x_ext + mv[REFP_1][0] < min_clip[0])
		{
			mv_t[0] = ((s16)(min_clip[0] - x_ext));
		}
		if (y_ext + mv[REFP_1][1] < min_clip[1])
		{
			mv_t[1] = ((s16)(min_clip[1] - y_ext));
		}
		if (x_ext + mv[REFP_1][0] + w_ext - 4 > max_clip[0])
		{
			mv_t[0] = ((s16)(max_clip[0] - x_ext - w_ext + 4));
		}
		if (y_ext + mv[REFP_1][1] + h_ext - 4 > max_clip[1])
		{
			mv_t[1] = ((s16)(max_clip[1] - y_ext - h_ext + 4));
		}
		/* forward */
		x_ext_of_ctu = x_ext & ((1 << 7 >> 1 << 2) - 1);
		y_ext_of_ctu = y_ext & ((1 << 7 >> 1 << 2) - 1);
		qpel_gmv_x_of_ctu = x_ext_of_ctu + ((int)mv_t[0]);
		qpel_gmv_y_of_ctu = y_ext_of_ctu + ((int)mv_t[1]);
		qpel_gmv_x_of_refp_cu = qpel_gmv_x_of_ctu + (REFP_SURD_OFF_W << 2);
		qpel_gmv_y_of_refp_cu = qpel_gmv_y_of_ctu + (REFP_SURD_OFF_H << 2);
		//		assert((qpel_gmv_x_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + 4 < REFP_CU_SIZE && (qpel_gmv_y_of_refp_cu >> 2) - 3 >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + 4 < REFP_CU_SIZE);
		dx = qpel_gmv_x_of_refp_cu & 3;
		dy = qpel_gmv_y_of_refp_cu & 3;
		//assert((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + cu->cu_width + (dx ? 4 : 0) < SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + cu->cu_height + (dy ? 4 : 0) < SWH);
		if (!((qpel_gmv_x_of_refp_cu >> 2) - (dx ? 3 : 0) >= 0 && (qpel_gmv_x_of_refp_cu >> 2) + mod_info_curr->cu_width + (dx ? 4 : 0) < SWW && (qpel_gmv_y_of_refp_cu >> 2) - (dy ? 3 : 0) >= 0 && (qpel_gmv_y_of_refp_cu >> 2) + mod_info_curr->cu_height + (dy ? 4 : 0) < SWH)) { return FALSE; }

		w >= 8 && h >= 8 ? ((void)0) : __assert_HLS("w >= 8 && h >= 8", "../separate/com_mc.c", (unsigned int)3258,
			__FUNCTION__);

		U2 UV_flag;
		get_ref_u_wsc32(Fetch_Ref_window_ptr, refi[REFP_1], REFP_1, &UV_flag);
		com_tbl_mc_c_1_uv_wsc(mv[REFP_1][0], mv[REFP_1][1],  qpel_gmv_x_of_refp_cu, qpel_gmv_y_of_refp_cu, pred_u1,pred_v1, 
			mod_info_curr->cu_width >> 1, mod_info_curr->cu_height >> 1, bit_depth, Fetch_Ref_window_ptr, UV_flag);


		bidx++;
		flag_u1 = 1;
	}

	if ((flag_u0 == 1) && (flag_u1 == 1)) {
		for (int j = 0; j < h1; j++)
	{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (int i = 0; i < 32; i++)
			{
				//if (i < w1) {
				pred_u[j][i] = (pred_u0[j][i] + pred_u1[j][i] + 1) >> 1;
				pred_v[j][i] = (pred_v0[j][i] + pred_v1[j][i] + 1) >> 1;
				pred0_u[j][i] = (pred_u0[j][i] + pred_u1[j][i] + 1) >> 1;
				pred0_v[j][i] = (pred_v0[j][i] + pred_v1[j][i] + 1) >> 1;
				//}
			}
		}
	}
	else if ((flag_u0 == 1) && (flag_u1 == 0)) {
		for (int j = 0; j < h1; j++)
		{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (int i = 0; i < 32; i++)
			{
				//if (i < w1) {
				pred_u[j][i] = pred_u0[j][i];
				pred_v[j][i] = pred_v0[j][i];
				pred0_u[j][i] = pred_u0[j][i];
				pred0_v[j][i] = pred_v0[j][i];
				//}
			}
		}
	}
	else if ((flag_u0 == 0) && (flag_u1 == 1)) {
		for (int j = 0; j < h1; j++)
		{
#pragma HLS PIPELINE
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32
			for (int i = 0; i < 32; i++)
			{
				//if (i < w1) {
				pred_u[j][i] = pred_u1[j][i];
				pred_v[j][i] = pred_v1[j][i];
				pred0_u[j][i] = pred_u1[j][i];
				pred0_v[j][i] = pred_v1[j][i];
				//}
			}
		}
	}
#endif
	return 1;
}

#if USE_TSCPM
void const_up_64x32(pel* up, U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu,
	pel IP_buffer_ptr_64x32_up_line[2 * 64], int H, int W)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < W; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_64x32_up_line[i];
		}
		for (int i = 0; i < (W >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (W >> 2) + i < pic_width_in_scu : pic_x_scu + (W >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_64x32_map_scu_up_line[(W >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (W >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = IP_buffer_ptr_64x32_up_line[W + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = up[W + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_64x32(pel* left, U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu,
	pel IP_buffer_ptr_64x32_left_line[2 * 32], int H, int W)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < H; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_64x32_left_line[i];
		}
		for (int i = 0; i < (H >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (H >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_64x32_map_scu_left_line_new[(H >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (H >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = IP_buffer_ptr_64x32_left_line[H + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = left[H + (i << 2) + 2];
				}
			}
		}
	}
}
void const_top_left_64x32(pel* up, pel* left, int avail_cu, pel IP_buffer_ptr_64x32_top_left)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_64x32_top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}

void const_up_32x64(pel* up, U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu,
	pel IP_buffer_ptr_32x64_up_line[2 * 32], int H, int W)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < W; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_32x64_up_line[i];
		}
		for (int i = 0; i < (W >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (W >> 2) + i < pic_width_in_scu : pic_x_scu + (W >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_32x64_map_scu_up_line[(W >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (W >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = IP_buffer_ptr_32x64_up_line[W + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = up[W + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_32x64(pel* left, U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu,
	pel IP_buffer_ptr_32x64_left_line[2 * 64], int H, int W)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < H; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_32x64_left_line[i];
		}
		for (int i = 0; i < (H >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (H >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_32x64_map_scu_left_line_new[(H >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (H >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = IP_buffer_ptr_32x64_left_line[H + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = left[H + (i << 2) + 2];
				}
			}
		}
	}
}
void const_top_left_32x64(pel* up, pel* left, int avail_cu, pel IP_buffer_ptr_32x64_top_left)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_32x64_top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}

void const_up_64x16(pel* up, U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu,
	pel IP_buffer_ptr_64x16_up_line[2 * 64], int H, int W)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < W; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_64x16_up_line[i];
		}
		for (int i = 0; i < (W >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (W >> 2) + i < pic_width_in_scu : pic_x_scu + (W >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_64x16_map_scu_up_line[(W >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (W >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = IP_buffer_ptr_64x16_up_line[W + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = up[W + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_64x16(pel* left, U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu,
	pel IP_buffer_ptr_64x16_left_line[2 * 16], int H, int W)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < H; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_64x16_left_line[i];
		}
		for (int i = 0; i < (H >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (H >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_64x16_map_scu_left_line_new[(H >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (H >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = IP_buffer_ptr_64x16_left_line[H + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = left[H + (i << 2) + 2];
				}
			}
		}
	}
}
void const_top_left_64x16(pel* up, pel* left, int avail_cu, pel IP_buffer_ptr_64x16_top_left)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_64x16_top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}

void const_up_16x64(pel* up, U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu,
	pel IP_buffer_ptr_16x64_up_line[2 * 16], int H, int W)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < W; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_16x64_up_line[i];
		}
		for (int i = 0; i < (W >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (W >> 2) + i < pic_width_in_scu : pic_x_scu + (W >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_16x64_map_scu_up_line[(W >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (W >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = IP_buffer_ptr_16x64_up_line[W + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = up[W + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_16x64(pel* left, U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu,
	pel IP_buffer_ptr_16x64_left_line[2 * 64], int H, int W)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < H; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_16x64_left_line[i];
		}
		for (int i = 0; i < (H >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (H >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_16x64_map_scu_left_line_new[(H >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (H >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = IP_buffer_ptr_16x64_left_line[H + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = left[H + (i << 2) + 2];
				}
			}
		}
	}
}
void const_top_left_16x64(pel* up, pel* left, int avail_cu, pel IP_buffer_ptr_16x64_top_left)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_16x64_top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}

void const_up_64x8(pel* up, U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu,
	pel IP_buffer_ptr_64x8_up_line[2 * 64], int H, int W)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < W; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_64x8_up_line[i];
		}
		for (int i = 0; i < (W >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (W >> 2) + i < pic_width_in_scu : pic_x_scu + (W >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_64x8_map_scu_up_line[(W >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (W >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = IP_buffer_ptr_64x8_up_line[W + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = up[W + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_64x8(pel* left, U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu,
	pel IP_buffer_ptr_64x8_left_line[2 * 8], int H, int W)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < H; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_64x8_left_line[i];
		}
		for (int i = 0; i < (H >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (H >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_64x8_map_scu_left_line_new[(H >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (H >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = IP_buffer_ptr_64x8_left_line[H + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = left[H + (i << 2) + 2];
				}
			}
		}
	}
}
void const_top_left_64x8(pel* up, pel* left, int avail_cu, pel IP_buffer_ptr_64x8_top_left)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_64x8_top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}

void const_up_8x64(pel* up, U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_y, int x_scu, int pic_width_in_scu,
	pel IP_buffer_ptr_8x64_up_line[2 * 8], int H, int W)
{
	if ((((int)avail_cu) & 1 << 0) == 1 << 0)
	{
		int flag;
		for (int i = 0; i < W; ++i)
		{
#pragma HLS UNROLL
			up[i + 3] = IP_buffer_ptr_8x64_up_line[i];
		}
		for (int i = 0; i < (W >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + (W >> 2) + i < pic_width_in_scu : pic_x_scu + (W >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_8x64_map_scu_up_line[(W >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (x_scu + (W >> 2) + i < pic_width_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = IP_buffer_ptr_8x64_up_line[W + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					up[W + (i << 2) + j + 3] = up[W + (i << 2) + 2];
				}
			}
		}
	}
}
void const_left_8x64(pel* left, U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1], int avail_cu, int pic_y_scu, int pic_x_scu, int pic_x, int y_scu, int pic_height_in_scu,
	pel IP_buffer_ptr_8x64_left_line[2 * 64], int H, int W)
{
	if ((avail_cu & 1 << 1) == 1 << 1)
	{
		int flag;
		for (int i = 0; i < H; ++i)
		{
#pragma HLS UNROLL
			left[i + 3] = IP_buffer_ptr_8x64_left_line[i];
		}
		for (int i = 0; i < (H >> 2); i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + (H >> 2) + i < 16)
			{
				flag = IP_map_scu_ptr_8x64_map_scu_left_line_new[(H >> 2) + i] >> 31 & 1;
			}
			else
			{
				flag = 0;
			}
			if (y_scu + (H >> 2) + i < pic_height_in_scu && flag)
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = IP_buffer_ptr_8x64_left_line[H + (i << 2) + j];
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
#pragma HLS UNROLL
					left[H + (i << 2) + j + 3] = left[H + (i << 2) + 2];
				}
			}
		}
	}
}
void const_top_left_8x64(pel* up, pel* left, int avail_cu, pel IP_buffer_ptr_8x64_top_left)
{
	if ((avail_cu & 1 << 2) == 1 << 2)
	{
		up[2] = left[2] = IP_buffer_ptr_8x64_top_left;
	}
	else if ((avail_cu & 1 << 0) == 1 << 0)
	{
		up[2] = left[2] = up[3];
	}
	else if ((avail_cu & 1 << 1) == 1 << 1)
	{
		up[2] = left[2] = left[3];
	}
}
//void get_IP_pixel_64_for_chroma(U7 w, U7 h, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
//	U4 bit_depth, U2 ch_type, pel left[2 * 64 + 3], pel up[2 * 64 + 3], U14 x, U14 y, 
//	IP_ARRAY_SIZE<64, 64>* IP_buffer_ptr_64x64,
//	IP_ARRAY_SIZE<32, 64>* IP_buffer_ptr_32x64, IP_ARRAY_SIZE<64, 32>* IP_buffer_ptr_64x32,
//	IP_ARRAY_SIZE<16, 64>* IP_buffer_ptr_16x64, IP_ARRAY_SIZE<64, 16>* IP_buffer_ptr_64x16,
//	IP_ARRAY_SIZE<8, 64>* IP_buffer_ptr_8x64, IP_ARRAY_SIZE<64, 8>* IP_buffer_ptr_64x8,
//
//	IP_MAP_SCU_SIZE<32, 64>* IP_map_scu_ptr_32x64, IP_MAP_SCU_SIZE<64, 32>* IP_map_scu_ptr_64x32,
//	IP_MAP_SCU_SIZE<16, 64>* IP_map_scu_ptr_16x64, IP_MAP_SCU_SIZE<64, 16>* IP_map_scu_ptr_64x16,
//	IP_MAP_SCU_SIZE<8, 64>* IP_map_scu_ptr_8x64, IP_MAP_SCU_SIZE<64, 8>* IP_map_scu_ptr_64x8)
void get_IP_pixel_64_for_chroma(U7 w, U7 h, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, U2 ch_type, pel left[2 * 64 + 3], pel up[2 * 64 + 3], U14 x, U14 y,
	pel IP_buffer_ptr_64x64_up_line[128], pel IP_buffer_ptr_64x64_left_line[64], pel IP_buffer_ptr_64x64_top_left,
	pel IP_buffer_ptr_32x64_up_line[2 * 32], pel IP_buffer_ptr_32x64_left_line[2 * 64], pel IP_buffer_ptr_32x64_top_left,
	pel IP_buffer_ptr_64x32_up_line[2 * 64], pel IP_buffer_ptr_64x32_left_line[2 * 32], pel IP_buffer_ptr_64x32_top_left,
	pel IP_buffer_ptr_16x64_up_line[2 * 16], pel IP_buffer_ptr_16x64_left_line[2 * 64], pel IP_buffer_ptr_16x64_top_left,
	pel IP_buffer_ptr_64x16_up_line[2 * 64], pel IP_buffer_ptr_64x16_left_line[2 * 16], pel IP_buffer_ptr_64x16_top_left,
	pel IP_buffer_ptr_8x64_up_line[2 * 8], pel IP_buffer_ptr_8x64_left_line[2 * 64], pel IP_buffer_ptr_8x64_top_left,
	pel IP_buffer_ptr_64x8_up_line[2 * 64], pel IP_buffer_ptr_64x8_left_line[2 * 8], pel IP_buffer_ptr_64x8_top_left,
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1])
{
#pragma HLS INLINE OFF
	int i;
	int j;
	int width_in_scu = ch_type == 0 ? w >> 2 : w >> (2 - 1);
	int height_in_scu = ch_type == 0 ? h >> 2 : h >> (2 - 1);
	//4
	U4 unit_size = ch_type == 0 ? 1 << 2 : 1 << 2 >> 1;
	U2 unit_size_bit = ch_type == 0 ? 2 : 1;
	//x/4
	int x_scu = ((ch_type == 0 ? x : x << 1)) >> 2;
	//y/4
	int y_scu = ((ch_type == 0 ? y : y << 1)) >> 2;
	//number of padding pixel in the left column   64
	int pad_le = h;
	//number of padding pixel in the upper row     64
	int pad_up = w;
	//16
	int pad_le_in_scu = height_in_scu;
	//16
	int pad_up_in_scu = width_in_scu;
	int pic_x = x % 64;
	int pic_y = y % 64;
	int pic_x_scu = pic_x >> 2;
	int pic_y_scu = pic_y >> 2;
	int flag;

	S7 ip_array_size_idx = get_ip_array_size_idx(w, h);
#if MD_PRINT
	assert(ip_array_size_idx != -1);
#endif

#pragma HLS ARRAY_PARTITION variable=left complete dim=0
#pragma HLS ARRAY_PARTITION variable=up complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x64_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x64_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_32x64_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_32x64_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x32_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_16x64_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_16x64_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x16_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_8x64_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_8x64_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x8_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_64x8_left_line complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x64_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x64_map_scu_left_line_new complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x32_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x32_map_scu_left_line_new complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x64_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x64_map_scu_left_line_new complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x16_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x16_map_scu_left_line_new complete dim=0


//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_8x64_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_8x64_map_scu_left_line_new complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x8_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x8_map_scu_left_line_new complete dim=0

	if (w == 64 && h == 64)
	{
		if ((avail_cu & 1 << 0) == 1 << 0)
		{
			int w_temp = (pic_width_in_scu << 2) - x;

			for (i = 0; i < 128; i++)
			{
#pragma HLS UNROLL
				if (i < w_temp) {
				up[i + 3] = IP_buffer_ptr_64x64_up_line[i];
			}
				else {
				up[i + 3] = up[w_temp + 2];
				}
			}
		}
		if ((avail_cu & 1 << 1) == 1 << 1)
		{
			for (i = 0; i < 64; i++)
			{
#pragma HLS UNROLL
				left[i + 3] = IP_buffer_ptr_64x64_left_line[i];
			}
			for (int i = 64; i < 128; ++i)
			{
#pragma HLS UNROLL
				left[i + 3] = left[66];
			}
		}
		if ((avail_cu & 1 << 2) == 1 << 2)
		{
			up[2] = left[2] = IP_buffer_ptr_64x64_top_left;
		}
		else if ((avail_cu & 1 << 0) == 1 << 0)
		{
			up[2] = left[2] = up[3];
		}
		else if ((avail_cu & 1 << 1) == 1 << 1)
		{
			up[2] = left[2] = left[3];
		}
	}
	
	else if (w == 64 && h == 32)
	{
		/*IP_buffer_ptr_64x32->const_up(up, IP_map_scu_ptr_64x32, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_64x32->const_left(left, IP_map_scu_ptr_64x32, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_64x32->const_top_left(up, left, avail_cu);*/
		const_up_64x32(up, IP_map_scu_ptr_64x32_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu, IP_buffer_ptr_64x32_up_line, h, w);
		const_left_64x32(left, IP_map_scu_ptr_64x32_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu, IP_buffer_ptr_64x32_left_line, h, w);
		const_top_left_64x32(up, left, avail_cu, IP_buffer_ptr_64x32_top_left);
	}
	else if (w == 32 && h == 64)
	{
		/*IP_buffer_ptr_32x64->const_up(up, IP_map_scu_ptr_32x64, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_32x64->const_left(left, IP_map_scu_ptr_32x64, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_32x64->const_top_left(up, left, avail_cu);*/
		const_up_32x64(up, IP_map_scu_ptr_32x64_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu, IP_buffer_ptr_32x64_up_line, h, w);
		const_left_32x64(left, IP_map_scu_ptr_32x64_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu, IP_buffer_ptr_32x64_left_line, h, w);
		const_top_left_32x64(up, left, avail_cu, IP_buffer_ptr_32x64_top_left);
	}
	else if (w == 64 && h == 16)
	{
		/*IP_buffer_ptr_64x16->const_up(up, IP_map_scu_ptr_64x16, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_64x16->const_left(left, IP_map_scu_ptr_64x16, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_64x16->const_top_left(up, left, avail_cu);*/
		const_up_64x16(up, IP_map_scu_ptr_64x16_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu, IP_buffer_ptr_64x16_up_line, h, w);
		const_left_64x16(left, IP_map_scu_ptr_64x16_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu, IP_buffer_ptr_64x16_left_line, h, w);
		const_top_left_64x16(up, left, avail_cu, IP_buffer_ptr_64x16_top_left);
	}
	else if (w == 16 && h == 64)
	{
		/*IP_buffer_ptr_16x64->const_up(up, IP_map_scu_ptr_16x64, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_16x64->const_left(left, IP_map_scu_ptr_16x64, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_16x64->const_top_left(up, left, avail_cu);*/
		const_up_16x64(up, IP_map_scu_ptr_16x64_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu, IP_buffer_ptr_16x64_up_line, h, w);
		const_left_16x64(left, IP_map_scu_ptr_16x64_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu, IP_buffer_ptr_16x64_left_line, h, w);
		const_top_left_16x64(up, left, avail_cu, IP_buffer_ptr_16x64_top_left);
	}
	else if (w == 64 && h == 8)
	{
		/*IP_buffer_ptr_64x8->const_up(up, IP_map_scu_ptr_64x8, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_64x8->const_left(left, IP_map_scu_ptr_64x8, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_64x8->const_top_left(up, left, avail_cu);*/
		const_up_64x8(up, IP_map_scu_ptr_64x8_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu, IP_buffer_ptr_64x8_up_line, h, w);
		const_left_64x8(left, IP_map_scu_ptr_64x8_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu, IP_buffer_ptr_64x8_left_line, h, w);
		const_top_left_64x8(up, left, avail_cu, IP_buffer_ptr_64x8_top_left);
	}
	else if (w == 8 && h == 64)
	{
		/*IP_buffer_ptr_8x64->const_up(up, IP_map_scu_ptr_8x64, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu);
		IP_buffer_ptr_8x64->const_left(left, IP_map_scu_ptr_8x64, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu);
		IP_buffer_ptr_8x64->const_top_left(up, left, avail_cu);*/
		const_up_8x64(up, IP_map_scu_ptr_8x64_map_scu_up_line, avail_cu, pic_y_scu, pic_x_scu, pic_y, x_scu, pic_width_in_scu, IP_buffer_ptr_8x64_up_line, h, w);
		const_left_8x64(left, IP_map_scu_ptr_8x64_map_scu_left_line_new, avail_cu, pic_y_scu, pic_x_scu, pic_x, y_scu, pic_height_in_scu, IP_buffer_ptr_8x64_left_line, h, w);
		const_top_left_8x64(up, left, avail_cu, IP_buffer_ptr_8x64_top_left);
	}


	up[1] = left[3];
	left[1] = up[3];
	up[0] = left[4];
	left[0] = up[4];
}

#endif // USE_TSCPM

static __inline void com_mset_8b(pel* dst, pel v, int cnt)
{
#pragma HLS INLINE off
	int i;
	for (i = 0; i < cnt; i++)
	{
#pragma HLS LOOP_TRIPCOUNT max=67 
		dst[i] = v;
	}
}

template<size_t w_chroma, size_t h_chroma>
void get_IP_pixel_chroma(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	IP_ARRAY_SIZE<w_chroma, h_chroma>* IP_buffer_ptr_U,
	IP_ARRAY_SIZE<w_chroma, h_chroma>* IP_buffer_ptr_V,
	IP_MAP_SCU_SIZE<w_chroma * 2, h_chroma * 2>* IP_map_scu_ptr)
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U->up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V->up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr->map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U->up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V->up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U->left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V->left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr->map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U->left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V->left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}


	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U->top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V->top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	//				assert(MCU_GET_CODED_FLAG(map_scu[scup - pic_width_in_scu + width_in_scu + i]) == 1);
	left_v[0] = up_v[4];

}

void get_IP_pixel_chroma_32x32(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	pel IP_buffer_ptr_U_32x32_up_line[2 * 32], pel IP_buffer_ptr_U_32x32_left_line[2 * 32], pel IP_buffer_ptr_U_32x32_top_left,
	pel IP_buffer_ptr_V_32x32_up_line[2 * 32], pel IP_buffer_ptr_V_32x32_left_line[2 * 32], pel IP_buffer_ptr_V_32x32_top_left,
	U32 IP_map_scu_ptr_64x64_map_scu_up_line[(64 >> 2) << 1], U32 IP_map_scu_ptr_64x64_map_scu_left_line_new[(64 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_32x32_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_32x32_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr_64x64_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x32_up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x32_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U_32x32_left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V_32x32_left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr_64x64_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x32_left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x32_left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_32x32_top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_32x32_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

void get_IP_pixel_chroma_16x32(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	pel IP_buffer_ptr_U_16x32_up_line[2 * 16], pel IP_buffer_ptr_U_16x32_left_line[2 * 32], pel IP_buffer_ptr_U_16x32_top_left,
	pel IP_buffer_ptr_V_16x32_up_line[2 * 16], pel IP_buffer_ptr_V_16x32_left_line[2 * 32], pel IP_buffer_ptr_V_16x32_top_left,
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1], U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_16x32_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_16x32_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr_32x64_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x32_up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x32_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U_16x32_left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V_16x32_left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr_32x64_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_16x32_left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_16x32_left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_16x32_top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_16x32_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

void get_IP_pixel_chroma_32x16(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	pel IP_buffer_ptr_U_32x16_up_line[2 * 32], pel IP_buffer_ptr_U_32x16_left_line[2 * 16], pel IP_buffer_ptr_U_32x16_top_left,
	pel IP_buffer_ptr_V_32x16_up_line[2 * 32], pel IP_buffer_ptr_V_32x16_left_line[2 * 16], pel IP_buffer_ptr_V_32x16_top_left,
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1], U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_32x16_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_32x16_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr_64x32_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x16_up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x16_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U_32x16_left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V_32x16_left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr_64x32_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x16_left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x16_left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_32x16_top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_32x16_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

void get_IP_pixel_chroma_8x32(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	pel IP_buffer_ptr_U_8x32_up_line[2 * 8], pel IP_buffer_ptr_U_8x32_left_line[2 * 32], pel IP_buffer_ptr_U_8x32_top_left,
	pel IP_buffer_ptr_V_8x32_up_line[2 * 8], pel IP_buffer_ptr_V_8x32_left_line[2 * 32], pel IP_buffer_ptr_V_8x32_top_left,
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1], U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_8x32_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_8x32_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr_16x64_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_8x32_up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_8x32_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U_8x32_left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V_8x32_left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr_16x64_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_8x32_left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_8x32_left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_8x32_top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_8x32_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

void get_IP_pixel_chroma_32x8(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	pel IP_buffer_ptr_U_32x8_up_line[2 * 32], pel IP_buffer_ptr_U_32x8_left_line[2 * 8], pel IP_buffer_ptr_U_32x8_top_left,
	pel IP_buffer_ptr_V_32x8_up_line[2 * 32], pel IP_buffer_ptr_V_32x8_left_line[2 * 8], pel IP_buffer_ptr_V_32x8_top_left,
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1], U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_32x8_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_32x8_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr_64x16_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x8_up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x8_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U_32x8_left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V_32x8_left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr_64x16_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x8_left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x8_left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_32x8_top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_32x8_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

void get_IP_pixel_chroma_4x32(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	pel IP_buffer_ptr_U_4x32_up_line[2 * 4], pel IP_buffer_ptr_U_4x32_left_line[2 * 32], pel IP_buffer_ptr_U_4x32_top_left,
	pel IP_buffer_ptr_V_4x32_up_line[2 * 4], pel IP_buffer_ptr_V_4x32_left_line[2 * 32], pel IP_buffer_ptr_V_4x32_top_left,
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1], U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_4x32_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_4x32_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr_8x64_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_4x32_up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_4x32_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U_4x32_left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V_4x32_left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr_8x64_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_4x32_left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_4x32_left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_4x32_top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_4x32_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

void get_IP_pixel_chroma_32x4(U7 width, U7 height, u16 avail_cu, U11 pic_width_in_scu, U11 pic_height_in_scu,
	U4 bit_depth, pel left_u[67], pel up_u[67], pel left_v[67], pel up_v[67], U12 x, U12 y,
	pel IP_buffer_ptr_U_32x4_up_line[2 * 32], pel IP_buffer_ptr_U_32x4_left_line[2 * 4], pel IP_buffer_ptr_U_32x4_top_left,
	pel IP_buffer_ptr_V_32x4_up_line[2 * 32], pel IP_buffer_ptr_V_32x4_left_line[2 * 4], pel IP_buffer_ptr_V_32x4_top_left,
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1], U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1])
{
	int i;
	int j;
	U6 width_in_scu = width >> (2 - 1);
	U6 height_in_scu = height >> (2 - 1);
	//4
	U3 unit_size = 1 << 2 >> 1;
	U2 unit_size_bit = 1;
	//x/4
	U11 x_scu = ((x << 1)) >> 2;
	//y/4
	U11 y_scu = ((y << 1)) >> 2;
	//number of padding pixel in the left column   32
	U7 pad_le = height;
	//number of padding pixel in the upper row     32
	U7 pad_up = width;
	//16
	U6 pad_le_in_scu = height_in_scu;
	//16
	U6 pad_up_in_scu = width_in_scu;
	U6 pic_x = x % 32;
	U6 pic_y = y % 32;
	//com_mset_8b(left_u, (1 << (bit_depth - 1)), height + pad_le + 3);
	//com_mset_8b(up_v, (1 << (bit_depth - 1)), width + pad_up + 3);
	for (i = 0; i < 67; i++)
	{
#pragma HLS UNROLL
		up_u[i] = (1 << (bit_depth - 1));
		left_u[i] = (1 << (bit_depth - 1));
		up_v[i] = (1 << (bit_depth - 1));
		left_v[i] = (1 << (bit_depth - 1));
	}
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	U1 flag = 0;
	if (((avail_cu) & 1 << 0) == 1 << 0) {
		for (i = 0; i < width; i++)
		{
#pragma HLS UNROLL
			up_u[i + 3] = (IP_buffer_ptr_U_32x4_up_line[i]);
			up_v[i + 3] = (IP_buffer_ptr_V_32x4_up_line[i]);
		}
		for (i = 0; i < pad_up_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y == 0 ? x_scu + width_in_scu + i < pic_width_in_scu : pic_x_scu + width_in_scu + i < 16)
			{
				flag = pic_y == 0 ? 1 : ((int)(IP_map_scu_ptr_64x8_map_scu_up_line[width_in_scu + i] >> 31 & (1)));
			}
			else {
				flag = 0;
			}

			if (x_scu + width_in_scu + i < pic_width_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x4_up_line[width + (i << unit_size_bit) + j]);
					up_v[width + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x4_up_line[width + (i << unit_size_bit) + j]);
				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					up_u[width + (i << unit_size_bit) + j + 3] = up_u[width + (i << unit_size_bit) + 2];
					up_v[width + (i << unit_size_bit) + j + 3] = up_v[width + (i << unit_size_bit) + 2];
				}
			}
		}
	}
	if (((avail_cu) & 1 << 1) == 1 << 1) {

		for (i = 0; i < height; i++)
		{
#pragma HLS UNROLL
			left_u[i + 3] = (IP_buffer_ptr_U_32x4_left_line[i]);
			left_v[i + 3] = (IP_buffer_ptr_V_32x4_left_line[i]);
		}
		for (i = 0; i < pad_le_in_scu; i++)
		{
#pragma HLS UNROLL
			if (pic_y_scu + height_in_scu + i < 16)
			{
				flag = ((int)(IP_map_scu_ptr_64x8_map_scu_left_line_new[height_in_scu + i] >> 31 & (1)));
			}
			else
			{
				flag = 0;
			}
			if (y_scu + height_in_scu + i < pic_height_in_scu && flag)
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_U_32x4_left_line[height + (i << unit_size_bit) + j]);
					left_v[height + (i << unit_size_bit) + j + 3] = (IP_buffer_ptr_V_32x4_left_line[height + (i << unit_size_bit) + j]);

				}
			}
			else
			{
				for (j = 0; j < unit_size; j++)
				{
#pragma HLS UNROLL
					left_u[height + (i << unit_size_bit) + j + 3] = left_u[height + (i << unit_size_bit) + 2];
					left_v[height + (i << unit_size_bit) + j + 3] = left_v[height + (i << unit_size_bit) + 2];

				}
			}

		}
	}
	if (((avail_cu) & 1 << 2) == 1 << 2) {
		up_u[2] = left_u[2] = (IP_buffer_ptr_U_32x4_top_left);
		up_v[2] = left_v[2] = (IP_buffer_ptr_V_32x4_top_left);
	}
	else if ((((int)avail_cu) & 1 << 0) == 1 << 0) {
		up_u[2] = left_u[2] = up_u[3];
		up_v[2] = left_v[2] = up_v[3];
	}
	else if ((((int)avail_cu) & 1 << 1) == 1 << 1) {
		up_u[2] = left_u[2] = left_u[3];
		up_v[2] = left_v[2] = left_v[3];
	}

	up_u[1] = left_u[3];
	left_u[1] = up_u[3];
	up_u[0] = left_u[4];
	left_u[0] = up_u[4];

	up_v[1] = left_v[3];
	left_v[1] = up_v[3];
	up_v[0] = left_v[4];
	left_v[0] = up_v[4];
}

/*void get_IP_pixel_chroma_package_32(MD_FW* md_fw_ptr, U3 cu_width_log2, U3 cu_height_log2, U13 pb_x, U13 pb_y,
	pel nb_u[2][2 * 32 + 3], pel nb_v[2][2 * 32 + 3], 
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_U_32x32, IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_V_32x32,
	IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_U_16x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_V_16x32,
	IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_U_32x16, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_V_32x16,
	IP_ARRAY_SIZE<8, 32>*  IP_buffer_ptr_U_8x32, IP_ARRAY_SIZE<8, 32>* IP_buffer_ptr_V_8x32,
	IP_ARRAY_SIZE<32, 8>*  IP_buffer_ptr_U_32x8, IP_ARRAY_SIZE<32, 8>* IP_buffer_ptr_V_32x8,
	IP_ARRAY_SIZE<4, 32>*  IP_buffer_ptr_U_4x32, IP_ARRAY_SIZE<4, 32>* IP_buffer_ptr_V_4x32,
	IP_ARRAY_SIZE<32, 4>*  IP_buffer_ptr_U_32x4, IP_ARRAY_SIZE<32, 4>* IP_buffer_ptr_V_32x4,

	IP_MAP_SCU_SIZE<64, 64>* IP_map_scu_ptr_64x64,
	IP_MAP_SCU_SIZE<32, 64>* IP_map_scu_ptr_32x64, IP_MAP_SCU_SIZE<64, 32>* IP_map_scu_ptr_64x32,
	IP_MAP_SCU_SIZE<16, 64>* IP_map_scu_ptr_16x64, IP_MAP_SCU_SIZE<64, 16>* IP_map_scu_ptr_64x16,
	IP_MAP_SCU_SIZE<8, 64>* IP_map_scu_ptr_8x64, IP_MAP_SCU_SIZE<64, 8>* IP_map_scu_ptr_64x8, 
	u16 avail_cu)*/
void get_IP_pixel_chroma_package_32(MD_FW* md_fw_ptr, U3 cu_width_log2, U3 cu_height_log2, U13 pb_x, U13 pb_y,
	pel nb_u[2][2 * 32 + 3], pel nb_v[2][2 * 32 + 3],
	pel IP_buffer_ptr_U_32x32_up_line[2 * 32], pel IP_buffer_ptr_U_32x32_left_line[2 * 32], pel IP_buffer_ptr_U_32x32_top_left,
	pel IP_buffer_ptr_V_32x32_up_line[2 * 32], pel IP_buffer_ptr_V_32x32_left_line[2 * 32], pel IP_buffer_ptr_V_32x32_top_left,
	pel IP_buffer_ptr_U_16x32_up_line[2 * 16], pel IP_buffer_ptr_U_16x32_left_line[2 * 32], pel IP_buffer_ptr_U_16x32_top_left,
	pel IP_buffer_ptr_V_16x32_up_line[2 * 16], pel IP_buffer_ptr_V_16x32_left_line[2 * 32], pel IP_buffer_ptr_V_16x32_top_left,
	pel IP_buffer_ptr_U_32x16_up_line[2 * 32], pel IP_buffer_ptr_U_32x16_left_line[2 * 16], pel IP_buffer_ptr_U_32x16_top_left,
	pel IP_buffer_ptr_V_32x16_up_line[2 * 32], pel IP_buffer_ptr_V_32x16_left_line[2 * 16], pel IP_buffer_ptr_V_32x16_top_left,
	pel IP_buffer_ptr_U_8x32_up_line[2 * 8], pel IP_buffer_ptr_U_8x32_left_line[2 * 32], pel IP_buffer_ptr_U_8x32_top_left,
	pel IP_buffer_ptr_V_8x32_up_line[2 * 8], pel IP_buffer_ptr_V_8x32_left_line[2 * 32], pel IP_buffer_ptr_V_8x32_top_left,
	pel IP_buffer_ptr_U_32x8_up_line[2 * 32], pel IP_buffer_ptr_U_32x8_left_line[2 * 8], pel IP_buffer_ptr_U_32x8_top_left,
	pel IP_buffer_ptr_V_32x8_up_line[2 * 32], pel IP_buffer_ptr_V_32x8_left_line[2 * 8], pel IP_buffer_ptr_V_32x8_top_left,
	pel IP_buffer_ptr_U_4x32_up_line[2 * 4], pel IP_buffer_ptr_U_4x32_left_line[2 * 32], pel IP_buffer_ptr_U_4x32_top_left,
	pel IP_buffer_ptr_V_4x32_up_line[2 * 4], pel IP_buffer_ptr_V_4x32_left_line[2 * 32], pel IP_buffer_ptr_V_4x32_top_left,
	pel IP_buffer_ptr_U_32x4_up_line[2 * 32], pel IP_buffer_ptr_U_32x4_left_line[2 * 4], pel IP_buffer_ptr_U_32x4_top_left,
	pel IP_buffer_ptr_V_32x4_up_line[2 * 32], pel IP_buffer_ptr_V_32x4_left_line[2 * 4], pel IP_buffer_ptr_V_32x4_top_left,
	U32 IP_map_scu_ptr_64x64_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1],
	u16 avail_cu)
{
#pragma HLS INLINE 
#pragma HLS ARRAY_PARTITION variable=nb_u complete dim=0
#pragma HLS ARRAY_PARTITION variable=nb_v complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x64_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x64_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x32_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x32_left_line complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x64_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_32x64_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_16x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_16x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_16x32_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_16x32_left_line complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x32_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x32_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x16_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x16_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x16_left_line complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x64_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_16x64_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_8x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_8x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_8x32_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_8x32_left_line complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x16_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x16_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x8_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x8_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x8_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x8_left_line complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_8x64_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_8x64_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_4x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_4x32_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_4x32_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_4x32_left_line complete dim=0

//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x8_map_scu_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_map_scu_ptr_64x8_map_scu_left_line_new complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x4_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x4_up_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_U_32x4_left_line complete dim=0
//#pragma HLS ARRAY_PARTITION variable=IP_buffer_ptr_V_32x4_left_line complete dim=0


	if (cu_width_log2 == 5 && cu_height_log2 == 5)
	{
		/*get_IP_pixel_chroma<32, 32>(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x32,
			IP_buffer_ptr_V_32x32,
			IP_map_scu_ptr_64x64);*/
		get_IP_pixel_chroma_32x32(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x32_up_line, IP_buffer_ptr_U_32x32_left_line, IP_buffer_ptr_U_32x32_top_left,
			IP_buffer_ptr_V_32x32_up_line, IP_buffer_ptr_V_32x32_left_line, IP_buffer_ptr_V_32x32_top_left,
			IP_map_scu_ptr_64x64_map_scu_up_line, IP_map_scu_ptr_64x64_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 4 && cu_height_log2 == 5)
	{
		/*get_IP_pixel_chroma<16, 32>(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_16x32,
			IP_buffer_ptr_V_16x32,
			IP_map_scu_ptr_32x64);*/
		get_IP_pixel_chroma_16x32(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_16x32_up_line, IP_buffer_ptr_U_16x32_left_line, IP_buffer_ptr_U_16x32_top_left,
			IP_buffer_ptr_V_16x32_up_line, IP_buffer_ptr_V_16x32_left_line, IP_buffer_ptr_V_16x32_top_left,
			IP_map_scu_ptr_32x64_map_scu_up_line, IP_map_scu_ptr_32x64_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 5 && cu_height_log2 == 4)
	{
		/*get_IP_pixel_chroma<32, 16>(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x16,
			IP_buffer_ptr_V_32x16,
			IP_map_scu_ptr_64x32);*/
		get_IP_pixel_chroma_32x16(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x16_up_line, IP_buffer_ptr_U_32x16_left_line, IP_buffer_ptr_U_32x16_top_left,
			IP_buffer_ptr_V_32x16_up_line, IP_buffer_ptr_V_32x16_left_line, IP_buffer_ptr_V_32x16_top_left,
			IP_map_scu_ptr_64x32_map_scu_up_line, IP_map_scu_ptr_64x32_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 3 && cu_height_log2 == 5)
	{
		/*get_IP_pixel_chroma<8, 32>(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_8x32,
			IP_buffer_ptr_V_8x32,
			IP_map_scu_ptr_16x64);*/
		get_IP_pixel_chroma_8x32(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_8x32_up_line, IP_buffer_ptr_U_8x32_left_line, IP_buffer_ptr_U_8x32_top_left,
			IP_buffer_ptr_V_8x32_up_line, IP_buffer_ptr_V_8x32_left_line, IP_buffer_ptr_V_8x32_top_left,
			IP_map_scu_ptr_16x64_map_scu_up_line, IP_map_scu_ptr_16x64_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 5 && cu_height_log2 == 3)
	{
		/*get_IP_pixel_chroma<32, 8>(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x8,
			IP_buffer_ptr_V_32x8,
			IP_map_scu_ptr_64x16);*/
		get_IP_pixel_chroma_32x8(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x8_up_line, IP_buffer_ptr_U_32x8_left_line, IP_buffer_ptr_U_32x8_top_left,
			IP_buffer_ptr_V_32x8_up_line, IP_buffer_ptr_V_32x8_left_line, IP_buffer_ptr_V_32x8_top_left,
			IP_map_scu_ptr_64x16_map_scu_up_line, IP_map_scu_ptr_64x16_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 2 && cu_height_log2 == 5)
	{
		/*get_IP_pixel_chroma<4, 32>(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_4x32,
			IP_buffer_ptr_V_4x32,
			IP_map_scu_ptr_8x64);*/
		get_IP_pixel_chroma_4x32(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_4x32_up_line, IP_buffer_ptr_U_4x32_left_line, IP_buffer_ptr_U_4x32_top_left,
			IP_buffer_ptr_V_4x32_up_line, IP_buffer_ptr_V_4x32_left_line, IP_buffer_ptr_V_4x32_top_left,
			IP_map_scu_ptr_8x64_map_scu_up_line, IP_map_scu_ptr_8x64_map_scu_left_line_new);
	}
	else if (cu_width_log2 == 5 && cu_height_log2 == 2)
	{
		/*get_IP_pixel_chroma<32, 4>(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x4,
			IP_buffer_ptr_V_32x4,
			IP_map_scu_ptr_64x8);*/
		get_IP_pixel_chroma_32x4(1 << cu_width_log2, 1 << cu_height_log2,
			avail_cu,
			md_fw_ptr->pic_width_in_scu, md_fw_ptr->pic_height_in_scu,
			md_fw_ptr->bit_depth_internal,
			nb_u[0], nb_u[1], nb_v[0], nb_v[1], pb_x >> 1, pb_y >> 1,
			IP_buffer_ptr_U_32x4_up_line, IP_buffer_ptr_U_32x4_left_line, IP_buffer_ptr_U_32x4_top_left,
			IP_buffer_ptr_V_32x4_up_line, IP_buffer_ptr_V_32x4_left_line, IP_buffer_ptr_V_32x4_top_left,
			IP_map_scu_ptr_64x8_map_scu_up_line, IP_map_scu_ptr_64x8_map_scu_left_line_new);
	}
}

u16 com_get_avail_intra_ip_chroma_32x32(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_64x64_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_top_left_new
)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_64x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_64x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_64x64_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

u16 com_get_avail_intra_ip_chroma_16x32(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_top_left_new
)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_32x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_32x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_32x64_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_32x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

u16 com_get_avail_intra_ip_chroma_32x16(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_top_left_new
)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x32_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x32_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_64x32_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_64x32_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_64x32_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x32_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x32_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

u16 com_get_avail_intra_ip_chroma_8x32(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_top_left_new
)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_16x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_16x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_16x64_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_16x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

u16 com_get_avail_intra_ip_chroma_32x8(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_top_left_new
)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x16_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x16_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_64x16_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_64x16_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_64x16_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x16_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x16_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

u16 com_get_avail_intra_ip_chroma_4x32(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_top_left_new
)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_8x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_8x64_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_8x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_8x64_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_8x64_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_8x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_8x64_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

u16 com_get_avail_intra_ip_chroma_32x4(U11 x_scu, U11 y_scu,
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_top_left_new
)
{
#pragma HLS INLINE off
	u16 avail = (u16)0;
	U11 pic_x_scu = x_scu & 15;
	U11 pic_y_scu = y_scu & 15;
	if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x8_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x8_map_scu_left_line_new[0] >> 31 & (1)))) {
			avail |= 1 << 1;
		}
	}
	if (y_scu > 0) {
		if (pic_y_scu == 0) {
			if ((IP_map_scu_ptr_64x8_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
		else {
			if ((IP_map_scu_ptr_64x8_map_scu_up_line[0] >> 31 & (1))) {
				avail |= 1 << 0;
			}
		}
	}
	if (pic_y_scu == 0) {
		if (x_scu > 0)
			if (x_scu > 0
				&& ((IP_map_scu_ptr_64x8_map_scu_top_left_new >> 31 & (1)))) {
				avail |= 1 << 2;
			}
	}
	else if (pic_x_scu == 0) {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x8_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	else {
		if (x_scu > 0
			&& ((IP_map_scu_ptr_64x8_map_scu_top_left_new >> 31 & (1)))) {
			avail |= 1 << 2;
		}
	}
	return avail;
}

/*
void ipred_c_32_prepare(MD_FW* md_fw_ptr, U3 cu_width_log2, U3 cu_height_log2, 
	U13 pb_x, U13 pb_y,  MD_COM_MODE_BEST* mod_info_curr_ptr,
	pel nb_y[2][2 * 64 + 3], pel nb_u[2][2 * 32 + 3], pel nb_v[2][2 * 32 + 3],
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_U_32x32, IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_V_32x32,
	IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_U_16x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_V_16x32,
	IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_U_32x16, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_V_32x16,
	IP_ARRAY_SIZE<8, 32>* IP_buffer_ptr_U_8x32, IP_ARRAY_SIZE<8, 32>* IP_buffer_ptr_V_8x32,
	IP_ARRAY_SIZE<32, 8>* IP_buffer_ptr_U_32x8, IP_ARRAY_SIZE<32, 8>* IP_buffer_ptr_V_32x8,
	IP_ARRAY_SIZE<4, 32>* IP_buffer_ptr_U_4x32, IP_ARRAY_SIZE<4, 32>* IP_buffer_ptr_V_4x32,
	IP_ARRAY_SIZE<32, 4>* IP_buffer_ptr_U_32x4, IP_ARRAY_SIZE<32, 4>* IP_buffer_ptr_V_32x4,
	IP_ARRAY_SIZE<64, 64>* IP_buffer_ptr_64x64,
	IP_ARRAY_SIZE<32, 64>* IP_buffer_ptr_32x64, IP_ARRAY_SIZE<64, 32>* IP_buffer_ptr_64x32,
	IP_ARRAY_SIZE<16, 64>* IP_buffer_ptr_16x64, IP_ARRAY_SIZE<64, 16>* IP_buffer_ptr_64x16,
	IP_ARRAY_SIZE<8, 64>* IP_buffer_ptr_8x64, IP_ARRAY_SIZE<64, 8>* IP_buffer_ptr_64x8,
	IP_MAP_SCU_SIZE<64, 64>* IP_map_scu_ptr_64x64,
	IP_MAP_SCU_SIZE<32, 64>* IP_map_scu_ptr_32x64, IP_MAP_SCU_SIZE<64, 32>* IP_map_scu_ptr_64x32,
	IP_MAP_SCU_SIZE<16, 64>* IP_map_scu_ptr_16x64, IP_MAP_SCU_SIZE<64, 16>* IP_map_scu_ptr_64x16,
	IP_MAP_SCU_SIZE<8, 64>* IP_map_scu_ptr_8x64, IP_MAP_SCU_SIZE<64, 8>* IP_map_scu_ptr_64x8, u16* avail_cu_output)
*/
void ipred_c_32_prepare(MD_FW* md_fw_ptr, U3 cu_width_log2, U3 cu_height_log2,
	U13 pb_x, U13 pb_y, MD_COM_MODE_BEST* mod_info_curr_ptr,
	pel nb_y[2][2 * 64 + 3], pel nb_u[2][2 * 32 + 3], pel nb_v[2][2 * 32 + 3],
	pel IP_buffer_ptr_U_32x32_up_line[2 * 32], pel IP_buffer_ptr_U_32x32_left_line[2 * 32], pel IP_buffer_ptr_U_32x32_top_left,
	pel IP_buffer_ptr_V_32x32_up_line[2 * 32], pel IP_buffer_ptr_V_32x32_left_line[2 * 32], pel IP_buffer_ptr_V_32x32_top_left,
	pel IP_buffer_ptr_U_16x32_up_line[2 * 16], pel IP_buffer_ptr_U_16x32_left_line[2 * 32], pel IP_buffer_ptr_U_16x32_top_left,
	pel IP_buffer_ptr_V_16x32_up_line[2 * 16], pel IP_buffer_ptr_V_16x32_left_line[2 * 32], pel IP_buffer_ptr_V_16x32_top_left,
	pel IP_buffer_ptr_U_32x16_up_line[2 * 32], pel IP_buffer_ptr_U_32x16_left_line[2 * 16], pel IP_buffer_ptr_U_32x16_top_left,
	pel IP_buffer_ptr_V_32x16_up_line[2 * 32], pel IP_buffer_ptr_V_32x16_left_line[2 * 16], pel IP_buffer_ptr_V_32x16_top_left,
	pel IP_buffer_ptr_U_8x32_up_line[2 * 8], pel IP_buffer_ptr_U_8x32_left_line[2 * 32], pel IP_buffer_ptr_U_8x32_top_left,
	pel IP_buffer_ptr_V_8x32_up_line[2 * 8], pel IP_buffer_ptr_V_8x32_left_line[2 * 32], pel IP_buffer_ptr_V_8x32_top_left,
	pel IP_buffer_ptr_U_32x8_up_line[2 * 32], pel IP_buffer_ptr_U_32x8_left_line[2 * 8], pel IP_buffer_ptr_U_32x8_top_left,
	pel IP_buffer_ptr_V_32x8_up_line[2 * 32], pel IP_buffer_ptr_V_32x8_left_line[2 * 8], pel IP_buffer_ptr_V_32x8_top_left,
	pel IP_buffer_ptr_U_4x32_up_line[2 * 4], pel IP_buffer_ptr_U_4x32_left_line[2 * 32], pel IP_buffer_ptr_U_4x32_top_left,
	pel IP_buffer_ptr_V_4x32_up_line[2 * 4], pel IP_buffer_ptr_V_4x32_left_line[2 * 32], pel IP_buffer_ptr_V_4x32_top_left,
	pel IP_buffer_ptr_U_32x4_up_line[2 * 32], pel IP_buffer_ptr_U_32x4_left_line[2 * 4], pel IP_buffer_ptr_U_32x4_top_left,
	pel IP_buffer_ptr_V_32x4_up_line[2 * 32], pel IP_buffer_ptr_V_32x4_left_line[2 * 4], pel IP_buffer_ptr_V_32x4_top_left,
	pel IP_buffer_ptr_64x64_up_line[128], pel IP_buffer_ptr_64x64_left_line[64], pel IP_buffer_ptr_64x64_top_left,
	pel IP_buffer_ptr_32x64_up_line[2 * 32], pel IP_buffer_ptr_32x64_left_line[2 * 64], pel IP_buffer_ptr_32x64_top_left,
	pel IP_buffer_ptr_64x32_up_line[2 * 64], pel IP_buffer_ptr_64x32_left_line[2 * 32], pel IP_buffer_ptr_64x32_top_left,
	pel IP_buffer_ptr_16x64_up_line[2 * 16], pel IP_buffer_ptr_16x64_left_line[2 * 64], pel IP_buffer_ptr_16x64_top_left,
	pel IP_buffer_ptr_64x16_up_line[2 * 64], pel IP_buffer_ptr_64x16_left_line[2 * 16], pel IP_buffer_ptr_64x16_top_left,
	pel IP_buffer_ptr_8x64_up_line[2 * 8], pel IP_buffer_ptr_8x64_left_line[2 * 64], pel IP_buffer_ptr_8x64_top_left,
	pel IP_buffer_ptr_64x8_up_line[2 * 64], pel IP_buffer_ptr_64x8_left_line[2 * 8], pel IP_buffer_ptr_64x8_top_left,
	U32 IP_map_scu_ptr_64x64_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_top_left_new,
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_top_left_new,
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_top_left_new,
	u16* avail_cu_output)
{
	//u16 avail_cu = com_get_avail_intra_ip(MAP_SCU_IP_ptr, mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu);
#pragma HLS ARRAY_PARTITION variable=nb_y complete dim=0
#pragma HLS ARRAY_PARTITION variable=nb_u complete dim=0
#pragma HLS ARRAY_PARTITION variable=nb_v complete dim=0

	u16 avail_cu;
	if (cu_width_log2 == 5 && cu_height_log2 == 5)
	{
		//avail_cu = com_get_avail_intra_ip_chroma<32, 32>(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, IP_map_scu_ptr_64x64);
		avail_cu = com_get_avail_intra_ip_chroma_32x32(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, 
			IP_map_scu_ptr_64x64_map_scu_up_line, IP_map_scu_ptr_64x64_map_scu_left_line_new, IP_map_scu_ptr_64x64_map_scu_top_left_new);
	}
	else if (cu_width_log2 == 4 && cu_height_log2 == 5)
	{
		//avail_cu = com_get_avail_intra_ip_chroma<16, 32>(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, IP_map_scu_ptr_32x64);
		avail_cu = com_get_avail_intra_ip_chroma_16x32(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_32x64_map_scu_up_line, IP_map_scu_ptr_32x64_map_scu_left_line_new, IP_map_scu_ptr_32x64_map_scu_top_left_new);
	}
	else if (cu_width_log2 == 5 && cu_height_log2 == 4)
	{
		//avail_cu = com_get_avail_intra_ip_chroma<32, 16>(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, IP_map_scu_ptr_64x32);
		avail_cu = com_get_avail_intra_ip_chroma_32x16(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_64x32_map_scu_up_line, IP_map_scu_ptr_64x32_map_scu_left_line_new, IP_map_scu_ptr_64x32_map_scu_top_left_new);

	}
	else if (cu_width_log2 == 3 && cu_height_log2 == 5)
	{
		//avail_cu = com_get_avail_intra_ip_chroma<8, 32>(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, IP_map_scu_ptr_16x64);
		avail_cu = com_get_avail_intra_ip_chroma_8x32(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_16x64_map_scu_up_line, IP_map_scu_ptr_16x64_map_scu_left_line_new, IP_map_scu_ptr_16x64_map_scu_top_left_new);

	}
	else if (cu_width_log2 == 5 && cu_height_log2 == 3)
	{
		//avail_cu = com_get_avail_intra_ip_chroma<32, 8>(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, IP_map_scu_ptr_64x16);
		avail_cu = com_get_avail_intra_ip_chroma_32x8(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_64x16_map_scu_up_line, IP_map_scu_ptr_64x16_map_scu_left_line_new, IP_map_scu_ptr_64x16_map_scu_top_left_new);

	}
	else if (cu_width_log2 == 2 && cu_height_log2 == 5)
	{
		//avail_cu = com_get_avail_intra_ip_chroma<4, 32>(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, IP_map_scu_ptr_8x64);
		avail_cu = com_get_avail_intra_ip_chroma_4x32(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_8x64_map_scu_up_line, IP_map_scu_ptr_8x64_map_scu_left_line_new, IP_map_scu_ptr_8x64_map_scu_top_left_new);

	}
	else if (cu_width_log2 == 5 && cu_height_log2 == 2)
	{
		//avail_cu = com_get_avail_intra_ip_chroma<32, 4>(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu, IP_map_scu_ptr_64x8);
		avail_cu = com_get_avail_intra_ip_chroma_32x4(mod_info_curr_ptr->x_scu, mod_info_curr_ptr->y_scu,
			IP_map_scu_ptr_64x8_map_scu_up_line, IP_map_scu_ptr_64x8_map_scu_left_line_new, IP_map_scu_ptr_64x8_map_scu_top_left_new);
	}

	/*get_IP_pixel_chroma_package_32(md_fw_ptr, cu_width_log2, cu_height_log2, pb_x, pb_y, nb_u, nb_v,
		IP_buffer_ptr_U_32x32, IP_buffer_ptr_V_32x32,
		IP_buffer_ptr_U_16x32, IP_buffer_ptr_V_16x32,
		IP_buffer_ptr_U_32x16, IP_buffer_ptr_V_32x16,
		IP_buffer_ptr_U_8x32,  IP_buffer_ptr_V_8x32,
		IP_buffer_ptr_U_32x8,  IP_buffer_ptr_V_32x8,
		IP_buffer_ptr_U_4x32,  IP_buffer_ptr_V_4x32,
		IP_buffer_ptr_U_32x4,  IP_buffer_ptr_V_32x4,
		IP_map_scu_ptr_64x64,
		IP_map_scu_ptr_32x64, IP_map_scu_ptr_64x32,
		IP_map_scu_ptr_16x64, IP_map_scu_ptr_64x16,
		IP_map_scu_ptr_8x64,  IP_map_scu_ptr_64x8,
		avail_cu);*/
	get_IP_pixel_chroma_package_32(md_fw_ptr, cu_width_log2, cu_height_log2, pb_x, pb_y, nb_u, nb_v,
		IP_buffer_ptr_U_32x32_up_line, IP_buffer_ptr_U_32x32_left_line, IP_buffer_ptr_U_32x32_top_left,
		IP_buffer_ptr_V_32x32_up_line, IP_buffer_ptr_V_32x32_left_line, IP_buffer_ptr_V_32x32_top_left,
		IP_buffer_ptr_U_16x32_up_line, IP_buffer_ptr_U_16x32_left_line, IP_buffer_ptr_U_16x32_top_left,
		IP_buffer_ptr_V_16x32_up_line, IP_buffer_ptr_V_16x32_left_line, IP_buffer_ptr_V_16x32_top_left,
		IP_buffer_ptr_U_32x16_up_line, IP_buffer_ptr_U_32x16_left_line, IP_buffer_ptr_U_32x16_top_left,
		IP_buffer_ptr_V_32x16_up_line, IP_buffer_ptr_V_32x16_left_line, IP_buffer_ptr_V_32x16_top_left,
		IP_buffer_ptr_U_8x32_up_line, IP_buffer_ptr_U_8x32_left_line, IP_buffer_ptr_U_8x32_top_left,
		IP_buffer_ptr_V_8x32_up_line, IP_buffer_ptr_V_8x32_left_line, IP_buffer_ptr_V_8x32_top_left,
		IP_buffer_ptr_U_32x8_up_line, IP_buffer_ptr_U_32x8_left_line, IP_buffer_ptr_U_32x8_top_left,
		IP_buffer_ptr_V_32x8_up_line, IP_buffer_ptr_V_32x8_left_line, IP_buffer_ptr_V_32x8_top_left,
		IP_buffer_ptr_U_4x32_up_line, IP_buffer_ptr_U_4x32_left_line, IP_buffer_ptr_U_4x32_top_left,
		IP_buffer_ptr_V_4x32_up_line, IP_buffer_ptr_V_4x32_left_line, IP_buffer_ptr_V_4x32_top_left,
		IP_buffer_ptr_U_32x4_up_line, IP_buffer_ptr_U_32x4_left_line, IP_buffer_ptr_U_32x4_top_left,
		IP_buffer_ptr_V_32x4_up_line, IP_buffer_ptr_V_32x4_left_line, IP_buffer_ptr_V_32x4_top_left,
		IP_map_scu_ptr_64x64_map_scu_up_line,
		IP_map_scu_ptr_64x64_map_scu_left_line_new,
		IP_map_scu_ptr_32x64_map_scu_up_line,
		IP_map_scu_ptr_32x64_map_scu_left_line_new,
		IP_map_scu_ptr_64x32_map_scu_up_line,
		IP_map_scu_ptr_64x32_map_scu_left_line_new,
		IP_map_scu_ptr_16x64_map_scu_up_line,
		IP_map_scu_ptr_16x64_map_scu_left_line_new,
		IP_map_scu_ptr_64x16_map_scu_up_line,
		IP_map_scu_ptr_64x16_map_scu_left_line_new,
		IP_map_scu_ptr_8x64_map_scu_up_line,
		IP_map_scu_ptr_8x64_map_scu_left_line_new,
		IP_map_scu_ptr_64x8_map_scu_up_line,
		IP_map_scu_ptr_64x8_map_scu_left_line_new,
		avail_cu);
//#if USE_TSCPM
	/*get_IP_pixel_64_for_chroma(1 << (cu_width_log2 + 1), 1 << (cu_height_log2 + 1), avail_cu, md_fw_ptr->pic_width_in_scu,
		md_fw_ptr->pic_height_in_scu, md_fw_ptr->bit_depth_internal, 0, nb_y[0], nb_y[1], pb_x, pb_y, 
		IP_buffer_ptr_64x64, IP_buffer_ptr_32x64, IP_buffer_ptr_64x32, IP_buffer_ptr_16x64, IP_buffer_ptr_64x16, IP_buffer_ptr_8x64, IP_buffer_ptr_64x8,
		IP_map_scu_ptr_32x64, IP_map_scu_ptr_64x32, IP_map_scu_ptr_16x64, IP_map_scu_ptr_64x16, IP_map_scu_ptr_8x64, IP_map_scu_ptr_64x8);*/
	get_IP_pixel_64_for_chroma(1 << (cu_width_log2 + 1), 1 << (cu_height_log2 + 1), avail_cu, md_fw_ptr->pic_width_in_scu,
		md_fw_ptr->pic_height_in_scu, md_fw_ptr->bit_depth_internal, 0, nb_y[0], nb_y[1], pb_x, pb_y,
		IP_buffer_ptr_64x64_up_line, IP_buffer_ptr_64x64_left_line, IP_buffer_ptr_64x64_top_left,
		IP_buffer_ptr_32x64_up_line, IP_buffer_ptr_32x64_left_line, IP_buffer_ptr_32x64_top_left,
		IP_buffer_ptr_64x32_up_line, IP_buffer_ptr_64x32_left_line, IP_buffer_ptr_64x32_top_left,
		IP_buffer_ptr_16x64_up_line, IP_buffer_ptr_16x64_left_line, IP_buffer_ptr_16x64_top_left,
		IP_buffer_ptr_64x16_up_line, IP_buffer_ptr_64x16_left_line, IP_buffer_ptr_64x16_top_left,
		IP_buffer_ptr_8x64_up_line, IP_buffer_ptr_8x64_left_line, IP_buffer_ptr_8x64_top_left,
		IP_buffer_ptr_64x8_up_line, IP_buffer_ptr_64x8_left_line, IP_buffer_ptr_64x8_top_left,
		IP_map_scu_ptr_32x64_map_scu_up_line, IP_map_scu_ptr_32x64_map_scu_left_line_new,
		IP_map_scu_ptr_64x32_map_scu_up_line, IP_map_scu_ptr_64x32_map_scu_left_line_new,
		IP_map_scu_ptr_16x64_map_scu_up_line, IP_map_scu_ptr_16x64_map_scu_left_line_new,
		IP_map_scu_ptr_64x16_map_scu_up_line, IP_map_scu_ptr_64x16_map_scu_left_line_new,
		IP_map_scu_ptr_8x64_map_scu_up_line, IP_map_scu_ptr_8x64_map_scu_left_line_new,
		IP_map_scu_ptr_64x8_map_scu_up_line, IP_map_scu_ptr_64x8_map_scu_left_line_new);
//#endif // USE_TSCPM
	*avail_cu_output = avail_cu;
}








	//int stride_org_c = 64;


#if 0
static void update_chroma_32(MD_COM_MODE_BEST* mod_info_curr_ptr, s16 coef_y_pb_part[1024], U1 i, U1 coef_rec_write_flag[1], U2 inter_mode, pel pred[2][32][32], pel rec[2][32][32], int num_nz[4][3], U4 bit_depth)
{
	U3 cu_width_log2 = mod_info_curr_ptr->cu_width_log2;
	U3 cu_height_log2 = mod_info_curr_ptr->cu_height_log2;
	U7 cu_width = mod_info_curr_ptr->cu_width;
	U7 cu_height = mod_info_curr_ptr->cu_height;
	U12 size_tmp = cu_width * cu_height >> 2;
	int w = cu_width >> 1, h = cu_height >> 1;
	int j, k;

	if (inter_mode == 2) {
		mod_info_curr_ptr->num_nz[0][i + 1] = 0;
		//mod_info_best_ptr->num_nz[0][i + 1] = 0;
	}
	if (mod_info_curr_ptr->num_nz[0][i + 1] == 0) {
		//mod_info_best_ptr->num_nz[0][i + 1] = 0;
		for (k = 0; k < h; ++k) {
			for (j = 0; j < w; j++) {
				int d = k * w + j;
				if (i == 0)mod_info_curr_ptr->coef_u[d] = 0;
				else if (i == 1)mod_info_curr_ptr->coef_v[d] = 0;
				if (i == 0) {
					mod_info_curr_ptr->rec_u[d] = (((0 > (((1 << bit_depth) - 1 < (pred[i][k][j]) ?
						(1 << bit_depth) - 1 : (pred[i][k][j]))) ? 0 : (((1 << bit_depth) - 1 < (pred[i][k][j]) ? (1 << bit_depth) - 1 : (pred[i][k][j]))))));
				}
				else if (i == 1) {
					mod_info_curr_ptr->rec_v[d] = (((0 > (((1 << bit_depth) - 1 < (pred[i][k][j]) ?
						(1 << bit_depth) - 1 : (pred[i][k][j]))) ? 0 : (((1 << bit_depth) - 1 < (pred[i][k][j]) ? (1 << bit_depth) - 1 : (pred[i][k][j]))))));
				}
			}
		}
		coef_rec_write_flag[0] = 1;
	}
	else {
		//mod_info_curr_ptr->num_nz[0][i + 1] = mod_info_best_ptr->num_nz[0][i + 1];
		for (k = 0; k < h; ++k) {
			for (j = 0; j < w; j++) {
				int d = k * w + j;
				if (i == 0) {
					mod_info_curr_ptr->coef_u[d] = coef_y_pb_part[d];
					mod_info_curr_ptr->rec_u[d] = ((pel)((0 > (((1 << bit_depth) - 1 < (rec[i][k][j]) ?
						(1 << bit_depth) - 1 : (rec[i][k][j]))) ? 0 : (((1 << bit_depth) - 1 < (rec[i][k][j]) ? (1 << bit_depth) - 1 : (rec[i][k][j]))))));

				}
				else if (i == 1) {
					mod_info_curr_ptr->coef_v[d] = coef_y_pb_part[d];
					mod_info_curr_ptr->rec_v[d] = ((pel)((0 > (((1 << bit_depth) - 1 < (rec[i][k][j]) ?
						(1 << bit_depth) - 1 : (rec[i][k][j]))) ? 0 : (((1 << bit_depth) - 1 < (rec[i][k][j]) ? (1 << bit_depth) - 1 : (rec[i][k][j]))))));
				}
			}
		}
		coef_rec_write_flag[0] = 1;
	}
}
#endif

static s64 enc_ssd_16b_chroma_32(U3 w_log2, U3 h_log2, s16 src1[32][32], s16 src2[32][32], U8 s_src1, U7 s_src2, U4 bit_depth)
{
	U7 w = 1 << w_log2;
	U7 h = 1 << h_log2;
	const U2 shift = (bit_depth - 8) << 1;
	s64 ssd = 0;
	/*s16* s1 = (s16*)src1;*/
	//s16* s2 = (s16*)src2;
	U7 i, j;
	int diff;

	for (i = 0; i < h; i++) {
#pragma HLS PIPELINE II=1
#pragma HLS LOOP_TRIPCOUNT min=32 max=32 avg=32

		for (j = 0; j < 32; j++) {
			if (j < w) {
			diff = src1[i][j] - src2[i][j];
			ssd += ((diff * diff >> shift));
			}
		}
		//s2 += s_src2;
	}
	return ssd;

}

//--------------------------------------------------------pipeline change function  4/1------------------------------------------------------------------
enum ChromaModeType
{
	INTER_U = 0,
	INTRA_PLANE_U = 1,
	INTRA_ANG_U = 2,
	INTRA_DC_U = 3,
	INTRA_HOR_U = 4,
	INTRA_VER_U = 5,
	INTRA_BI_U = 6,
	INTER_V = 7,
	INTRA_PLANE_V = 8,
	INTRA_ANG_V = 9,
	INTRA_DC_V = 10,
	INTRA_HOR_V = 11,
	INTRA_VER_V = 12,
	INTRA_BI_V = 13,
	CMODE_NUM = 14
};
ChromaModeType chromaTypeU2V(ChromaModeType uType) { return (ChromaModeType)(uType + (CMODE_NUM >> 1)); }

void updateCoefRec32x32(pel modeInfoBestRec[32 * 32], pel bestRec[32][32])
{

	pel* startRec = modeInfoBestRec;

	for (int i = 0; i < 32; i++)
	{
		for (int j = 0; j < 32; j++)
		{
			startRec[j] = bestRec[i][j];
		}
		startRec += 32;
	}
}

void prepareChromaModeList(ChromaModeType modeTypeList[10], S8 ipmChromaIP[10], S8 ipmChromaRD[10], S8 ipmChromaUp[10], U2 cuMode, S8 ipmLuma)
{

	if (cuMode != MODE_INTRA)
	{
		modeTypeList[0] = INTER_U;
		modeTypeList[1] = INTER_V;
	}
	else
	{
		if (ipmLuma == 12)
		{
			ipmChromaIP[0] = 3;
			ipmChromaIP[1] = 3;
			ipmChromaRD[0] = 3;
			ipmChromaRD[1] = 3;
			ipmChromaUp[0] = 3;
			ipmChromaUp[1] = 3;
			modeTypeList[0] = INTRA_VER_U;
			modeTypeList[1] = INTRA_VER_V;
		}
		else if (ipmLuma == 24)
		{
			ipmChromaIP[0] = 2;
			ipmChromaIP[1] = 2;
			ipmChromaRD[0] = 2;
			ipmChromaRD[1] = 2;
			ipmChromaUp[0] = 2;
			ipmChromaUp[1] = 2;
			modeTypeList[0] = INTRA_HOR_U;
			modeTypeList[1] = INTRA_HOR_V;
		}
		else if (ipmLuma == 0)
		{
			ipmChromaIP[0] = 1;
			ipmChromaIP[1] = 1;
			ipmChromaRD[0] = 1;
			ipmChromaRD[1] = 1;
			ipmChromaUp[0] = 1;
			ipmChromaUp[1] = 1;
			modeTypeList[0] = INTRA_DC_U;
			modeTypeList[1] = INTRA_DC_V;
		}
		else if (ipmLuma == 2)
		{
			ipmChromaIP[0] = 4;
			ipmChromaIP[1] = 4;
			ipmChromaRD[0] = 4;
			ipmChromaRD[1] = 4;
			ipmChromaUp[0] = 4;
			ipmChromaUp[1] = 4;
			modeTypeList[0] = INTRA_BI_U;
			modeTypeList[1] = INTRA_BI_V;
		}
		else if (ipmLuma == 1)
		{
			ipmChromaIP[0] = 0;
			ipmChromaIP[1] = 0;
			ipmChromaRD[0] = 0;
			ipmChromaRD[1] = 0;
			ipmChromaUp[0] = 0;
			ipmChromaUp[1] = 0;
			modeTypeList[0] = INTRA_PLANE_U;
			modeTypeList[1] = INTRA_PLANE_V;
		}
		else
		{
			ipmChromaIP[0] = 0;
			ipmChromaIP[1] = 0;
			ipmChromaRD[0] = 0;
			ipmChromaRD[1] = 0;
			ipmChromaUp[0] = 0;
			ipmChromaUp[1] = 0;
			modeTypeList[0] = INTRA_ANG_U;
			modeTypeList[1] = INTRA_ANG_V;
		}

		for (s8 ipmChromaIdx = 1; ipmChromaIdx < 5; ipmChromaIdx++)
		{
			ipmChromaIP[(ipmChromaIdx << 1)] = ipmChromaIdx;
			ipmChromaIP[(ipmChromaIdx << 1) + 1] = ipmChromaIdx;
			ipmChromaRD[(ipmChromaIdx << 1)] = ipmChromaIdx;
			ipmChromaRD[(ipmChromaIdx << 1) + 1] = ipmChromaIdx;
			ipmChromaUp[(ipmChromaIdx << 1)] = ipmChromaIdx;
			ipmChromaUp[(ipmChromaIdx << 1) + 1] = ipmChromaIdx;
			modeTypeList[ipmChromaIdx << 1] = (ChromaModeType)(INTRA_ANG_U + ipmChromaIdx);
			modeTypeList[(ipmChromaIdx << 1) + 1] = chromaTypeU2V(modeTypeList[ipmChromaIdx << 1]);
		}

	}

}

#if 0
void updateModeInfoBestChroma32(ENC_CU_DATA_ARRAY* cu_data_temp_ptr, MD_COM_MODE_BEST* mod_info_best, s16 coef_uv_pb_part[2][32 * 32],
	U1 coef_rec_write_flag[1], pel pred[2][32][32], s16 rec_tmp[2][32][32], U4 bit_depth)
{

	if (mod_info_best->cu_mode != 0)
	{
		for (int uv = 0; uv < 2; uv++) {
			update_chroma_32(mod_info_best, coef_uv_pb_part[uv], uv, coef_rec_write_flag, mod_info_best->cu_mode, pred, rec_tmp, mod_info_best->num_nz,bit_depth);
		}

	}
}
#endif

//#if !DISABLE_CHROMA_32

void copyChromaRefWindowToRef(S16 cuWidth, S16 cuHeight, int gmv_x, int gmv_y, U8 RefWindowLCU_P[(SWH * SWW) >> 2], U8 ref[35][35])
{

	int startPosX = (gmv_x >> 3) - 1, startPosY = (gmv_y >> 3) - 1;

	for (int j = 0; j < 35; j++)
	{
		static U8 ref_read[SWW >> 1];
		for (int i = 0; i < (SWW >> 1); i++)
		{
			ref_read[i] = RefWindowLCU_P[((j + startPosY) * i)];
		}
		for (int i = 0; i < 35; i++)
		{
			if (i < cuWidth + 3 && j < cuHeight + 3)	ref[j][i] = ref_read[i + startPosX];
		}
	}
}

void getCoefRunWH(U7 widthIdx, s16 coef[32][32], s16 coef_out[32], U10 run[32], U10 run_num[1])
{

	if (widthIdx == 0)
	{
		coef_out[0] = coef[0][widthIdx];
		if (coef[0][widthIdx])
		{
			run_num[0] = 0;
		}
		else
			run_num[0] = 1;
	}
	else
	{
		if (widthIdx & 0x1)
		{
			for (int j = 0; j < 32; j++)
			{
				if (j <= widthIdx)
				{
					coef_out[j] = coef[j][widthIdx - j];
					if (coef[j][widthIdx - j])
					{
						run[j] = *run_num;
						run_num[0] = 0;
					}
					else
					{
						run[j] = 0;
						run_num[0]++;
					}
				}
			}
		}
		else
		{
			for (int j = 31; j >= 0; j--)
			{
				if (j <= widthIdx)
				{
					coef_out[widthIdx - j] = coef[j][widthIdx - j];
					if (coef[j][widthIdx - j])
					{
						run[widthIdx - j] = *run_num;
						run_num[0] = 0;
					}
					else
					{
						run[widthIdx - j] = 0;
						run_num[0]++;
					}
				}
			}
		}
	}

}
void getCoefRunHW(U7 widthIdx, U8 cu_height, s16 coef[32][32], s16 coef_out[32], U10 run[32], U10 run_num[1])
{

	U7 max_cnt = 0;

	if (widthIdx < cu_height)
		max_cnt = widthIdx;

	if (widthIdx & 1)
	{
		for (int j = 0; j < 32; j++)
		{
			if (j <= max_cnt)
			{
				coef_out[j] = coef[j][widthIdx - j];
				if (coef[j][widthIdx - j])
				{
					run[j] = run_num[0];
					run_num[0] = 0;
				}
				else
				{
					run[j] = 0;
					run_num[0]++;
				}
			}
		}
	}
	else
	{
		for (int j = 31; j >= 0; j--)
		{
			if (j <= max_cnt)
			{
				coef_out[max_cnt - j] = coef[j][widthIdx - j];
				if (coef[j][widthIdx - j])
				{
					run[max_cnt - j] = run_num[0];
					run_num[0] = 0;
				}
				else
				{
					run[max_cnt - j] = 0;
					run_num[0]++;
				}
			}
		}
	}
}

int encEcoCoefWH32(U8 cu_width, U8 cu_height, s16 coef[32][32], U3 log2_w, U3 log2_h)
{
	U15 enc_est = 0;
	static s16 coef_out[32];
	//s16 coef[H][W];
	static U10 run[32];

	for (U7 z = 0; z < 32; z++)
	{
		run[z] = 0;
		coef_out[z] = 0;
	}
	//	run_end[0] = 0;
	U10 run_num[1] = { 0 };
	for (U7 i = 0; i < cu_width; i++)
	{

		getCoefRunWH(i, coef, coef_out, run, run_num);

		enc_est += rate_coef_est_32(coef_out, run, cu_width);
	}

	return enc_est;


}
int encEcoCoefHW32(U8 cu_width, U8 cu_height, s16 coef[32][32], U3 log2_w, U3 log2_h)
{
	/*U7 cu_width = 1 << log2_w;
	U7 cu_height = 1 << log2_h;*/
	U15 enc_est = 0;
	s16 coef_out[32];
	//s16 coef[H][W];
	U10 run[32];

	for (U7 z = 0; z < 32; z++)
	{
		run[z] = 0;
		coef_out[z] = 0;
	}
	U10 run_num[1] = { 0 };
	U7 max_cnt = 0;

	for (U7 i = 0; i < cu_width; i++)
	{

		getCoefRunHW(i, cu_height, coef, coef_out, run, run_num);

		enc_est += rate_coef_est_32(coef_out, run, cu_height);
	}

	return enc_est;
}

int encodeChromaIntraDirEst32(u8 ipm, u8 ipm_l, u8 tscpm_enable_flag)
{
	int enc_est = 0;
	//  ENC_SBAC *sbac;
	u8 chk_bypass;
	//	sbac = &core_inner->s_temp_run;
	COM_IPRED_CONV_L2C_CHK(ipm_l, chk_bypass);
	enc_est++;
	//enc_sbac_encode_bin(!ipm, sbac, sbac->ctx.intra_dir + 7, bs);

	if (ipm)
	{
#if TSCPM
		if (tscpm_enable_flag)
		{
			if (ipm == IPD_TSCPM_C)
			{
				//enc_sbac_encode_bin(1, sbac, sbac->ctx.intra_dir + 9, bs);
				enc_est++;
				return enc_est;
			}
			else
			{
				//enc_sbac_encode_bin(0, sbac, sbac->ctx.intra_dir + 9, bs);
				enc_est++;
			}
		}
#endif
		u8 symbol = (chk_bypass && ipm > ipm_l) ? ipm - 2 : ipm - 1;

		//sbac_write_truncate_unary_sym(symbol, 1, IPD_CHROMA_CNT - 1, sbac, sbac->ctx.intra_dir + 8, bs);
		enc_est += sbac_write_truncate_unary_sym_est(symbol, IPD_CHROMA_CNT - 1);

	}

	return enc_est;
}
int encChromaIntraBitEst32(int log2_w, int log2_h, int cbf, U8 ipmChroma, U8 ipmLuma, pel coef[32][32], u8 tscpm_enable_flag)
{

	int estRate = 0, estRateCoef = 0;

	estRate = encodeChromaIntraDirEst32(ipmChroma, ipmLuma, tscpm_enable_flag) + 2;

	if (log2_w <= log2_h)
		estRateCoef = encEcoCoefWH32(1 << log2_w, 1 << log2_h, coef, log2_w, log2_h);
	else
		estRateCoef = encEcoCoefHW32(1 << log2_w, 1 << log2_h, coef, log2_w, log2_h);

	if (cbf)
		estRate += estRateCoef;

	return estRate;
}

pel quantPelFlag(s16 pel, int scale_x_ns_scale, int offset, int shift, S16 flag1, S16 flag2, U2 cu_mode)
{

	if (flag1 <= 0 || flag2 <= 0 || cu_mode == 2)
		return 0;

	int sign;
	s16 lev;
	sign = COM_SIGN_GET(pel);
	lev = ((int)(COM_ABS(pel) * scale_x_ns_scale + offset) >> shift);
	return (s16)(COM_SIGN_SET(lev, sign));
}
s16 dquatPelFlag(S16 pel, int iAj, int scale, int shift, int offset, int refix, S16 flag1, S16 flag2)
{

	if (flag1 <= 0 || flag2 <= 0)
		return 0;

	int weight = (iAj) & 0xE0 ? 0 : (int)pel;
	int lev = (weight * scale + offset) >> shift;
	lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
	if (refix)
	{
		lev = (lev * 181 + 128) >> 8;
	}
	return lev;
}

S16 calcDiffFlag(pel a, pel b, S16 flag)
{
	if (flag > 0) return a - b;
	else return 0;
}

S64 getChromaIntraBitEst32(int log2_w, int log2_h, int cbf, U8 ipmChroma, U8 ipmLuma, pel coef[32][32], u8 tscpm_enable_flag)
{
	int est_bit_intra = 0, bit_cnt = 0;
	int cu_width = 1 << log2_w, cu_height = 1 << log2_h;
	est_bit_intra = encChromaIntraBitEst32(log2_w, log2_h, cbf, ipmChroma, ipmLuma, coef, tscpm_enable_flag);
	if (cu_height == 32 && cu_width == 32)
	{
		bit_cnt = (882 * est_bit_intra + 1375);
	}
	if (cu_height == 32 && cu_width == 16)
	{
		bit_cnt = (913 * est_bit_intra + 186);
	}
	if (cu_height == 32 && cu_width == 8)
	{
		bit_cnt = (973 * est_bit_intra - 578);
	}
	if (cu_height == 16 && cu_width == 32)
	{
		bit_cnt = (954 * est_bit_intra - 367);
	}
	if (cu_height == 8 && cu_width == 32)
	{
		bit_cnt = (982 * est_bit_intra - 661);
	}
	return bit_cnt >> 10;
}
S64 calcChromaSSD32(U3 w_log2, U3 h_log2, s16 src1[32][32], s16 src2[32][32], U4 bit_depth)
{

	U7 w = 1 << w_log2;
	U7 h = 1 << h_log2;
	const U2 shift = (bit_depth - 8) << 1;
	S64 ssd = 0;
	/*s16* s1 = (s16*)src1;*/
	s16* s2 = (s16*)src2;
	U7 i, j;
	int diff;
	for (i = 0; i < h; i++)
	{
		for (j = 0; j < 32; j++)
		{
			diff = calcDiffFlag(src1[i][j], src2[i][j], w - j);
			ssd += ((diff * diff >> shift));
		}
	}
	return ssd;

}

void copyChromaBlock32ByDim2(pel src[32][32], s16 dst[32][32])
{
	for (int i = 0; i < 32; i++)
	{
		for (int j = 0; j < 32; j++)
		{
			dst[i][j] = src[i][j];
		}
	}
}

void deriveRDCostChroma32(U2 cu_mode, U32 dist_chroma_weight, MD_COM_MODE_BEST* mod_info_best, U3 cu_width_log2_chroma,
	U3 cu_height_log2_chroma, int cu_width_chroma, int cu_height_chroma, s16 rec_tmp[32][32], s16 orgU[32][32], s64 lambda_y, 
	s16 coef_tmp[32][32], u8 tscpm_enable_flag, s64 cost[6], U4 bit_depth, U1 uv, int num_nz[12], int rdo_idx)
{
#pragma HLS ARRAY_PARTITION variable=rec_tmp complete dim=2
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=2
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=1
#pragma HLS ARRAY_PARTITION variable=cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=num_nz complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_best->ipm complete dim=0
	int bin_cnt_chroma;
	s64 ssd_uv;
	static s64 ssd_u;
	static s64 ssd_v;
	int est_bit_intra_uv_tmp;
	static int est_bit_intra_u;
	static int est_bit_intra_v;
	if (cu_mode == 0) {
		s8 ipm01 = (s8)rdo_idx / 2;

		ssd_uv = (dist_chroma_weight * enc_ssd_16b_chroma_32(cu_width_log2_chroma, cu_height_log2_chroma, rec_tmp, orgU,
			cu_width_chroma, 32, bit_depth) + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE;
		est_bit_intra_uv_tmp = enc_eco_xcoef_est_32(coef_tmp, cu_width_chroma, cu_height_chroma, num_nz[rdo_idx]);
		if (uv == 0) {	
			ssd_u = ssd_uv;
			est_bit_intra_u = est_bit_intra_uv_tmp;
		}
		if (uv == 1) {
			ssd_v = ssd_uv;
			est_bit_intra_v = est_bit_intra_uv_tmp;
			//mod_info_best->num_nz[0][2] = num_nz[rdo_idx];
			int est_bit_intra = 2 + encode_intra_dir_c_est(ipm01, mod_info_best->ipm[PB0][0], tscpm_enable_flag);
			int est_bit_intra_tmp = est_bit_intra + est_bit_intra_u + est_bit_intra_v;
			bin_cnt_chroma = get_bit_est_intra_chroma_32( cu_width_chroma  , cu_height_chroma , est_bit_intra_tmp);
			cost[rdo_idx / 2] =  ssd_u + ssd_v + ((bin_cnt_chroma * lambda_y + (1 << (LAMBDA_SCALE - 1))) >> LAMBDA_SCALE);
		}
	}
}

void copyChromaBlock32ByDim1(pel src[32][32], s16 dst[32][32])
{

	for (int i = 0; i < 32; i++)
	{
		for (int j = 0; j < 32; j++)
		{
			dst[j][i] = src[j][i];
		}
	}
}

static U4 com_get_inverse_trans_shift_chroma(U3 log2_size, U3 type, U4 bit_depth)
{

#if MD_PRINT
	log2_size <= 6 ? ((void)0) : __assert_HLS("log2_size <= 6", "../separate/com_itdq.c", (unsigned int)40,
		__FUNCTION__);
#endif
	return type == 0 ? (U4)5 : (U4)(15 + 5 - bit_depth);
}

void invDctCol32(U8 cu_width, U8 cu_height, s16 coeff[32][32], s16 block[32][32], U4 shift)
{

	if (cu_height == 4)
	{

		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 32; i++)
		{
			O[0] = (42) * coeff[1][i] + (17) * coeff[3][i];
			O[1] = (17) * coeff[1][i] + (-42) * coeff[3][i];
			E[0] = (32) * coeff[0][i] + (32) * coeff[2][i];
			E[1] = (32) * coeff[0][i] + (-32) * coeff[2][i];
			block[i][(0 + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][(1 + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][(2 + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][(3 + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_height == 8)
	{

		int E[4], O[4];
		int EE[2], EO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++)
		{

			O[0] = (44) * coeff[1][i] + (38) * coeff[3][i] + (25) * coeff[5][i] + (9) * coeff[7][i];
			O[1] = (38) * coeff[1][i] + (-9) * coeff[3][i] + (-44) * coeff[5][i] + (-25) * coeff[7][i];
			O[2] = (25) * coeff[1][i] + (-44) * coeff[3][i] + (9) * coeff[5][i] + (38) * coeff[7][i];
			O[3] = (9) * coeff[1][i] + (-25) * coeff[3][i] + (38) * coeff[5][i] + (-44) * coeff[7][i];

			EO[0] = (42) * coeff[2][i] + (17) * coeff[6][i];
			EO[1] = (17) * coeff[2][i] + (-42) * coeff[6][i];
			EE[0] = (32) * coeff[0][i] + (32) * coeff[4][i];
			EE[1] = (32) * coeff[0][i] + (-32) * coeff[4][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];

			for (k = 0; k < 4; k++)
			{
				block[i][(k + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][(k + 4 + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else if (cu_height == 16)
	{

		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++)
		{
			O[0] = (45) * coeff[1][i] + (43) * coeff[3][i] + (40) * coeff[5][i] + (35) * coeff[7][i] + (29) * coeff[9][i] + (21) * coeff[11][i] + (13) * coeff[13][i] + (4) * coeff[15][i];
			O[1] = (43) * coeff[1][i] + (29) * coeff[3][i] + (4) * coeff[5][i] + (-21) * coeff[7][i] + (-40) * coeff[9][i] + (-45) * coeff[11][i] + (-35) * coeff[13][i] + (-13) * coeff[15][i];
			O[2] = (40) * coeff[1][i] + (4) * coeff[3][i] + (-35) * coeff[5][i] + (-43) * coeff[7][i] + (-13) * coeff[9][i] + (29) * coeff[11][i] + (45) * coeff[13][i] + (21) * coeff[15][i];
			O[3] = (35) * coeff[1][i] + (-21) * coeff[3][i] + (-43) * coeff[5][i] + (4) * coeff[7][i] + (45) * coeff[9][i] + (13) * coeff[11][i] + (-40) * coeff[13][i] + (-29) * coeff[15][i];
			O[4] = (29) * coeff[1][i] + (-40) * coeff[3][i] + (-13) * coeff[5][i] + (45) * coeff[7][i] + (-4) * coeff[9][i] + (-43) * coeff[11][i] + (21) * coeff[13][i] + (35) * coeff[15][i];
			O[5] = (21) * coeff[1][i] + (-45) * coeff[3][i] + (29) * coeff[5][i] + (13) * coeff[7][i] + (-43) * coeff[9][i] + (35) * coeff[11][i] + (4) * coeff[13][i] + (-40) * coeff[15][i];
			O[6] = (13) * coeff[1][i] + (-35) * coeff[3][i] + (45) * coeff[5][i] + (-40) * coeff[7][i] + (21) * coeff[9][i] + (4) * coeff[11][i] + (-29) * coeff[13][i] + (43) * coeff[15][i];
			O[7] = (4) * coeff[1][i] + (-13) * coeff[3][i] + (21) * coeff[5][i] + (-29) * coeff[7][i] + (35) * coeff[9][i] + (-40) * coeff[11][i] + (43) * coeff[13][i] + (-45) * coeff[15][i];

			EO[0] = (44) * coeff[2][i] + (38) * coeff[6][i] + (25) * coeff[10][i] + (9) * coeff[14][i];
			EO[1] = (38) * coeff[2][i] + (-9) * coeff[6][i] + (-44) * coeff[10][i] + (-25) * coeff[14][i];
			EO[2] = (25) * coeff[2][i] + (-44) * coeff[6][i] + (9) * coeff[10][i] + (38) * coeff[14][i];
			EO[3] = (9) * coeff[2][i] + (-25) * coeff[6][i] + (38) * coeff[10][i] + (-44) * coeff[14][i];

			EEO[0] = (42) * coeff[4][i] + (17) * coeff[12][i];
			EEE[0] = (32) * coeff[0][i] + (32) * coeff[8][i];
			EEO[1] = (17) * coeff[4][i] + (-42) * coeff[12][i];
			EEE[1] = (32) * coeff[0][i] + (-32) * coeff[8][i];

			for (k = 0; k < 2; k++)
			{
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++)
			{
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++)
			{
				block[i][(k + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][(k + 8 + i) & 31] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
	else
	{
		int E[16], O[16];
		int EE[8], EO[8];
		int EEE[4], EEO[4];
		int EEEE[2], EEEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++)
		{
			O[0] = (45) * coeff[1][i] + (45) * coeff[3][i] + (44) * coeff[5][i] + (43) * coeff[7][i] + (41) * coeff[9][i] + (39) * coeff[11][i] + (36) * coeff[13][i] + (34) * coeff[15][i] + (30) * coeff[17][i] + (27) * coeff[19][i] + (23) * coeff[21][i] + (19) * coeff[23][i] + (15) * coeff[25][i] + (11) * coeff[27][i] + (7) * coeff[29][i] + (2) * coeff[31][i];
			O[1] = (45) * coeff[1][i] + (41) * coeff[3][i] + (34) * coeff[5][i] + (23) * coeff[7][i] + (11) * coeff[9][i] + (-2) * coeff[11][i] + (-15) * coeff[13][i] + (-27) * coeff[15][i] + (-36) * coeff[17][i] + (-43) * coeff[19][i] + (-45) * coeff[21][i] + (-44) * coeff[23][i] + (-39) * coeff[25][i] + (-30) * coeff[27][i] + (-19) * coeff[29][i] + (-7) * coeff[31][i];
			O[2] = (44) * coeff[1][i] + (34) * coeff[3][i] + (15) * coeff[5][i] + (-7) * coeff[7][i] + (-27) * coeff[9][i] + (-41) * coeff[11][i] + (-45) * coeff[13][i] + (-39) * coeff[15][i] + (-23) * coeff[17][i] + (-2) * coeff[19][i] + (19) * coeff[21][i] + (36) * coeff[23][i] + (45) * coeff[25][i] + (43) * coeff[27][i] + (30) * coeff[29][i] + (11) * coeff[31][i];
			O[3] = (43) * coeff[1][i] + (23) * coeff[3][i] + (-7) * coeff[5][i] + (-34) * coeff[7][i] + (-45) * coeff[9][i] + (-36) * coeff[11][i] + (-11) * coeff[13][i] + (19) * coeff[15][i] + (41) * coeff[17][i] + (44) * coeff[19][i] + (27) * coeff[21][i] + (-2) * coeff[23][i] + (-30) * coeff[25][i] + (-45) * coeff[27][i] + (-39) * coeff[29][i] + (-15) * coeff[31][i];
			O[4] = (41) * coeff[1][i] + (11) * coeff[3][i] + (-27) * coeff[5][i] + (-45) * coeff[7][i] + (-30) * coeff[9][i] + (7) * coeff[11][i] + (39) * coeff[13][i] + (43) * coeff[15][i] + (15) * coeff[17][i] + (-23) * coeff[19][i] + (-45) * coeff[21][i] + (-34) * coeff[23][i] + (2) * coeff[25][i] + (36) * coeff[27][i] + (44) * coeff[29][i] + (19) * coeff[31][i];
			O[5] = (39) * coeff[1][i] + (-2) * coeff[3][i] + (-41) * coeff[5][i] + (-36) * coeff[7][i] + (7) * coeff[9][i] + (43) * coeff[11][i] + (34) * coeff[13][i] + (-11) * coeff[15][i] + (-44) * coeff[17][i] + (-30) * coeff[19][i] + (15) * coeff[21][i] + (45) * coeff[23][i] + (27) * coeff[25][i] + (-19) * coeff[27][i] + (-45) * coeff[29][i] + (-23) * coeff[31][i];
			O[6] = (36) * coeff[1][i] + (-15) * coeff[3][i] + (-45) * coeff[5][i] + (-11) * coeff[7][i] + (39) * coeff[9][i] + (34) * coeff[11][i] + (-19) * coeff[13][i] + (-45) * coeff[15][i] + (-7) * coeff[17][i] + (41) * coeff[19][i] + (30) * coeff[21][i] + (-23) * coeff[23][i] + (-44) * coeff[25][i] + (-2) * coeff[27][i] + (43) * coeff[29][i] + (27) * coeff[31][i];
			O[7] = (34) * coeff[1][i] + (-27) * coeff[3][i] + (-39) * coeff[5][i] + (19) * coeff[7][i] + (43) * coeff[9][i] + (-11) * coeff[11][i] + (-45) * coeff[13][i] + (2) * coeff[15][i] + (45) * coeff[17][i] + (7) * coeff[19][i] + (-44) * coeff[21][i] + (-15) * coeff[23][i] + (41) * coeff[25][i] + (23) * coeff[27][i] + (-36) * coeff[29][i] + (-30) * coeff[31][i];
			O[8] = (30) * coeff[1][i] + (-36) * coeff[3][i] + (-23) * coeff[5][i] + (41) * coeff[7][i] + (15) * coeff[9][i] + (-44) * coeff[11][i] + (-7) * coeff[13][i] + (45) * coeff[15][i] + (-2) * coeff[17][i] + (-45) * coeff[19][i] + (11) * coeff[21][i] + (43) * coeff[23][i] + (-19) * coeff[25][i] + (-39) * coeff[27][i] + (27) * coeff[29][i] + (34) * coeff[31][i];
			O[9] = (27) * coeff[1][i] + (-43) * coeff[3][i] + (-2) * coeff[5][i] + (44) * coeff[7][i] + (-23) * coeff[9][i] + (-30) * coeff[11][i] + (41) * coeff[13][i] + (7) * coeff[15][i] + (-45) * coeff[17][i] + (19) * coeff[19][i] + (34) * coeff[21][i] + (-39) * coeff[23][i] + (-11) * coeff[25][i] + (45) * coeff[27][i] + (-15) * coeff[29][i] + (-36) * coeff[31][i];
			O[10] = (23) * coeff[1][i] + (-45) * coeff[3][i] + (19) * coeff[5][i] + (27) * coeff[7][i] + (-45) * coeff[9][i] + (15) * coeff[11][i] + (30) * coeff[13][i] + (-44) * coeff[15][i] + (11) * coeff[17][i] + (34) * coeff[19][i] + (-43) * coeff[21][i] + (7) * coeff[23][i] + (36) * coeff[25][i] + (-41) * coeff[27][i] + (2) * coeff[29][i] + (39) * coeff[31][i];
			O[11] = (19) * coeff[1][i] + (-44) * coeff[3][i] + (36) * coeff[5][i] + (-2) * coeff[7][i] + (-34) * coeff[9][i] + (45) * coeff[11][i] + (-23) * coeff[13][i] + (-15) * coeff[15][i] + (43) * coeff[17][i] + (-39) * coeff[19][i] + (7) * coeff[21][i] + (30) * coeff[23][i] + (-45) * coeff[25][i] + (27) * coeff[27][i] + (11) * coeff[29][i] + (-41) * coeff[31][i];
			O[12] = (15) * coeff[1][i] + (-39) * coeff[3][i] + (45) * coeff[5][i] + (-30) * coeff[7][i] + (2) * coeff[9][i] + (27) * coeff[11][i] + (-44) * coeff[13][i] + (41) * coeff[15][i] + (-19) * coeff[17][i] + (-11) * coeff[19][i] + (36) * coeff[21][i] + (-45) * coeff[23][i] + (34) * coeff[25][i] + (-7) * coeff[27][i] + (-23) * coeff[29][i] + (43) * coeff[31][i];
			O[13] = (11) * coeff[1][i] + (-30) * coeff[3][i] + (43) * coeff[5][i] + (-45) * coeff[7][i] + (36) * coeff[9][i] + (-19) * coeff[11][i] + (-2) * coeff[13][i] + (23) * coeff[15][i] + (-39) * coeff[17][i] + (45) * coeff[19][i] + (-41) * coeff[21][i] + (27) * coeff[23][i] + (-7) * coeff[25][i] + (-15) * coeff[27][i] + (34) * coeff[29][i] + (-44) * coeff[31][i];
			O[14] = (7) * coeff[1][i] + (-19) * coeff[3][i] + (30) * coeff[5][i] + (-39) * coeff[7][i] + (44) * coeff[9][i] + (-45) * coeff[11][i] + (43) * coeff[13][i] + (-36) * coeff[15][i] + (27) * coeff[17][i] + (-15) * coeff[19][i] + (2) * coeff[21][i] + (11) * coeff[23][i] + (-23) * coeff[25][i] + (34) * coeff[27][i] + (-41) * coeff[29][i] + (45) * coeff[31][i];
			O[15] = (2) * coeff[1][i] + (-7) * coeff[3][i] + (11) * coeff[5][i] + (-15) * coeff[7][i] + (19) * coeff[9][i] + (-23) * coeff[11][i] + (27) * coeff[13][i] + (-30) * coeff[15][i] + (34) * coeff[17][i] + (-36) * coeff[19][i] + (39) * coeff[21][i] + (-41) * coeff[23][i] + (43) * coeff[25][i] + (-44) * coeff[27][i] + (45) * coeff[29][i] + (-45) * coeff[31][i];

			EO[0] = (45) * coeff[2][i] + (43) * coeff[6][i] + (40) * coeff[10][i] + (35) * coeff[14][i] + (29) * coeff[18][i] + (21) * coeff[22][i] + (13) * coeff[26][i] + (4) * coeff[30][i];
			EO[1] = (43) * coeff[2][i] + (29) * coeff[6][i] + (4) * coeff[10][i] + (-21) * coeff[14][i] + (-40) * coeff[18][i] + (-45) * coeff[22][i] + (-35) * coeff[26][i] + (-13) * coeff[30][i];
			EO[2] = (40) * coeff[2][i] + (4) * coeff[6][i] + (-35) * coeff[10][i] + (-43) * coeff[14][i] + (-13) * coeff[18][i] + (29) * coeff[22][i] + (45) * coeff[26][i] + (21) * coeff[30][i];
			EO[3] = (35) * coeff[2][i] + (-21) * coeff[6][i] + (-43) * coeff[10][i] + (4) * coeff[14][i] + (45) * coeff[18][i] + (13) * coeff[22][i] + (-40) * coeff[26][i] + (-29) * coeff[30][i];
			EO[4] = (29) * coeff[2][i] + (-40) * coeff[6][i] + (-13) * coeff[10][i] + (45) * coeff[14][i] + (-4) * coeff[18][i] + (-43) * coeff[22][i] + (21) * coeff[26][i] + (35) * coeff[30][i];
			EO[5] = (21) * coeff[2][i] + (-45) * coeff[6][i] + (29) * coeff[10][i] + (13) * coeff[14][i] + (-43) * coeff[18][i] + (35) * coeff[22][i] + (4) * coeff[26][i] + (-40) * coeff[30][i];
			EO[6] = (13) * coeff[2][i] + (-35) * coeff[6][i] + (45) * coeff[10][i] + (-40) * coeff[14][i] + (21) * coeff[18][i] + (4) * coeff[22][i] + (-29) * coeff[26][i] + (43) * coeff[30][i];
			EO[7] = (4) * coeff[2][i] + (-13) * coeff[6][i] + (21) * coeff[10][i] + (-29) * coeff[14][i] + (35) * coeff[18][i] + (-40) * coeff[22][i] + (43) * coeff[26][i] + (-45) * coeff[30][i];

			EEO[0] = (44) * coeff[4][i] + (38) * coeff[12][i] + (25) * coeff[20][i] + (9) * coeff[28][i];
			EEO[1] = (38) * coeff[4][i] + (-9) * coeff[12][i] + (-44) * coeff[20][i] + (-25) * coeff[28][i];
			EEO[2] = (25) * coeff[4][i] + (-44) * coeff[12][i] + (9) * coeff[20][i] + (38) * coeff[28][i];
			EEO[3] = (9) * coeff[4][i] + (-25) * coeff[12][i] + (38) * coeff[20][i] + (-44) * coeff[28][i];

			EEEO[0] = (42) * coeff[8][i] + (17) * coeff[24][i];
			EEEO[1] = (17) * coeff[8][i] + (-42) * coeff[24][i];
			EEEE[0] = (32) * coeff[0][i] + (32) * coeff[16][i];
			EEEE[1] = (32) * coeff[0][i] + (-32) * coeff[16][i];

			EEE[0] = EEEE[0] + EEEO[0];
			EEE[3] = EEEE[0] - EEEO[0];
			EEE[1] = EEEE[1] + EEEO[1];
			EEE[2] = EEEE[1] - EEEO[1];

			for (k = 0; k < 4; k++)
			{
				EE[k] = EEE[k] + EEO[k];
				EE[k + 4] = EEE[3 - k] - EEO[3 - k];
			}
			for (k = 0; k < 8; k++)
			{
				E[k] = EE[k] + EO[k];
				E[k + 8] = EE[7 - k] - EO[7 - k];
			}
			for (k = 0; k < 16; k++)
			{
				block[(i + k) & 31][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[(i + k + 16) & 31][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
			}
		}


	}
}

void invDctRow32(U8 cu_width, U8 cu_height, s16 coeff[32][32], s16 block[32][32], U4 shift)
{

	if (cu_width == 4)
	{


		int E[2], O[2];
		int rnd_factor = 1 << (shift - 1);
		for (int i = 0; i < 32; i++)
		{
			O[0] = (42) * coeff[(1 + i) & 31][i] + (17) * coeff[(3 + i) & 31][i];
			O[1] = (17) * coeff[(1 + i) & 31][i] + (-42) * coeff[(3 + i) & 31][i];
			E[0] = (32) * coeff[(0 + i) & 31][i] + (32) * coeff[(2 + i) & 31][i];
			E[1] = (32) * coeff[(0 + i) & 31][i] + (-32) * coeff[(2 + i) & 31][i];
			block[i][0] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] + O[0] + rnd_factor) >> shift);
			block[i][1] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] + O[1] + rnd_factor) >> shift);
			block[i][2] = Clip3(-(1 << 15), (1 << 15) - 1, (E[1] - O[1] + rnd_factor) >> shift);
			block[i][3] = Clip3(-(1 << 15), (1 << 15) - 1, (E[0] - O[0] + rnd_factor) >> shift);
		}
	}
	else if (cu_width == 8)
	{

		int E[4], O[4];
		int EE[2], EO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++)
		{
			O[0] = (44) * coeff[(1 + i) & 31][i] + (38) * coeff[(3 + i) & 31][i] + (25) * coeff[(5 + i) & 31][i] + (9) * coeff[(7 + i) & 31][i];
			O[1] = (38) * coeff[(1 + i) & 31][i] + (-9) * coeff[(3 + i) & 31][i] + (-44) * coeff[(5 + i) & 31][i] + (-25) * coeff[(7 + i) & 31][i];
			O[2] = (25) * coeff[(1 + i) & 31][i] + (-44) * coeff[(3 + i) & 31][i] + (9) * coeff[(5 + i) & 31][i] + (38) * coeff[(7 + i) & 31][i];
			O[3] = (9) * coeff[(1 + i) & 31][i] + (-25) * coeff[(3 + i) & 31][i] + (38) * coeff[(5 + i) & 31][i] + (-44) * coeff[(7 + i) & 31][i];

			EO[0] = (42) * coeff[(2 + i) & 31][i] + (17) * coeff[(6 + i) & 31][i];
			EO[1] = (17) * coeff[(2 + i) & 31][i] + (-42) * coeff[(6 + i) & 31][i];
			EE[0] = (32) * coeff[(0 + i) & 31][i] + (32) * coeff[(4 + i) & 31][i];
			EE[1] = (32) * coeff[(0 + i) & 31][i] + (-32) * coeff[(4 + i) & 31][i];

			E[0] = EE[0] + EO[0];
			E[3] = EE[0] - EO[0];
			E[1] = EE[1] + EO[1];
			E[2] = EE[1] - EO[1];
			for (k = 0; k < 4; k++)
			{
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[k] + O[k] + rnd_factor)) >> shift);
				block[i][k + 4] = Clip3(-(1 << 15), (1 << 15) - 1, ((int)(E[3 - k] - O[3 - k] + rnd_factor)) >> shift);

			}
		}
	}
	else if (cu_width == 16)
	{

		int E[8], O[8];
		int EE[4], EO[4];
		int EEE[2], EEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++)
		{
			O[0] = (45) * coeff[(1 + i) & 31][i] + (43) * coeff[(3 + i) & 31][i] + (40) * coeff[(5 + i) & 31][i] + (35) * coeff[(7 + i) & 31][i] + (29) * coeff[(9 + i) & 31][i] + (21) * coeff[(11 + i) & 31][i] + (13) * coeff[(13 + i) & 31][i] + (4) * coeff[(15 + i) & 31][i];
			O[1] = (43) * coeff[(1 + i) & 31][i] + (29) * coeff[(3 + i) & 31][i] + (4) * coeff[(5 + i) & 31][i] + (-21) * coeff[(7 + i) & 31][i] + (-40) * coeff[(9 + i) & 31][i] + (-45) * coeff[(11 + i) & 31][i] + (-35) * coeff[(13 + i) & 31][i] + (-13) * coeff[(15 + i) & 31][i];
			O[2] = (40) * coeff[(1 + i) & 31][i] + (4) * coeff[(3 + i) & 31][i] + (-35) * coeff[(5 + i) & 31][i] + (-43) * coeff[(7 + i) & 31][i] + (-13) * coeff[(9 + i) & 31][i] + (29) * coeff[(11 + i) & 31][i] + (45) * coeff[(13 + i) & 31][i] + (21) * coeff[(15 + i) & 31][i];
			O[3] = (35) * coeff[(1 + i) & 31][i] + (-21) * coeff[(3 + i) & 31][i] + (-43) * coeff[(5 + i) & 31][i] + (4) * coeff[(7 + i) & 31][i] + (45) * coeff[(9 + i) & 31][i] + (13) * coeff[(11 + i) & 31][i] + (-40) * coeff[(13 + i) & 31][i] + (-29) * coeff[(15 + i) & 31][i];
			O[4] = (29) * coeff[(1 + i) & 31][i] + (-40) * coeff[(3 + i) & 31][i] + (-13) * coeff[(5 + i) & 31][i] + (45) * coeff[(7 + i) & 31][i] + (-4) * coeff[(9 + i) & 31][i] + (-43) * coeff[(11 + i) & 31][i] + (21) * coeff[(13 + i) & 31][i] + (35) * coeff[(15 + i) & 31][i];
			O[5] = (21) * coeff[(1 + i) & 31][i] + (-45) * coeff[(3 + i) & 31][i] + (29) * coeff[(5 + i) & 31][i] + (13) * coeff[(7 + i) & 31][i] + (-43) * coeff[(9 + i) & 31][i] + (35) * coeff[(11 + i) & 31][i] + (4) * coeff[(13 + i) & 31][i] + (-40) * coeff[(15 + i) & 31][i];
			O[6] = (13) * coeff[(1 + i) & 31][i] + (-35) * coeff[(3 + i) & 31][i] + (45) * coeff[(5 + i) & 31][i] + (-40) * coeff[(7 + i) & 31][i] + (21) * coeff[(9 + i) & 31][i] + (4) * coeff[(11 + i) & 31][i] + (-29) * coeff[(13 + i) & 31][i] + (43) * coeff[(15 + i) & 31][i];
			O[7] = (4) * coeff[(1 + i) & 31][i] + (-13) * coeff[(3 + i) & 31][i] + (21) * coeff[(5 + i) & 31][i] + (-29) * coeff[(7 + i) & 31][i] + (35) * coeff[(9 + i) & 31][i] + (-40) * coeff[(11 + i) & 31][i] + (43) * coeff[(13 + i) & 31][i] + (-45) * coeff[(15 + i) & 31][i];

			EO[0] = (44) * coeff[(2 + i) & 31][i] + (38) * coeff[(6 + i) & 31][i] + (25) * coeff[(10 + i) & 31][i] + (9) * coeff[(14 + i) & 31][i];
			EO[1] = (38) * coeff[(2 + i) & 31][i] + (-9) * coeff[(6 + i) & 31][i] + (-44) * coeff[(10 + i) & 31][i] + (-25) * coeff[(14 + i) & 31][i];
			EO[2] = (25) * coeff[(2 + i) & 31][i] + (-44) * coeff[(6 + i) & 31][i] + (9) * coeff[(10 + i) & 31][i] + (38) * coeff[(14 + i) & 31][i];
			EO[3] = (9) * coeff[(2 + i) & 31][i] + (-25) * coeff[(6 + i) & 31][i] + (38) * coeff[(10 + i) & 31][i] + (-44) * coeff[(14 + i) & 31][i];

			EEO[0] = (42) * coeff[(4 + i) & 31][i] + (17) * coeff[(12 + i) & 31][i];
			EEE[0] = (32) * coeff[(0 + i) & 31][i] + (32) * coeff[(8 + i) & 31][i];
			EEO[1] = (17) * coeff[(4 + i) & 31][i] + (-42) * coeff[(12 + i) & 31][i];
			EEE[1] = (32) * coeff[(0 + i) & 31][i] + (-32) * coeff[(8 + i) & 31][i];

			for (k = 0; k < 2; k++)
			{
				EE[k] = EEE[k] + EEO[k];
				EE[k + 2] = EEE[1 - k] - EEO[1 - k];
			}
			for (k = 0; k < 4; k++)
			{
				E[k] = EE[k] + EO[k];
				E[k + 4] = EE[3 - k] - EO[3 - k];
			}
			for (k = 0; k < 8; k++)
			{
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 8] = Clip3(-(1 << 15), (1 << 15) - 1, (E[7 - k] - O[7 - k] + rnd_factor) >> shift);
			}
		}
	}
	else
	{

		int E[16], O[16];
		int EE[8], EO[8];
		int EEE[4], EEO[4];
		int EEEE[2], EEEO[2];
		int rnd_factor = 1 << (shift - 1);
		int k;
		for (int i = 0; i < 32; i++)
		{
			O[0] = (45) * coeff[(1 + i) & 31][i] + (45) * coeff[(3 + i) & 31][i] + (44) * coeff[(5 + i) & 31][i] + (43) * coeff[(7 + i) & 31][i] + (41) * coeff[(9 + i) & 31][i] + (39) * coeff[(11 + i) & 31][i] + (36) * coeff[(13 + i) & 31][i] + (34) * coeff[(15 + i) & 31][i] + (30) * coeff[(17 + i) & 31][i] + (27) * coeff[(19 + i) & 31][i] + (23) * coeff[(21 + i) & 31][i] + (19) * coeff[(23 + i) & 31][i] + (15) * coeff[(25 + i) & 31][i] + (11) * coeff[(27 + i) & 31][i] + (7) * coeff[(29 + i) & 31][i] + (2) * coeff[(31 + i) & 31][i];
			O[1] = (45) * coeff[(1 + i) & 31][i] + (41) * coeff[(3 + i) & 31][i] + (34) * coeff[(5 + i) & 31][i] + (23) * coeff[(7 + i) & 31][i] + (11) * coeff[(9 + i) & 31][i] + (-2) * coeff[(11 + i) & 31][i] + (-15) * coeff[(13 + i) & 31][i] + (-27) * coeff[(15 + i) & 31][i] + (-36) * coeff[(17 + i) & 31][i] + (-43) * coeff[(19 + i) & 31][i] + (-45) * coeff[(21 + i) & 31][i] + (-44) * coeff[(23 + i) & 31][i] + (-39) * coeff[(25 + i) & 31][i] + (-30) * coeff[(27 + i) & 31][i] + (-19) * coeff[(29 + i) & 31][i] + (-7) * coeff[(31 + i) & 31][i];
			O[2] = (44) * coeff[(1 + i) & 31][i] + (34) * coeff[(3 + i) & 31][i] + (15) * coeff[(5 + i) & 31][i] + (-7) * coeff[(7 + i) & 31][i] + (-27) * coeff[(9 + i) & 31][i] + (-41) * coeff[(11 + i) & 31][i] + (-45) * coeff[(13 + i) & 31][i] + (-39) * coeff[(15 + i) & 31][i] + (-23) * coeff[(17 + i) & 31][i] + (-2) * coeff[(19 + i) & 31][i] + (19) * coeff[(21 + i) & 31][i] + (36) * coeff[(23 + i) & 31][i] + (45) * coeff[(25 + i) & 31][i] + (43) * coeff[(27 + i) & 31][i] + (30) * coeff[(29 + i) & 31][i] + (11) * coeff[(31 + i) & 31][i];
			O[3] = (43) * coeff[(1 + i) & 31][i] + (23) * coeff[(3 + i) & 31][i] + (-7) * coeff[(5 + i) & 31][i] + (-34) * coeff[(7 + i) & 31][i] + (-45) * coeff[(9 + i) & 31][i] + (-36) * coeff[(11 + i) & 31][i] + (-11) * coeff[(13 + i) & 31][i] + (19) * coeff[(15 + i) & 31][i] + (41) * coeff[(17 + i) & 31][i] + (44) * coeff[(19 + i) & 31][i] + (27) * coeff[(21 + i) & 31][i] + (-2) * coeff[(23 + i) & 31][i] + (-30) * coeff[(25 + i) & 31][i] + (-45) * coeff[(27 + i) & 31][i] + (-39) * coeff[(29 + i) & 31][i] + (-15) * coeff[(31 + i) & 31][i];
			O[4] = (41) * coeff[(1 + i) & 31][i] + (11) * coeff[(3 + i) & 31][i] + (-27) * coeff[(5 + i) & 31][i] + (-45) * coeff[(7 + i) & 31][i] + (-30) * coeff[(9 + i) & 31][i] + (7) * coeff[(11 + i) & 31][i] + (39) * coeff[(13 + i) & 31][i] + (43) * coeff[(15 + i) & 31][i] + (15) * coeff[(17 + i) & 31][i] + (-23) * coeff[(19 + i) & 31][i] + (-45) * coeff[(21 + i) & 31][i] + (-34) * coeff[(23 + i) & 31][i] + (2) * coeff[(25 + i) & 31][i] + (36) * coeff[(27 + i) & 31][i] + (44) * coeff[(29 + i) & 31][i] + (19) * coeff[(31 + i) & 31][i];
			O[5] = (39) * coeff[(1 + i) & 31][i] + (-2) * coeff[(3 + i) & 31][i] + (-41) * coeff[(5 + i) & 31][i] + (-36) * coeff[(7 + i) & 31][i] + (7) * coeff[(9 + i) & 31][i] + (43) * coeff[(11 + i) & 31][i] + (34) * coeff[(13 + i) & 31][i] + (-11) * coeff[(15 + i) & 31][i] + (-44) * coeff[(17 + i) & 31][i] + (-30) * coeff[(19 + i) & 31][i] + (15) * coeff[(21 + i) & 31][i] + (45) * coeff[(23 + i) & 31][i] + (27) * coeff[(25 + i) & 31][i] + (-19) * coeff[(27 + i) & 31][i] + (-45) * coeff[(29 + i) & 31][i] + (-23) * coeff[(31 + i) & 31][i];
			O[6] = (36) * coeff[(1 + i) & 31][i] + (-15) * coeff[(3 + i) & 31][i] + (-45) * coeff[(5 + i) & 31][i] + (-11) * coeff[(7 + i) & 31][i] + (39) * coeff[(9 + i) & 31][i] + (34) * coeff[(11 + i) & 31][i] + (-19) * coeff[(13 + i) & 31][i] + (-45) * coeff[(15 + i) & 31][i] + (-7) * coeff[(17 + i) & 31][i] + (41) * coeff[(19 + i) & 31][i] + (30) * coeff[(21 + i) & 31][i] + (-23) * coeff[(23 + i) & 31][i] + (-44) * coeff[(25 + i) & 31][i] + (-2) * coeff[(27 + i) & 31][i] + (43) * coeff[(29 + i) & 31][i] + (27) * coeff[(31 + i) & 31][i];
			O[7] = (34) * coeff[(1 + i) & 31][i] + (-27) * coeff[(3 + i) & 31][i] + (-39) * coeff[(5 + i) & 31][i] + (19) * coeff[(7 + i) & 31][i] + (43) * coeff[(9 + i) & 31][i] + (-11) * coeff[(11 + i) & 31][i] + (-45) * coeff[(13 + i) & 31][i] + (2) * coeff[(15 + i) & 31][i] + (45) * coeff[(17 + i) & 31][i] + (7) * coeff[(19 + i) & 31][i] + (-44) * coeff[(21 + i) & 31][i] + (-15) * coeff[(23 + i) & 31][i] + (41) * coeff[(25 + i) & 31][i] + (23) * coeff[(27 + i) & 31][i] + (-36) * coeff[(29 + i) & 31][i] + (-30) * coeff[(31 + i) & 31][i];
			O[8] = (30) * coeff[(1 + i) & 31][i] + (-36) * coeff[(3 + i) & 31][i] + (-23) * coeff[(5 + i) & 31][i] + (41) * coeff[(7 + i) & 31][i] + (15) * coeff[(9 + i) & 31][i] + (-44) * coeff[(11 + i) & 31][i] + (-7) * coeff[(13 + i) & 31][i] + (45) * coeff[(15 + i) & 31][i] + (-2) * coeff[(17 + i) & 31][i] + (-45) * coeff[(19 + i) & 31][i] + (11) * coeff[(21 + i) & 31][i] + (43) * coeff[(23 + i) & 31][i] + (-19) * coeff[(25 + i) & 31][i] + (-39) * coeff[(27 + i) & 31][i] + (27) * coeff[(29 + i) & 31][i] + (34) * coeff[(31 + i) & 31][i];
			O[9] = (27) * coeff[(1 + i) & 31][i] + (-43) * coeff[(3 + i) & 31][i] + (-2) * coeff[(5 + i) & 31][i] + (44) * coeff[(7 + i) & 31][i] + (-23) * coeff[(9 + i) & 31][i] + (-30) * coeff[(11 + i) & 31][i] + (41) * coeff[(13 + i) & 31][i] + (7) * coeff[(15 + i) & 31][i] + (-45) * coeff[(17 + i) & 31][i] + (19) * coeff[(19 + i) & 31][i] + (34) * coeff[(21 + i) & 31][i] + (-39) * coeff[(23 + i) & 31][i] + (-11) * coeff[(25 + i) & 31][i] + (45) * coeff[(27 + i) & 31][i] + (-15) * coeff[(29 + i) & 31][i] + (-36) * coeff[(31 + i) & 31][i];
			O[10] = (23) * coeff[(1 + i) & 31][i] + (-45) * coeff[(3 + i) & 31][i] + (19) * coeff[(5 + i) & 31][i] + (27) * coeff[(7 + i) & 31][i] + (-45) * coeff[(9 + i) & 31][i] + (15) * coeff[(11 + i) & 31][i] + (30) * coeff[(13 + i) & 31][i] + (-44) * coeff[(15 + i) & 31][i] + (11) * coeff[(17 + i) & 31][i] + (34) * coeff[(19 + i) & 31][i] + (-43) * coeff[(21 + i) & 31][i] + (7) * coeff[(23 + i) & 31][i] + (36) * coeff[(25 + i) & 31][i] + (-41) * coeff[(27 + i) & 31][i] + (2) * coeff[(29 + i) & 31][i] + (39) * coeff[(31 + i) & 31][i];
			O[11] = (19) * coeff[(1 + i) & 31][i] + (-44) * coeff[(3 + i) & 31][i] + (36) * coeff[(5 + i) & 31][i] + (-2) * coeff[(7 + i) & 31][i] + (-34) * coeff[(9 + i) & 31][i] + (45) * coeff[(11 + i) & 31][i] + (-23) * coeff[(13 + i) & 31][i] + (-15) * coeff[(15 + i) & 31][i] + (43) * coeff[(17 + i) & 31][i] + (-39) * coeff[(19 + i) & 31][i] + (7) * coeff[(21 + i) & 31][i] + (30) * coeff[(23 + i) & 31][i] + (-45) * coeff[(25 + i) & 31][i] + (27) * coeff[(27 + i) & 31][i] + (11) * coeff[(29 + i) & 31][i] + (-41) * coeff[(31 + i) & 31][i];
			O[12] = (15) * coeff[(1 + i) & 31][i] + (-39) * coeff[(3 + i) & 31][i] + (45) * coeff[(5 + i) & 31][i] + (-30) * coeff[(7 + i) & 31][i] + (2) * coeff[(9 + i) & 31][i] + (27) * coeff[(11 + i) & 31][i] + (-44) * coeff[(13 + i) & 31][i] + (41) * coeff[(15 + i) & 31][i] + (-19) * coeff[(17 + i) & 31][i] + (-11) * coeff[(19 + i) & 31][i] + (36) * coeff[(21 + i) & 31][i] + (-45) * coeff[(23 + i) & 31][i] + (34) * coeff[(25 + i) & 31][i] + (-7) * coeff[(27 + i) & 31][i] + (-23) * coeff[(29 + i) & 31][i] + (43) * coeff[(31 + i) & 31][i];
			O[13] = (11) * coeff[(1 + i) & 31][i] + (-30) * coeff[(3 + i) & 31][i] + (43) * coeff[(5 + i) & 31][i] + (-45) * coeff[(7 + i) & 31][i] + (36) * coeff[(9 + i) & 31][i] + (-19) * coeff[(11 + i) & 31][i] + (-2) * coeff[(13 + i) & 31][i] + (23) * coeff[(15 + i) & 31][i] + (-39) * coeff[(17 + i) & 31][i] + (45) * coeff[(19 + i) & 31][i] + (-41) * coeff[(21 + i) & 31][i] + (27) * coeff[(23 + i) & 31][i] + (-7) * coeff[(25 + i) & 31][i] + (-15) * coeff[(27 + i) & 31][i] + (34) * coeff[(29 + i) & 31][i] + (-44) * coeff[(31 + i) & 31][i];
			O[14] = (7) * coeff[(1 + i) & 31][i] + (-19) * coeff[(3 + i) & 31][i] + (30) * coeff[(5 + i) & 31][i] + (-39) * coeff[(7 + i) & 31][i] + (44) * coeff[(9 + i) & 31][i] + (-45) * coeff[(11 + i) & 31][i] + (43) * coeff[(13 + i) & 31][i] + (-36) * coeff[(15 + i) & 31][i] + (27) * coeff[(17 + i) & 31][i] + (-15) * coeff[(19 + i) & 31][i] + (2) * coeff[(21 + i) & 31][i] + (11) * coeff[(23 + i) & 31][i] + (-23) * coeff[(25 + i) & 31][i] + (34) * coeff[(27 + i) & 31][i] + (-41) * coeff[(29 + i) & 31][i] + (45) * coeff[(31 + i) & 31][i];
			O[15] = (2) * coeff[(1 + i) & 31][i] + (-7) * coeff[(3 + i) & 31][i] + (11) * coeff[(5 + i) & 31][i] + (-15) * coeff[(7 + i) & 31][i] + (19) * coeff[(9 + i) & 31][i] + (-23) * coeff[(11 + i) & 31][i] + (27) * coeff[(13 + i) & 31][i] + (-30) * coeff[(15 + i) & 31][i] + (34) * coeff[(17 + i) & 31][i] + (-36) * coeff[(19 + i) & 31][i] + (39) * coeff[(21 + i) & 31][i] + (-41) * coeff[(23 + i) & 31][i] + (43) * coeff[(25 + i) & 31][i] + (-44) * coeff[(27 + i) & 31][i] + (45) * coeff[(29 + i) & 31][i] + (-45) * coeff[(31 + i) & 31][i];

			EO[0] = (45) * coeff[(2 + i) & 31][i] + (43) * coeff[(6 + i) & 31][i] + (40) * coeff[(10 + i) & 31][i] + (35) * coeff[(14 + i) & 31][i] + (29) * coeff[(18 + i) & 31][i] + (21) * coeff[(22 + i) & 31][i] + (13) * coeff[(26 + i) & 31][i] + (4) * coeff[(30 + i) & 31][i];
			EO[1] = (43) * coeff[(2 + i) & 31][i] + (29) * coeff[(6 + i) & 31][i] + (4) * coeff[(10 + i) & 31][i] + (-21) * coeff[(14 + i) & 31][i] + (-40) * coeff[(18 + i) & 31][i] + (-45) * coeff[(22 + i) & 31][i] + (-35) * coeff[(26 + i) & 31][i] + (-13) * coeff[(30 + i) & 31][i];
			EO[2] = (40) * coeff[(2 + i) & 31][i] + (4) * coeff[(6 + i) & 31][i] + (-35) * coeff[(10 + i) & 31][i] + (-43) * coeff[(14 + i) & 31][i] + (-13) * coeff[(18 + i) & 31][i] + (29) * coeff[(22 + i) & 31][i] + (45) * coeff[(26 + i) & 31][i] + (21) * coeff[(30 + i) & 31][i];
			EO[3] = (35) * coeff[(2 + i) & 31][i] + (-21) * coeff[(6 + i) & 31][i] + (-43) * coeff[(10 + i) & 31][i] + (4) * coeff[(14 + i) & 31][i] + (45) * coeff[(18 + i) & 31][i] + (13) * coeff[(22 + i) & 31][i] + (-40) * coeff[(26 + i) & 31][i] + (-29) * coeff[(30 + i) & 31][i];
			EO[4] = (29) * coeff[(2 + i) & 31][i] + (-40) * coeff[(6 + i) & 31][i] + (-13) * coeff[(10 + i) & 31][i] + (45) * coeff[(14 + i) & 31][i] + (-4) * coeff[(18 + i) & 31][i] + (-43) * coeff[(22 + i) & 31][i] + (21) * coeff[(26 + i) & 31][i] + (35) * coeff[(30 + i) & 31][i];
			EO[5] = (21) * coeff[(2 + i) & 31][i] + (-45) * coeff[(6 + i) & 31][i] + (29) * coeff[(10 + i) & 31][i] + (13) * coeff[(14 + i) & 31][i] + (-43) * coeff[(18 + i) & 31][i] + (35) * coeff[(22 + i) & 31][i] + (4) * coeff[(26 + i) & 31][i] + (-40) * coeff[(30 + i) & 31][i];
			EO[6] = (13) * coeff[(2 + i) & 31][i] + (-35) * coeff[(6 + i) & 31][i] + (45) * coeff[(10 + i) & 31][i] + (-40) * coeff[(14 + i) & 31][i] + (21) * coeff[(18 + i) & 31][i] + (4) * coeff[(22 + i) & 31][i] + (-29) * coeff[(26 + i) & 31][i] + (43) * coeff[(30 + i) & 31][i];
			EO[7] = (4) * coeff[(2 + i) & 31][i] + (-13) * coeff[(6 + i) & 31][i] + (21) * coeff[(10 + i) & 31][i] + (-29) * coeff[(14 + i) & 31][i] + (35) * coeff[(18 + i) & 31][i] + (-40) * coeff[(22 + i) & 31][i] + (43) * coeff[(26 + i) & 31][i] + (-45) * coeff[(30 + i) & 31][i];

			EEO[0] = (44) * coeff[(4 + i) & 31][i] + (38) * coeff[(12 + i) & 31][i] + (25) * coeff[(20 + i) & 31][i] + (9) * coeff[(28 + i) & 31][i];
			EEO[1] = (38) * coeff[(4 + i) & 31][i] + (-9) * coeff[(12 + i) & 31][i] + (-44) * coeff[(20 + i) & 31][i] + (-25) * coeff[(28 + i) & 31][i];
			EEO[2] = (25) * coeff[(4 + i) & 31][i] + (-44) * coeff[(12 + i) & 31][i] + (9) * coeff[(20 + i) & 31][i] + (38) * coeff[(28 + i) & 31][i];
			EEO[3] = (9) * coeff[(4 + i) & 31][i] + (-25) * coeff[(12 + i) & 31][i] + (38) * coeff[(20 + i) & 31][i] + (-44) * coeff[(28 + i) & 31][i];

			EEEO[0] = (42) * coeff[(8 + i) & 31][i] + (17) * coeff[(24 + i) & 31][i];
			EEEO[1] = (17) * coeff[(8 + i) & 31][i] + (-42) * coeff[(24 + i) & 31][i];
			EEEE[0] = (32) * coeff[(0 + i) & 31][i] + (32) * coeff[(16 + i) & 31][i];
			EEEE[1] = (32) * coeff[(0 + i) & 31][i] + (-32) * coeff[(16 + i) & 31][i];
			EEE[0] = EEEE[0] + EEEO[0];
			EEE[3] = EEEE[0] - EEEO[0];
			EEE[1] = EEEE[1] + EEEO[1];
			EEE[2] = EEEE[1] - EEEO[1];
			for (k = 0; k < 4; k++)
			{
				EE[k] = EEE[k] + EEO[k];
				EE[k + 4] = EEE[3 - k] - EEO[3 - k];
			}
			for (k = 0; k < 8; k++)
			{
				E[k] = EE[k] + EO[k];
				E[k + 8] = EE[7 - k] - EO[7 - k];
			}
			for (k = 0; k < 16; k++)
			{
				block[i][k] = Clip3(-(1 << 15), (1 << 15) - 1, (E[k] + O[k] + rnd_factor) >> shift);
				block[i][k + 16] = Clip3(-(1 << 15), (1 << 15) - 1, (E[15 - k] - O[15 - k] + rnd_factor) >> shift);
			}
		}

	}

}

void reconChroma32(U8 cu_width, U8 cu_height, U4 bit_depth, int num_nz, pel pred_cache[32][32], pel rec[32][32], pel resi[32][32],  int *num_nz_out, int rdo_idx, int all_rdo_num)
{
#pragma HLS ARRAY_PARTITION variable=pred_cache complete dim=2		
#pragma HLS ARRAY_PARTITION variable=rec complete dim=2
#pragma HLS ARRAY_PARTITION variable=resi complete dim=2	
	if (rdo_idx < all_rdo_num) {

	recon_32(resi, pred_cache, num_nz,  cu_width, cu_height, rec, bit_depth);
		*num_nz_out = num_nz;
	//if (!type)
	//{
	//	cost += ((enc_ssd_16b_1_32_chroma(cu_width_log2, cu_height_log2, rec, org, s_org, bit_depth)));
	}

}




void calcDiffChroma32( U3 cu_width_log2_chroma, U3 cu_height_log2_chroma, pel orgU[32][32], s16 predOut[32][32], s16 diff[32][32],int rdo_idx, int all_rdo_num)
{
	if (rdo_idx < all_rdo_num) {

	//if (cu_mode != 0) {

		enc_diff_16b_32_chroma(cu_width_log2_chroma, cu_height_log2_chroma, orgU, predOut, 32, diff);
	}
}




static void dquant_Chroma32(U8 cu_width, U8 cu_height, U6 qp, s16 coef[32][32], s16 coef_out[32][32], U3 log2_w, U3 log2_h, U4 bit_depth, int* num_nz_ith, int num_nz_q)
{
#pragma HLS INLINE off
	int w = 1 << log2_w;
	int h = 1 << log2_h;
	int log2_size = (log2_w + log2_h) >> 1;
	int refix = (log2_w + log2_h) & 1;
	static const int com_tbl_dq_scale[80] = { // [64 + 16]
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933,
		65535, 35734, 38968, 42577, 46341, 50617, 55027, 60097,
		32809, 35734, 38968, 42454, 46382, 50576, 55109, 60056,
		65535, 35734, 38968, 42495, 46320, 50515, 55109, 60076,
		65535, 35744, 38968, 42495, 46341, 50535, 55099, 60087,
		65535, 35734, 38973, 42500, 46341, 50535, 55109, 60097,
		32771, 35734, 38965, 42497, 46341, 50535, 55109, 60099,
		32768, 36061, 38968, 42495, 46341, 50535, 55437, 60424,
		32932, 35734, 38968, 42495, 46177, 50535, 55109, 59933
	};
	static const int com_tbl_dq_shift[80] = { // [64 + 16]
		14, 14, 14, 14, 14, 14, 14, 14,  //15, 15, 15, 15, 15, 15, 15, 15,
		13, 13, 13, 13, 13, 13, 13, 13,  //14, 14, 14, 14, 14, 14, 14, 14,
		13, 12, 12, 12, 12, 12, 12, 12,  //14, 13, 13, 13, 13, 13, 13, 13,
		11, 11, 11, 11, 11, 11, 11, 11,  //12, 12, 12, 12, 12, 12, 12, 12,
		11, 10, 10, 10, 10, 10, 10, 10,  //12, 11, 11, 11, 11, 11, 11, 11,
		10, 9, 9, 9, 9, 9, 9, 9,  //11, 10, 10, 10, 10, 10, 10, 10,
		9, 8, 8, 8, 8, 8, 8, 8,  //10,  9,  9,  9,  9,  9,  9,  9,
		7, 7, 7, 7, 7, 7, 7, 7,  // 8,  8,  8,  8,  8,  8,  8,  8,
		6, 6, 6, 6, 6, 6, 6, 6,  // 7,  7,  7,  7,  7,  7,  7,  7,
		5, 5, 5, 5, 5, 5, 5, 5,  // 6,  6,  6,  6,  6,  6,  6,  6
	};
	int scale = com_tbl_dq_scale[qp];
	int shift = com_tbl_dq_shift[qp] - get_transform_shift(bit_depth, log2_size) + 1;
	int offset = (shift == 0) ? 0 : (1 << (shift - 1));
	int sr_x = 0;
	int sr_y = 0;
#if 0
	for (int i = 0; i < 32; i++) {
#pragma HLS PIPELINE
		if (i < cu_height) {
			for (int j = 0; j < 32; j++) {
				if (j < cu_width) {
					int weight = ((i | j) & 0xE0) ? 0 : coef[i][j];
					int lev = (weight * scale + offset) >> shift;
					lev = (lev > 32767 ? 32767 : ((lev < -32768 ? -32768 : lev)));
					if (refix) {
						lev = (lev * 181 + 128) >> 8;
					}
					coef_out[i][j] = (lev);
				}
			}
		}
	}
#else
	s16 coef_tmp[32];
	int lev_tmp;
	#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=0
	s16 i_tmp[32];
#pragma HLS ARRAY_PARTITION variable=i_tmp complete dim=0
	U1 sr_x_flag;
	int sr_y_tmp;
	for (int j = 0; j < 32; j++) {
#pragma HLS PIPELINE
		for (int i = 0; i < 32; i++) {
			coef_tmp[i] = coef[i][j];
		}
		sr_x_flag = 0;
			for (int i = 0; i < 32; i++) {
			if ((i < cu_height)&& (j < cu_width)) {
				if (coef_tmp[i]) {
					//sr_y = i > sr_y ? i : sr_y;
					i_tmp[i] = 1;
					//sr_x = j > sr_x ? j : sr_x;
					sr_x_flag = 1;
					}
				else {
					i_tmp[i] = 0;
				}
				int weight = ((i | j) & 0xE0) ? 0 : coef_tmp[i];
					int lev = (weight * scale + offset) >> shift;
					lev = (lev > 32767) ? 32767 : ((lev < -32768) ? -32768 : lev);
					if (refix) {
						lev = (lev * 181 + 128) >> 8;
					}
				lev_tmp = lev;
			}
			else {
				lev_tmp = 0;
				i_tmp[i] = 0;
			}
			coef_out[i][j] = lev_tmp;
				}
		sr_y_tmp = 0;
		for (int i = 31; i >=0; i--) {
			if (i_tmp[i] == 1) {
				sr_y_tmp = i;
				break;
			}
		}
		if (sr_y< sr_y_tmp) {
			sr_y = sr_y_tmp;
		}
		if(sr_x_flag ) {
			sr_x = j;
		}
	}
	*num_nz_ith = (sr_y << 20) + (sr_x << 12) + num_nz_q;
#endif
}
void dquantChroma32(U8 w, U8 h, U4 bit_depth, U6 qp_y, int *num_nz, s16 coef_tmp[32][32], s16 coef_dq[32][32],  int num_nz_q, int cu_width_log2_chroma,  int cu_height_log2_chroma, int rdo_idx, int all_rdo_num)
{
#pragma HLS ARRAY_PARTITION variable=coef_tmp complete dim=1
#pragma HLS ARRAY_PARTITION variable=coef_dq complete dim=1
	U3 tb_width_log2 = cu_width_log2_chroma;// com_tbl_log2[w];
	U3 tb_height_log2 = cu_height_log2_chroma;// com_tbl_log2[h];
	if (rdo_idx < all_rdo_num) {
	//for (int i = 0; i < 32; i++)
	//{
	//	for (int j = 0; j < 32; j++)
	//	{
	//		coef_dq[i][j] = 0;
	//	}
	//}

	if (num_nz_q) {
		dquant_Chroma32(w, h, qp_y, coef_tmp, coef_dq, tb_width_log2, tb_height_log2, bit_depth, num_nz, num_nz_q);
	}
	else {
		*num_nz = 0;
		}
	}
}


void invTransVerChroma32(int cu_width_log2_chroma, U8 w, U8 h, U4 bit_depth, U6 qp_y, int num_nz, int *num_nz1, s16 coef_dq[32][32], s16 coef_tmp[32][32], int rdo_idx, int all_rdo_num)
{
	U3 tb_width_log2 = cu_width_log2_chroma;// com_tbl_log2[w];
	*num_nz1 = num_nz;
	if (rdo_idx < all_rdo_num) {
	if (num_nz) {
			itrans_v_32(w, h, coef_dq, coef_tmp, tb_width_log2, bit_depth);
		}
	}
}


void invTransHorChroma32(U8 w, U8 h, U4 bit_depth, int num_nz, int *num_nz2, U3 cu_height_log2, s16 coef_temp[32][32],  pel resi[32][32], int rdo_idx, int all_rdo_num)
{

	*num_nz2 = num_nz;
	if (rdo_idx < all_rdo_num) {
	if (num_nz) {
			itrans_h_32(w, h, resi, coef_temp, cu_height_log2, bit_depth);
	}
	}
}


void updateBestModeChroma32_phase(int num_nz[12],
	s64 cost[6], s16 rec_tmp[12][32][32], s16 coef_uv_pb_part[12][32][32], pel pred[12][32][32],
int *num_nz1,
int * num_nz2,
s16 rec_tmp_buf_u[32][32],
s16 coef_buf_u[32][32],
pel pred_buf_u[32][32],

s16 rec_tmp_buf_v[32][32],
s16 coef_buf_v[32][32],
pel pred_buf_v[32][32],
int *best_ipd_tmp
)
{
	static s64 cost_best1 ;
	cost_best1 = 9223372036854775807;
	static int best_ipd1 ;
		 best_ipd1 = 0;
	*num_nz1 = 0;
	*num_nz2 = 0;
	for (int rdo_idx = 0; rdo_idx < 6; rdo_idx++) {
#pragma HLS UNROLL
		if (cost[rdo_idx] < cost_best1) {
			cost_best1 = cost[rdo_idx];
			best_ipd1 = rdo_idx;
		}
	}
	*num_nz1 = num_nz[best_ipd1 * 2];
	*num_nz2 = num_nz[best_ipd1 * 2 + 1];
	*best_ipd_tmp = best_ipd1;

	for (U8 i = 0; i < 32; i++)
	{
#pragma HLS PIPELINE
		for (U8 j = 0; j < 32; j++) 
		{
			rec_tmp_buf_u[i][j] = rec_tmp[best_ipd1 * 2][i][j];
			pred_buf_u[i][j] = pred[best_ipd1 * 2][i][j];;
		}
		for (U8 j = 0; j < 32; j++)
		{
			rec_tmp_buf_v[i][j] = rec_tmp[best_ipd1 * 2 + 1][i][j];
			pred_buf_v[i][j] = pred[best_ipd1 * 2 + 1][i][j];
		}
		if (i==0) {for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; }}
		else if (i == 1) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 2) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 3) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 4) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 5) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 6) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 7) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 8) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 9) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 10) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 11) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 12) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 13) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 14) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 15) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 16) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 17) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 18) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 19) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 20) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 21) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 22) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 23) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 24) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 25) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 26) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 27) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 28) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 29) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 30) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		else if (i == 31) { for (U8 j = 0; j < 32; j++) { coef_buf_u[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2][j][i]; } }
		if (i == 0) {for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; }}
		else if (i == 1) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 2) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 3) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 4) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 5) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 6) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 7) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 8) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 9) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 10) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 11) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 12) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 13) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 14) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 15) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 16) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 17) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 18) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 19) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 20) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 21) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 22) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 23) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 24) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 25) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 26) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 27) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 28) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 29) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 30) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
		else if (i == 31) { for (U8 j = 0; j < 32; j++) { coef_buf_v[(j + i) & 31][i] = coef_uv_pb_part[best_ipd1 * 2 + 1][j][i]; } }
	}
}

void updateModeChroma32_coefu_mux(int i,s16 coef_buf_u_tmp[32],s16 coef_buf_u[32][32])
{
#pragma HLS INLINE
	if (i == 0) {
		for (U8 j = 0; j < 32; j++){coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j]; }
	}
	else if (i == 1) {
		for (U8 j = 0; j < 32; j++){coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j]; }
	}
	else if (i == 2) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];}
	}
	else if (i == 3) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 4) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 5) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 6) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 7) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 8) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 9) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 10) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 11) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 12) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 13) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 14) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 15) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 16) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 17) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 18) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 19) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 20) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 21) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 22) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 23) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 24) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 25) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 26) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 27) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 28) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 29) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 30) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}
	else if (i == 31) {
		for (U8 j = 0; j < 32; j++) { coef_buf_u_tmp[j] = coef_buf_u[(j + i) & 31][j];  }
	}

}
void updateModeChroma32_coefv_mux(int i,s16 coef_buf_v_tmp[32],s16 coef_buf_v[32][32])
{
#pragma HLS INLINE
	if (i == 0) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 1) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 2) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 3) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 4) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 5) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 6) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 7) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 8) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 9) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 10) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 11) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 12) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 13) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 14) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 15) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 16) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 17) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 18) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 19) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 20) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 21) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 22) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 23) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 24) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 25) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 26) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 27) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 28) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 29) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 30) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
	else if (i == 31) {
		for (U8 j = 0; j < 32; j++) {  coef_buf_v_tmp[j] = coef_buf_v[(j + i) & 31][j]; }
	}
}
void updateBestModeChroma32_phase1(
	U2 cu_mode, MD_COM_MODE_BEST* mod_info_best, U4 bit_depth,
	int num_nz[12],
	int num_nz1,
	int num_nz2,
	int best_ipd,
	s16 rec_tmp_buf_u[32][32],
	s16 coef_buf_u[32][32],
	pel pred_buf_u[32][32],
	s16 rec_tmp_buf_v[32][32],
	s16 coef_buf_v[32][32],
	pel pred_buf_v[32][32],
	pel mod_info_best_rec_u[32][32],
	pel mod_info_best_rec_v[32][32],
	pel mod_info_best_coef_u[32][32],
	pel mod_info_best_coef_v[32][32]
) {
	int w = 32;
	int h = 32;
	int j, k;

	s16 coef_buf_u_tmp[32];
	s16 coef_buf_v_tmp[32];
#pragma HLS ARRAY_PARTITION variable=coef_buf_u_tmp complete  dim=0
#pragma HLS ARRAY_PARTITION variable=coef_buf_v_tmp complete  dim=0
	if (cu_mode == 0) {

			
			//memcpy_rewrintra_2d_to_1d_32(mod_info_best->rec_u, rec_tmp2, cu_width_log2 - 1, cu_height_log2 - 1);
			//memcpy_rewrintra_2d_to_1d_32(mod_info_best->rec_v, rec_tmp, cu_width_log2 - 1, cu_height_log2 - 1);

			//memcpy_rewrintra(mod_info_best->coef_u, coef_uv_pb_part[0], size_tmp);
			//memcpy_rewrintra(mod_info_best->coef_v, coef_uv_pb_part[1], size_tmp);
			for (U8 i = 0; i < h; i++)
			{
#pragma HLS PIPELINE
				for (U8 j = 0; j < w; j++)
				{
				mod_info_best_rec_u[i][j] = rec_tmp_buf_u[i][j];

				mod_info_best_rec_v[i][j] = rec_tmp_buf_v[i][j];
				}
			updateModeChroma32_coefu_mux(i, coef_buf_u_tmp, coef_buf_u);
			updateModeChroma32_coefv_mux(i, coef_buf_v_tmp, coef_buf_v);
			for (U8 j = 0; j < w; j++)
			{
				mod_info_best_coef_u[i][j] = coef_buf_u_tmp[j];// coef_buf_u[(j + i) & 31][j];
				mod_info_best_coef_v[i][j] = coef_buf_v_tmp[j];// coef_buf_v[(j + i) & 31][j];
			}


		}

#if USE_TSCPM
		mod_info_best->ipm[0][1] = best_ipd;
			mod_info_best->num_nz[0][1] = num_nz1;
			mod_info_best->num_nz[0][2] = num_nz2;
#else
		mod_info_best->ipm[0][1] = best_ipd;
		mod_info_best->num_nz[0][1] = num_nz1;
		mod_info_best->num_nz[0][2] = num_nz2;
#endif
	}
	else {
		
		if (cu_mode == 2) {
			mod_info_best->num_nz[0][1] = 0;
			mod_info_best->num_nz[0][2] = 0;
		}
		else {
			mod_info_best->num_nz[0][1] = num_nz[best_ipd * 2];
			mod_info_best->num_nz[0][2] = num_nz[best_ipd * 2 + 1];
		}




			//mod_info_best_ptr->num_nz[0][i + 1] = 0;
			//mod_info_best_ptr->num_nz[0][i + 1] = 0;
			for (k = 0; k < h; ++k) {
#pragma HLS PIPELINE
				if (mod_info_best->num_nz[0][1] == 0) {
				for (j = 0; j < w; j++) {
						mod_info_best_coef_u[k][j] = 0;
						mod_info_best_rec_u[k][j] = (pel)((0 > pred_buf_u[k][j]) ? 0 : ((1 << bit_depth) - 1) < pred_buf_u[k][j] ? ((1 << bit_depth) - 1) : pred_buf_u[k][j]);
					}
				}
				else {
					for (j = 0; j < w; j++) {
						mod_info_best_rec_u[k][j] = (pel)((0 > rec_tmp_buf_u[k][j]) ? 0 : ((1 << bit_depth) - 1) < (rec_tmp_buf_u[k][j]) ? ((1 << bit_depth) - 1) : (rec_tmp_buf_u[k][j]));
					}
					updateModeChroma32_coefu_mux(k, coef_buf_u_tmp, coef_buf_u);
					for (j = 0; j < w; j++)
					{
						mod_info_best_coef_u[k][j] = coef_buf_u_tmp[j];// coef_buf_u[(k + j) & 31][j];
					}
				}
				if (mod_info_best->num_nz[0][2] == 0) {
					for (j = 0; j < w; j++) {
						mod_info_best_coef_v[k][j] = 0;
						mod_info_best_rec_v[k][j] = (((0 > pred_buf_v[k][j] ? 0 : (((1 << bit_depth) - 1 < (pred_buf_v[k][j]) ? (1 << bit_depth) - 1 : (pred_buf_v[k][j]))))));
			}
		}
		else {
			//mod_info_best->num_nz[0][i + 1] = mod_info_best_ptr->num_nz[0][i + 1];
				for (j = 0; j < w; j++) {
						mod_info_best_rec_v[k][j] = ((pel)((0 > rec_tmp_buf_v[k][j] ? 0 : (((1 << bit_depth) - 1 < (rec_tmp_buf_v[k][j]) ? (1 << bit_depth) - 1 : (rec_tmp_buf_v[k][j]))))));

					}
					updateModeChroma32_coefv_mux(k, coef_buf_v_tmp, coef_buf_v);
					for (j = 0; j < w; j++)
					{
						mod_info_best_coef_v[k][j] = coef_buf_v_tmp[j];
					}
				}
			}
		}

	}
void updateBestModeChroma32(int cu_width_chroma,  int cu_height_chroma, U2 cu_mode, MD_COM_MODE_BEST* mod_info_best,
	s16 rec_tmp[12][32][32],   s16 coef_uv_pb_part[12][32][32],    s64 cost[6], 
	 U4 bit_depth, pel pred[12][32][32], int num_nz[12],
	pel mod_info_best_rec_u[32][32],
	pel mod_info_best_rec_v[32][32],
	pel mod_info_best_coef_u[32][32],
	pel mod_info_best_coef_v[32][32]
)
{
#pragma HLS ARRAY_PARTITION variable=rec_tmp complete dim=3	
//#pragma HLS ARRAY_PARTITION variable=rec_tmp cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=coef_uv_pb_part complete dim=2		
//#pragma HLS ARRAY_PARTITION variable=coef_uv_pb_part cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=cost complete dim=0
#pragma HLS ARRAY_PARTITION variable=num_nz complete dim=0	
#pragma HLS ARRAY_PARTITION variable=pred complete dim=3	
//#pragma HLS ARRAY_PARTITION variable=pred cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=mod_info_best_rec_u complete  dim=2
#pragma HLS ARRAY_PARTITION variable=mod_info_best_rec_v complete  dim=2
#pragma HLS ARRAY_PARTITION variable=mod_info_best_coef_u complete dim=2
#pragma HLS ARRAY_PARTITION variable=mod_info_best_coef_v complete dim=2
	int best_ipd;
	int num_nz1;
	int num_nz2;
	s16 rec_tmp_buf_u[32][32];
	s16 coef_buf_u[32][32];
	pel pred_buf_u[32][32];
	s16 rec_tmp_buf_v[32][32];
	s16 coef_buf_v[32][32];
	pel pred_buf_v[32][32];
#pragma HLS ARRAY_PARTITION variable=rec_tmp_buf_u complete  dim=2
#pragma HLS ARRAY_PARTITION variable=rec_tmp_buf_v complete  dim=2
#pragma HLS ARRAY_PARTITION variable=pred_buf_u complete  dim=2
#pragma HLS ARRAY_PARTITION variable=pred_buf_v complete  dim=2
#pragma HLS ARRAY_PARTITION variable=coef_buf_u complete  dim=1
#pragma HLS ARRAY_PARTITION variable=coef_buf_v complete  dim=1
	updateBestModeChroma32_phase(num_nz,
		cost, rec_tmp, coef_uv_pb_part, pred,
		&num_nz1,
		&num_nz2,
		rec_tmp_buf_u,
		coef_buf_u,
		pred_buf_u,
		rec_tmp_buf_v,
		coef_buf_v,
		pred_buf_v,
		& best_ipd
	);
	updateBestModeChroma32_phase1(
		 cu_mode,  mod_info_best,  bit_depth,
		 num_nz,
		 num_nz1,
		 num_nz2,
		 best_ipd,
		 rec_tmp_buf_u,
		 coef_buf_u,
		 pred_buf_u,
		 rec_tmp_buf_v,
		 coef_buf_v,
		 pred_buf_v,
		 mod_info_best_rec_u,
		 mod_info_best_rec_v,
		 mod_info_best_coef_u,
		 mod_info_best_coef_v
	);
}


//#endif


void rdo_chroma_dataflow_32_x(MD_INPUT* md_input_ptr,
int all_rdo_num, int bit_depth, MD_FW* md_fw_ptr, U2 tree_status, RDOQ_ARRAY* rdoq_array,MD_COM_MODE_BEST* mod_info_best,
int cu_width_log2_chroma, int cu_width_chroma, int cu_height_log2_chroma, int cu_height_chroma,
pel orgU[2][32][32], pel pred[12][32][32],pel pred0[12][32][32],
pel rec_tmp[12][32][32],s16 coef_q[12][32][32],int num_nz_out[12]
) 
{
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_cbf complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_run complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_level complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_last complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_input_ptr->lambda complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_best->ipm complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_input_ptr->dist_chroma_weight complete dim=0
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred complete dim=3	
#pragma HLS ARRAY_PARTITION variable=pred0 complete dim=3
#pragma HLS ARRAY_PARTITION variable=rec_tmp complete dim=3		
#pragma HLS ARRAY_PARTITION variable=coef_q complete dim=2
#pragma HLS ARRAY_PARTITION variable=num_nz_out complete dim=0
#pragma HLS RESOURCE variable=orgU core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred0 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=rec_tmp core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_q core=RAM_S2P_BRAM

	U1 uv;

	for (int rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {
#pragma HLS DATAFLOW
#pragma HLS LOOP_TRIPCOUNT min=12 max=12 avg=12
		uv = rdo_idx & 1;
		 pel diff[32][32];
		 s16 coefHor[32][32];
		 s16 coefVer[32][32];
		 s16 coefVer_q[32][32];
		 s16 coefIVer[32][32];
		 pel resi[32][32];
		 s16 coef_dq[32][32];
		 S16 tmp_dst_coef[32][32];
		 int final_x;
		 int final_y;
		 int num_nz_q;
		 int num_nz0;
		 int num_nz1;
		 int num_nz2;
#pragma HLS RESOURCE variable=diff core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefHor core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefVer core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefVer_q core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefIVer core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=resi core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_dq core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=tmp_dst_coef core=RAM_S2P_BRAM

		calcDiffChroma32( cu_width_log2_chroma, cu_height_log2_chroma, orgU[uv], pred[rdo_idx], diff, rdo_idx, all_rdo_num);
		transform_hor_32_chroma( cu_width_log2_chroma,cu_width_chroma, cu_height_chroma, bit_depth, diff, coefHor, rdo_idx, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma,cu_width_chroma, cu_height_chroma,  bit_depth, coefHor, coefVer, rdo_idx, all_rdo_num);

		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer, md_input_ptr->qp_u, tmp_dst_coef,
				rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level,
				rdoq_array->rdoq_est_last,  md_input_ptr->lambda[1], bit_depth, &final_x, &final_y, uv, rdo_idx, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q, tmp_dst_coef, final_x, final_y, coef_q[rdo_idx], coefVer_q, rdo_idx, all_rdo_num);

		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0, coefVer_q, coef_dq,  num_nz_q,  cu_width_log2_chroma,  cu_height_log2_chroma, rdo_idx, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma,cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0, &num_nz1, coef_dq, coefIVer, rdo_idx, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1, &num_nz2, cu_height_log2_chroma, coefIVer,  resi, rdo_idx, all_rdo_num);
		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2,  pred0[rdo_idx],rec_tmp[rdo_idx],  resi,  &num_nz_out[rdo_idx], rdo_idx, all_rdo_num);
	
	}
}

void rdo_chroma_dataflow_32(MD_INPUT* md_input_ptr,
	int all_rdo_num, int bit_depth, MD_FW* md_fw_ptr, U2 tree_status, RDOQ_ARRAY* rdoq_array, MD_COM_MODE_BEST* mod_info_best,
	int cu_width_log2_chroma, int cu_width_chroma, int cu_height_log2_chroma, int cu_height_chroma,
	pel orgU[2][32][32], pel pred[12][32][32], pel pred0[12][32][32],
	pel rec_tmp[12][32][32], s16 coef_q[12][32][32], int num_nz_out[12]
)
{
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_cbf complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_run complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_level complete dim=0
#pragma HLS ARRAY_PARTITION variable=rdoq_array->rdoq_est_last complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_input_ptr->lambda complete dim=0
#pragma HLS ARRAY_PARTITION variable=mod_info_best->ipm complete dim=0
#pragma HLS ARRAY_PARTITION variable=md_input_ptr->dist_chroma_weight complete dim=0
#pragma HLS ARRAY_PARTITION variable=orgU complete dim=3
#pragma HLS ARRAY_PARTITION variable=pred complete dim=3	
#pragma HLS ARRAY_PARTITION variable=pred0 complete dim=3
#pragma HLS ARRAY_PARTITION variable=rec_tmp complete dim=3		
#pragma HLS ARRAY_PARTITION variable=coef_q complete dim=2
#pragma HLS ARRAY_PARTITION variable=num_nz_out complete dim=0
#pragma HLS RESOURCE variable=orgU core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=pred0 core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=rec_tmp core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_q core=RAM_S2P_BRAM

		pel diff[2][32][32];
		s16 coefHor[2][32][32];
		s16 coefVer[2][32][32];
		s16 coefVer_q[2][32][32];
		s16 coefIVer[2][32][32];
		pel resi[2][32][32];
		s16 coef_dq[2][32][32];
		S16 tmp_dst_coef[2][32][32];
		int final_x[2];
		int final_y[2];
		int num_nz_q[2];
		int num_nz0[2];
		int num_nz1[2];
		int num_nz2[2];
#pragma HLS RESOURCE variable=diff core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefHor core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefVer core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefVer_q core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coefIVer core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=resi core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=coef_dq core=RAM_S2P_BRAM
#pragma HLS RESOURCE variable=tmp_dst_coef core=RAM_S2P_BRAM

		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[0], pred[0], diff[0], 0, all_rdo_num);

		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[0], coefHor[0], 0, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[1], pred[1], diff[1], 1, all_rdo_num);

		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[0], coefVer[0], 0, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[1], coefHor[1], 1, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[0], pred[2], diff[0], 2, all_rdo_num);

		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[0], md_input_ptr->qp_u, tmp_dst_coef[0], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[0], &final_y[0], 0, 0, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[1], coefVer[1], 1, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[0], coefHor[0], 2, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[1], pred[3], diff[1], 3, all_rdo_num);


		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[0], tmp_dst_coef[0], final_x[0], final_y[0], coef_q[0], coefVer_q[0], 0, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[1], md_input_ptr->qp_u, tmp_dst_coef[1], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[1], &final_y[1], 1, 1, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[0], coefVer[0], 2, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[1], coefHor[1], 3, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[0], pred[4], diff[0], 4, all_rdo_num);


		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[0], coefVer_q[0], coef_dq[0], num_nz_q[0], cu_width_log2_chroma, cu_height_log2_chroma, 0, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[1], tmp_dst_coef[1], final_x[1], final_y[1], coef_q[1], coefVer_q[1], 1, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[0], md_input_ptr->qp_u, tmp_dst_coef[0], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[0], &final_y[0], 0, 2, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[1], coefVer[1], 3, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[0], coefHor[0], 4, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[1], pred[5], diff[1], 5, all_rdo_num);

		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[0], &num_nz1[0], coef_dq[0], coefIVer[0], 0, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[1], coefVer_q[1], coef_dq[1], num_nz_q[1], cu_width_log2_chroma, cu_height_log2_chroma, 1, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[0], tmp_dst_coef[0], final_x[0], final_y[0], coef_q[2], coefVer_q[0], 2, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[1], md_input_ptr->qp_u, tmp_dst_coef[1], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[1], &final_y[1], 1, 3, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[0], coefVer[0], 4, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[1], coefHor[1], 5, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[0], pred[6], diff[0], 6, all_rdo_num);

		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[0], &num_nz2[0], cu_height_log2_chroma, coefIVer[0], resi[0], 0, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[1], &num_nz1[1], coef_dq[1], coefIVer[1], 1, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[0], coefVer_q[0], coef_dq[0], num_nz_q[0], cu_width_log2_chroma, cu_height_log2_chroma, 2, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[1], tmp_dst_coef[1], final_x[1], final_y[1], coef_q[3], coefVer_q[1], 3, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[0], md_input_ptr->qp_u, tmp_dst_coef[0], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[0], &final_y[0], 0, 4, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[1], coefVer[1], 5, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[0], coefHor[0], 6, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[1], pred[7], diff[1], 7, all_rdo_num);


		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[0], pred0[0], rec_tmp[0], resi[0], &num_nz_out[0], 0, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[1], &num_nz2[1], cu_height_log2_chroma, coefIVer[1], resi[1], 1, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[0], &num_nz1[0], coef_dq[0], coefIVer[0], 2, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[1], coefVer_q[1], coef_dq[1], num_nz_q[1], cu_width_log2_chroma, cu_height_log2_chroma, 3, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[0], tmp_dst_coef[0], final_x[0], final_y[0], coef_q[4], coefVer_q[0], 4, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[1], md_input_ptr->qp_u, tmp_dst_coef[1], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[1], &final_y[1], 1, 5, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[0], coefVer[0], 6, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[1], coefHor[1], 7, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[0], pred[8], diff[0], 8, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[1], pred0[1], rec_tmp[1], resi[1], &num_nz_out[1], 1, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[0], &num_nz2[0], cu_height_log2_chroma, coefIVer[0], resi[0], 2, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[1], &num_nz1[1], coef_dq[1], coefIVer[1], 3, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[0], coefVer_q[0], coef_dq[0], num_nz_q[0], cu_width_log2_chroma, cu_height_log2_chroma, 4, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[1], tmp_dst_coef[1], final_x[1], final_y[1], coef_q[5], coefVer_q[1], 5, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[0], md_input_ptr->qp_u, tmp_dst_coef[0], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[0], &final_y[0], 0, 6, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[1], coefVer[1], 7, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[0], coefHor[0], 8, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[1], pred[9], diff[1], 9, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[0], pred0[2], rec_tmp[2], resi[0], &num_nz_out[2], 2, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[1], &num_nz2[1], cu_height_log2_chroma, coefIVer[1], resi[1], 3, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[0], &num_nz1[0], coef_dq[0], coefIVer[0], 4, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[1], coefVer_q[1], coef_dq[1], num_nz_q[1], cu_width_log2_chroma, cu_height_log2_chroma, 5, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[0], tmp_dst_coef[0], final_x[0], final_y[0], coef_q[6], coefVer_q[0], 6, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[1], md_input_ptr->qp_u, tmp_dst_coef[1], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[1], &final_y[1], 1, 7, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[0], coefVer[0], 8, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[1], coefHor[1], 9, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[0], pred[10], diff[0], 10, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[1], pred0[3], rec_tmp[3], resi[1], &num_nz_out[3], 3, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[0], &num_nz2[0], cu_height_log2_chroma, coefIVer[0], resi[0], 4, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[1], &num_nz1[1], coef_dq[1], coefIVer[1], 5, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[0], coefVer_q[0], coef_dq[0], num_nz_q[0], cu_width_log2_chroma, cu_height_log2_chroma, 6, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[1], tmp_dst_coef[1], final_x[1], final_y[1], coef_q[7], coefVer_q[1], 7, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[0], md_input_ptr->qp_u, tmp_dst_coef[0], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[0], &final_y[0], 0, 8, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[1], coefVer[1], 9, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[0], coefHor[0], 10, all_rdo_num);
		calcDiffChroma32(cu_width_log2_chroma, cu_height_log2_chroma, orgU[1], pred[11], diff[1], 11, all_rdo_num);


		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[0], pred0[4], rec_tmp[4], resi[0], &num_nz_out[4], 4, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[1], &num_nz2[1], cu_height_log2_chroma, coefIVer[1], resi[1], 5, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[0], &num_nz1[0], coef_dq[0], coefIVer[0], 6, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[1], coefVer_q[1], coef_dq[1], num_nz_q[1], cu_width_log2_chroma, cu_height_log2_chroma, 7, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[0], tmp_dst_coef[0], final_x[0], final_y[0], coef_q[8], coefVer_q[0], 8, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[1], md_input_ptr->qp_u, tmp_dst_coef[1], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[1], &final_y[1], 1, 9, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[0], coefVer[0], 10, all_rdo_num);
		transform_hor_32_chroma(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, diff[1], coefHor[1], 11, all_rdo_num);


		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[1], pred0[5], rec_tmp[5], resi[1], &num_nz_out[5], 5, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[0], &num_nz2[0], cu_height_log2_chroma, coefIVer[0], resi[0], 6, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[1], &num_nz1[1], coef_dq[1], coefIVer[1], 7, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[0], coefVer_q[0], coef_dq[0], num_nz_q[0], cu_width_log2_chroma, cu_height_log2_chroma, 8, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[1], tmp_dst_coef[1], final_x[1], final_y[1], coef_q[9], coefVer_q[1], 9, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[0], md_input_ptr->qp_u, tmp_dst_coef[0], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[0], &final_y[0], 0, 10, all_rdo_num);
		transform_ver_32_chroma(cu_height_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, coefHor[1], coefVer[1], 11, all_rdo_num);


		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[0], pred0[6], rec_tmp[6], resi[0], &num_nz_out[6], 6, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[1], &num_nz2[1], cu_height_log2_chroma, coefIVer[1], resi[1], 7, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[0], &num_nz1[0], coef_dq[0], coefIVer[0], 8, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[1], coefVer_q[1], coef_dq[1], num_nz_q[1], cu_width_log2_chroma, cu_height_log2_chroma, 9, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[0], tmp_dst_coef[0], final_x[0], final_y[0], coef_q[10], coefVer_q[0], 10, all_rdo_num);
		rdoq_32_all_hardware_chroma(cu_width_log2_chroma, cu_height_log2_chroma, coefVer[1], md_input_ptr->qp_u, tmp_dst_coef[1], rdoq_array->rdoq_est_cbf, rdoq_array->rdoq_est_run, rdoq_array->rdoq_est_level, rdoq_array->rdoq_est_last, md_input_ptr->lambda[1], bit_depth, &final_x[1], &final_y[1], 1, 11, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[1], pred0[7], rec_tmp[7], resi[1], &num_nz_out[7], 7, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[0], &num_nz2[0], cu_height_log2_chroma, coefIVer[0], resi[0], 8, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[1], &num_nz1[1], coef_dq[1], coefIVer[1], 9, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[0], coefVer_q[0], coef_dq[0], num_nz_q[0], cu_width_log2_chroma, cu_height_log2_chroma, 10, all_rdo_num);
		CleanNz_32_all_Chroma32(cu_width_chroma, cu_height_chroma, &num_nz_q[1], tmp_dst_coef[1], final_x[1], final_y[1], coef_q[11], coefVer_q[1], 11, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[0], pred0[8], rec_tmp[8], resi[0], &num_nz_out[8], 8, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[1], &num_nz2[1], cu_height_log2_chroma, coefIVer[1], resi[1], 9, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[0], &num_nz1[0], coef_dq[0], coefIVer[0], 10, all_rdo_num);
		dquantChroma32(cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, &num_nz0[1], coefVer_q[1], coef_dq[1], num_nz_q[1], cu_width_log2_chroma, cu_height_log2_chroma, 11, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[1], pred0[9], rec_tmp[9], resi[1], &num_nz_out[9], 9, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[0], &num_nz2[0], cu_height_log2_chroma, coefIVer[0], resi[0], 10, all_rdo_num);
		invTransVerChroma32(cu_width_log2_chroma, cu_width_chroma, cu_height_chroma, bit_depth, md_input_ptr->qp_u, num_nz0[1], &num_nz1[1], coef_dq[1], coefIVer[1], 11, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[0], pred0[10], rec_tmp[10], resi[0], &num_nz_out[10], 10, all_rdo_num);
		invTransHorChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz1[1], &num_nz2[1], cu_height_log2_chroma, coefIVer[1], resi[1], 11, all_rdo_num);

		reconChroma32(cu_width_chroma, cu_height_chroma, bit_depth, num_nz2[1], pred0[11], rec_tmp[11], resi[1], &num_nz_out[11], 11, all_rdo_num);


}

#if !CHROMA_32_PIPELINE_DUMMY
void rdo_chroma_pipeline_32_pred(int all_rdo_num, U13 pb_x, U13 pb_y,
	int cu_width_log2_chroma, int cu_width_chroma, int cu_height_log2_chroma, int cu_height_chroma, int bit_depth, MD_COM_MODE_BEST* mod_info_best, MD_FW* md_fw_ptr,

	pel pred[12][32][32], pel pred0[12][32][32], strFetch_ref_window* Fetch_Ref_window_ptr,
	pel piRecoY[64][64]
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
	,
	pel IP_buffer_ptr_U_32x32_up_line[2 * 32], pel IP_buffer_ptr_U_32x32_left_line[2 * 32], pel IP_buffer_ptr_U_32x32_top_left,
	pel IP_buffer_ptr_V_32x32_up_line[2 * 32], pel IP_buffer_ptr_V_32x32_left_line[2 * 32], pel IP_buffer_ptr_V_32x32_top_left,
	pel IP_buffer_ptr_U_16x32_up_line[2 * 16], pel IP_buffer_ptr_U_16x32_left_line[2 * 32], pel IP_buffer_ptr_U_16x32_top_left,
	pel IP_buffer_ptr_V_16x32_up_line[2 * 16], pel IP_buffer_ptr_V_16x32_left_line[2 * 32], pel IP_buffer_ptr_V_16x32_top_left,
	pel IP_buffer_ptr_U_32x16_up_line[2 * 32], pel IP_buffer_ptr_U_32x16_left_line[2 * 16], pel IP_buffer_ptr_U_32x16_top_left,
	pel IP_buffer_ptr_V_32x16_up_line[2 * 32], pel IP_buffer_ptr_V_32x16_left_line[2 * 16], pel IP_buffer_ptr_V_32x16_top_left,
	pel IP_buffer_ptr_U_8x32_up_line[2 * 8], pel IP_buffer_ptr_U_8x32_left_line[2 * 32], pel IP_buffer_ptr_U_8x32_top_left,
	pel IP_buffer_ptr_V_8x32_up_line[2 * 8], pel IP_buffer_ptr_V_8x32_left_line[2 * 32], pel IP_buffer_ptr_V_8x32_top_left,
	pel IP_buffer_ptr_U_32x8_up_line[2 * 32], pel IP_buffer_ptr_U_32x8_left_line[2 * 8], pel IP_buffer_ptr_U_32x8_top_left,
	pel IP_buffer_ptr_V_32x8_up_line[2 * 32], pel IP_buffer_ptr_V_32x8_left_line[2 * 8], pel IP_buffer_ptr_V_32x8_top_left,
	pel IP_buffer_ptr_U_4x32_up_line[2 * 4], pel IP_buffer_ptr_U_4x32_left_line[2 * 32], pel IP_buffer_ptr_U_4x32_top_left,
	pel IP_buffer_ptr_V_4x32_up_line[2 * 4], pel IP_buffer_ptr_V_4x32_left_line[2 * 32], pel IP_buffer_ptr_V_4x32_top_left,
	pel IP_buffer_ptr_U_32x4_up_line[2 * 32], pel IP_buffer_ptr_U_32x4_left_line[2 * 4], pel IP_buffer_ptr_U_32x4_top_left,
	pel IP_buffer_ptr_V_32x4_up_line[2 * 32], pel IP_buffer_ptr_V_32x4_left_line[2 * 4], pel IP_buffer_ptr_V_32x4_top_left,
	pel IP_buffer_ptr_64x64_up_line[128], pel IP_buffer_ptr_64x64_left_line[64], pel IP_buffer_ptr_64x64_top_left,
	pel IP_buffer_ptr_32x64_up_line[2 * 32], pel IP_buffer_ptr_32x64_left_line[2 * 64], pel IP_buffer_ptr_32x64_top_left,
	pel IP_buffer_ptr_64x32_up_line[2 * 64], pel IP_buffer_ptr_64x32_left_line[2 * 32], pel IP_buffer_ptr_64x32_top_left,
	pel IP_buffer_ptr_16x64_up_line[2 * 16], pel IP_buffer_ptr_16x64_left_line[2 * 64], pel IP_buffer_ptr_16x64_top_left,
	pel IP_buffer_ptr_64x16_up_line[2 * 64], pel IP_buffer_ptr_64x16_left_line[2 * 16], pel IP_buffer_ptr_64x16_top_left,
	pel IP_buffer_ptr_8x64_up_line[2 * 8], pel IP_buffer_ptr_8x64_left_line[2 * 64], pel IP_buffer_ptr_8x64_top_left,
	pel IP_buffer_ptr_64x8_up_line[2 * 64], pel IP_buffer_ptr_64x8_left_line[2 * 8], pel IP_buffer_ptr_64x8_top_left,
	U32 IP_map_scu_ptr_64x64_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_top_left_new,
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_top_left_new,
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_top_left_new
) {
//#pragma HLS ARRAY_PARTITION variable=pred cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=pred complete dim=3
//#pragma HLS ARRAY_PARTITION variable=pred0 cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=pred0 complete dim=3	
	pel nb[2][2][32 * 2 + 3];
#if USE_TSCPM
	pel nb_y[2][64 * 2 + 3];
#pragma HLS ARRAY_PARTITION variable=nb_y complete dim=0
#endif
#pragma HLS ARRAY_PARTITION variable=nb complete dim=0
	for (int i = 0; i < 2 * 32 + 3; i++)
	{
#pragma HLS UNROLL
		nb[0][0][i] = (1 << bit_depth - 1);
		nb[0][1][i] = (1 << bit_depth - 1);
		nb[1][0][i] = (1 << bit_depth - 1);
		nb[1][1][i] = (1 << bit_depth - 1);
	}

	for (int i = 0; i < 2 * 64 + 3; i++) {
#pragma HLS UNROLL
		nb_y[0][i] = (1 << bit_depth - 1);
		nb_y[1][i] = (1 << bit_depth - 1);
	}


	u16 avail_cu_output;
	if (mod_info_best->cu_mode != 0)
	{
		com_mc_cu_uv_32(mod_info_best, md_fw_ptr->pic_width, md_fw_ptr->pic_height, mod_info_best->refi, mod_info_best->mv,
			pred[0], pred[1], pred0[0], pred0[1], bit_depth, Fetch_Ref_window_ptr
#if SUB_TMVP
			, core_sbtmvp, mod_info_best->skip_idx, mod_info_best->cu_mode
#endif
		);
	}
	else {

		ipred_c_32_prepare(md_fw_ptr, cu_width_log2_chroma, cu_height_log2_chroma, pb_x, pb_y,
			mod_info_best, nb_y, nb[0], nb[1],
			IP_buffer_ptr_U_32x32_up_line, IP_buffer_ptr_U_32x32_left_line, IP_buffer_ptr_U_32x32_top_left,
			IP_buffer_ptr_V_32x32_up_line, IP_buffer_ptr_V_32x32_left_line, IP_buffer_ptr_V_32x32_top_left,
			IP_buffer_ptr_U_16x32_up_line, IP_buffer_ptr_U_16x32_left_line, IP_buffer_ptr_U_16x32_top_left,
			IP_buffer_ptr_V_16x32_up_line, IP_buffer_ptr_V_16x32_left_line, IP_buffer_ptr_V_16x32_top_left,
			IP_buffer_ptr_U_32x16_up_line, IP_buffer_ptr_U_32x16_left_line, IP_buffer_ptr_U_32x16_top_left,
			IP_buffer_ptr_V_32x16_up_line, IP_buffer_ptr_V_32x16_left_line, IP_buffer_ptr_V_32x16_top_left,
			IP_buffer_ptr_U_8x32_up_line, IP_buffer_ptr_U_8x32_left_line, IP_buffer_ptr_U_8x32_top_left,
			IP_buffer_ptr_V_8x32_up_line, IP_buffer_ptr_V_8x32_left_line, IP_buffer_ptr_V_8x32_top_left,
			IP_buffer_ptr_U_32x8_up_line, IP_buffer_ptr_U_32x8_left_line, IP_buffer_ptr_U_32x8_top_left,
			IP_buffer_ptr_V_32x8_up_line, IP_buffer_ptr_V_32x8_left_line, IP_buffer_ptr_V_32x8_top_left,
			IP_buffer_ptr_U_4x32_up_line, IP_buffer_ptr_U_4x32_left_line, IP_buffer_ptr_U_4x32_top_left,
			IP_buffer_ptr_V_4x32_up_line, IP_buffer_ptr_V_4x32_left_line, IP_buffer_ptr_V_4x32_top_left,
			IP_buffer_ptr_U_32x4_up_line, IP_buffer_ptr_U_32x4_left_line, IP_buffer_ptr_U_32x4_top_left,
			IP_buffer_ptr_V_32x4_up_line, IP_buffer_ptr_V_32x4_left_line, IP_buffer_ptr_V_32x4_top_left,
			IP_buffer_ptr_64x64_up_line, IP_buffer_ptr_64x64_left_line, IP_buffer_ptr_64x64_top_left,
			IP_buffer_ptr_32x64_up_line, IP_buffer_ptr_32x64_left_line, IP_buffer_ptr_32x64_top_left,
			IP_buffer_ptr_64x32_up_line, IP_buffer_ptr_64x32_left_line, IP_buffer_ptr_64x32_top_left,
			IP_buffer_ptr_16x64_up_line, IP_buffer_ptr_16x64_left_line, IP_buffer_ptr_16x64_top_left,
			IP_buffer_ptr_64x16_up_line, IP_buffer_ptr_64x16_left_line, IP_buffer_ptr_64x16_top_left,
			IP_buffer_ptr_8x64_up_line, IP_buffer_ptr_8x64_left_line, IP_buffer_ptr_8x64_top_left,
			IP_buffer_ptr_64x8_up_line, IP_buffer_ptr_64x8_left_line, IP_buffer_ptr_64x8_top_left,
			IP_map_scu_ptr_64x64_map_scu_up_line,
			IP_map_scu_ptr_64x64_map_scu_left_line_new,
			IP_map_scu_ptr_64x64_map_scu_top_left_new,
			IP_map_scu_ptr_32x64_map_scu_up_line,
			IP_map_scu_ptr_32x64_map_scu_left_line_new,
			IP_map_scu_ptr_32x64_map_scu_top_left_new,
			IP_map_scu_ptr_64x32_map_scu_up_line,
			IP_map_scu_ptr_64x32_map_scu_left_line_new,
			IP_map_scu_ptr_64x32_map_scu_top_left_new,
			IP_map_scu_ptr_16x64_map_scu_up_line,
			IP_map_scu_ptr_16x64_map_scu_left_line_new,
			IP_map_scu_ptr_16x64_map_scu_top_left_new,
			IP_map_scu_ptr_64x16_map_scu_up_line,
			IP_map_scu_ptr_64x16_map_scu_left_line_new,
			IP_map_scu_ptr_64x16_map_scu_top_left_new,
			IP_map_scu_ptr_8x64_map_scu_up_line,
			IP_map_scu_ptr_8x64_map_scu_left_line_new,
			IP_map_scu_ptr_8x64_map_scu_top_left_new,
			IP_map_scu_ptr_64x8_map_scu_up_line,
			IP_map_scu_ptr_64x8_map_scu_left_line_new,
			IP_map_scu_ptr_64x8_map_scu_top_left_new,
			&avail_cu_output);


		for (int rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {
#pragma HLS LOOP_TRIPCOUNT min=12 max=12 avg=12
			com_ipred_uv_32(cu_width_log2_chroma, cu_height_log2_chroma, nb[rdo_idx & 1][0], nb[rdo_idx & 1][1], pred[rdo_idx], pred0[rdo_idx], rdo_idx / 2, mod_info_best->ipm[0][0],
				1 << cu_width_log2_chroma, 1 << cu_height_log2_chroma, md_fw_ptr->bit_depth_internal, avail_cu_output, piRecoY, nb_y
#if MIPF
				, md_fw_ptr->mipf_enable_flag
#endif
			);
		}

	}

}
#endif

void rdo_chroma_pipeline_32_updata(int tscpm_enable_flag, int all_rdo_num,  MD_INPUT* md_input_ptr, int bit_depth, 
	int cu_width_log2_chroma, int cu_width_chroma, int cu_height_log2_chroma, int cu_height_chroma,
	pel rec_tmp[12][32][32],s16 coef_q[12][32][32],int num_nz_out[12],pel orgU[2][32][32],
	pel pred[12][32][32],MD_COM_MODE_BEST* mod_info_best,pel mod_info_best_rec_u[32][32],
	pel mod_info_best_rec_v[32][32],pel mod_info_best_coef_u[32][32],pel mod_info_best_coef_v[32][32]
) {
//#pragma HLS ARRAY_PARTITION variable=pred cyclic factor = 2 dim=1	
#pragma HLS ARRAY_PARTITION variable=pred complete dim=3


	s64 cost[6];
#pragma HLS ARRAY_PARTITION variable=cost complete dim=0
	for (int i = 0; i < 6; i++)
	{
#pragma HLS UNROLL
		cost[i] = 9223372036854775807;
	}
	U1 uv;
	for (int rdo_idx = 0; rdo_idx < all_rdo_num; rdo_idx++) {
#pragma HLS LOOP_TRIPCOUNT min=12 max=12 avg=12
		uv = rdo_idx & 1;


		deriveRDCostChroma32(mod_info_best->cu_mode, md_input_ptr->dist_chroma_weight[uv], mod_info_best, cu_width_log2_chroma, cu_height_log2_chroma,
			cu_width_chroma, cu_height_chroma, rec_tmp[rdo_idx],
			orgU[uv], md_input_ptr->lambda[uv], coef_q[rdo_idx], tscpm_enable_flag, cost, bit_depth,
			uv, num_nz_out, rdo_idx);
	}

	updateBestModeChroma32(cu_width_chroma, cu_height_chroma, mod_info_best->cu_mode, mod_info_best,
		rec_tmp, coef_q, cost, bit_depth,
		pred, num_nz_out,
		mod_info_best_rec_u,
		mod_info_best_rec_v,
		mod_info_best_coef_u,
		mod_info_best_coef_v);


}

#if !CHROMA_32_PIPELINE_DUMMY
void rdo_chroma_pipeline_32(int all_rdo_num, RDOQ_ARRAY* rdoq_array, MD_INPUT* md_input_ptr, U13 pb_x, U13 pb_y,
	MD_FW* md_fw_ptr, pel RefWindowLCU_UP[(SWH * SWW) >> 2], pel RefWindowLCU_VP[(SWH * SWW) >> 2], S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS],
#if ENABLE_BFRAME
	pel RefWindowLCU_UP_ref1[(SWH * SWW) >> 2], pel RefWindowLCU_VP_ref1[(SWH * SWW) >> 2], S14 CtrPos_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	U2 tree_status,
	MD_COM_MODE_BEST* mod_info_best, COM_PART_INFO* mod_info_curr_pb_info,
	pel orgU[2][32][32],
	int cu_width_log2_chroma, int cu_width_chroma, int cu_height_log2_chroma, int cu_height_chroma, int bit_depth,
	U2 cu_mode, U2 slice_type, U14 scale[2], U6 qpUV[2], int tscpm_enable_flag, s64 lambda_y,
	S12 size_tmp, strFetch_ref_window* Fetch_Ref_window_ptr,
	pel piRecoY[64][64]
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
	, pel mod_info_best_rec_u[32][32],
	pel mod_info_best_rec_v[32][32],
	pel mod_info_best_coef_u[32][32],
	pel mod_info_best_coef_v[32][32],
	pel IP_buffer_ptr_U_32x32_up_line[2 * 32], pel IP_buffer_ptr_U_32x32_left_line[2 * 32], pel IP_buffer_ptr_U_32x32_top_left,
	pel IP_buffer_ptr_V_32x32_up_line[2 * 32], pel IP_buffer_ptr_V_32x32_left_line[2 * 32], pel IP_buffer_ptr_V_32x32_top_left,
	pel IP_buffer_ptr_U_16x32_up_line[2 * 16], pel IP_buffer_ptr_U_16x32_left_line[2 * 32], pel IP_buffer_ptr_U_16x32_top_left,
	pel IP_buffer_ptr_V_16x32_up_line[2 * 16], pel IP_buffer_ptr_V_16x32_left_line[2 * 32], pel IP_buffer_ptr_V_16x32_top_left,
	pel IP_buffer_ptr_U_32x16_up_line[2 * 32], pel IP_buffer_ptr_U_32x16_left_line[2 * 16], pel IP_buffer_ptr_U_32x16_top_left,
	pel IP_buffer_ptr_V_32x16_up_line[2 * 32], pel IP_buffer_ptr_V_32x16_left_line[2 * 16], pel IP_buffer_ptr_V_32x16_top_left,
	pel IP_buffer_ptr_U_8x32_up_line[2 * 8], pel IP_buffer_ptr_U_8x32_left_line[2 * 32], pel IP_buffer_ptr_U_8x32_top_left,
	pel IP_buffer_ptr_V_8x32_up_line[2 * 8], pel IP_buffer_ptr_V_8x32_left_line[2 * 32], pel IP_buffer_ptr_V_8x32_top_left,
	pel IP_buffer_ptr_U_32x8_up_line[2 * 32], pel IP_buffer_ptr_U_32x8_left_line[2 * 8], pel IP_buffer_ptr_U_32x8_top_left,
	pel IP_buffer_ptr_V_32x8_up_line[2 * 32], pel IP_buffer_ptr_V_32x8_left_line[2 * 8], pel IP_buffer_ptr_V_32x8_top_left,
	pel IP_buffer_ptr_U_4x32_up_line[2 * 4], pel IP_buffer_ptr_U_4x32_left_line[2 * 32], pel IP_buffer_ptr_U_4x32_top_left,
	pel IP_buffer_ptr_V_4x32_up_line[2 * 4], pel IP_buffer_ptr_V_4x32_left_line[2 * 32], pel IP_buffer_ptr_V_4x32_top_left,
	pel IP_buffer_ptr_U_32x4_up_line[2 * 32], pel IP_buffer_ptr_U_32x4_left_line[2 * 4], pel IP_buffer_ptr_U_32x4_top_left,
	pel IP_buffer_ptr_V_32x4_up_line[2 * 32], pel IP_buffer_ptr_V_32x4_left_line[2 * 4], pel IP_buffer_ptr_V_32x4_top_left,
	pel IP_buffer_ptr_64x64_up_line[128], pel IP_buffer_ptr_64x64_left_line[64], pel IP_buffer_ptr_64x64_top_left,
	pel IP_buffer_ptr_32x64_up_line[2 * 32], pel IP_buffer_ptr_32x64_left_line[2 * 64], pel IP_buffer_ptr_32x64_top_left,
	pel IP_buffer_ptr_64x32_up_line[2 * 64], pel IP_buffer_ptr_64x32_left_line[2 * 32], pel IP_buffer_ptr_64x32_top_left,
	pel IP_buffer_ptr_16x64_up_line[2 * 16], pel IP_buffer_ptr_16x64_left_line[2 * 64], pel IP_buffer_ptr_16x64_top_left,
	pel IP_buffer_ptr_64x16_up_line[2 * 64], pel IP_buffer_ptr_64x16_left_line[2 * 16], pel IP_buffer_ptr_64x16_top_left,
	pel IP_buffer_ptr_8x64_up_line[2 * 8], pel IP_buffer_ptr_8x64_left_line[2 * 64], pel IP_buffer_ptr_8x64_top_left,
	pel IP_buffer_ptr_64x8_up_line[2 * 64], pel IP_buffer_ptr_64x8_left_line[2 * 8], pel IP_buffer_ptr_64x8_top_left,
	U32 IP_map_scu_ptr_64x64_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_32x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1],
	U32 IP_map_scu_ptr_64x32_map_scu_top_left_new,
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_16x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1],
	U32 IP_map_scu_ptr_64x16_map_scu_top_left_new,
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_8x64_map_scu_top_left_new,
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1],
	U32 IP_map_scu_ptr_64x8_map_scu_top_left_new
)
{



	pel pred[12][32][32];
	pel pred0[12][32][32];


	rdo_chroma_pipeline_32_pred(all_rdo_num, pb_x, pb_y, cu_width_log2_chroma, cu_width_chroma, cu_height_log2_chroma, cu_height_chroma, bit_depth,
		mod_info_best, md_fw_ptr, pred, pred0, Fetch_Ref_window_ptr, piRecoY
#if SUB_TMVP
		, core_sbtmvp
#endif
			/*ipred_c_32_prepare(md_fw_ptr, cu_width_log2_chroma, cu_height_log2_chroma, pb_x, pb_y,
				mod_info_best, nb_y, nb[0], nb[1],
			IP_buffer_ptr_U_32x32, IP_buffer_ptr_V_32x32,
			IP_buffer_ptr_U_16x32, IP_buffer_ptr_V_16x32,
			IP_buffer_ptr_U_32x16, IP_buffer_ptr_V_32x16,
			IP_buffer_ptr_U_8x32, IP_buffer_ptr_V_8x32,
			IP_buffer_ptr_U_32x8, IP_buffer_ptr_V_32x8,
			IP_buffer_ptr_U_4x32, IP_buffer_ptr_V_4x32,
			IP_buffer_ptr_U_32x4, IP_buffer_ptr_V_32x4,
			IP_buffer_ptr_64x64,
			IP_buffer_ptr_32x64, IP_buffer_ptr_64x32,
			IP_buffer_ptr_16x64, IP_buffer_ptr_64x16,
			IP_buffer_ptr_8x64, IP_buffer_ptr_64x8,
			IP_map_scu_ptr_64x64,
			IP_map_scu_ptr_32x64, IP_map_scu_ptr_64x32,
			IP_map_scu_ptr_16x64, IP_map_scu_ptr_64x16,
				IP_map_scu_ptr_8x64, IP_map_scu_ptr_64x8, &avail_cu_output);*/
		, IP_buffer_ptr_U_32x32_up_line, IP_buffer_ptr_U_32x32_left_line, IP_buffer_ptr_U_32x32_top_left,
				IP_buffer_ptr_V_32x32_up_line, IP_buffer_ptr_V_32x32_left_line, IP_buffer_ptr_V_32x32_top_left,
				IP_buffer_ptr_U_16x32_up_line, IP_buffer_ptr_U_16x32_left_line, IP_buffer_ptr_U_16x32_top_left,
				IP_buffer_ptr_V_16x32_up_line, IP_buffer_ptr_V_16x32_left_line, IP_buffer_ptr_V_16x32_top_left,
				IP_buffer_ptr_U_32x16_up_line, IP_buffer_ptr_U_32x16_left_line, IP_buffer_ptr_U_32x16_top_left,
				IP_buffer_ptr_V_32x16_up_line, IP_buffer_ptr_V_32x16_left_line, IP_buffer_ptr_V_32x16_top_left,
				IP_buffer_ptr_U_8x32_up_line, IP_buffer_ptr_U_8x32_left_line, IP_buffer_ptr_U_8x32_top_left,
				IP_buffer_ptr_V_8x32_up_line, IP_buffer_ptr_V_8x32_left_line, IP_buffer_ptr_V_8x32_top_left,
				IP_buffer_ptr_U_32x8_up_line, IP_buffer_ptr_U_32x8_left_line, IP_buffer_ptr_U_32x8_top_left,
				IP_buffer_ptr_V_32x8_up_line, IP_buffer_ptr_V_32x8_left_line, IP_buffer_ptr_V_32x8_top_left,
				IP_buffer_ptr_U_4x32_up_line, IP_buffer_ptr_U_4x32_left_line, IP_buffer_ptr_U_4x32_top_left,
				IP_buffer_ptr_V_4x32_up_line, IP_buffer_ptr_V_4x32_left_line, IP_buffer_ptr_V_4x32_top_left,
				IP_buffer_ptr_U_32x4_up_line, IP_buffer_ptr_U_32x4_left_line, IP_buffer_ptr_U_32x4_top_left,
				IP_buffer_ptr_V_32x4_up_line, IP_buffer_ptr_V_32x4_left_line, IP_buffer_ptr_V_32x4_top_left,
				IP_buffer_ptr_64x64_up_line, IP_buffer_ptr_64x64_left_line, IP_buffer_ptr_64x64_top_left,
				IP_buffer_ptr_32x64_up_line, IP_buffer_ptr_32x64_left_line, IP_buffer_ptr_32x64_top_left,
				IP_buffer_ptr_64x32_up_line, IP_buffer_ptr_64x32_left_line, IP_buffer_ptr_64x32_top_left,
				IP_buffer_ptr_16x64_up_line, IP_buffer_ptr_16x64_left_line, IP_buffer_ptr_16x64_top_left,
				IP_buffer_ptr_64x16_up_line, IP_buffer_ptr_64x16_left_line, IP_buffer_ptr_64x16_top_left,
				IP_buffer_ptr_8x64_up_line, IP_buffer_ptr_8x64_left_line, IP_buffer_ptr_8x64_top_left,
				IP_buffer_ptr_64x8_up_line, IP_buffer_ptr_64x8_left_line, IP_buffer_ptr_64x8_top_left,
				IP_map_scu_ptr_64x64_map_scu_up_line,
				IP_map_scu_ptr_64x64_map_scu_left_line_new,
				IP_map_scu_ptr_64x64_map_scu_top_left_new,
				IP_map_scu_ptr_32x64_map_scu_up_line,
				IP_map_scu_ptr_32x64_map_scu_left_line_new,
				IP_map_scu_ptr_32x64_map_scu_top_left_new,
				IP_map_scu_ptr_64x32_map_scu_up_line,
				IP_map_scu_ptr_64x32_map_scu_left_line_new,
				IP_map_scu_ptr_64x32_map_scu_top_left_new,
				IP_map_scu_ptr_16x64_map_scu_up_line,
				IP_map_scu_ptr_16x64_map_scu_left_line_new,
				IP_map_scu_ptr_16x64_map_scu_top_left_new,
				IP_map_scu_ptr_64x16_map_scu_up_line,
				IP_map_scu_ptr_64x16_map_scu_left_line_new,
				IP_map_scu_ptr_64x16_map_scu_top_left_new,
				IP_map_scu_ptr_8x64_map_scu_up_line,
				IP_map_scu_ptr_8x64_map_scu_left_line_new,
				IP_map_scu_ptr_8x64_map_scu_top_left_new,
				IP_map_scu_ptr_64x8_map_scu_up_line,
				IP_map_scu_ptr_64x8_map_scu_left_line_new,
		IP_map_scu_ptr_64x8_map_scu_top_left_new


					);	




		pel rec_tmp[12][32][32];
		s16 coef_q[12][32][32];
		int num_nz_out[12];

			


		rdo_chroma_dataflow_32(md_input_ptr,all_rdo_num,  bit_depth,   md_fw_ptr,  tree_status,   rdoq_array,   mod_info_best,
		cu_width_log2_chroma, cu_width_chroma, cu_height_log2_chroma, cu_height_chroma, orgU, pred, pred0, 
		rec_tmp, coef_q, num_nz_out
		);

	

	rdo_chroma_pipeline_32_updata( tscpm_enable_flag,  all_rdo_num,  md_input_ptr,  bit_depth,

		 cu_width_log2_chroma,  cu_width_chroma,  cu_height_log2_chroma,  cu_height_chroma,
		 rec_tmp,  coef_q,  num_nz_out,  orgU, pred,  mod_info_best,  mod_info_best_rec_u,

		 mod_info_best_rec_v,  mod_info_best_coef_u,  mod_info_best_coef_v
	);

	//#endif
}
#endif



int RDOChroma32(RDOQ_ARRAY* rdoq_array, MD_FW* md_fw_ptr, 
	U2 tree_status, MD_COM_MODE_BEST* mod_info_best, COM_PART_INFO* mod_info_curr_pb_info, MD_INPUT* md_input_ptr, pel orgU[2][32][32], 
	IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_U_32x32, IP_ARRAY_SIZE<32, 32>* IP_buffer_ptr_V_32x32,
	IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_U_16x32, IP_ARRAY_SIZE<16, 32>* IP_buffer_ptr_V_16x32,
	IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_U_32x16, IP_ARRAY_SIZE<32, 16>* IP_buffer_ptr_V_32x16,
	IP_ARRAY_SIZE<8, 32>* IP_buffer_ptr_U_8x32, IP_ARRAY_SIZE<8, 32>* IP_buffer_ptr_V_8x32,
	IP_ARRAY_SIZE<32, 8>* IP_buffer_ptr_U_32x8, IP_ARRAY_SIZE<32, 8>* IP_buffer_ptr_V_32x8,
	IP_ARRAY_SIZE<4, 32>* IP_buffer_ptr_U_4x32, IP_ARRAY_SIZE<4, 32>* IP_buffer_ptr_V_4x32,
	IP_ARRAY_SIZE<32, 4>* IP_buffer_ptr_U_32x4, IP_ARRAY_SIZE<32, 4>* IP_buffer_ptr_V_32x4,
	pel RefWindowLCU_UP[(SWH * SWW) >> 2], pel RefWindowLCU_VP[(SWH * SWW) >> 2],
	S14 CtrPos[RANGE_NUM][DIR_DIM][MAP_DIMS], 
#if ENABLE_BFRAME
	pel RefWindowLCU_UP_ref1[(SWH * SWW) >> 2], pel RefWindowLCU_VP_ref1[(SWH * SWW) >> 2], S14 CtrPos_ref1[RANGE_NUM][DIR_DIM][MAP_DIMS],
#endif
	U1 coef_rec_write_flag[1], strFetch_ref_window* Fetch_Ref_window_ptr,
	pel piRecoY[64][64], IP_ARRAY_SIZE<64, 64>* IP_buffer_ptr_64x64,
	IP_ARRAY_SIZE<32, 64>* IP_buffer_ptr_32x64, IP_ARRAY_SIZE<64, 32>* IP_buffer_ptr_64x32,
	IP_ARRAY_SIZE<16, 64>* IP_buffer_ptr_16x64, IP_ARRAY_SIZE<64, 16>* IP_buffer_ptr_64x16,
	IP_ARRAY_SIZE<8, 64>* IP_buffer_ptr_8x64, IP_ARRAY_SIZE<64, 8>* IP_buffer_ptr_64x8,
	IP_MAP_SCU_SIZE<64, 64>* IP_map_scu_ptr_64x64,
	IP_MAP_SCU_SIZE<32, 64>* IP_map_scu_ptr_32x64, IP_MAP_SCU_SIZE<64, 32>* IP_map_scu_ptr_64x32,
	IP_MAP_SCU_SIZE<16, 64>* IP_map_scu_ptr_16x64, IP_MAP_SCU_SIZE<64, 16>* IP_map_scu_ptr_64x16,
	IP_MAP_SCU_SIZE<8, 64>* IP_map_scu_ptr_8x64, IP_MAP_SCU_SIZE<64, 8>* IP_map_scu_ptr_64x8
#if SUB_TMVP
	, CORE_SBTMVP* core_sbtmvp
#endif
)
{


	static pel rec_tmp[2][32][32];
	static const U14 quant_scale[80] = { (16302), (15024), (13777), (12634), (11626), (10624), (9742), (8958), (8192), (7512), (6889), (6305), (5793), (5303), (4878), (4467), (4091), (3756), (3444), (3161), (2894), (2654), (2435), (2235), (2048), (1878), (1722), (1579), (1449), (1329), (1218), (1117), (1024), (939), (861), (790), (724), (664), (609), (558), (512), (470), (430), (395), (362), (332), (304), (279), (256), (235), (215), (197), (181), (166), (152), (140), (128), (116), (108), (99), (91), (83), (76), (69), (64), (59), (54), (49), (45), (41), (38), (35), (32), (30), (27), (25), (23), (21), (19), (18) };

	U4 bit_depth = md_fw_ptr->bit_depth_internal;

	U3 cu_width_log2 = mod_info_best->cu_width_log2;
	U3 cu_height_log2 = mod_info_best->cu_height_log2;

	U7 cu_width = (1 << cu_width_log2);
	U7 cu_height = (1 << cu_height_log2);

	U7 cu_width_chroma = cu_width >> 1;
	U7 cu_height_chroma = cu_height >> 1;

	U3 cu_width_log2_chroma = cu_width_log2 - 1;
	U3 cu_height_log2_chroma = cu_height_log2 - 1;

	U13 pb_x = mod_info_best->x_pos;
	U13 pb_y = mod_info_best->y_pos;


	s64 lambda_y = md_input_ptr->lambda_y;
	int all_rdo_num = 0;

	int tscpm_enable_flag = 0;

	U2  slice_type = md_fw_ptr->slice_type;
	U2  cu_mode = mod_info_best->cu_mode;


	U12 size_tmp = (1 << (cu_width_log2 - 1)) * (1 << (cu_height_log2 - 1));


	U6 qpUV[2] = { md_input_ptr->qp_u ,md_input_ptr->qp_v };
	U14 scale[2] = { quant_scale[md_input_ptr->qp_u],quant_scale[md_input_ptr->qp_v] };


	if (tree_status != TREE_LC && tree_status != TREE_C)
	{
		return 0;
	}

	if (mod_info_best->cu_mode != 0)
	{
		all_rdo_num = 2;
	}
	else
	{
#if USE_TSCPM
		all_rdo_num = 12;
#else
		all_rdo_num = 10;
#endif // USE_TSCPM
	}

	pel mod_info_best_rec_u[32][32];
	pel mod_info_best_rec_v[32][32];
	pel mod_info_best_coef_u[32][32];
	pel mod_info_best_coef_v[32][32];

	/*
	Template unroll
	by: SK.Wang
	*/
	// UV
	pel IP_buffer_ptr_U_32x32_up_line[2 * 32]; pel IP_buffer_ptr_U_32x32_left_line[2 * 32]; pel IP_buffer_ptr_U_32x32_top_left;
	pel IP_buffer_ptr_V_32x32_up_line[2 * 32]; pel IP_buffer_ptr_V_32x32_left_line[2 * 32]; pel IP_buffer_ptr_V_32x32_top_left;
	pel IP_buffer_ptr_U_16x32_up_line[2 * 16]; pel IP_buffer_ptr_U_16x32_left_line[2 * 32]; pel IP_buffer_ptr_U_16x32_top_left;
	pel IP_buffer_ptr_V_16x32_up_line[2 * 16]; pel IP_buffer_ptr_V_16x32_left_line[2 * 32]; pel IP_buffer_ptr_V_16x32_top_left;
	pel IP_buffer_ptr_U_32x16_up_line[2 * 32]; pel IP_buffer_ptr_U_32x16_left_line[2 * 16]; pel IP_buffer_ptr_U_32x16_top_left;
	pel IP_buffer_ptr_V_32x16_up_line[2 * 32]; pel IP_buffer_ptr_V_32x16_left_line[2 * 16]; pel IP_buffer_ptr_V_32x16_top_left;
	pel IP_buffer_ptr_U_8x32_up_line[2 * 8]; pel IP_buffer_ptr_U_8x32_left_line[2 * 32]; pel IP_buffer_ptr_U_8x32_top_left;
	pel IP_buffer_ptr_V_8x32_up_line[2 * 8]; pel IP_buffer_ptr_V_8x32_left_line[2 * 32]; pel IP_buffer_ptr_V_8x32_top_left;
	pel IP_buffer_ptr_U_32x8_up_line[2 * 32]; pel IP_buffer_ptr_U_32x8_left_line[2 * 8]; pel IP_buffer_ptr_U_32x8_top_left;
	pel IP_buffer_ptr_V_32x8_up_line[2 * 32]; pel IP_buffer_ptr_V_32x8_left_line[2 * 8]; pel IP_buffer_ptr_V_32x8_top_left;
	pel IP_buffer_ptr_U_4x32_up_line[2 * 4]; pel IP_buffer_ptr_U_4x32_left_line[2 * 32]; pel IP_buffer_ptr_U_4x32_top_left;
	pel IP_buffer_ptr_V_4x32_up_line[2 * 4]; pel IP_buffer_ptr_V_4x32_left_line[2 * 32]; pel IP_buffer_ptr_V_4x32_top_left;
	pel IP_buffer_ptr_U_32x4_up_line[2 * 32]; pel IP_buffer_ptr_U_32x4_left_line[2 * 4]; pel IP_buffer_ptr_U_32x4_top_left;
	pel IP_buffer_ptr_V_32x4_up_line[2 * 32]; pel IP_buffer_ptr_V_32x4_left_line[2 * 4]; pel IP_buffer_ptr_V_32x4_top_left;
	// Y
	pel IP_buffer_ptr_64x64_up_line[128]; pel IP_buffer_ptr_64x64_left_line[64]; pel IP_buffer_ptr_64x64_top_left;
	pel IP_buffer_ptr_32x64_up_line[2 * 32]; pel IP_buffer_ptr_32x64_left_line[2 * 64]; pel IP_buffer_ptr_32x64_top_left;
	pel IP_buffer_ptr_64x32_up_line[2 * 64]; pel IP_buffer_ptr_64x32_left_line[2 * 32]; pel IP_buffer_ptr_64x32_top_left;
	pel IP_buffer_ptr_16x64_up_line[2 * 16]; pel IP_buffer_ptr_16x64_left_line[2 * 64]; pel IP_buffer_ptr_16x64_top_left;
	pel IP_buffer_ptr_64x16_up_line[2 * 64]; pel IP_buffer_ptr_64x16_left_line[2 * 16]; pel IP_buffer_ptr_64x16_top_left;
	pel IP_buffer_ptr_8x64_up_line[2 * 8]; pel IP_buffer_ptr_8x64_left_line[2 * 64]; pel IP_buffer_ptr_8x64_top_left;
	pel IP_buffer_ptr_64x8_up_line[2 * 64]; pel IP_buffer_ptr_64x8_left_line[2 * 8]; pel IP_buffer_ptr_64x8_top_left;
	// MAP_SCU
	U32 IP_map_scu_ptr_64x64_map_scu_up_line[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_64x64_map_scu_left_line_new[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_64x64_map_scu_top_left_new;
	U32 IP_map_scu_ptr_32x64_map_scu_up_line[(32 >> 2) << 1];
	U32 IP_map_scu_ptr_32x64_map_scu_left_line_new[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_32x64_map_scu_top_left_new;
	U32 IP_map_scu_ptr_64x32_map_scu_up_line[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_64x32_map_scu_left_line_new[(32 >> 2) << 1];
	U32 IP_map_scu_ptr_64x32_map_scu_top_left_new;
	U32 IP_map_scu_ptr_16x64_map_scu_up_line[(16 >> 2) << 1];
	U32 IP_map_scu_ptr_16x64_map_scu_left_line_new[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_16x64_map_scu_top_left_new;
	U32 IP_map_scu_ptr_64x16_map_scu_up_line[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_64x16_map_scu_left_line_new[(16 >> 2) << 1];
	U32 IP_map_scu_ptr_64x16_map_scu_top_left_new;
	U32 IP_map_scu_ptr_8x64_map_scu_up_line[(8 >> 2) << 1];
	U32 IP_map_scu_ptr_8x64_map_scu_left_line_new[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_8x64_map_scu_top_left_new;
	U32 IP_map_scu_ptr_64x8_map_scu_up_line[(64 >> 2) << 1];
	U32 IP_map_scu_ptr_64x8_map_scu_left_line_new[(8 >> 2) << 1];
	U32 IP_map_scu_ptr_64x8_map_scu_top_left_new;

	// init
	// Y 64x64
	IP_buffer_ptr_64x64_top_left = 0;
	IP_buffer_ptr_U_32x32_top_left = 0;
	IP_buffer_ptr_V_32x32_top_left = 0;
	IP_map_scu_ptr_64x64_map_scu_top_left_new = 0;
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_U_32x32_up_line[i] = 0;
		IP_buffer_ptr_U_32x32_left_line[i] = 0;
		IP_buffer_ptr_V_32x32_up_line[i] = 0;
		IP_buffer_ptr_V_32x32_left_line[i] = 0;
		IP_buffer_ptr_64x64_left_line[i] = 0;
	}
	for (int i = 0; i < 128; i++) {
		IP_buffer_ptr_64x64_up_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_map_scu_ptr_64x64_map_scu_up_line[i] = 0;
		IP_map_scu_ptr_64x64_map_scu_left_line_new[i] = 0;
	}
	// Y 32x64
	IP_buffer_ptr_32x64_top_left = 0;
	IP_buffer_ptr_U_16x32_top_left = 0;
	IP_buffer_ptr_V_16x32_top_left = 0;
	IP_map_scu_ptr_32x64_map_scu_top_left_new = 0;
	for (int i = 0; i < 32; i++) {
		IP_buffer_ptr_U_16x32_up_line[i] = 0;
		IP_buffer_ptr_V_16x32_up_line[i] = 0;
		// MAP_SCU
		IP_map_scu_ptr_32x64_map_scu_left_line_new[i] = 0;
	}
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_U_16x32_left_line[i] = 0;
		IP_buffer_ptr_V_16x32_left_line[i] = 0;
		IP_buffer_ptr_32x64_up_line[i] = 0;
	}
	for (int i = 0; i < 128; i++) {
		IP_buffer_ptr_32x64_left_line[i] = 0;
	}
	for (int i = 0; i < 16; i++) {
		IP_map_scu_ptr_32x64_map_scu_up_line[i] = 0;
	}
	// Y 64x32
	IP_buffer_ptr_64x32_top_left = 0;
	IP_buffer_ptr_U_32x16_top_left = 0;
	IP_buffer_ptr_V_32x16_top_left = 0;
	IP_map_scu_ptr_64x32_map_scu_top_left_new = 0;
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_U_32x16_up_line[i] = 0;
		IP_buffer_ptr_V_32x16_up_line[i] = 0;
		IP_buffer_ptr_64x32_left_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_buffer_ptr_U_32x16_left_line[i] = 0;
		IP_buffer_ptr_V_32x16_left_line[i] = 0;
		// MAP_SCU
		IP_map_scu_ptr_64x32_map_scu_up_line[i] = 0;
	}
	for (int i = 0; i < 128; i++) {
		IP_buffer_ptr_64x32_up_line[i] = 0;
	}
	for (int i = 0; i < 16; i++) {
		IP_map_scu_ptr_64x32_map_scu_left_line_new[i] = 0;
	}
	// Y 16x64
	IP_buffer_ptr_16x64_top_left = 0;
	IP_buffer_ptr_U_8x32_top_left = 0;
	IP_buffer_ptr_V_8x32_top_left = 0;
	IP_map_scu_ptr_16x64_map_scu_top_left_new = 0;
	for (int i = 0; i < 16; i++) {
		IP_buffer_ptr_U_8x32_up_line[i] = 0;
		IP_buffer_ptr_V_8x32_up_line[i] = 0;
	}
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_U_8x32_left_line[i] = 0;
		IP_buffer_ptr_V_8x32_left_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_buffer_ptr_16x64_up_line[i] = 0;
		// MAP_SCU
		IP_map_scu_ptr_16x64_map_scu_left_line_new[i] = 0;
	}
	for (int i = 0; i < 128; i++) {
		IP_buffer_ptr_16x64_left_line[i] = 0;
	}
	for (int i = 0; i < 8; i++) {
		IP_map_scu_ptr_16x64_map_scu_up_line[i] = 0;
	}
	// Y 64x16
	IP_buffer_ptr_64x16_top_left = 0;
	IP_buffer_ptr_U_32x8_top_left = 0;
	IP_buffer_ptr_V_32x8_top_left = 0;
	IP_map_scu_ptr_64x16_map_scu_top_left_new = 0;
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_U_32x8_up_line[i] = 0;
		IP_buffer_ptr_V_32x8_up_line[i] = 0;
	}
	for (int i = 0; i < 16; i++) {
		IP_buffer_ptr_U_32x8_left_line[i] = 0;
		IP_buffer_ptr_V_32x8_left_line[i] = 0;
	}
	for (int i = 0; i < 128; i++) {
		IP_buffer_ptr_64x16_up_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_buffer_ptr_64x16_left_line[i] = 0;
		// MAP_SCU
		IP_map_scu_ptr_64x16_map_scu_up_line[i] = 0;
	}
	for (int i = 0; i < 8; i++) {
		IP_map_scu_ptr_64x16_map_scu_left_line_new[i] = 0;
	}
	// Y 8x64
	IP_buffer_ptr_8x64_top_left = 0;
	IP_buffer_ptr_U_4x32_top_left = 0;
	IP_buffer_ptr_V_4x32_top_left = 0;
	IP_map_scu_ptr_8x64_map_scu_top_left_new = 0;
	for (int i = 0; i < 8; i++) {
		IP_buffer_ptr_U_4x32_up_line[i] = 0;
		IP_buffer_ptr_V_4x32_up_line[i] = 0;
	}
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_U_4x32_left_line[i] = 0;
		IP_buffer_ptr_V_4x32_left_line[i] = 0;
	}
	for (int i = 0; i < 16; i++) {
		IP_buffer_ptr_8x64_up_line[i] = 0;
	}
	for (int i = 0; i < 128; i++) {
		IP_buffer_ptr_8x64_left_line[i] = 0;
	}
	for (int i = 0; i < 4; i++) {
		IP_map_scu_ptr_8x64_map_scu_up_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_map_scu_ptr_8x64_map_scu_left_line_new[i] = 0;
	}
	// Y 64x8
	IP_buffer_ptr_64x8_top_left = 0;
	IP_buffer_ptr_U_32x4_top_left = 0;
	IP_buffer_ptr_V_32x4_top_left = 0;
	IP_map_scu_ptr_64x8_map_scu_top_left_new = 0;
	for (int i = 0; i < 64; i++) {
		IP_buffer_ptr_U_32x4_up_line[i] = 0;
		IP_buffer_ptr_V_32x4_up_line[i] = 0;
	}
	for (int i = 0; i < 8; i++) {
		IP_buffer_ptr_U_32x4_left_line[i] = 0;
		IP_buffer_ptr_V_32x4_left_line[i] = 0;
	}
	for (int i = 0; i < 128; i++) {
		IP_buffer_ptr_64x8_up_line[i] = 0;
	}
	for (int i = 0; i < 16; i++) {
		IP_buffer_ptr_64x8_left_line[i] = 0;
	}
	for (int i = 0; i < 32; i++) {
		IP_map_scu_ptr_64x8_map_scu_up_line[i] = 0;
	}
	for (int i = 0; i < 4; i++) {
		IP_map_scu_ptr_64x8_map_scu_left_line_new[i] = 0;
	}

	/*
		Copy data
	*/
	if ((cu_width_log2 == 6) && (cu_height_log2 == 6))  // Y wxh == 64x64
	{
		IP_buffer_ptr_64x64_top_left = IP_buffer_ptr_64x64->top_left;
		IP_buffer_ptr_U_32x32_top_left = IP_buffer_ptr_U_32x32->top_left;
		IP_buffer_ptr_V_32x32_top_left = IP_buffer_ptr_V_32x32->top_left;
		IP_map_scu_ptr_64x64_map_scu_top_left_new = IP_map_scu_ptr_64x64->map_scu_top_left_new;
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_U_32x32_up_line[i] = IP_buffer_ptr_U_32x32->up_line[i];
			IP_buffer_ptr_U_32x32_left_line[i] = IP_buffer_ptr_U_32x32->left_line[i];
			IP_buffer_ptr_V_32x32_up_line[i] = IP_buffer_ptr_V_32x32->up_line[i];
			IP_buffer_ptr_V_32x32_left_line[i] = IP_buffer_ptr_V_32x32->left_line[i];
			IP_buffer_ptr_64x64_left_line[i] = IP_buffer_ptr_64x64->left_line[i];
		}
		for (int i = 0; i < 128; i++) {
			IP_buffer_ptr_64x64_up_line[i] = IP_buffer_ptr_64x64->up_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_map_scu_ptr_64x64_map_scu_up_line[i] = IP_map_scu_ptr_64x64->map_scu_up_line[i];
			IP_map_scu_ptr_64x64_map_scu_left_line_new[i] = IP_map_scu_ptr_64x64->map_scu_left_line_new[i];
		}
	}
	else if ((cu_width_log2 == 5) && (cu_height_log2 == 6))  // Y wxh == 32x64
	{
		IP_buffer_ptr_32x64_top_left = IP_buffer_ptr_32x64->top_left;
		IP_buffer_ptr_U_16x32_top_left = IP_buffer_ptr_U_16x32->top_left;
		IP_buffer_ptr_V_16x32_top_left = IP_buffer_ptr_V_16x32->top_left;
		IP_map_scu_ptr_32x64_map_scu_top_left_new = IP_map_scu_ptr_32x64->map_scu_top_left_new;
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_U_16x32_up_line[i] = IP_buffer_ptr_U_16x32->up_line[i];
			IP_buffer_ptr_V_16x32_up_line[i] = IP_buffer_ptr_V_16x32->up_line[i];
			// MAP_SCU
			IP_map_scu_ptr_32x64_map_scu_left_line_new[i] = IP_map_scu_ptr_32x64->map_scu_left_line_new[i];
		}
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_U_16x32_left_line[i] = IP_buffer_ptr_U_16x32->left_line[i];
			IP_buffer_ptr_V_16x32_left_line[i] = IP_buffer_ptr_V_16x32->left_line[i];
			IP_buffer_ptr_32x64_up_line[i] = IP_buffer_ptr_32x64->up_line[i];
		}
		for (int i = 0; i < 128; i++) {
			IP_buffer_ptr_32x64_left_line[i] = IP_buffer_ptr_32x64->left_line[i];
		}
		for (int i = 0; i < 16; i++) {
			IP_map_scu_ptr_32x64_map_scu_up_line[i] = IP_map_scu_ptr_32x64->map_scu_up_line[i];
		}
	}
	else if ((cu_width_log2 == 6) && (cu_height_log2 == 5))  // Y wxh == 64x32
	{
		IP_buffer_ptr_64x32_top_left = IP_buffer_ptr_64x32->top_left;
		IP_buffer_ptr_U_32x16_top_left = IP_buffer_ptr_U_32x16->top_left;
		IP_buffer_ptr_V_32x16_top_left = IP_buffer_ptr_V_32x16->top_left;
		IP_map_scu_ptr_64x32_map_scu_top_left_new = IP_map_scu_ptr_64x32->map_scu_top_left_new;
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_U_32x16_up_line[i] = IP_buffer_ptr_U_32x16->up_line[i];
			IP_buffer_ptr_V_32x16_up_line[i] = IP_buffer_ptr_V_32x16->up_line[i];
			IP_buffer_ptr_64x32_left_line[i] = IP_buffer_ptr_64x32->left_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_U_32x16_left_line[i] = IP_buffer_ptr_U_32x16->left_line[i];
			IP_buffer_ptr_V_32x16_left_line[i] = IP_buffer_ptr_V_32x16->left_line[i];
			// MAP_SCU
			IP_map_scu_ptr_64x32_map_scu_up_line[i] = IP_map_scu_ptr_64x32->map_scu_up_line[i];
		}
		for (int i = 0; i < 128; i++) {
			IP_buffer_ptr_64x32_up_line[i] = IP_buffer_ptr_64x32->up_line[i];
		}
		for (int i = 0; i < 16; i++) {
			IP_map_scu_ptr_64x32_map_scu_left_line_new[i] = IP_map_scu_ptr_64x32->map_scu_left_line_new[i];
		}
	}
	else if ((cu_width_log2 == 4) && (cu_height_log2 == 6))  // Y wxh == 16x64
	{
		IP_buffer_ptr_16x64_top_left = IP_buffer_ptr_16x64->top_left;
		IP_buffer_ptr_U_8x32_top_left = IP_buffer_ptr_U_8x32->top_left;
		IP_buffer_ptr_V_8x32_top_left = IP_buffer_ptr_V_8x32->top_left;
		IP_map_scu_ptr_16x64_map_scu_top_left_new = IP_map_scu_ptr_16x64->map_scu_top_left_new;
		for (int i = 0; i < 16; i++) {
			IP_buffer_ptr_U_8x32_up_line[i] = IP_buffer_ptr_U_8x32->up_line[i];
			IP_buffer_ptr_V_8x32_up_line[i] = IP_buffer_ptr_V_8x32->up_line[i];
		}
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_U_8x32_left_line[i] = IP_buffer_ptr_U_8x32->left_line[i];
			IP_buffer_ptr_V_8x32_left_line[i] = IP_buffer_ptr_V_8x32->left_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_16x64_up_line[i] = IP_buffer_ptr_16x64->up_line[i];
			// MAP_SCU
			IP_map_scu_ptr_16x64_map_scu_left_line_new[i] = IP_map_scu_ptr_16x64->map_scu_left_line_new[i];
		}
		for (int i = 0; i < 128; i++) {
			IP_buffer_ptr_16x64_left_line[i] = IP_buffer_ptr_16x64->left_line[i];
		}
		for (int i = 0; i < 8; i++) {
			IP_map_scu_ptr_16x64_map_scu_up_line[i] = IP_map_scu_ptr_16x64->map_scu_up_line[i];
		}
	}
	else if ((cu_width_log2 == 6) && (cu_height_log2 == 4))  // Y wxh == 64x16
	{
		IP_buffer_ptr_64x16_top_left = IP_buffer_ptr_64x16->top_left;
		IP_buffer_ptr_U_32x8_top_left = IP_buffer_ptr_U_32x8->top_left;
		IP_buffer_ptr_V_32x8_top_left = IP_buffer_ptr_V_32x8->top_left;
		IP_map_scu_ptr_64x16_map_scu_top_left_new = IP_map_scu_ptr_64x16->map_scu_top_left_new;
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_U_32x8_up_line[i] = IP_buffer_ptr_U_32x8->up_line[i];
			IP_buffer_ptr_V_32x8_up_line[i] = IP_buffer_ptr_V_32x8->up_line[i];
		}
		for (int i = 0; i < 16; i++) {
			IP_buffer_ptr_U_32x8_left_line[i] = IP_buffer_ptr_U_32x8->left_line[i];
			IP_buffer_ptr_V_32x8_left_line[i] = IP_buffer_ptr_V_32x8->left_line[i];
		}
		for (int i = 0; i < 128; i++) {
			IP_buffer_ptr_64x16_up_line[i] = IP_buffer_ptr_64x16->up_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_buffer_ptr_64x16_left_line[i] = IP_buffer_ptr_64x16->left_line[i];
			// MAP_SCU
			IP_map_scu_ptr_64x16_map_scu_up_line[i] = IP_map_scu_ptr_64x16->map_scu_up_line[i];
		}
		for (int i = 0; i < 8; i++) {
			IP_map_scu_ptr_64x16_map_scu_left_line_new[i] = IP_map_scu_ptr_64x16->map_scu_left_line_new[i];
		}
	}
	else if ((cu_width_log2 == 3) && (cu_height_log2 == 6))  // Y wxh == 8x64
	{
		IP_buffer_ptr_8x64_top_left = IP_buffer_ptr_8x64->top_left;
		IP_buffer_ptr_U_4x32_top_left = IP_buffer_ptr_U_4x32->top_left;
		IP_buffer_ptr_V_4x32_top_left = IP_buffer_ptr_V_4x32->top_left;
		IP_map_scu_ptr_8x64_map_scu_top_left_new = IP_map_scu_ptr_8x64->map_scu_top_left_new;
		for (int i = 0; i < 8; i++) {
			IP_buffer_ptr_U_4x32_up_line[i] = IP_buffer_ptr_U_4x32->up_line[i];
			IP_buffer_ptr_V_4x32_up_line[i] = IP_buffer_ptr_V_4x32->up_line[i];
		}
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_U_4x32_left_line[i] = IP_buffer_ptr_U_4x32->left_line[i];
			IP_buffer_ptr_V_4x32_left_line[i] = IP_buffer_ptr_V_4x32->left_line[i];
		}
		for (int i = 0; i < 16; i++) {
			IP_buffer_ptr_8x64_up_line[i] = IP_buffer_ptr_8x64->up_line[i];
		}
		for (int i = 0; i < 128; i++) {
			IP_buffer_ptr_8x64_left_line[i] = IP_buffer_ptr_8x64->left_line[i];
		}
		for (int i = 0; i < 4; i++) {
			IP_map_scu_ptr_8x64_map_scu_up_line[i] = IP_map_scu_ptr_8x64->map_scu_up_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_map_scu_ptr_8x64_map_scu_left_line_new[i] = IP_map_scu_ptr_8x64->map_scu_left_line_new[i];
		}
	}
	else if ((cu_width_log2 == 6) && (cu_height_log2 == 3))  // Y wxh == 64x8
	{
		IP_buffer_ptr_64x8_top_left = IP_buffer_ptr_64x8->top_left;
		IP_buffer_ptr_U_32x4_top_left = IP_buffer_ptr_U_32x4->top_left;
		IP_buffer_ptr_V_32x4_top_left = IP_buffer_ptr_V_32x4->top_left;
		IP_map_scu_ptr_64x8_map_scu_top_left_new = IP_map_scu_ptr_64x8->map_scu_top_left_new;
		for (int i = 0; i < 64; i++) {
			IP_buffer_ptr_U_32x4_up_line[i] = IP_buffer_ptr_U_32x4->up_line[i];
			IP_buffer_ptr_V_32x4_up_line[i] = IP_buffer_ptr_V_32x4->up_line[i];
		}
		for (int i = 0; i < 8; i++) {
			IP_buffer_ptr_U_32x4_left_line[i] = IP_buffer_ptr_U_32x4->left_line[i];
			IP_buffer_ptr_V_32x4_left_line[i] = IP_buffer_ptr_V_32x4->left_line[i];
		}
		for (int i = 0; i < 128; i++) {
			IP_buffer_ptr_64x8_up_line[i] = IP_buffer_ptr_64x8->up_line[i];
		}
		for (int i = 0; i < 16; i++) {
			IP_buffer_ptr_64x8_left_line[i] = IP_buffer_ptr_64x8->left_line[i];
		}
		for (int i = 0; i < 32; i++) {
			IP_map_scu_ptr_64x8_map_scu_up_line[i] = IP_map_scu_ptr_64x8->map_scu_up_line[i];
		}
		for (int i = 0; i < 4; i++) {
			IP_map_scu_ptr_64x8_map_scu_left_line_new[i] = IP_map_scu_ptr_64x8->map_scu_left_line_new[i];
		}
	}

	rdo_chroma_pipeline_32(all_rdo_num, rdoq_array, md_input_ptr, pb_x, pb_y,
		md_fw_ptr, RefWindowLCU_UP, RefWindowLCU_VP, CtrPos, 
#if ENABLE_BFRAME
		RefWindowLCU_UP_ref1, RefWindowLCU_VP_ref1, CtrPos_ref1,
#endif
		tree_status, 
		mod_info_best, mod_info_curr_pb_info, 
		orgU, cu_width_log2_chroma, cu_width_chroma, 
		cu_height_log2_chroma, cu_height_chroma, 
		bit_depth, cu_mode, slice_type, scale, qpUV, tscpm_enable_flag, lambda_y, 
	    size_tmp, Fetch_Ref_window_ptr, piRecoY
#if SUB_TMVP
		, core_sbtmvp
#endif
		,mod_info_best_rec_u,
		mod_info_best_rec_v,
		mod_info_best_coef_u,
		mod_info_best_coef_v,
		IP_buffer_ptr_U_32x32_up_line, IP_buffer_ptr_U_32x32_left_line, IP_buffer_ptr_U_32x32_top_left,
		IP_buffer_ptr_V_32x32_up_line, IP_buffer_ptr_V_32x32_left_line, IP_buffer_ptr_V_32x32_top_left,
		IP_buffer_ptr_U_16x32_up_line, IP_buffer_ptr_U_16x32_left_line, IP_buffer_ptr_U_16x32_top_left,
		IP_buffer_ptr_V_16x32_up_line, IP_buffer_ptr_V_16x32_left_line, IP_buffer_ptr_V_16x32_top_left,
		IP_buffer_ptr_U_32x16_up_line, IP_buffer_ptr_U_32x16_left_line, IP_buffer_ptr_U_32x16_top_left,
		IP_buffer_ptr_V_32x16_up_line, IP_buffer_ptr_V_32x16_left_line, IP_buffer_ptr_V_32x16_top_left,
		IP_buffer_ptr_U_8x32_up_line, IP_buffer_ptr_U_8x32_left_line, IP_buffer_ptr_U_8x32_top_left,
		IP_buffer_ptr_V_8x32_up_line, IP_buffer_ptr_V_8x32_left_line, IP_buffer_ptr_V_8x32_top_left,
		IP_buffer_ptr_U_32x8_up_line, IP_buffer_ptr_U_32x8_left_line, IP_buffer_ptr_U_32x8_top_left,
		IP_buffer_ptr_V_32x8_up_line, IP_buffer_ptr_V_32x8_left_line, IP_buffer_ptr_V_32x8_top_left,
		IP_buffer_ptr_U_4x32_up_line, IP_buffer_ptr_U_4x32_left_line, IP_buffer_ptr_U_4x32_top_left,
		IP_buffer_ptr_V_4x32_up_line, IP_buffer_ptr_V_4x32_left_line, IP_buffer_ptr_V_4x32_top_left,
		IP_buffer_ptr_U_32x4_up_line, IP_buffer_ptr_U_32x4_left_line, IP_buffer_ptr_U_32x4_top_left,
		IP_buffer_ptr_V_32x4_up_line, IP_buffer_ptr_V_32x4_left_line, IP_buffer_ptr_V_32x4_top_left,
		IP_buffer_ptr_64x64_up_line, IP_buffer_ptr_64x64_left_line, IP_buffer_ptr_64x64_top_left,
		IP_buffer_ptr_32x64_up_line, IP_buffer_ptr_32x64_left_line, IP_buffer_ptr_32x64_top_left,
		IP_buffer_ptr_64x32_up_line, IP_buffer_ptr_64x32_left_line, IP_buffer_ptr_64x32_top_left,
		IP_buffer_ptr_16x64_up_line, IP_buffer_ptr_16x64_left_line, IP_buffer_ptr_16x64_top_left,
		IP_buffer_ptr_64x16_up_line, IP_buffer_ptr_64x16_left_line, IP_buffer_ptr_64x16_top_left,
		IP_buffer_ptr_8x64_up_line, IP_buffer_ptr_8x64_left_line, IP_buffer_ptr_8x64_top_left,
		IP_buffer_ptr_64x8_up_line, IP_buffer_ptr_64x8_left_line, IP_buffer_ptr_64x8_top_left,
		IP_map_scu_ptr_64x64_map_scu_up_line,
		IP_map_scu_ptr_64x64_map_scu_left_line_new,
		IP_map_scu_ptr_64x64_map_scu_top_left_new,
		IP_map_scu_ptr_32x64_map_scu_up_line,
		IP_map_scu_ptr_32x64_map_scu_left_line_new,
		IP_map_scu_ptr_32x64_map_scu_top_left_new,
		IP_map_scu_ptr_64x32_map_scu_up_line,
		IP_map_scu_ptr_64x32_map_scu_left_line_new,
		IP_map_scu_ptr_64x32_map_scu_top_left_new,
		IP_map_scu_ptr_16x64_map_scu_up_line,
		IP_map_scu_ptr_16x64_map_scu_left_line_new,
		IP_map_scu_ptr_16x64_map_scu_top_left_new,
		IP_map_scu_ptr_64x16_map_scu_up_line,
		IP_map_scu_ptr_64x16_map_scu_left_line_new,
		IP_map_scu_ptr_64x16_map_scu_top_left_new,
		IP_map_scu_ptr_8x64_map_scu_up_line,
		IP_map_scu_ptr_8x64_map_scu_left_line_new,
		IP_map_scu_ptr_8x64_map_scu_top_left_new,
		IP_map_scu_ptr_64x8_map_scu_up_line,
		IP_map_scu_ptr_64x8_map_scu_left_line_new,
		IP_map_scu_ptr_64x8_map_scu_top_left_new
	);

	for (int k = 0; k < 32; ++k) {
		//#pragma HLS PIPELINE
		for (int j = 0; j < 32; j++) {
			//#pragma HLS UNROLL	
			if ((k < cu_height_chroma) && (j < cu_width_chroma)) {
				mod_info_best->rec_u[k * cu_width_chroma + j] = mod_info_best_rec_u[k][j];
				mod_info_best->rec_v[k * cu_width_chroma + j] = mod_info_best_rec_v[k][j];
				mod_info_best->coef_u[k * cu_width_chroma + j] = mod_info_best_coef_u[k][j];
				mod_info_best->coef_v[k * cu_width_chroma + j] = mod_info_best_coef_v[k][j];// coef_uv_pb_part[k][(j + k) & 31];
			}
		}
	}

	return 0;
}

void copy_to_cu_data_chroma32(U6 qp_y, ENC_CU_DATA_ARRAY* cu_data, MD_COM_MODE_BEST* mod_info_best, U2 tree_status, U1 coef_rec_write_flag[1])
{
	int i;
	int j;
	int k;
	int idx;
	int size;
	U3 cu_width_log2;
	U3 cu_height_log2;
	//int num_coef_y = 0;
	U12 num_coef_u = 0;
	U12 num_coef_v = 0;
	//int num_nnz_sum = 0;
	U1 cu_cbf_flag = 0;
	//int pb_idx_u = 0;
	U2 tb_idx_u = 0;
	U2 tb_idx_y;
	U14 num_coef_y = 0;

	cu_width_log2 = mod_info_best->cu_width_log2;
	cu_height_log2 = mod_info_best->cu_height_log2;

	if ((tree_status) != (TREE_L)) {
		/* copy coef */
		size = ((((mod_info_best->cu_width * mod_info_best->cu_height)) * sizeof(s16) >> 2));
		//if (coef_rec_write_flag[0] == 0) {////for Intra_CU
		for (i = 0; i < ((mod_info_best->cu_width * mod_info_best->cu_height) >> 2); i++) {
			cu_data->coef_u[i] = mod_info_best->coef_u[i];
			cu_data->coef_v[i] = mod_info_best->coef_v[i];
			cu_data->reco_u[i] = mod_info_best->rec_u[i];
			cu_data->reco_v[i] = mod_info_best->rec_v[i];  /* copy reco */

		}

		//}

		for (i = 0; i < mod_info_best->cu_width * mod_info_best->cu_height / 4; i++) {
			num_coef_u += ((cu_data->coef_u[i]) != 0 ? 1 : 0);
			num_coef_v += ((cu_data->coef_v[i]) != 0 ? 1 : 0);
		}
	}
	if (tree_status != TREE_C)
	{
		for (i = 0; i < mod_info_best->cu_width * mod_info_best->cu_height; i++) {
			num_coef_y += ((cu_data->coef_y[i]) != 0 ? 1 : 0);
		}
	}
	if (tree_status == TREE_LC) {
		cu_cbf_flag = ((num_coef_y == 0 ? 0 : 1)) | ((num_coef_u == 0 ? 0 : 1)) | ((num_coef_v == 0 ? 0 : 1));
	}
	else if ((tree_status) == (TREE_L)) {
		cu_cbf_flag = (num_coef_y == 0 ? 0 : 1);
	}
	/* copy mode info */
	if ((tree_status) == (TREE_C)) {
		idx = 0;
		for (j = 0; j < mod_info_best->cu_height >> 2; j++) {
			for (i = 0; i < mod_info_best->cu_width >> 2; i++) {
				//intra chroma mode
				if (mod_info_best->cu_mode == 0) {
					cu_data->ipm[1][idx + i] = mod_info_best->ipm[0][1];
				}
				// residual and partition
				for (k = 1; k < 3; k++) {
					cu_data->num_nz_coef[k][idx + i] = mod_info_best->num_nz[0][k];
				}
			}
			idx += mod_info_best->cu_width >> 2;
		}
	}
	else {
		idx = 0;
		for (j = 0; j < mod_info_best->cu_height >> 2; j++) {
			for (i = 0; i < mod_info_best->cu_width >> 2; i++) {

				//			tb_idx_y = get_part_idx((PART_SIZE)(mod_info_best->tb_part), i << 2, j << 2, mod_info_best->cu_width,mod_info_best->cu_height);
				tb_idx_y = get_part_idx(SIZE_2Nx2N, i << 2, j << 2, mod_info_best->cu_width,
					mod_info_best->cu_height);
				//pb_idx_u = 0;
				tb_idx_u = 0;

				for (k = 1; k < 3; k++) {
					cu_data->num_nz_coef[k][idx + i] = mod_info_best->num_nz[(k == 0 ? tb_idx_y : tb_idx_u)][k];
				}

				if (cu_cbf_flag) {
					cu_data->map_scu[idx + i] = cu_data->map_scu[idx + i] | ((1 << 24));
				}
				else {
					cu_data->map_scu[idx + i] = cu_data->map_scu[idx + i] & ((~(1 << 24)));
				}

				if (mod_info_best->cu_mode == 0)
				{
					cu_data->ipm[1][idx + i] = mod_info_best->ipm[0][1];
				}
			}
			idx += mod_info_best->cu_width >> 2;
		}

	}
}


